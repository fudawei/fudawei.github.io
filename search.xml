<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[[Java并发包学习一]ThreadPoolExecutor分析]]></title>
      <url>https://fudawei.github.io/2017/03/16/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%80%5DThreadPoolExecutor%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Java中使用线程池技术一般都是使用Executors这个工厂类，它提供了非常简单方法来创建各种类型的线程池：</p>
<p>public static ExecutorService newFixedThreadPool(int nThreads)<br>public static ExecutorService newSingleThreadExecutor()<br>public static ExecutorService newCachedThreadPool()<br>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</p>
<p>核心的接口其实是Executor，它只有一个execute方法抽象为对任务（Runnable接口）的执行， ExecutorService接口在Executor的基础上提供了对任务执行的生命周期的管理，主要是submit和shutdown方法， AbstractExecutorService对ExecutorService一些方法做了默认的实现，主要是submit和invoke方法，而真正的任务执行 的Executor接口execute方法是由子类实现，就是ThreadPoolExecutor，它实现了基于线程池的任务执行框架，所以要了解 JDK的线程池，那么就得先看这个类。<br>再看execute方法之前需要先介几个变量或类。</p>
<h1 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h1><p>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));<br>这个变量是整个类的核心，AtomicInteger保证了对这个变量的操作是原子的，通过巧妙的操作，ThreadPoolExecutor用这一个变量保存了两个内容：</p>
<p>所有有效线程的数量<br>各个线程的状态（runState）<br>低29位存线程数，高3位存runState,这样runState有5个值：</p>
<p>RUNNING:   -536870912<br>SHUTDOWN:  0<br>STOP:      536870912<br>TIDYING:   1073741824<br>TERMINATED:1610612736<br>线程池中各个状态间的转换比较复杂，主要记住下面内容就可以了：</p>
<p>RUNNING状态：线程池正常运行，可以接受新的任务并处理队列中的任务；<br>SHUTDOWN状态：不再接受新的任务，但是会执行队列中的任务；<br>STOP状态：不再接受新任务，不处理队列中的任务<br>围绕ctl变量有一些操作，了解这些方法是看懂后面一些晦涩代码的基础：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 这个方法用于取出runState的值 因为CAPACITY值为：00011111111111111111111111111111</div><div class="line"> * ~为按位取反操作，则~CAPACITY值为：11100000000000000000000000000000</div><div class="line"> * 再同参数做&amp;操作，就将低29位置0了，而高3位还是保持原先的值，也就是runState的值</div><div class="line"> * </div><div class="line"> * @param 该参数为存储runState和workerCount的int值</div><div class="line"> * @return runState的值</div><div class="line"> */</div><div class="line">private static int runStateOf(int c) &#123;</div><div class="line">    return c &amp; ~CAPACITY;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * 这个方法用于取出workerCount的值</div><div class="line"> * 因为CAPACITY值为：00011111111111111111111111111111，所以&amp;操作将参数的高3位置0了</div><div class="line"> * 保留参数的低29位，也就是workerCount的值</div><div class="line"> * </div><div class="line"> * @param ctl, 存储runState和workerCount的int值</div><div class="line"> * @return workerCount的值</div><div class="line"> */</div><div class="line">private static int workerCountOf(int c) &#123;</div><div class="line">    return c &amp; CAPACITY;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将runState和workerCount存到同一个int中</div><div class="line"> * “|”运算的意思是，假设rs的值是101000，wc的值是000111，则他们位或运算的值为101111</div><div class="line"> * </div><div class="line"> * @param rs runState移位过后的值，负责填充返回值的高3位</div><div class="line"> * @param wc  workerCount移位过后的值，负责填充返回值的低29位</div><div class="line"> * @return 两者或运算过后的值</div><div class="line"> */</div><div class="line">private static int ctlOf(int rs, int wc) &#123;</div><div class="line">    return rs | wc;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 只有RUNNING状态会小于0</div><div class="line">private static boolean isRunning(int c) &#123;</div><div class="line">    return c &lt; SHUTDOWN;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h1><p>核心线程池大小，活动线程小于corePoolSize则直接创建，大于等于则先加到workQueue中，队列满了才创建新的线程。</p>
<h1 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h1><p>线程从队列中获取任务的超时时间，也就是说如果线程空闲超过这个时间就会终止。</p>
<h1 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h1><p>private final class Worker extends AbstractQueuedSynchronizer implements Runnable …<br>内部类Worker是对任务的封装，所有submit的Runnable都被封装成了Worker，它本身也是一个Runnable， 然后利用AQS框架（关于AQS可以看我这篇文章）实现了一个简单的非重入的互斥锁， 实现互斥锁主要目的是为了中断的时候判断线程是在空闲还是运行，可以看后面shutdown和shutdownNow方法的分析。</p>
<p>// state只有0和1，互斥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">protected boolean tryAcquire(int unused) &#123;</div><div class="line">    if (compareAndSetState(0, 1)) &#123;</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">        return true;// 成功获得锁</div><div class="line">    &#125;</div><div class="line">    // 线程进入等待队列</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">protected boolean tryRelease(int unused) &#123;</div><div class="line">    setExclusiveOwnerThread(null);</div><div class="line">    setState(0);</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之所以不用ReentrantLock是为了避免任务执行的代码中修改线程池的变量，如setCorePoolSize，因为ReentrantLock是可重入的。</p>
<h1 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h1><p>execute方法主要三个步骤：</p>
<ul>
<li>活动线程小于corePoolSize的时候创建新的线程；</li>
<li>活动线程大于corePoolSize时都是先加入到任务队列当中；</li>
<li>任务队列满了再去启动新的线程，如果线程数达到最大值就拒绝任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public void execute(Runnable command) &#123;</div><div class="line">    if (command == null)</div><div class="line">        throw new NullPointerException();</div><div class="line"></div><div class="line">    int c = ctl.get();</div><div class="line">    // 活动线程数 &lt; corePoolSize</div><div class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        // 直接启动新的线程。第二个参数true:addWorker中会重新检查workerCount是否小于corePoolSize</div><div class="line">        if (addWorker(command, true))</div><div class="line">            // 添加成功返回</div><div class="line">            return;</div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    // 活动线程数 &gt;= corePoolSize</div><div class="line">    // runState为RUNNING &amp;&amp; 队列未满</div><div class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        int recheck = ctl.get();</div><div class="line">        // double check</div><div class="line">        // 非RUNNING状态 则从workQueue中移除任务并拒绝</div><div class="line">        if (!isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);// 采用线程池指定的策略拒绝任务</div><div class="line">        // 线程池处于RUNNING状态 || 线程池处于非RUNNING状态但是任务移除失败</div><div class="line">        else if (workerCountOf(recheck) == 0)</div><div class="line">            // 这行代码是为了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</div><div class="line">            // 添加一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务</div><div class="line">            addWorker(null, false);</div><div class="line"></div><div class="line">        // 两种情况：</div><div class="line">        // 1.非RUNNING状态拒绝新的任务</div><div class="line">        // 2.队列满了启动新的线程失败（workCount &gt; maximumPoolSize）</div><div class="line">    &#125; else if (!addWorker(command, false))</div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h1><p>这个方法理解起来比较费劲。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</div><div class="line">        retry: for (;;) &#123;</div><div class="line">            int c = ctl.get();</div><div class="line">            int rs = runStateOf(c);// 当前线程池状态</div><div class="line"></div><div class="line">            // Check if queue empty only if necessary.</div><div class="line">            // 这条语句等价：rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null ||</div><div class="line">            // workQueue.isEmpty())</div><div class="line">            // 满足下列调价则直接返回false，线程创建失败:</div><div class="line">            // rs &gt; SHUTDOWN:STOP || TIDYING || TERMINATED 此时不再接受新的任务，且所有任务执行结束</div><div class="line">            // rs = SHUTDOWN:firtTask != null 此时不再接受任务，但是仍然会执行队列中的任务</div><div class="line">            // rs = SHUTDOWN:firtTask == null见execute方法的addWorker(null,</div><div class="line">            // false)，任务为null &amp;&amp; 队列为空</div><div class="line">            // 最后一种情况也就是说SHUTDONW状态下，如果队列不为空还得接着往下执行，为什么？add一个null任务目的到底是什么？</div><div class="line">            // 看execute方法只有workCount==0的时候firstTask才会为null结合这里的条件就是线程池SHUTDOWN了不再接受新任务</div><div class="line">            // 但是此时队列不为空，那么还得创建线程把任务给执行完才行。</div><div class="line">            if (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty()))</div><div class="line">                return false;</div><div class="line"></div><div class="line">            // 走到这的情形：</div><div class="line">            // 1.线程池状态为RUNNING</div><div class="line">            // 2.SHUTDOWN状态，但队列中还有任务需要执行</div><div class="line">            for (;;) &#123;</div><div class="line">                int wc = workerCountOf(c);</div><div class="line">                if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                    return false;</div><div class="line">                if (compareAndIncrementWorkerCount(c))// 原子操作递增workCount</div><div class="line">                    break retry;// 操作成功跳出的重试的循环</div><div class="line">                c = ctl.get(); // Re-read ctl</div><div class="line">                if (runStateOf(c) != rs)// 如果线程池的状态发生变化则重试</div><div class="line">                    continue retry;</div><div class="line">                // else CAS failed due to workerCount change; retry inner loop</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // wokerCount递增成功</div><div class="line"></div><div class="line">        boolean workerStarted = false;</div><div class="line">        boolean workerAdded = false;</div><div class="line">        Worker w = null;</div><div class="line">        try &#123;</div><div class="line">            final ReentrantLock mainLock = this.mainLock;</div><div class="line">            w = new Worker(firstTask);</div><div class="line">            final Thread t = w.thread;</div><div class="line">            if (t != null) &#123;</div><div class="line">                // 并发的访问线程池workers对象必须加锁</div><div class="line">                mainLock.lock();</div><div class="line">                try &#123;</div><div class="line">                    // Recheck while holding lock.</div><div class="line">                    // Back out on ThreadFactory failure or if</div><div class="line">                    // shut down before lock acquired.</div><div class="line">                    int c = ctl.get();</div><div class="line">                    int rs = runStateOf(c);</div><div class="line"></div><div class="line">                    // RUNNING状态 || SHUTDONW状态下清理队列中剩余的任务</div><div class="line">                    if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</div><div class="line">                        if (t.isAlive()) // precheck that t is startable</div><div class="line">                            throw new IllegalThreadStateException();</div><div class="line">                        // 将新启动的线程添加到线程池中</div><div class="line">                        workers.add(w);</div><div class="line">                        // 更新largestPoolSize</div><div class="line">                        int s = workers.size();</div><div class="line">                        if (s &gt; largestPoolSize)</div><div class="line">                            largestPoolSize = s;</div><div class="line">                        workerAdded = true;</div><div class="line">                    &#125;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    mainLock.unlock();</div><div class="line">                &#125;</div><div class="line">                // 启动新添加的线程，这个线程首先执行firstTask，然后不停的从队列中取任务执行</div><div class="line">                // 当等待keepAlieTime还没有任务执行则该线程结束。见runWoker和getTask方法的代码。</div><div class="line">                if (workerAdded) &#123;</div><div class="line">                    t.start();// 最终执行的是ThreadPoolExecutor的runWoker方法</div><div class="line">                    workerStarted = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            // 线程启动失败，则从wokers中移除w并递减wokerCount</div><div class="line">            if (!workerStarted)</div><div class="line">                // 递减wokerCount会触发tryTerminate方法</div><div class="line">                addWorkerFailed(w);</div><div class="line">        &#125;</div><div class="line">        return workerStarted;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h1><p>任务添加成功后实际执行的是runWorker这个方法，这个方法非常重要，简单来说它做的就是：</p>
<p>第一次启动会执行初始化传进来的任务firstTask；<br>然后会从workQueue中取任务执行，如果队列为空则等待keepAliveTime这么长时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">final void runWorker(Worker w) &#123;</div><div class="line">        Thread wt = Thread.currentThread();</div><div class="line">        Runnable task = w.firstTask;</div><div class="line">        w.firstTask = null;</div><div class="line">        // Worker的构造函数中抑制了线程中断setState(-1)，所以这里需要unlock从而允许中断</div><div class="line">        w.unlock();</div><div class="line">        // 用于标识是否异常终止，finally中processWorkerExit的方法会有不同逻辑</div><div class="line">        // 为true的情况：1.执行任务抛出异常；2.被中断。</div><div class="line">        boolean completedAbruptly = true;</div><div class="line">        try &#123;</div><div class="line">            // 如果getTask返回null那么getTask中会将workerCount递减，如果异常了这个递减操作会在processWorkerExit中处理</div><div class="line">            while (task != null || (task = getTask()) != null) &#123;</div><div class="line">                w.lock();</div><div class="line">                // If pool is stopping, ensure thread is interrupted;</div><div class="line">                // if not, ensure thread is not interrupted. This</div><div class="line">                // requires a recheck in second case to deal with</div><div class="line">                // shutdownNow race while clearing interrupt</div><div class="line">                if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)))</div><div class="line">                        &amp;&amp; !wt.isInterrupted())</div><div class="line">                    wt.interrupt();</div><div class="line">                try &#123;</div><div class="line">                    // 任务执行前可以插入一些处理，子类重载该方法</div><div class="line">                    beforeExecute(wt, task);</div><div class="line">                    Throwable thrown = null;</div><div class="line">                    try &#123;</div><div class="line">                        task.run();// 执行用户任务</div><div class="line">                    &#125; catch (RuntimeException x) &#123;</div><div class="line">                        thrown = x;</div><div class="line">                        throw x;</div><div class="line">                    &#125; catch (Error x) &#123;</div><div class="line">                        thrown = x;</div><div class="line">                        throw x;</div><div class="line">                    &#125; catch (Throwable x) &#123;</div><div class="line">                        thrown = x;</div><div class="line">                        throw new Error(x);</div><div class="line">                    &#125; finally &#123;</div><div class="line">                        // 和beforeExecute一样，留给子类去重载</div><div class="line">                        afterExecute(task, thrown);</div><div class="line">                    &#125;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    task = null;</div><div class="line">                    w.completedTasks++;</div><div class="line">                    w.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            completedAbruptly = false;</div><div class="line">        &#125; finally &#123;</div><div class="line">            // 结束线程的一些清理工作</div><div class="line">            processWorkerExit(w, completedAbruptly);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">private Runnable getTask() &#123;</div><div class="line">        boolean timedOut = false; // Did the last poll() time out?</div><div class="line"></div><div class="line">        retry: for (;;) &#123;</div><div class="line">            int c = ctl.get();</div><div class="line">            int rs = runStateOf(c);</div><div class="line"></div><div class="line">            // Check if queue empty only if necessary.</div><div class="line">            // 1.rs &gt; SHUTDOWN 所以rs至少等于STOP,这时不再处理队列中的任务</div><div class="line">            // 2.rs = SHUTDOWN 所以rs&gt;=STOP肯定不成立，这时还需要处理队列中的任务除非队列为空</div><div class="line">            // 这两种情况都会返回null让runWoker退出while循环也就是当前线程结束了，所以必须要decrement</div><div class="line">            // wokerCount</div><div class="line">            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">                // 递减workerCount值</div><div class="line">                decrementWorkerCount();</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 标记从队列中取任务时是否设置超时时间</div><div class="line">            boolean timed; // Are workers subject to culling?</div><div class="line"></div><div class="line">            // 1.RUNING状态</div><div class="line">            // 2.SHUTDOWN状态，但队列中还有任务需要执行</div><div class="line">            for (;;) &#123;</div><div class="line">                int wc = workerCountOf(c);</div><div class="line"></div><div class="line">                // 1.core thread允许被超时，那么超过corePoolSize的的线程必定有超时</div><div class="line">                // 2.allowCoreThreadTimeOut == false &amp;&amp; wc &gt;</div><div class="line">                // corePoolSize时，一般都是这种情况，core thread即使空闲也不会被回收，只要超过的线程才会</div><div class="line">                timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">                // 从addWorker可以看到一般wc不会大于maximumPoolSize，所以更关心后面半句的情形：</div><div class="line">                // 1. timedOut == false 第一次执行循环， 从队列中取出任务不为null方法返回 或者</div><div class="line">                // poll出异常了重试</div><div class="line">                // 2.timeOut == true &amp;&amp; timed ==</div><div class="line">                // false:看后面的代码workerQueue.poll超时时timeOut才为true，</div><div class="line">                // 并且timed要为false，这两个条件相悖不可能同时成立（既然有超时那么timed肯定为true）</div><div class="line">                // 所以超时不会继续执行而是return null结束线程。（重点：线程是如何超时的？？？）</div><div class="line">                if (wc &lt;= maximumPoolSize &amp;&amp; !(timedOut &amp;&amp; timed))</div><div class="line">                    break;</div><div class="line"></div><div class="line">                // workerCount递减，结束当前thread</div><div class="line">                if (compareAndDecrementWorkerCount(c))</div><div class="line">                    return null;</div><div class="line">                c = ctl.get(); // Re-read ctl</div><div class="line">                // 需要重新检查线程池状态，因为上述操作过程中线程池可能被SHUTDOWN</div><div class="line">                if (runStateOf(c) != rs)</div><div class="line">                    continue retry;</div><div class="line">                // else CAS failed due to workerCount change; retry inner loop</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                // 1.以指定的超时时间从队列中取任务</div><div class="line">                // 2.core thread没有超时</div><div class="line">                Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</div><div class="line">                if (r != null)</div><div class="line">                    return r;</div><div class="line">                timedOut = true;// 超时</div><div class="line">            &#125; catch (InterruptedException retry) &#123;</div><div class="line">                timedOut = false;// 线程被中断重试</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h1><p>线程退出会执行这个方法做一些清理工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</div><div class="line">        // 正常的话再runWorker的getTask方法workerCount已经被减一了</div><div class="line">        if (completedAbruptly)</div><div class="line">            decrementWorkerCount();</div><div class="line"></div><div class="line">        final ReentrantLock mainLock = this.mainLock;</div><div class="line">        mainLock.lock();</div><div class="line">        try &#123;</div><div class="line">            // 累加线程的completedTasks</div><div class="line">            completedTaskCount += w.completedTasks;</div><div class="line">            // 从线程池中移除超时或者出现异常的线程</div><div class="line">            workers.remove(w);</div><div class="line">        &#125; finally &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 尝试停止线程池</div><div class="line">        tryTerminate();</div><div class="line"></div><div class="line">        int c = ctl.get();</div><div class="line">        // runState为RUNNING或SHUTDOWN</div><div class="line">        if (runStateLessThan(c, STOP)) &#123;</div><div class="line">            // 线程不是异常结束</div><div class="line">            if (!completedAbruptly) &#123;</div><div class="line">                // 线程池最小空闲数，允许core thread超时就是0，否则就是corePoolSize</div><div class="line">                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</div><div class="line">                // 如果min == 0但是队列不为空要保证有1个线程来执行队列中的任务</div><div class="line">                if (min == 0 &amp;&amp; !workQueue.isEmpty())</div><div class="line">                    min = 1;</div><div class="line">                // 线程池还不为空那就不用担心了</div><div class="line">                if (workerCountOf(c) &gt;= min)</div><div class="line">                    return; // replacement not needed</div><div class="line">            &#125;</div><div class="line">            // 1.线程异常退出</div><div class="line">            // 2.线程池为空，但是队列中还有任务没执行，看addWoker方法对这种情况的处理</div><div class="line">            addWorker(null, false);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h1><p>processWorkerExit方法中会尝试调用tryTerminate来终止线程池。这个方法在任何可能导致线程池终止的动作后执行：比如减少wokerCount或SHUTDOWN状态下从队列中移除任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">final void tryTerminate() &#123;</div><div class="line">        for (;;) &#123;</div><div class="line">            int c = ctl.get();</div><div class="line">            // 以下状态直接返回：</div><div class="line">            // 1.线程池还处于RUNNING状态</div><div class="line">            // 2.SHUTDOWN状态但是任务队列非空</div><div class="line">            // 3.runState &gt;= TIDYING 线程池已经停止了或在停止了</div><div class="line">            if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))</div><div class="line">                return;</div><div class="line"></div><div class="line">            // 只能是以下情形会继续下面的逻辑：结束线程池。</div><div class="line">            // 1.SHUTDOWN状态，这时不再接受新任务而且任务队列也空了</div><div class="line">            // 2.STOP状态，当调用了shutdownNow方法</div><div class="line"></div><div class="line">            // workerCount不为0则还不能停止线程池,而且这时线程都处于空闲等待的状态</div><div class="line">            // 需要中断让线程“醒”过来，醒过来的线程才能继续处理shutdown的信号。</div><div class="line">            if (workerCountOf(c) != 0) &#123; // Eligible to terminate</div><div class="line">                // runWoker方法中w.unlock就是为了可以被中断,getTask方法也处理了中断。</div><div class="line">                // ONLY_ONE:这里只需要中断1个线程去处理shutdown信号就可以了。</div><div class="line">                interruptIdleWorkers(ONLY_ONE);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final ReentrantLock mainLock = this.mainLock;</div><div class="line">            mainLock.lock();</div><div class="line">            try &#123;</div><div class="line">                // 进入TIDYING状态</div><div class="line">                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        // 子类重载：一些资源清理工作</div><div class="line">                        terminated();</div><div class="line">                    &#125; finally &#123;</div><div class="line">                        // TERMINATED状态</div><div class="line">                        ctl.set(ctlOf(TERMINATED, 0));</div><div class="line">                        // 继续awaitTermination</div><div class="line">                        termination.signalAll();</div><div class="line">                    &#125;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            // else retry on failed CAS</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="shutdown和shutdownNow"><a href="#shutdown和shutdownNow" class="headerlink" title="shutdown和shutdownNow"></a>shutdown和shutdownNow</h1><p>shutdown这个方法会将runState置为SHUTDOWN，会终止所有空闲的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void shutdown() &#123;</div><div class="line">        final ReentrantLock mainLock = this.mainLock;</div><div class="line">        mainLock.lock();</div><div class="line">        try &#123;</div><div class="line">            checkShutdownAccess();</div><div class="line">            // 线程池状态设为SHUTDOWN，如果已经至少是这个状态那么则直接返回</div><div class="line">            advanceRunState(SHUTDOWN);</div><div class="line">            // 注意这里是中断所有空闲的线程：runWorker中等待的线程被中断 → 进入processWorkerExit →</div><div class="line">            // tryTerminate方法中会保证队列中剩余的任务得到执行。</div><div class="line">            interruptIdleWorkers();</div><div class="line">            onShutdown(); // hook for ScheduledThreadPoolExecutor</div><div class="line">        &#125; finally &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line">        tryTerminate();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>shutdownNow方法将runState置为STOP。和shutdown方法的区别，这个方法会终止所有的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public List&lt;Runnable&gt; shutdownNow() &#123;</div><div class="line">    List&lt;Runnable&gt; tasks;</div><div class="line">    final ReentrantLock mainLock = this.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    try &#123;</div><div class="line">        checkShutdownAccess();</div><div class="line">        // STOP状态：不再接受新任务且不再执行队列中的任务。</div><div class="line">        advanceRunState(STOP);</div><div class="line">        // 中断所有线程</div><div class="line">        interruptWorkers();</div><div class="line">        // 返回队列中还没有被执行的任务。</div><div class="line">        tasks = drainQueue();</div><div class="line">    &#125;</div><div class="line">    finally &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">    tryTerminate();</div><div class="line">    return tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要区别在于shutdown调用的是interruptIdleWorkers这个方法，而shutdownNow实际调用的是Worker类的interruptIfStarted方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private void interruptIdleWorkers(boolean onlyOne) &#123;</div><div class="line">    final ReentrantLock mainLock = this.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    try &#123;</div><div class="line">        for (Worker w : workers) &#123;</div><div class="line">            Thread t = w.thread;</div><div class="line">            // w.tryLock能获取到锁，说明该线程没有在运行，因为runWorker中执行任务会先lock，</div><div class="line">            // 因此保证了中断的肯定是空闲的线程。</div><div class="line">            if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</div><div class="line">                try &#123;</div><div class="line">                    t.interrupt();</div><div class="line">                &#125; catch (SecurityException ignore) &#123;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    w.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (onlyOne)</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    finally &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">void interruptIfStarted() &#123;</div><div class="line">    Thread t;</div><div class="line">    // 初始化时state == -1</div><div class="line">    if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;</div><div class="line">        try &#123;</div><div class="line">            t.interrupt();</div><div class="line">        &#125; catch (SecurityException ignore) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是前面提到的Woker类实现AQS的主要作用。</p>
<p>注意：shutdown方法可能会在finalize被隐式的调用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Java并发包学习八]深度剖析ConcurrentHashMap]]></title>
      <url>https://fudawei.github.io/2017/03/16/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E5%85%AB%5D%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90ConcurrentHashMap/</url>
      <content type="html"><![CDATA[<p>HashTable是一个线程安全的类，它使用synchronized来锁住整张Hash表来实现线程安全，即每次锁住整张表让线程独占。ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的Hashtable，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<p>有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</p>
<h1 id="一-实现原理"><a href="#一-实现原理" class="headerlink" title="一. 实现原理"></a>一. 实现原理</h1><p>ConcurrentHashMap使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。如下图是ConcurrentHashMap的内部结构图：<br><img src="/img/concurrent_map/c_hash_map_1.png" alt=""><br>从图中可以看到，ConcurrentHashMap内部分为很多个Segment，每一个Segment拥有一把锁，然后每个Segment（继承ReentrantLock）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable</div></pre></td></tr></table></figure>
<p>Segment继承了ReentrantLock，表明每个segment都可以当做一个锁。这样对每个segment中的数据需要同步操作的话都是使用每个segment容器对象自身的锁来实现。只有对全局需要改变时锁定的是所有的segment。</p>
<p>Segment下面包含很多个HashEntry列表数组。对于一个key，需要经过三次（为什么要hash三次下文会详细讲解）hash操作，才能最终定位这个元素的位置，这三次hash分别为：</p>
<ol>
<li>对于一个key，先进行一次hash操作，得到hash值h1，也即h1 = hash1(key)；</li>
<li>将得到的h1的高几位进行第二次hash，得到hash值h2，也即h2 = hash2(h1高几位)，通过h2能够确定该元素的放在哪个Segment；</li>
<li>将得到的h1进行第三次hash，得到hash值h3，也即h3 = hash3(h1)，通过h3能够确定该元素放置在哪个HashEntry。</li>
</ol>
<p>ConcurrentHashMap中主要实体类就是三个：ConcurrentHashMap（整个Hash表）,Segment（桶），HashEntry（节点），对应上面的图可以看出之间的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * The segments, each of which is a specialized hash table </div><div class="line"> */</div><div class="line">final Segment&lt;K,V&gt;[] segments;</div></pre></td></tr></table></figure>
<p>不变(Immutable)和易变(Volatile)ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。HashEntry代表每个hash链中的一个节点，其结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static final class HashEntry&lt;K,V&gt; &#123;</div><div class="line">     final K key;</div><div class="line">     final int hash;</div><div class="line">     volatile V value;</div><div class="line">     volatile HashEntry&lt;K,V&gt; next;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在JDK 1.6中，HashEntry中的next指针也定义为final，并且每次插入将新添加节点作为链的头节点（同HashMap实现），而且每次删除一个节点时，会将删除节点之前的所有节点 拷贝一份组成一个新的链，而将当前节点的上一个节点的next指向当前节点的下一个节点，从而在删除以后 有两条链存在，因而可以保证即使在同一条链中，有一个线程在删除，而另一个线程在遍历，它们都能工作良好，因为遍历的线程能继续使用原有的链。因而这种实现是一种更加细粒度的happens-before关系，即如果遍历线程在删除线程结束后开始，则它能看到删除后的变化，如果它发生在删除线程正在执行中间，则它会使用原有的链，而不会等到删除线程结束后再执行，即看不到删除线程的影响。如果这不符合你的需求，还是乖乖的用Hashtable或HashMap的synchronized版本，Collections.synchronizedMap()做的包装。</p>
<p>而HashMap中的Entry只有key是final的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">        final K key;</div><div class="line">        V value;</div><div class="line">        Entry&lt;K,V&gt; next;</div><div class="line">        int hash;</div></pre></td></tr></table></figure></p>
<p>不变 模式（immutable）是多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。<br>不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。</p>
<h2 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h2><p>先看看ConcurrentHashMap的初始化做了哪些事情，构造函数的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public ConcurrentHashMap(int initialCapacity,</div><div class="line">                             float loadFactor, int concurrencyLevel) &#123;</div><div class="line">        if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</div><div class="line">            throw new IllegalArgumentException();</div><div class="line">        if (concurrencyLevel &gt; MAX_SEGMENTS)</div><div class="line">            concurrencyLevel = MAX_SEGMENTS;</div><div class="line">        // Find power-of-two sizes best matching arguments</div><div class="line">        int sshift = 0;</div><div class="line">        int ssize = 1;</div><div class="line">        while (ssize &lt; concurrencyLevel) &#123;</div><div class="line">            ++sshift;</div><div class="line">            ssize &lt;&lt;= 1;</div><div class="line">        &#125;</div><div class="line">        this.segmentShift = 32 - sshift;</div><div class="line">        this.segmentMask = ssize - 1;</div><div class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        int c = initialCapacity / ssize;</div><div class="line">        if (c * ssize &lt; initialCapacity)</div><div class="line">            ++c;</div><div class="line">        int cap = MIN_SEGMENT_TABLE_CAPACITY;</div><div class="line">        while (cap &lt; c)</div><div class="line">            cap &lt;&lt;= 1;</div><div class="line">        // create segments and segments[0]</div><div class="line">        Segment&lt;K,V&gt; s0 =</div><div class="line">            new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</div><div class="line">                             (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</div><div class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];</div><div class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]</div><div class="line">        this.segments = ss;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>传入的参数有initialCapacity，loadFactor，concurrencyLevel这三个。</p>
<p>initialCapacity表示新创建的这个ConcurrentHashMap的初始容量，也就是上面的结构图中的Entry数量。默认值为static final int DEFAULT_INITIAL_CAPACITY = 16;<br>loadFactor表示负载因子，就是当ConcurrentHashMap中的元素个数大于loadFactor * 最大容量时就需要rehash，扩容。默认值为static final float DEFAULT_LOAD_FACTOR = 0.75f;<br>concurrencyLevel表示并发级别，这个值用来确定Segment的个数，Segment的个数是大于等于concurrencyLevel的第一个2的n次方的数。比如，如果concurrencyLevel为12，13，14，15，16这些数，则Segment的数目为16(2的4次方)。默认值为static final int DEFAULT_CONCURRENCY_LEVEL = 16;。理想情况下ConcurrentHashMap的真正的并发访问量能够达到concurrencyLevel，因为有concurrencyLevel个Segment，假如有concurrencyLevel个线程需要访问Map，并且需要访问的数据都恰好分别落在不同的Segment中，则这些线程能够无竞争地自由访问（因为他们不需要竞争同一把锁），达到同时访问的效果。这也是为什么这个参数起名为“并发级别”的原因。<br>初始化的一些动作：</p>
<p>验证参数的合法性，如果不合法，直接抛出异常。<br>concurrencyLevel也就是Segment的个数不能超过规定的最大Segment的个数，默认值为static final int MAX_SEGMENTS = 1 &lt;&lt; 16;，如果超过这个值，设置为这个值。<br>然后使用循环找到大于等于concurrencyLevel的第一个2的n次方的数ssize，这个数就是Segment数组的大小，并记录一共向左按位移动的次数sshift，并令segmentShift = 32 - sshift，并且segmentMask的值等于ssize - 1，segmentMask的各个二进制位都为1，目的是之后可以通过key的hash值与这个值做&amp;运算确定Segment的索引。<br>检查给的容量值是否大于允许的最大容量值，如果大于该值，设置为该值。最大容量值为static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;。<br>然后计算每个Segment平均应该放置多少个元素，这个值c是向上取整的值。比如初始容量为15，Segment个数为4，则每个Segment平均需要放置4个元素。<br>最后创建一个Segment实例，将其当做Segment数组的第一个元素。</p>
<h2 id="1-2-put操作"><a href="#1-2-put操作" class="headerlink" title="1.2 put操作"></a>1.2 put操作</h2><p>put操作的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">      Segment&lt;K,V&gt; s;</div><div class="line">      if (value == null)</div><div class="line">          throw new NullPointerException();</div><div class="line">      int hash = hash(key);</div><div class="line">      int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div><div class="line">      if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck</div><div class="line">           (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment</div><div class="line">          s = ensureSegment(j);</div><div class="line">      return s.put(key, hash, value, false);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>操作步骤如下：</p>
<p>判断value是否为null，如果为null，直接抛出异常。<br>key通过一次hash运算得到一个hash值。(这个hash运算下文详说)<br>将得到hash值向右按位移动segmentShift位，然后再与segmentMask做&amp;运算得到segment的索引j。<br>在初始化的时候我们说过segmentShift的值等于32-sshift，例如concurrencyLevel等于16，则sshift等于4，则segmentShift为28。hash值是一个32位的整数，将其向右移动28位就变成这个样子：<br>0000 0000 0000 0000 0000 0000 0000 xxxx，然后再用这个值与segmentMask做&amp;运算，也就是取最后四位的值。这个值确定Segment的索引。<br>使用Unsafe的方式从Segment数组中获取该索引对应的Segment对象。<br>向这个Segment对象中put值，这个put操作也基本是一样的步骤（通过&amp;运算获取HashEntry的索引，然后set）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</div><div class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? null :</div><div class="line">                scanAndLockForPut(key, hash, value);</div><div class="line">            V oldValue;</div><div class="line">            try &#123;</div><div class="line">                HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">                int index = (tab.length - 1) &amp; hash;</div><div class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</div><div class="line">                for (HashEntry&lt;K,V&gt; e = first;;) &#123;</div><div class="line">                    if (e != null) &#123;</div><div class="line">                        K k;</div><div class="line">                        if ((k = e.key) == key ||</div><div class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</div><div class="line">                            oldValue = e.value;</div><div class="line">                            if (!onlyIfAbsent) &#123;</div><div class="line">                                e.value = value;</div><div class="line">                                ++modCount;</div><div class="line">                            &#125;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                        e = e.next;</div><div class="line">                    &#125;</div><div class="line">                    else &#123;</div><div class="line">                        if (node != null)</div><div class="line">                            node.setNext(first);</div><div class="line">                        else</div><div class="line">                            node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</div><div class="line">                        int c = count + 1;</div><div class="line">                        if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</div><div class="line">                            rehash(node);</div><div class="line">                        else</div><div class="line">                            setEntryAt(tab, index, node);</div><div class="line">                        ++modCount;</div><div class="line">                        count = c;</div><div class="line">                        oldValue = null;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                unlock();</div><div class="line">            &#125;</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>put操作是要加锁的。</p>
<h2 id="1-3-get操作"><a href="#1-3-get操作" class="headerlink" title="1.3 get操作"></a>1.3 get操作</h2><p>get操作的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">        Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead</div><div class="line">        HashEntry&lt;K,V&gt;[] tab;</div><div class="line">        int h = hash(key);</div><div class="line">        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</div><div class="line">        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;</div><div class="line">            (tab = s.table) != null) &#123;</div><div class="line">            for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</div><div class="line">                     (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</div><div class="line">                 e != null; e = e.next) &#123;</div><div class="line">                K k;</div><div class="line">                if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</div><div class="line">                    return e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>操作步骤为：</p>
<p>和put操作一样，先通过key进行两次hash确定应该去哪个Segment中取数据。<br>使用Unsafe获取对应的Segment，然后再进行一次&amp;运算得到HashEntry链表的位置，然后从链表头开始遍历整个链表（因为Hash可能会有碰撞，所以用一个链表保存），如果找到对应的key，则返回对应的value值，如果链表遍历完都没有找到对应的key，则说明Map中不包含该key，返回null。<br>值得注意的是，get操作是不需要加锁的（如果value为null，会调用readValueUnderLock，只有这个步骤会加锁），通过前面提到的volatile和final来确保数据安全。</p>
<h2 id="1-4-size操作"><a href="#1-4-size操作" class="headerlink" title="1.4 size操作"></a>1.4 size操作</h2><p>size操作与put和get操作最大的区别在于，size操作需要遍历所有的Segment才能算出整个Map的大小，而put和get都只关心一个Segment。假设我们当前遍历的Segment为SA，那么在遍历SA过程中其他的Segment比如SB可能会被修改，于是这一次运算出来的size值可能并不是Map当前的真正大小。所以一个比较简单的办法就是计算Map大小的时候所有的Segment都Lock住，不能更新(包含put，remove等等)数据，计算完之后再Unlock。这是普通人能够想到的方案，但是牛逼的作者还有一个更好的Idea：先给3次机会，不lock所有的Segment，遍历所有Segment，累加各个Segment的大小得到整个Map的大小，如果某相邻的两次计算获取的所有Segment的更新的次数（每个Segment都有一个modCount变量，这个变量在Segment中的Entry被修改时会加一，通过这个值可以得到每个Segment的更新操作的次数）是一样的，说明计算过程中没有更新操作，则直接返回这个值。如果这三次不加锁的计算过程中Map的更新次数有变化，则之后的计算先对所有的Segment加锁，再遍历所有Segment计算Map大小，最后再解锁所有Segment。源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public int size() &#123;</div><div class="line">        // Try a few times to get accurate count. On failure due to</div><div class="line">        // continuous async changes in table, resort to locking.</div><div class="line">        final Segment&lt;K,V&gt;[] segments = this.segments;</div><div class="line">        int size;</div><div class="line">        boolean overflow; // true if size overflows 32 bits</div><div class="line">        long sum;         // sum of modCounts</div><div class="line">        long last = 0L;   // previous sum</div><div class="line">        int retries = -1; // first iteration isn&apos;t retry</div><div class="line">        try &#123;</div><div class="line">            for (;;) &#123;</div><div class="line">                if (retries++ == RETRIES_BEFORE_LOCK) &#123;</div><div class="line">                    for (int j = 0; j &lt; segments.length; ++j)</div><div class="line">                        ensureSegment(j).lock(); // force creation</div><div class="line">                &#125;</div><div class="line">                sum = 0L;</div><div class="line">                size = 0;</div><div class="line">                overflow = false;</div><div class="line">                for (int j = 0; j &lt; segments.length; ++j) &#123;</div><div class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div><div class="line">                    if (seg != null) &#123;</div><div class="line">                        sum += seg.modCount;</div><div class="line">                        int c = seg.count;</div><div class="line">                        if (c &lt; 0 || (size += c) &lt; 0)</div><div class="line">                            overflow = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (sum == last)</div><div class="line">                    break;</div><div class="line">                last = sum;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</div><div class="line">                for (int j = 0; j &lt; segments.length; ++j)</div><div class="line">                    segmentAt(segments, j).unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return overflow ? Integer.MAX_VALUE : size;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>举个例子：</p>
<p>一个Map有4个Segment，标记为S1，S2，S3，S4，现在我们要获取Map的size。计算过程是这样的：第一次计算，不对S1，S2，S3，S4加锁，遍历所有的Segment，假设每个Segment的大小分别为1，2，3，4，更新操作次数分别为：2，2，3，1，则这次计算可以得到Map的总大小为1+2+3+4=10，总共更新操作次数为2+2+3+1=8；第二次计算，不对S1,S2,S3,S4加锁，遍历所有Segment，假设这次每个Segment的大小变成了2，2，3，4，更新次数分别为3，2，3，1，因为两次计算得到的Map更新次数不一致(第一次是8，第二次是9)则可以断定这段时间Map数据被更新，则此时应该再试一次；第三次计算，不对S1，S2，S3，S4加锁，遍历所有Segment，假设每个Segment的更新操作次数还是为3，2，3，1，则因为第二次计算和第三次计算得到的Map的更新操作的次数是一致的，就能说明第二次计算和第三次计算这段时间内Map数据没有被更新，此时可以直接返回第三次计算得到的Map的大小。最坏的情况：第三次计算得到的数据更新次数和第二次也不一样，则只能先对所有Segment加锁再计算最后解锁。</p>
<h2 id="1-5-containsValue操作"><a href="#1-5-containsValue操作" class="headerlink" title="1.5 containsValue操作"></a>1.5 containsValue操作</h2><p>containsValue操作采用了和size操作一样的想法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public boolean containsValue(Object value) &#123;</div><div class="line">        // Same idea as size()</div><div class="line">        if (value == null)</div><div class="line">            throw new NullPointerException();</div><div class="line">        final Segment&lt;K,V&gt;[] segments = this.segments;</div><div class="line">        boolean found = false;</div><div class="line">        long last = 0;</div><div class="line">        int retries = -1;</div><div class="line">        try &#123;</div><div class="line">            outer: for (;;) &#123;</div><div class="line">                if (retries++ == RETRIES_BEFORE_LOCK) &#123;</div><div class="line">                    for (int j = 0; j &lt; segments.length; ++j)</div><div class="line">                        ensureSegment(j).lock(); // force creation</div><div class="line">                &#125;</div><div class="line">                long hashSum = 0L;</div><div class="line">                int sum = 0;</div><div class="line">                for (int j = 0; j &lt; segments.length; ++j) &#123;</div><div class="line">                    HashEntry&lt;K,V&gt;[] tab;</div><div class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div><div class="line">                    if (seg != null &amp;&amp; (tab = seg.table) != null) &#123;</div><div class="line">                        for (int i = 0 ; i &lt; tab.length; i++) &#123;</div><div class="line">                            HashEntry&lt;K,V&gt; e;</div><div class="line">                            for (e = entryAt(tab, i); e != null; e = e.next) &#123;</div><div class="line">                                V v = e.value;</div><div class="line">                                if (v != null &amp;&amp; value.equals(v)) &#123;</div><div class="line">                                    found = true;</div><div class="line">                                    break outer;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        sum += seg.modCount;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (retries &gt; 0 &amp;&amp; sum == last)</div><div class="line">                    break;</div><div class="line">                last = sum;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</div><div class="line">                for (int j = 0; j &lt; segments.length; ++j)</div><div class="line">                    segmentAt(segments, j).unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return found;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="2-关于hash"><a href="#2-关于hash" class="headerlink" title="2. 关于hash"></a>2. 关于hash</h1><p>看看hash的源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private int hash(Object k) &#123;</div><div class="line">        int h = hashSeed;</div><div class="line"></div><div class="line">        if ((0 != h) &amp;&amp; (k instanceof String)) &#123;</div><div class="line">            return sun.misc.Hashing.stringHash32((String) k);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        h ^= k.hashCode();</div><div class="line"></div><div class="line">        // Spread bits to regularize both segment and index locations,</div><div class="line">        // using variant of single-word Wang/Jenkins hash.</div><div class="line">        h += (h &lt;&lt;  15) ^ 0xffffcd7d;</div><div class="line">        h ^= (h &gt;&gt;&gt; 10);</div><div class="line">        h += (h &lt;&lt;   3);</div><div class="line">        h ^= (h &gt;&gt;&gt;  6);</div><div class="line">        h += (h &lt;&lt;   2) + (h &lt;&lt; 14);</div><div class="line">        return h ^ (h &gt;&gt;&gt; 16);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>源码中的注释是这样的：</p>
<p>Applies a supplemental hash function to a given hashCode, which defends against poor quality hash functions. This is critical because ConcurrentHashMap uses power-of-two length hash tables, that otherwise encounter collisions for hashCodes that do not differ in lower or upper bits.<br>这里用到了Wang/Jenkins hash算法的变种，主要的目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。假如哈希的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。</p>
<p>举个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.out.println(Integer.parseInt(&quot;0001111&quot;, 2) &amp; 15);</div><div class="line">System.out.println(Integer.parseInt(&quot;0011111&quot;, 2) &amp; 15);</div><div class="line">System.out.println(Integer.parseInt(&quot;0111111&quot;, 2) &amp; 15);</div><div class="line">System.out.println(Integer.parseInt(&quot;1111111&quot;, 2) &amp; 15);</div></pre></td></tr></table></figure>
<p>这些数字得到的hash值都是一样的，全是15，所以如果不进行第一次预hash，发生冲突的几率还是很大的，但是如果我们先把上例中的二进制数字使用hash()函数先进行一次预hash，得到的结果是这样的：</p>
<p>0100｜0111｜0110｜0111｜1101｜1010｜0100｜1110 1111｜0111｜0100｜0011｜0000｜0001｜1011｜1000 0111｜0111｜0110｜1001｜0100｜0110｜0011｜1110 1000｜0011｜0000｜0000｜1100｜1000｜0001｜1010<br>上面这个例子引用自:  InfoQ</p>
<p>可以看到每一位的数据都散开了，并且ConcurrentHashMap中是使用预hash值的高位参与运算的。比如之前说的先将hash值向右按位移动28位，再与15做&amp;运算，得到的结果都别为：4，15，7，8，没有冲突！</p>
<h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h1><p>ConcurrentHashMap中的key和value值都不能为null，HashMap中key可以为null，HashTable中key不能为null。<br>ConcurrentHashMap是线程安全的类并不能保证使用了ConcurrentHashMap的操作都是线程安全的！<br>ConcurrentHashMap的get操作不需要加锁，put操作需要加锁</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 并发编程：volatile使用]]></title>
      <url>https://fudawei.github.io/2017/03/02/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B:%E3%80%80%20volatile%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>Java 语言中的 volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。本文介绍了几种有效使用 volatile 变量的模式，并强调了几种不适合使用 volatile 变量的情形。</p>
<p>锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的 —— 如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。</p>
<h2 id="volatile-变量"><a href="#volatile-变量" class="headerlink" title="volatile 变量"></a>volatile 变量</h2><p>Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值。Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start &lt;=end”）。<br>出于简易性或可伸缩性的考虑，您可能倾向于使用 volatile 变量而不是锁。当使用 volatile 变量而非锁时，某些习惯用法（idiom）更加易于编码和阅读。此外，volatile 变量不会像锁那样造成线程阻塞，因此也很少造成可伸缩性问题。在某些情况下，如果读操作远远大于写操作，volatile 变量还可以提供优于锁的性能优势。</p>
<h2 id="正确使用-volatile-变量的条件"><a href="#正确使用-volatile-变量的条件" class="headerlink" title="正确使用 volatile 变量的条件"></a>正确使用 volatile 变量的条件</h2><p>您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：<br>对变量的写操作不依赖于当前值。<br>该变量没有包含在具有其他变量的不变式中。<br>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。（然而，如果将值调整为只从单个线程写入，那么可以忽略第一个条件。）<br>大多数编程情形都会与这两个条件的其中之一冲突，使得 volatile 变量不能像 synchronized 那样普遍适用于实现线程安全。清单 1 显示了一个非线程安全的数值范围类。它包含了一个不变式 —— 下界总是小于或等于上界。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@NotThreadSafe</div><div class="line">public class NumberRange &#123;</div><div class="line">    private int lower, upper;</div><div class="line"></div><div class="line">    public int getLower() &#123; return lower; &#125;</div><div class="line">    public int getUpper() &#123; return upper; &#125;</div><div class="line"></div><div class="line">    public void setLower(int value) &#123; </div><div class="line">        if (value &gt; upper) </div><div class="line">            throw new IllegalArgumentException(...);</div><div class="line">        lower = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setUpper(int value) &#123; </div><div class="line">        if (value &lt; lower) </div><div class="line">            throw new IllegalArgumentException(...);</div><div class="line">        upper = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种方式限制了范围的状态变量，因此将 lower 和 upper 字段定义为 volatile 类型不能够充分实现类的线程安全；从而仍然需要使用同步。否则，如果凑巧两个线程在同一时间使用不一致的值执行 setLower 和 setUpper 的话，则会使范围处于不一致的状态。例如，如果初始状态是 (0, 5)，同一时间内，线程 A 调用 setLower(4) 并且线程 B 调用 setUpper(3)，显然这两个操作交叉存入的值是不符合条件的，那么两个线程都会通过用于保护不变式的检查，使得最后的范围值是 (4, 3) —— 一个无效值。至于针对范围的其他操作，我们需要使 setLower() 和 setUpper() 操作原子化 —— 而将字段定义为 volatile 类型是无法实现这一目的的。</p>
<h5 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h5><p>使用 volatile 变量的主要原因是其简易性：在某些情形下，使用 volatile 变量要比使用相应的锁简单得多。使用 volatile 变量次要原因是其性能：某些情况下，volatile 变量同步机制的性能要优于锁。</p>
<p>很难做出准确、全面的评价，例如 “X 总是比 Y 快”，尤其是对 JVM 内在的操作而言。（例如，某些情况下 VM 也许能够完全删除锁机制，这使得我们难以抽象地比较 volatile 和 synchronized 的开销。）就是说，在目前大多数的处理器架构上，volatile 读操作开销非常低 —— 几乎和非 volatile 读操作一样。而 volatile 写操作的开销要比非 volatile 写操作多很多，因为要保证可见性需要实现内存界定（Memory Fence），即便如此，volatile 的总开销仍然要比锁获取低。</p>
<p>volatile 操作不会像锁一样造成阻塞，因此，在能够安全使用 volatile 的情况下，volatile 可以提供一些优于锁的可伸缩特性。如果读操作的次数要远远超过写操作，与锁相比，volatile 变量通常能够减少同步的性能开销。</p>
<h2 id="正确使用-volatile-的模式"><a href="#正确使用-volatile-的模式" class="headerlink" title="正确使用 volatile 的模式"></a>正确使用 volatile 的模式</h2><p>很多并发性专家事实上往往引导用户远离 volatile 变量，因为使用它们要比使用锁更加容易出错。然而，如果谨慎地遵循一些良好定义的模式，就能够在很多场合内安全地使用 volatile 变量。要始终牢记使用 volatile 的限制 —— 只有在状态真正独立于程序内其他内容时才能使用 volatile —— 这条规则能够避免将这些模式扩展到不安全的用例。</p>
<h4 id="模式-1：状态标志"><a href="#模式-1：状态标志" class="headerlink" title="模式 #1：状态标志"></a>模式 #1：状态标志</h4><p>也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。<br>很多应用程序包含了一种控制结构，形式为 “在还没有准备好停止程序时再执行一些工作”，如清单 2 所示：<br>清单 2. 将 volatile 变量作为状态标志使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">volatile boolean shutdownRequested;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">public void shutdown() &#123; shutdownRequested = true; &#125;</div><div class="line"></div><div class="line">public void doWork() &#123;</div><div class="line">    while (!shutdownRequested) &#123;</div><div class="line">        // do stuff</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很可能会从循环外部调用 shutdown() 方法 —— 即在另一个线程中 —— 因此，需要执行某种同步来确保正确实现 shutdownRequested 变量的可见性。（可能会从 JMX 侦听程序、GUI 事件线程中的操作侦听程序、通过 RMI 、通过一个 Web 服务等调用）。然而，使用 synchronized 块编写循环要比使用清单 2 所示的 volatile 状态标志编写麻烦很多。由于 volatile 简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用 volatile。<br>这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequested 标志从 false 转换为 true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展（从 false 到 true，再转换到 false）。此外，还需要某些原子状态转换机制，例如原子变量。</p>
<h4 id="模式-2：一次性安全发布（one-time-safe-publication）"><a href="#模式-2：一次性安全发布（one-time-safe-publication）" class="headerlink" title="模式 #2：一次性安全发布（one-time safe publication）"></a>模式 #2：一次性安全发布（one-time safe publication）</h4><p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。（这就是造成著名的双重检查锁定（double-checked-locking）问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象）。<br>实现安全发布对象的一种技术就是将对象引用定义为 volatile 类型。清单 3 展示了一个示例，其中后台线程在启动阶段从数据库加载一些数据。其他代码在能够利用这些数据时，在使用之前将检查这些数据是否曾经发布过。<br>清单 3. 将 volatile 变量用于一次性安全发布<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class BackgroundFloobleLoader &#123;</div><div class="line">    public volatile Flooble theFlooble;</div><div class="line"></div><div class="line">    public void initInBackground() &#123;</div><div class="line">        // do lots of stuff</div><div class="line">        theFlooble = new Flooble();  // this is the only write to theFlooble</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SomeOtherClass &#123;</div><div class="line">    public void doWork() &#123;</div><div class="line">        while (true) &#123; </div><div class="line">            // do some stuff...</div><div class="line">            // use the Flooble, but only if it is ready</div><div class="line">            if (floobleLoader.theFlooble != null) </div><div class="line">                doSomething(floobleLoader.theFlooble);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果 theFlooble 引用不是 volatile 类型，doWork() 中的代码在解除对 theFlooble 的引用时，将会得到一个不完全构造的 Flooble。<br>该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象（有效不可变意味着对象的状态在发布之后永远不会被修改）。volatile 类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。</p>
<h4 id="模式-3：独立观察（independent-observation）"><a href="#模式-3：独立观察（independent-observation）" class="headerlink" title="模式 #3：独立观察（independent observation）"></a>模式 #3：独立观察（independent observation）</h4><p>安全使用 volatile 的另一种简单模式是：定期 “发布” 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。<br>使用该模式的另一种应用程序就是收集程序的统计信息。清单 4 展示了身份验证机制如何记忆最近一次登录的用户的名字。将反复使用 lastUser 引用来发布值，以供程序的其他部分使用。<br>清单 4. 将 volatile 变量用于多个独立观察结果的发布<br>public class UserManager {<br>    public volatile String lastUser;</p>
<pre><code>public boolean authenticate(String user, String password) {
    boolean valid = passwordIsValid(user, password);
    if (valid) {
        User u = new User();
        activeUsers.add(u);
        lastUser = user;
    }
    return valid;
}
</code></pre><p>}<br>该模式是前面模式的扩展；将某个值发布以在程序内的其他地方使用，但是与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的 —— 即值的状态在发布后不会更改。使用该值的代码需要清楚该值可能随时发生变化。</p>
<h4 id="模式-4：“volatile-bean”-模式"><a href="#模式-4：“volatile-bean”-模式" class="headerlink" title="模式 #4：“volatile bean” 模式"></a>模式 #4：“volatile bean” 模式</h4><p>volatile bean 模式适用于将 JavaBeans 作为“荣誉结构”使用的框架。在 volatile bean 模式中，JavaBean 被用作一组具有 getter 和/或 setter 方法 的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者（例如 HttpSession）提供了容器，但是放入这些容器中的对象必须是线程安全的。<br>在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。（这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义）。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。清单 5 中的示例展示了遵守 volatile bean 模式的 JavaBean：<br>清单 5. 遵守 volatile bean 模式的 Person 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@ThreadSafe</div><div class="line">public class Person &#123;</div><div class="line">    private volatile String firstName;</div><div class="line">    private volatile String lastName;</div><div class="line">    private volatile int age;</div><div class="line"></div><div class="line">    public String getFirstName() &#123; return firstName; &#125;</div><div class="line">    public String getLastName() &#123; return lastName; &#125;</div><div class="line">    public int getAge() &#123; return age; &#125;</div><div class="line"></div><div class="line">    public void setFirstName(String firstName) &#123; </div><div class="line">        this.firstName = firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setLastName(String lastName) &#123; </div><div class="line">        this.lastName = lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAge(int age) &#123; </div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="volatile-的高级模式"><a href="#volatile-的高级模式" class="headerlink" title="volatile 的高级模式"></a>volatile 的高级模式</h2><p>前面几节介绍的模式涵盖了大部分的基本用例，在这些模式中使用 volatile 非常有用并且简单。这一节将介绍一种更加高级的模式，在该模式中，volatile 将提供性能或可伸缩性优势。<br>volatile 应用的的高级模式非常脆弱。因此，必须对假设的条件仔细证明，并且这些模式被严格地封装了起来，因为即使非常小的更改也会损坏您的代码！同样，使用更高级的 volatile 用例的原因是它能够提升性能，确保在开始应用高级模式之前，真正确定需要实现这种性能获益。需要对这些模式进行权衡，放弃可读性或可维护性来换取可能的性能收益 —— 如果您不需要提升性能（或者不能够通过一个严格的测试程序证明您需要它），那么这很可能是一次糟糕的交易，因为您很可能会得不偿失，换来的东西要比放弃的东西价值更低。</p>
<h4 id="模式-5：开销较低的读－写锁策略"><a href="#模式-5：开销较低的读－写锁策略" class="headerlink" title="模式 #5：开销较低的读－写锁策略"></a>模式 #5：开销较低的读－写锁策略</h4><p>目前为止，您应该了解了 volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作（读、添加、存储）的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。<br>然而，如果读操作远远超过写操作，您可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。清单 6 中显示的线程安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。<br>清单 6. 结合使用 volatile 和 synchronized 实现 “开销较低的读－写锁”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@ThreadSafe</div><div class="line">public class CheesyCounter &#123;</div><div class="line">    // Employs the cheap read-write lock trick</div><div class="line">    // All mutative operations MUST be done with the &apos;this&apos; lock held</div><div class="line">    @GuardedBy(&quot;this&quot;) private volatile int value;</div><div class="line"></div><div class="line">    public int getValue() &#123; return value; &#125;</div><div class="line"></div><div class="line">    public synchronized int increment() &#123;</div><div class="line">        return value++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之所以将这种技术称之为 “开销较低的读－写锁” 是因为您使用了不同的同步机制进行读写操作。因为本例中的写操作违反了使用 volatile 的第一个条件，因此不能使用 volatile 安全地实现计数器 —— 您必须使用锁。然而，您可以在读操作中使用 volatile 确保当前值的可见性，因此可以使用锁进行所有变化的操作，使用 volatile 进行只读操作。其中，锁一次只允许一个线程访问值，volatile 允许多个线程执行读操作，因此当使用 volatile 保证读代码路径时，要比使用锁执行全部代码路径获得更高的共享度 —— 就像读－写操作一样。然而，要随时牢记这种模式的弱点：如果超越了该模式的最基本应用，结合这两个竞争的同步机制将变得非常困难。<br>结束语<br>与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。本文介绍的模式涵盖了可以使用 volatile 代替 synchronized 的最常见的一些用例。遵循这些模式（注意使用时不要超过各自的限制）可以帮助您安全地实现大多数用例，使用 volatile 变量获得更佳性能。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程分享]]></title>
      <url>https://fudawei.github.io/2017/02/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%86%E4%BA%AB/</url>
      <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul>
<li>核心理论</li>
<li>内置锁实现原理以及底层优化</li>
<li>volatile的使用及其原理</li>
<li>Executor和ExecutorService</li>
<li>AQS阻塞队列</li>
</ul>
<h2 id="核心理论"><a href="#核心理论" class="headerlink" title="核心理论"></a><a href="https://fudawei.github.io/2017/02/05/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/" title="核心理论">核心理论</a></h2><ul>
<li>共享性</li>
<li>互斥性</li>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<h2 id="内置锁原理和优化"><a href="#内置锁原理和优化" class="headerlink" title="内置锁原理和优化"></a><a href="https://fudawei.github.io/2017/02/07/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E5%86%85%E7%BD%AE%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96/" title="内置锁原理和优化">内置锁原理和优化</a></h2><ul>
<li><p>内置锁的基本使用和原理</p>
<ul>
<li>内置锁的使用</li>
<li>内置锁原理</li>
</ul>
</li>
</ul>
<ul>
<li><p>内置锁的底层优化</p>
<ul>
<li>重量级锁</li>
<li>轻量级锁</li>
<li>偏向锁</li>
<li>其他优化</li>
</ul>
</li>
</ul>
<h2 id="volatile的使用及其原理"><a href="#volatile的使用及其原理" class="headerlink" title="volatile的使用及其原理"></a><a href="https://fudawei.github.io/2017/02/08/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9Avolatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/" title="volatile的使用及其原理">volatile的使用及其原理</a></h2><ul>
<li>volatile的作用</li>
<li>volatile的使用</li>
<li>volatile的原理</li>
</ul>
<h2 id="Executor和ExecutorService接口"><a href="#Executor和ExecutorService接口" class="headerlink" title="Executor和ExecutorService接口"></a><a href="https://fudawei.github.io/2013/08/11/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%80]Executor%E5%92%8CExecutorService/" title="Executor和ExecutorService接口">Executor和ExecutorService接口</a></h2><ul>
<li><p>Executor接口</p>
<ul>
<li>概述</li>
<li>execute方法</li>
</ul>
</li>
<li><p>ExecutorService接口</p>
<ul>
<li>概述</li>
<li>shutdown方法</li>
<li>shutdownNow方法</li>
<li>isShutdown方法</li>
<li>isTerminated方法</li>
<li>awaitTermination方法</li>
<li>submit方法</li>
<li>invokeAll方法</li>
<li>invokeAny方法</li>
</ul>
</li>
</ul>
<h2 id="AQS阻塞队列"><a href="#AQS阻塞队列" class="headerlink" title="AQS阻塞队列"></a><a href="https://fudawei.github.io/2017/02/14/[%E5%B9%B6%E5%8F%91%E9%94%81(%E4%BA%8C)]AQS%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/" title="AQS阻塞队列">AQS阻塞队列</a></h2><ul>
<li>自旋锁优化</li>
<li>CLH锁改造</li>
<li>公平性</li>
<li>AQS超时机制</li>
<li>同步状态的管理</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[并发锁(四)]加锁原理]]></title>
      <url>https://fudawei.github.io/2017/02/15/%5B%E5%B9%B6%E5%8F%91%E9%94%81(%E5%9B%9B)%5D%20%E5%8A%A0%E9%94%81%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>接上篇，这篇从Lock.lock/unlock开始。特别说明在没有特殊情况下所有程序、API、文档都是基于JDK 6.0的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void Java.util.concurrent.locks.ReentrantLock.lock()</div><div class="line"></div><div class="line">		获取锁。</div><div class="line">	    如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。</div><div class="line">	    如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。</div><div class="line">	    如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1。</div></pre></td></tr></table></figure>
<p>从上面的文档可以看出ReentrantLock是可重入锁的实现。而内部是委托java.util.concurrent.locks.ReentrantLock.Sync.lock()实现的。java.util.concurrent.locks.ReentrantLock.Sync是抽象类，有java.util.concurrent.locks.ReentrantLock.FairSync和java.util.concurrent.locks.ReentrantLock.NonfairSync两个实现，也就是常说的公平锁和不公平锁。</p>
<blockquote>
<p> 公平锁和非公平锁</p>
<p> 如果获取一个锁是按照请求的顺序得到的，那么就是公平锁，否则就是非公平锁。</p>
</blockquote>
<p>在没有深入了解内部机制及实现之前，先了解下为什么会存在公平锁和非公平锁。公平锁保证一个阻塞的线程最终能够获得锁，因为是有序的，所以总是可以按照请求的顺序获得锁。不公平锁意味着后请求锁的线程可能在其前面排列的休眠线程恢复前拿到锁，这样就有可能提高并发的性能。这是因为通常情况下挂起的线程重新开始与它真正开始运行，二者之间会产生严重的延时。因此非公平锁就可以利用这段时间完成操作。这是非公平锁在某些时候比公平锁性能要好的原因之一。</p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>我们先从公平锁（FairSync）开始。</p>
<p>前面说过java.util.concurrent.locks.AbstractQueuedSynchronizer （AQS) 是Lock的基础，对于一个FairSync而言，lock()就直接调用AQS的acquire(int arg);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final void acquire(int arg)</div></pre></td></tr></table></figure></p>
<p>acquire方法<br>以独占模式获取对象，忽略中断。通过至少调用一次tryAcquire(int) 来实现此方法，并在成功时返回。<br>否则在成功之前，一直调用 tryAcquire(int)   将线程加入队列，线程可能重复被阻塞或不被阻塞。</p>
<p>在介绍实现之前先要补充上一节的知识，对于一个AQS的实现而言，通常情况下需要实现以下方法来描述如何锁定线程。</p>
<ul>
<li>tryAcquire(int)   试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它。<br>此方法总是由执行 acquire 的线程来调用。如果此方法报告失败，则 acquire 方法可以将线程加入队列（如果还没有将它加入队列），直到获得其他某个线程释放了该线程的信号。也就是说此方法是一种尝试性* 方法，如果成功获取锁那最好，如果没有成功也没有关系，直接返回false。</li>
<li>tryRelease(int)   试图设置状态来反映独占模式下的一个释放。 此方法总是由正在执行释放的线程调用。释放锁可能失败或者抛出异常，这个在后面会具体分析。</li>
<li>tryAcquireShared(int)   试图在共享模式下获取对象状态。</li>
<li>tryReleaseShared(int)   试图设置状态来反映共享模式下的一个释放。</li>
<li>isHeldExclusively()   如果对于当前（正调用的）线程，同步是以独占方式进行的，则返回  true 。</li>
</ul>
<p>除了tryAcquire(int)外，其它方法会在后面具体介绍。首先对于ReentrantLock而言，不管是公平锁还是非公平锁，都是独占锁，也就是说同时能够有一个线程持有锁。因此对于acquire(int arg)而言，arg==1。在AQS中acquire的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public final void acquire(int arg) &#123;</div><div class="line">    if (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个看起来比较复杂，我们分解以下4个步骤。</p>
<ul>
<li>如果tryAcquire(arg)成功，那就没有问题，已经拿到锁，整个lock()过程就结束了。如果失败进行操作2。</li>
<li>创建一个独占节点（Node）并且此节点加入CHL队列末尾。进行操作3。</li>
<li>自旋尝试获取锁，失败根据前一个节点来决定是否挂起（park()），直到成功获取到锁。进行操作4。</li>
<li>如果当前线程已经中断过，那么就中断当前线程（清除中断位）。</li>
</ul>
<p>这是一个比较复杂的过程，我们按部就班一个一个分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tryAcquire(acquires)</div></pre></td></tr></table></figure>
<p>对于公平锁而言，它的实现方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">        final Thread current = Thread.currentThread();</div><div class="line">        int c = getState();</div><div class="line">        if (c == 0) &#123;</div><div class="line">            if (isFirst(current) &amp;&amp;</div><div class="line">                compareAndSetState(0, acquires)) &#123;</div><div class="line">                setExclusiveOwnerThread(current);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else if (current == getExclusiveOwnerThread()) &#123;</div><div class="line">            int nextc = c + acquires;</div><div class="line">            if (nextc &lt; 0)</div><div class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">            setState(nextc);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   在这段代码中，前面说明对于AQS存在一个state来描述当前有多少线程持有锁。<br>   由于AQS支持共享锁（例如读写锁，后面会继续讲），所以这里state&gt;=0，但是由于ReentrantLock是独占锁，所以这里不妨理解为0&lt;=state，acquires=1。isFirst(current)是一个很复杂的逻辑，包括踢出无用的节点等复杂过程，这里暂且不提，大体上的意思是说判断AQS是否为空或者当前线程是否在队列头（为了区分公平与非公平锁）。</p>
<ol>
<li><p>如果当前锁有其它线程持有，c!=0，进行操作2。否则，如果当前线程在AQS队列头部，则尝试将AQS状态state设为acquires（等于1），成功后将AQS独占线程设为当前线程返回true，否则进行2。这里可以看到compareAndSetState就是使用了CAS操作。</p>
</li>
<li><p>判断当前线程与AQS的独占线程是否相同，如果相同，那么就将当前状态位加1（这里+1后结果为负数后面会讲，这里暂且不理它），修改状态位，返回true，否则进行3。这里之所以不是将当前状态位设置为1，而是修改为旧值+1呢？这是因为ReentrantLock是可重入锁，同一个线程每持有一次就+1。</p>
</li>
<li><p>返回false。</p>
</li>
</ol>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>比较非公平锁的tryAcquire实现java.util.concurrent.locks.ReentrantLock.Sync.nonfairTryAcquire(int)，公平锁多了一个判断当前节点是否在队列头，这个就保证了是否按照请求锁的顺序来决定获取锁的顺序（同一个线程的多次获取锁除外）。</p>
<p>现在再回头看公平锁和非公平锁的lock()方法。公平锁只有一句acquire(1)；而非公平锁的调用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">final void lock() &#123;</div><div class="line">    if (compareAndSetState(0, 1))</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    else</div><div class="line">        acquire(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很显然，非公平锁在第一次获取锁，或者其它线程释放锁后（可能等待），优先采用compareAndSetState(0,1)然后设置AQS独占线程而持有锁，这样有时候比acquire(1)顺序检查锁持有而要高效。即使在重入锁上，也就是compareAndSetState(0,1)失败，但是是当前线程持有锁上，非公平锁也没有问题</p>
<h3 id="addWaiter-mode"><a href="#addWaiter-mode" class="headerlink" title="addWaiter(mode)"></a>addWaiter(mode)</h3><p>tryAcquire失败就意味着入队列了。此时AQS的队列中节点Node就开始发挥作用了。一般情况下AQS支持独占锁和共享锁，而独占锁在Node中就意味着条件（Condition）队列为空（上一篇中介绍过相关概念）。在java.util.concurrent.locks.AbstractQueuedSynchronizer.Node中有两个常量，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static final Node EXCLUSIVE = null; //独占节点模式</div><div class="line">static final Node SHARED = new Node(); //共享节点模式</div><div class="line"></div><div class="line">addWaiter(mode)中的mode就是节点模式，也就是共享锁还是独占锁模式</div></pre></td></tr></table></figure>
<p>前面一再强调ReentrantLock是独占锁模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private Node addWaiter(Node mode) &#123;</div><div class="line">     Node node = new Node(Thread.currentThread(), mode);</div><div class="line">     // Try the fast path of enq; backup to full enq on failure</div><div class="line">     Node pred = tail;</div><div class="line">     if (pred != null) &#123;</div><div class="line">         node.prev = pred;</div><div class="line">         if (compareAndSetTail(pred, node)) &#123;</div><div class="line">             pred.next = node;</div><div class="line">             return node;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     enq(node);</div><div class="line">     return node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是节点如队列的一部分。当前仅当队列不为空并且将新节点插入尾部成功后直接返回新节点。否则进入enq(Node)进行操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private Node enq(final Node node) &#123;</div><div class="line">    for (;;) &#123;</div><div class="line">        Node t = tail;</div><div class="line">        if (t == null) &#123; // Must initialize</div><div class="line">            Node h = new Node(); // Dummy header</div><div class="line">            h.next = node;</div><div class="line">            node.prev = h;</div><div class="line">            if (compareAndSetHead(h)) &#123;</div><div class="line">                tail = node;</div><div class="line">                return h;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            node.prev = t;</div><div class="line">            if (compareAndSetTail(t, node)) &#123;</div><div class="line">                t.next = node;</div><div class="line">                return t;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>enq(Node)去队列操作实现了CHL队列的算法，如果为空就创建头结点，然后同时比较节点尾部是否是改变来决定CAS操作是否成功，当且仅当成功后才将为不节点的下一个节点指向为新节点。可以看到这里仍然是CAS操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">acquireQueued(node,arg)</div></pre></td></tr></table></figure>
<p>自旋请求锁，如果可能的话挂起线程，直到得到锁，返回当前线程是否中断过（如果park()过并且中断过的话有一个interrupted中断位）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">final boolean acquireQueued(final Node node, int arg) &#123;</div><div class="line">    try &#123;</div><div class="line">        boolean interrupted = false;</div><div class="line">        for (;;) &#123;</div><div class="line">            final Node p = node.predecessor();</div><div class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = null; // help GC</div><div class="line">                return interrupted;</div><div class="line">            &#125;</div><div class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = true;</div><div class="line">        &#125;</div><div class="line">    &#125; catch (RuntimeException ex) &#123;</div><div class="line">        cancelAcquire(node);</div><div class="line">        throw ex;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面的分析就需要用到上节节点的状态描述了。acquireQueued过程是这样的：</p>
<p>如果当前节点是AQS队列的头结点（如果第一个节点是DUMP节点也就是傀儡节点，那么第二个节点实际上就是头结点了），就尝试在此获取锁tryAcquire(arg)。如果成功就将头结点设置为当前节点（不管第一个结点是否是DUMP节点），返回中断位。否则进行2。<br>检测当前节点是否应该park()，如果应该park()就挂起当前线程并且返回当前线程中断位。进行操作1。<br>一个节点是否该park()是关键，这是由方法java.util.concurrent.locks.AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire(Node, Node)实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</div><div class="line">    int s = pred.waitStatus;</div><div class="line">    if (s &lt; 0) return true;</div><div class="line">    if (s &gt; 0) &#123;</div><div class="line">        do &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; while (pred.waitStatus &gt; 0);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; else compareAndSetWaitStatus(pred, 0, Node.SIGNAL);</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果前一个节点的等待状态waitStatus<0，也就是前面的节点还没有获得到锁，那么返回true，表示当前节点（线程）就应该park()了。否则进行2。 如果前一个节点的等待状态waitstatus="">0，也就是前一个节点被CANCELLED了，那么就将前一个节点去掉，递归此操作直到所有前一个节点的waitStatus&lt;=0，进行4。否则进行3。<br>前一个节点等待状态waitStatus=0，修改前一个节点状态位为SINGAL，表示后面有节点等待你处理，需要根据它的等待状态来决定是否该park()。进行4。<br>返回false，表示线程不应该park()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">selfInterrupt()</div><div class="line"></div><div class="line">private static void selfInterrupt() &#123;</div><div class="line">    Thread.currentThread().interrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></0，也就是前面的节点还没有获得到锁，那么返回true，表示当前节点（线程）就应该park()了。否则进行2。></p>
<p>如果线程曾经中断过（或者阻塞过）（比如手动interrupt()或者超时等等，那么就再中断一次，中断两次的意思就是清除中断位）。</p>
<p>大体上整个Lock.lock()就这样一个流程。除了lock()方法外，还有lockInterruptibly()/tryLock()/unlock()/newCondition()等，在接下来的章节中会一一介绍</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[并发锁(二)]AQS阻塞队列]]></title>
      <url>https://fudawei.github.io/2017/02/14/%5B%E5%B9%B6%E5%8F%91%E9%94%81(%E4%B8%89)%5DAQS%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>我们知道一个线程在尝试获取锁失败后将被阻塞并加入等待队列中，它是一个怎样的队列？又是如何管理此队列？这节聊聊CHL Node FIFO队列。<br> 在谈到CHL Node FIFO队列之前，我们先分析这种队列的几个要素。首先要了解的是自旋锁，所谓自旋锁即是某一线程去尝试获取某个锁时，如果该锁已经被其他线程占用的话，此线程将不断循环检查该锁是否被释放，而不是让此线程挂起或睡眠。它属于为了保证共享资源而提出的一种锁机制，与互斥锁类似，保证了公共资源在任意时刻最多只能由一条线程获取使用，不同的是互斥锁在获取锁失败后将进入睡眠或阻塞状态。下面利用代码实现一个简单的自旋锁，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class SpinLock &#123;</div><div class="line">	private static Unsafe unsafe = null;</div><div class="line">	private static final long valueOffset;</div><div class="line">	private volatile int value = 0;</div><div class="line"></div><div class="line">	static &#123;</div><div class="line">		try &#123;</div><div class="line">			unsafe=getUnsafeInstance();</div><div class="line">			valueOffset = unsafe.objectFieldOffset(SpinLock.class.getDeclaredField(&quot;value&quot;));</div><div class="line">		&#125; catch (Exception ex) &#123;</div><div class="line">			throw new Error(ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static Unsafe getUnsafeInstance() throws SecurityException,NoSuchFieldException,IllegalArgumentException,IllegalAccessException &#123;</div><div class="line">		Field theUnsafeInstance = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</div><div class="line">		theUnsafeInstance.setAccessible(true);</div><div class="line">		return (Unsafe) theUnsafeInstance.get(Unsafe.class);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void lock() &#123;</div><div class="line">		for (;;) &#123;</div><div class="line">            int newV = value + 1;</div><div class="line">            if(newV==1)</div><div class="line">                if (unsafe.compareAndSwapInt(this, valueOffset, 0, newV))&#123;</div><div class="line">                	return ;</div><div class="line">                &#125;</div><div class="line">        	&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    public void unlock() &#123;</div><div class="line">		unsafe.compareAndSwapInt(this, valueOffset, 1, 0);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个很简单的自旋锁，主要看加粗加红的两个方法lock和unlock，Unsafe仅仅是为操作提供了硬件级别的原子CAS操作，暂时忽略此类，只要知道它的作用即可，我们将在后面的“原子性如何保证”小节中对此进行更加深入的阐述。对于lock方法，假如有若干线程竞争，能成功通过CAS操作修改value值为newV的线程即是成功获取锁的线程，将直接通过，而其他的线程则不断在循环检测value值是否又改回0，而将value改为0的操作就是获取锁的线程执行完后对该锁进行释放，通过unlock方法释放锁，释放后若干线程又对该锁竞争。如此一来，没获取的锁也不会被挂起或阻塞，而是不断循环检查状态。图2-5-9-3可加深自旋锁的理解，五条线程轮询value变量，t1获取成功后将value置为1，此状态时其他线程无法竞争锁，t1使用完锁后将value置为0，剩下的线程继续竞争锁，以此类推。这样就保证了某个区域块的线程安全性。</p>
<p><img src="/img/sy/sy-1.jpg" alt=""><br>自旋锁</p>
<blockquote>
<p>自旋锁缺点<br>自旋锁适用于锁占用时间短，即锁保护临界区很小的情景，同时它需要硬件级别操作，也要保证各缓存数据的一致性，另外，无法保证公平性，不保证先到先获得，可能造成线程饥饿。在多处理器机器上，每个线程对应的处理器都对同一个变量进行读写，而每次读写操作都将要同步每个处理器缓存，导致系统性能严重下降。</p>
</blockquote>
<h3 id="自旋锁优化"><a href="#自旋锁优化" class="headerlink" title="自旋锁优化"></a>自旋锁优化</h3><p>看Craig, Landin, and Hagersten发明的CLH锁如何优化同步带来的花销，其核心思想是：通过一定手段将所有线程对某一共享变量轮询竞争转化为一个线程队列且队列中的线程各自轮询自己的本地变量。这个转化过程由两个要点，一是构建怎样的队列&amp;如何构建队列，为了保证公平性，构建的将是一个FIFO队列，构建的时候主要通过移动尾部节点tail实现队列的排队，每个想获取锁的线程创建一个新节点并通过CAS原子操作将新节点赋予tail，然后让当前线程轮询前一节点的某个状态位，如图2-5-9-3，如此就成功构建线程排队队列；二是如何释放队列，执行完线程后只需将当前线程对应的节点状态位置为解锁状态，由于下一节点一直在轮询，可获取到锁</p>
<p><img src="/img/sy/sy-2.jpg" alt=""></p>
<p>CLH锁的核心思想貌似是将众多线程长时间对某资源的竞争，通过有序化这些线程转化为只需对本地变量检测。唯一存在竞争的地方就是在入队列之前对尾节点tail的竞争，但竞争的线程的数量已经少了很多，且比起所有线程直接对某资源竞争的轮询次数也减少了很多，节省了很多CPU缓存同步操作，大大提升系统性能，利用空间换取性能。下面提供一个简单的CLH锁实现代码，lock与unlock两方法提供加锁解锁操作，每次加锁解锁必须将一个CLHNode对象作为参数传入，lock方法的for循环是通过CAS操作将新节点插入队列，而while循环则是检测前驱节点的锁状态位，一旦前驱节点锁状态位允许则结束检测让线程往下执行。解锁操作先判断当前节点是否为尾节点，如是则直接将尾节点置为空，此时说名仅仅只有一条线程在执行，否则将当前节点的锁状态位置为解锁状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class CLHLock &#123;</div><div class="line"></div><div class="line">	private static Unsafe unsafe = null;</div><div class="line">	private static final long valueOffset;</div><div class="line">	private volatile CLHNode tail;</div><div class="line">	public class CLHNode &#123;</div><div class="line">		private boolean isLocked = true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	static &#123;</div><div class="line">		try &#123;</div><div class="line">			unsafe = getUnsafeInstance();</div><div class="line">     		valueOffset = unsafe.objectFieldOffset(CLHLock.class.getDeclaredField(&quot;tail&quot;));</div><div class="line">		&#125; catch (Exception ex) &#123;</div><div class="line">			throw new Error(ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void lock(CLHNode currentThreadNode) &#123;</div><div class="line">		CLHNode preNode = null;</div><div class="line">		for (;;) &#123;</div><div class="line">			preNode = tail;</div><div class="line">			if (unsafe.compareAndSwapObject(this, valueOffset, tail,currentThreadNode))</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			if (preNode != null)</div><div class="line">				while (preNode.isLocked) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	public void unlock(CLHNode currentThreadNode) &#123;</div><div class="line">  		if (!unsafe.compareAndSwapObject(this, valueOffset, currentThreadNode,null))</div><div class="line">   			currentThreadNode.isLocked = false;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	private static Unsafe getUnsafeInstance() throws SecurityException,</div><div class="line">							NoSuchFieldException, IllegalArgumentException,IllegalAccessException &#123;</div><div class="line">		Field theUnsafeInstance = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</div><div class="line">		theUnsafeInstance.setAccessible(true);</div><div class="line">		return (Unsafe) theUnsafeInstance.get(Unsafe.class);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CLH锁改造"><a href="#CLH锁改造" class="headerlink" title="CLH锁改造"></a>CLH锁改造</h3><p>在CLH锁核心思想的影响下，Java并发包的基础框架AQS以CLH锁作为基础而设计，其中主要是考虑到CLH锁更容易实现取消与超时功能。比起原来的CLH锁已经做了很大的改造，主要从两方面进行了改造：节点的结构与节点等待机制。在结构上引入了头结点和尾节点，他们分别指向队列的头和尾，尝试获取锁、入队列、释放锁等实现都与头尾节点相关，并且每个节点都引入前驱节点和后后续节点的引用；在等待机制上由原来的自旋改成阻塞唤醒。如图2-5-9-4，通过前驱后续节点的引用一节节连接起来形成一个链表队列，对于头尾节点的更新必须是原子的。下面详细看看入队、检测挂起、释放出队、超时、取消等操作。</p>
<p><img src="/img/sy/sy-3.jpg" alt=""></p>
<ol>
<li><p>入队，整块逻辑其实是用一个无限循环进行CAS操作，即用自旋方式竞争直到成功。将尾节点tail的旧值赋予新节点node的前驱节点，并尝试CAS操作将新节点node赋予尾节点tail，原先的尾节点的后续节点指向新建节点node。完成上面步骤就建立起一条如图2-5-9-4所示的链表队列。代码简化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for (;;) &#123;</div><div class="line">   Node t = tail;</div><div class="line">   node.prev = t;</div><div class="line">   if (compareAndSetTail(t, node)) &#123;</div><div class="line">      t.next = node;</div><div class="line">      return node;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>检测挂起，上面我们说到节点等待机制已经被AQS作者由自旋机制改造成阻塞机制，一个新建的节点完成入队操作后，如果是自旋则直接进入循环检测前驱节点是否为头结点即可，但现在被改为阻塞机制，当前线程将首先检测是否为头结点且尝试获取锁，如果当前节点为头结点并成功获取锁则直接返回，当前线程不进入阻塞，否则将当前线程阻塞。代码简化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> for (;;) &#123;</div><div class="line">    if (node.prev == head)</div><div class="line">	if(尝试获取锁成功)&#123;</div><div class="line">         head=node;</div><div class="line">         node.next=null;</div><div class="line">         return;</div><div class="line">     &#125;</div><div class="line">   阻塞线程</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>释放出队，出队的主要工作是负责唤醒等待队列中后续节点，让所有等待节点环环相接，每条线程有序地往下执行。代码简化如下：<br>Node s = node.next;<br>唤醒节点s包含的线程</p>
</li>
<li><p>超时，在支持超时的模式下需要LockSupport类的parkNanos方法支持，线程在阻塞一段时间后会自动唤醒，每次循环将累加消耗时间，当总消耗时间大于等于自定义的超时时间时就直接分返。代码简化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (;;) &#123;</div><div class="line">   尝试获取锁</div><div class="line">   if (nanosTimeout &lt;= 总消耗时间)</div><div class="line">      return;</div><div class="line">   LockSupport.parkNanos(this, nanosTimeout);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>取消，队列中等待锁的队列可能因为中断或超时而涉及到取消操作，这种情况下被取消的节点不再进行锁竞争。此过程主要完成的工作是将取消的节点移除，先将节点的。先将节点node状态设置成取消，再将前驱节点pred的后续节点指向node的后续节点，这里由于涉及到竞争，必须通过CAS进行操作，CAS操作就算失败也不必理会，因为已经改了节点的状态，在尝试获取锁操作中会循环对节点的状态判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">node.waitStatus = Node.CANCELLED;</div><div class="line">Node pred = node.prev;</div><div class="line">Node predNext = pred.next;</div><div class="line">Node next = node.next;</div><div class="line">compareAndSetNext(pred, predNext, next);</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>所谓公平性指所有线程对临界资源申请访问权限的成功率都一样，不会让某些线程拥有优先权。通过前面的CLH Node FIFO学习知道了等待队列是一个先进先出的队列，那么是否就可以说每条线程获取锁时就是公平的呢？关于公平性这里分拆成三个点分别阐述：</p>
<ol>
<li><p>准备入队列的节点，此情况讨论的是线程加入等待队列时产生的竞争是否公平，线程在尝试获取锁失败后将被加入等待队列，这时多个线程通过自旋将节点加入队列，所有线程在自旋过程中是无法保证其公平性的，可能后来的线程比早到的先进入队列，所以节点入队列不具公平性。</p>
</li>
<li><p>等待队列中的节点，情况①中成功加入队列后即成为等待队列中的节点，我们知道此队列是一个先入先出队列，那么很简单能得到，队列中的所有节点是公平的，他们都按照顺序等待自己被前驱节点唤醒并获取锁，所以等待队列中的节点具有公平性。</p>
</li>
<li><p>闯入的节点，这种情况是指一个新线程到达共享资源边界时不管等待队列中是否存在其他等待节点它都将优先尝试去获取锁，这种称为可闯入策略。可闯入特性破坏了公平性，AQS框架对外体现的公平性主要由此体现，下面将对闯入特性展开分析。</p>
</li>
</ol>
<p>AQS提供的基础获取锁算法是一种可闯入的算法，即如果有新线程到来先进行一次获取尝试，不成功的情况下才将当前线程加入等待队列。如图2-5-9-6所示，等待队列中节点线程按照顺序一个接一个尝试去获取共享资源的使用权，某时刻头结点线程准备尝试获取的同时另外一条线程闯入，此线程并非直接加入等待队列的尾部，而是先跟头结点线程竞争获取资源，闯入线程如果成功获取共享资源则直接执行，头结点线程则继续等待下一次尝试，如此一来闯入线程成功插队，后来的线程比早到的线程先执行，说明AQS基础获取算法是不严格公平的。</p>
<p><img src="/img/sy/sy-4.png" alt=""></p>
<p>基础获取算法逻辑简化如下：首先尝试获取锁，假如获取失败才创建节点并加入到等待队列的尾部，接着通过不断循环检查是否轮到自己执行，当然此过程为了提高性能可能将线程先挂起，最终由前驱节点唤醒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if (尝试获取锁失败) &#123;</div><div class="line">    创建node</div><div class="line">    使用CAS方式把node插入到队列尾部</div><div class="line">    while(true)&#123;</div><div class="line">    if(尝试获取锁成功 并且 node的前驱节点为头节点)&#123;</div><div class="line">	把当前节点设置为头节点</div><div class="line">    跳出循环</div><div class="line">&#125; else &#123;</div><div class="line">    使用CAS方式修改node前驱节点的waitStatus标识为signal</div><div class="line">    if(修改成功)</div><div class="line">        挂起当前线程</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么要使用闯入策略？可闯入的策略通常可以提供更高的总吞吐量。由于一般同步器颗粒度比较小，也可以说共享资源的范围较小，而线程从阻塞状态到被唤醒所消耗的时间周期可能是通过共享资源时间周期的几倍甚至几十倍，如此一来线程唤醒过程中将存在一个很大的时间周期空窗期，导致资源没有得到充分利用，为了提高吞吐量，引入这种闯入策略，它可以使在等待队列头结点从阻塞到被唤醒的时间段内闯入的线程直接获取锁并通过同步器，以便充分利用唤醒过程这一空窗期，大大增加了吞吐率。另外，闯入机制的实现对外提供一种竞争调节机制，即开发者可以在自定义同步器中定义闯入尝试获取的次数，假设次数为n则不断重复获取直到n次都获取不成功才把线程加入等待队列中，随着次数n的增加可以增大成功闯入的几率。同时，这种闯入策略可能导致等待队列中的线程饥饿，因为锁可能一直被闯入的线程获取，但由于一般持有同步器的时间很短暂而避免饥饿的发生，反之如果保护的代码体很长并且持有同步器的时间较长，这将大大增加等待队列无限等待的风险。</p>
<p>在实际情况中还是要根据用户需求制定策略，在一个公平性要求很高的场景，则可以把闯入策略去除掉以达到公平。在自定义同步器中可以通过AQS预留方法tryAcquire方法实现，只需判断当前线程是否为等待队列中头结点对应的线程，若不是则直接返回false，尝试获取失败。但前面这种公平性是相对Java语法语义层面上的公平性，在现实中JVM的实现会直接影响线程执行的顺序。</p>
<h3 id="AQS超时机制"><a href="#AQS超时机制" class="headerlink" title="AQS超时机制"></a>AQS超时机制</h3><p>AQS框架提供的另外一个优秀机制是锁获取超时的支持，当大量线程对某一锁竞争时可能导致某些线程在很长一段时间都获取不了锁，在某些场景下可能希望如果线程在一段时间内不能成功获取锁就取消对该锁的等待以提高性能，这时就需要用到超时机制。在JDK1.5之前还没有juc工具，当时的并发控制职能通过JVM内置的synchronized关键词实现锁，但对一些特殊要求却力不从心，例如超时取消控制。JDK1.5开始引入juc工具完美解决了此问题，而这正得益于并发基础框架AQS提供了超时的支持。</p>
<p>为了更精确地保证时间间隔统计的准确性，实现时使用了System.nanoTime()更为精确的方法，它能精确到纳秒级别。超时机制的思想就是在不断进行锁竞争的同时记录竞争的时间，一旦时间段超过指定的时间则停止轮询直接返回，返回前对等待队列中对应节点进行取消操作。往下看实现的逻辑，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">if(尝试获取锁失败) &#123;</div><div class="line">long lastTime = System.nanoTime();</div><div class="line">    创建node</div><div class="line">    使用CAS方式把node插入到队列尾部</div><div class="line">    while(true)&#123;</div><div class="line">    if(尝试获取锁成功 并且 node的前驱节点为头节点)&#123;</div><div class="line">	把当前节点设置为头节点</div><div class="line">    跳出循环</div><div class="line">&#125; else &#123;</div><div class="line">    if (nanosTimeout &lt;= 0)&#123;</div><div class="line">	取消等待队列中此节点</div><div class="line">	跳出循环</div><div class="line">&#125;</div><div class="line">    使用CAS方式修改node前驱节点的waitStatus标识为signal</div><div class="line">    if(修改成功)</div><div class="line">        if(nanosTimeout &gt; spinForTimeoutThreshold)</div><div class="line">        阻塞当前线程nanosTimeout纳秒</div><div class="line">   		long now = System.nanoTime();</div><div class="line">    	nanosTimeout -= now - lastTime;</div><div class="line">    	lastTime = now;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面正是在前面章节锁的获取逻辑中添加超时处理，核心逻辑是不断循环减去处理的时间消耗，一旦小于0就取消节点并跳出循环，其中有两点必须要注意，一个是真正的阻塞时间应该是扣除了竞争入队的时间后剩余的时间，保证阻塞事件的准确性，我们可以看到每次循环都会减去相应的处理时间；另外一个是关于spinForTimeoutThreshold变量阀值，它是决定使用自旋方式消耗时间还是使用系统阻塞方式消耗时间的分割线，juc工具包作者通过测试将默认值设置为1000ns，即如果在成功插入等待队列后剩余时间大于1000ns则调用系统底层阻塞，否则不调用系统底层，取而代之的是仅仅让之在Java应用层不断循环消耗时间，属于优化的措施。</p>
<h3 id="同步状态的管理"><a href="#同步状态的管理" class="headerlink" title="同步状态的管理"></a>同步状态的管理</h3><p>整个AQS框架核心功能都是围绕着其32位整型属性state进行，一般可以说它表示锁的数量，对同步状态的控制可以实现不同的同步工具，例如闭锁、信号量、栅栏等等。为了保证可见性此变量被声明为volatile，保证每次的原子更新都将及时反映到每条线程上。而对于同步状态的管理可以大体分为两块，一是独占模式的管理，另外是共享模式的管理。通过对这两种模式的灵活变换可以实现多种不同的同步器，如下图，对state的控制可以看成一个管道，管道的大小决定了同时通过的线程，独占模式好比宽度只容许一个线程通过的管道，在这种模式下线程只能逐一通过管道，任意时刻管内只能存在一条线程，这便形成了互斥效果。而共享模式就是管道宽度大于1的管道，可以同时让n条管道通过，吞吐量增加但可能存在共享数据一致性问题。（注意：两种模式的讨论忽略了队列的管理逻辑，实际上CLH Node的引入是为了优化竞争带来的性能问题，不影响同步状态管理的探讨）</p>
<p><img src="/img/sy/sy-4.png" alt=""><br>图5 独占模式与共享模式</p>
<p>如何通过state实现独占模式和共享模式？在此之前先了解AQS框架中相关的getState、setState、compareAndSetState三个操作state的基本方法，前两个方法是普通的获取设置方法，其必须保证不存在数据竞争的情况下使用，compareAndSetState方法则提供了CAS方式的硬件级别的原子更新。两种模式就是通过这些方法对state操作实现不同同步模式，下面给出最简单的实现。</p>
<p> 独占模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public boolean tryAcquire(int acquires) &#123;</div><div class="line">	if (compareAndSetState(0, 1)) &#123;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">	return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">protected boolean tryRelease(int releases) &#123;</div><div class="line">	setState(0);</div><div class="line">	return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>多条线程通过tryAcquire尝试把state变量改为1，由于CAS算法的保证，最终有且仅有一条线程成功修改state，修改成功的线程代表获取锁成功，将拥有往下执行的权利，进入管道。当执行完毕退出管道时执行tryRelease尝试把state变量改为0，让出管道，此处由于不存在线程竞争所以可直接使用setState，接着其他未通过的线程继续重复尝试</p>
<p> 共享模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public int tryAcquireShared(int interval) &#123;</div><div class="line">	for (;;) &#123;</div><div class="line">		int current = getState();</div><div class="line">		int newCount = current - 1;</div><div class="line">		if (newCount &lt; 0 || compareAndSetState(current, newCount)) &#123;</div><div class="line">			return newCount;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean tryReleaseShared(int interval) &#123;</div><div class="line">	for (;;) &#123;</div><div class="line">		int current = getState();</div><div class="line">		int newCount = current + 1;</div><div class="line">		if (compareAndSetState(current, newCount)) &#123;</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与独占模式不同的是对state的管理及判断条件，独占模式state的值只能为0或1，而共享模式的state是可以被出事换成任意整数，一般初始值表示提供一个同时n条线程通过的管道宽度，这样一来，多条线程通过tryAcquireShared尝试将state的值减去1，成功修改state后就返回新值，只有当新值大于等于0才表示获取锁成功，拥有往下执行的权利，进入管道。在执行完毕时线程将调用tryReleaseShared尝试修改state值使之增加1，表示我已经执行完了并让出管道的通道供后面线程使用，需要说明的是与独占模式不同，由于可能存在多条线程并发释放锁，所以此处必须使用基于CAS算法的修改方法，修改成功后其他线程便可继续竞争锁。</p>
<p>ASQ框架提供了对同步状态state的基本操作，了解了两种模式对state操作开发者可能很自由地自定义自己的同步器。实际中AQS框架在提供state状态管理接口的同时也将维护等待队列的工作，两项工作被封装成一个模板，规定了工作流程，工作流程包括什么条件下加入等待队列、什么条件移除等待节点、如何操作等待队列、需不需要阻塞、支不支持中断等等，对外仅仅提供state状态操作接口供开发者自定义，而队列的维护工作已经绑定在模板中，无需你自己动手。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 并发编程：volatile的使用及其原理]]></title>
      <url>https://fudawei.github.io/2017/02/08/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9Avolatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="一、volatile的作用"><a href="#一、volatile的作用" class="headerlink" title="一、volatile的作用"></a>一、volatile的作用</h1><p>　　在《Java并发编程：核心理论》一文中，我们已经提到过可见性、有序性及原子性问题，通常情况下我们可以通过Synchronized关键字来解决这些个问题，不过如果对Synchronized原理有了解的话，应该知道Synchronized是一个比较重量级的操作，对系统的性能有比较大的影响，所以，如果有其他解决方案，我们通常都避免使用Synchronized来解决问题。而volatile关键字就是Java中提供的另一种解决可见性和有序性问题的方案。对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。</p>
<h1 id="二、volatile的使用"><a href="#二、volatile的使用" class="headerlink" title="二、volatile的使用"></a>二、volatile的使用</h1><p>　　关于volatile的使用，我们可以通过几个例子来说明其使用方式和场景。</p>
<p>1、防止重排序</p>
<p>　　我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁（DCL）的方式来实现。其源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.ellis.concurrent;</div><div class="line"></div><div class="line">public class Singleton &#123;</div><div class="line">    public static volatile Singleton singleton;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 构造函数私有，禁止外部实例化</div><div class="line">     */</div><div class="line">    private Singleton() &#123;&#125;;</div><div class="line"></div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        if (singleton == null) &#123;</div><div class="line">            synchronized (Singleton.class) &#123;</div><div class="line">                if (singleton == null) &#123;</div><div class="line">                    singleton = new Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p>
<p>　　（1）分配内存空间。</p>
<p>　　（2）初始化对象。</p>
<p>　　（3）将内存空间的地址赋值给对应的引用。</p>
<p>但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：</p>
<p>　　（1）分配内存空间。</p>
<p>　　（2）将内存空间的地址赋值给对应的引用。</p>
<p>　　（3）初始化对象</p>
<p>　　如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。</p>
<p>2、实现可见性</p>
<p>　　可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">package com.ellis.concurrent;</div><div class="line"></div><div class="line">public class VolatileTest &#123;</div><div class="line">    int a = 1;</div><div class="line">    int b = 2;</div><div class="line"></div><div class="line">    public void change()&#123;</div><div class="line">        a = 3;</div><div class="line">        b = a;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void print()&#123;</div><div class="line">        System.out.println(&quot;b=&quot;+b+&quot;;a=&quot;+a);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        while (true)&#123;</div><div class="line">            final VolatileTest test = new VolatileTest();</div><div class="line">            new Thread(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(10);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    test.change();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line"></div><div class="line">            new Thread(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(10);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    test.print();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直观上说，这段代码的结果只可能有两种：b=3;a=3 或 b=2;a=1。不过运行上面的代码（可能时间上要长一点），你会发现除了上两种结果之外，还出现了第三种结果：</p>
<p>……<br>b=2;a=1<br>b=2;a=1<br>b=3;a=3<br>b=3;a=3<br>b=3;a=1<br>b=3;a=3<br>b=2;a=1<br>b=3;a=3<br>b=3;a=3<br>……</p>
<p>为什么会出现b=3;a=1这种结果呢？正常情况下，如果先执行change方法，再执行print方法，输出结果应该为b=3;a=3。相反，如果先执行的print方法，再执行change方法，结果应该是 b=2;a=1。那b=3;a=1的结果是怎么出来的？原因就是第一个线程将值a=3修改后，但是对第二个线程是不可见的，所以才出现这一结果。如果将a和b都改成volatile类型的变量再执行，则再也不会出现b=3;a=1的结果了。</p>
<p>3、保证原子性</p>
<p> 　　关于原子性的问题，上面已经解释过。volatile只能保证对单次读/写的原子性。这个问题可以看下JLS中的描述：</p>
<blockquote>
<p> 17.7 Non-Atomic Treatment of double and long<br>For the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.</p>
<p>Writes and reads of volatile long and double values are always atomic.</p>
<p>Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.</p>
<p>Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. For efficiency’s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts.</p>
<p>Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.</p>
</blockquote>
<p>这段话的内容跟我前面的描述内容大致类似。因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。</p>
<p>　　关于volatile变量对原子性保证，有一个问题容易被误解。现在我们就通过下列程序来演示一下这个问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package com.ellis.concurrent;</div><div class="line"></div><div class="line">public class VolatileTest01 &#123;</div><div class="line">    volatile int i;</div><div class="line"></div><div class="line">    public void addI()&#123;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        final  VolatileTest01 test01 = new VolatileTest01();</div><div class="line">        for (int n = 0; n &lt; 1000; n++) &#123;</div><div class="line">            new Thread(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(10);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    test01.addI();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Thread.sleep(10000);//等待10秒，保证上面程序执行完成</div><div class="line"></div><div class="line">        System.out.println(test01.i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大家可能会误认为对变量i加上关键字volatile后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">981</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure></p>
<p>可能每个人运行的结果不相同。不过应该能看出，volatile是无法保证原子性的（否则结果应该是1000）。原因也很简单，i++其实是一个复合操作，包括三步骤：</p>
<p>　　（1）读取i的值。</p>
<p>　　（2）对i加1。</p>
<p>　　（3）将i的值写回内存。</p>
<p>volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。</p>
<p>注：上面几段代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。</p>
<h1 id="三、volatile的原理"><a href="#三、volatile的原理" class="headerlink" title="三、volatile的原理"></a>三、volatile的原理</h1><p>　　通过上面的例子，我们基本应该知道了volatile是什么以及怎么使用。现在我们再来看看volatile的底层是怎么实现的。</p>
<p>　　1、可见性实现：</p>
<p>　　在前文中已经提及过，线程本身并不直接与主内存进行数据的交互，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。因此要实现volatile变量的可见性，直接从这方面入手即可。对volatile变量的写操作与普通变量的主要区别有两点：</p>
<p>　　（1）修改volatile变量时会强制将修改后的值刷新的主内存中。</p>
<p>　　（2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。</p>
<p>　　通过这两个操作，就可以解决volatile变量的可见性问题。</p>
<p>　　2、有序性实现：</p>
<p> 　　在解释这个问题前，我们先来了解一下Java中的happen-before规则，JSR 133中对Happen-before的定义如下：</p>
<blockquote>
<p>Two actions can be ordered by a happens-before relationship.If one action happens before another, then the first is visible to and ordered before the second.</p>
</blockquote>
<p>通俗一点说就是如果a happen-before b，则a所做的任何操作对b是可见的。（这一点大家务必记住，因为happen-before这个词容易被误解为是时间的前后）。我们再来看看JSR 133中定义了哪些happen-before规则：</p>
<blockquote>
<p> Each action in a thread happens before every subsequent action in that thread.<br>• An unlock on a monitor happens before every subsequent lock on that monitor.<br>• A write to a volatile field happens before every subsequent read of that volatile.<br>• A call to start() on a thread happens before any actions in the started thread.<br>• All actions in a thread happen before any other thread successfully returns from a join() on that thread.<br>• If an action a happens before an action b, and b happens before an action c, then a happens before c.</p>
</blockquote>
<p>翻译过来为：</p>
<p>同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。<br>监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则）<br>对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则）<br>线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则）<br>线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。<br>如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。<br>　　这里我们主要看下第三条：volatile变量的保证有序性的规则。《Java并发编程：核心理论》一文中提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会对volatile变量限制这两种类型的重排序。下面是JMM针对volatile变量所规定的重排序规则表：<br>  <img src="/img/volatile/volatile-1.png" alt=""></p>
<p>3、内存屏障</p>
<p>　　为了实现volatile可见性和happen-befor的语义。JVM底层是通过一个叫做“内存屏障”的东西来完成。内存屏障，也叫做内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。下面是完成上述规则所要求的内存屏障：<br>    <img src="/img/volatile/volatile-2.png" alt=""><br>（1）LoadLoad 屏障<br>执行顺序：Load1—&gt;Loadload—&gt;Load2<br>确保Load2及后续Load指令加载数据之前能访问到Load1加载的数据。</p>
<p>（2）StoreStore 屏障<br>执行顺序：Store1—&gt;StoreStore—&gt;Store2<br>确保Store2以及后续Store指令执行前，Store1操作的数据对其它处理器可见。</p>
<p>（3）LoadStore 屏障<br>执行顺序： Load1—&gt;LoadStore—&gt;Store2<br>确保Store2和后续Store指令执行前，可以访问到Load1加载的数据。</p>
<p>（4）StoreLoad 屏障<br>执行顺序: Store1—&gt; StoreLoad—&gt;Load2<br>确保Load2和后续的Load指令读取之前，Store1的数据对其他处理器是可见的。</p>
<p>最后我可以通过一个实例来说明一下JVM中是如何插入内存屏障的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class X &#123;  </div><div class="line">    int a, b;  </div><div class="line">    volatile int v, u;  </div><div class="line">  </div><div class="line">    void f() &#123;  </div><div class="line">        int i, j;  </div><div class="line">  </div><div class="line">        i = a;// load a  </div><div class="line">        j = b;// load b  </div><div class="line">        i = v;// load v  </div><div class="line">        // LoadLoad  </div><div class="line">        j = u;// load u  </div><div class="line">        // LoadStore  </div><div class="line">        a = i;// store a  </div><div class="line">        b = j;// store b  </div><div class="line">        // StoreStore  </div><div class="line">        v = i;// store v  </div><div class="line">        // StoreStore  </div><div class="line">        u = j;// store u  </div><div class="line">        // StoreLoad  </div><div class="line">        i = u;// load u  </div><div class="line">        // LoadLoad  </div><div class="line">        // LoadStore  </div><div class="line">        j = b;// load b  </div><div class="line">        a = i;// store a  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>　　总体上来说volatile的理解还是比较困难的，如果不是特别理解，也不用急，完全理解需要一个过程，在后续的文章中也还会多次看到volatile的使用场景。这里暂且对volatile的基础知识和原来有一个基本的了解。总体来说，volatile是并发编程中的一种优化，在某些场景下可以代替Synchronized。但是，volatile的不能完全取代Synchronized的位置，只有在一些特殊的场景下，才能适用volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：</p>
<p>　　（1）对变量的写操作不依赖于当前值。</p>
<p>　　（2）该变量没有包含在具有其他变量的不变式中。</p>
<h2 id="Java-理论与实践-正确使用-Volatile-变量"><a href="#Java-理论与实践-正确使用-Volatile-变量" class="headerlink" title="Java 理论与实践: 正确使用 Volatile 变量"></a><a href="https://fudawei.github.io/2017/02/05/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/" title="Java 理论与实践: 正确使用 Volatile 变量">Java 理论与实践: 正确使用 Volatile 变量</a></h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 并发编程：内置锁实现原理以及底层优化]]></title>
      <url>https://fudawei.github.io/2017/02/07/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E5%86%85%E7%BD%AE%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="内置锁的基本使用和原理"><a href="#内置锁的基本使用和原理" class="headerlink" title="内置锁的基本使用和原理"></a>内置锁的基本使用和原理</h2><h3 id="一、内置锁的使用"><a href="#一、内置锁的使用" class="headerlink" title="一、内置锁的使用"></a>一、内置锁的使用</h3><ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li>
<li>修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</li>
<li>修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<h3 id="二、内置锁原理"><a href="#二、内置锁原理" class="headerlink" title="二、内置锁原理"></a>二、内置锁原理</h3><p>我们先从一个实例来看一下内置锁原理，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedDemo &#123;</div><div class="line">     public void method() &#123;</div><div class="line">         synchronized (this) &#123;</div><div class="line">             System.out.println(&quot;Method 1 start&quot;);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们先通过反编译下面的代码来看看内置锁是如何实现对代码块进行同步的：<br><img src="/img/synchronized/synchronized-1.png" alt=""></p>
<p>关于这两条指令的作用，我们直接参考JVM规范中描述：<br>monitorenter ：</p>
<blockquote>
<pre><code>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:

• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.

• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.

• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor&apos;s entry count is zero, then tries again to gain ownership.
</code></pre></blockquote>
<p>这段话的大概意思为：</p>
<p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<ul>
<li><p>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>
</li>
<li><p>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p>
</li>
<li><p>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
</li>
</ul>
<p>monitorexit：</p>
<blockquote>
<p>  The thread that executes monitorexit must be the owner of the monitor associated    &gt;   with the instance referenced by objectref.<br>  The thread decrements the entry count of the monitor associated with objectref. If<br>  as a result the value of the entry count is zero, the thread exits the monitor and<br>  is no longer its owner. Other threads that are blocking to enter the monitor are<br>  allowed to attempt to do so.</p>
</blockquote>
<p>这段话的大概意思为：</p>
<p>执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p>
<p>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p>
<p>　　通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p>
<p>　　我们再来看一下同步方法的反编译结果：</p>
<p>源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedMethod &#123;</div><div class="line">    public synchronized void method() &#123;</div><div class="line">        System.out.println(&quot;Hello World!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>反编译结果：<br><img src="/img/synchronized/synchronized-2.png" alt=""><br>　从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</p>
<h3 id="三、运行结果解释"><a href="#三、运行结果解释" class="headerlink" title="三、运行结果解释"></a>三、运行结果解释</h3><p>　　有了对内置锁原理的认识，再来看上面的程序就可以迎刃而解了。</p>
<p>1、代码段一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> public class SynchronizedTest &#123;</div><div class="line"></div><div class="line">     public synchronized void method1()&#123;</div><div class="line">         System.out.println(&quot;Method 1 start&quot;);</div><div class="line">         try &#123;</div><div class="line">             System.out.println(&quot;Method 1 execute&quot;);</div><div class="line">             Thread.sleep(3000);</div><div class="line">         &#125; catch (InterruptedException e) &#123;</div><div class="line">             e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">         System.out.println(&quot;Method 1 end&quot;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     public synchronized void method2()&#123;</div><div class="line">         System.out.println(&quot;Method 2 start&quot;);</div><div class="line">         try &#123;</div><div class="line">             System.out.println(&quot;Method 2 execute&quot;);</div><div class="line">             Thread.sleep(1000);</div><div class="line">         &#125; catch (InterruptedException e) &#123;</div><div class="line">             e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">         System.out.println(&quot;Method 2 end&quot;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     public static void main(String[] args) &#123;</div><div class="line">         final SynchronizedTest test = new SynchronizedTest();</div><div class="line">         new Thread(new Runnable() &#123;</div><div class="line">             @Override</div><div class="line">             public void run() &#123;</div><div class="line">                 test.method1();</div><div class="line">             &#125;</div><div class="line">         &#125;).start();</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                test.method2();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　虽然method1和method2是不同的方法，但是这两个方法都进行了同步，并且是通过同一个对象去调用的，所以调用之前都需要先去竞争同一个对象上的锁（monitor），也就只能互斥的获取到锁，因此，method1和method2只能顺序的执行。</p>
<p>2、代码段2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedTest &#123;</div><div class="line"></div><div class="line">     public static synchronized void method1()&#123;</div><div class="line">         System.out.println(&quot;Method 1 start&quot;);</div><div class="line">         try &#123;</div><div class="line">             System.out.println(&quot;Method 1 execute&quot;);</div><div class="line">             Thread.sleep(3000);</div><div class="line">         &#125; catch (InterruptedException e) &#123;</div><div class="line">             e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">         System.out.println(&quot;Method 1 end&quot;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     public static synchronized void method2()&#123;</div><div class="line">         System.out.println(&quot;Method 2 start&quot;);</div><div class="line">         try &#123;</div><div class="line">             System.out.println(&quot;Method 2 execute&quot;);</div><div class="line">             Thread.sleep(1000);</div><div class="line">         &#125; catch (InterruptedException e) &#123;</div><div class="line">             e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">         System.out.println(&quot;Method 2 end&quot;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     public static void main(String[] args) &#123;</div><div class="line">         final SynchronizedTest test = new SynchronizedTest();</div><div class="line">         final SynchronizedTest test2 = new SynchronizedTest();</div><div class="line"></div><div class="line">         new Thread(new Runnable() &#123;</div><div class="line">             @Override</div><div class="line">             public void run() &#123;</div><div class="line">                 test.method1();</div><div class="line">             &#125;</div><div class="line">         &#125;).start();</div><div class="line"></div><div class="line">         new Thread(new Runnable() &#123;</div><div class="line">             @Override</div><div class="line">             public void run() &#123;</div><div class="line">                 test2.method2();</div><div class="line">             &#125;</div><div class="line">         &#125;).start();</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　虽然test和test2属于不同对象，但是test和test2属于同一个类的不同实例，由于method1和method2都属于静态同步方法，所以调用的时候需要获取同一个类上monitor（每个类只对应一个class对象），所以也只能顺序的执行。</p>
<p>3、代码段3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedTest &#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        System.out.println(&quot;Method 1 start&quot;);</div><div class="line">        try &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                System.out.println(&quot;Method 1 execute&quot;);</div><div class="line">                Thread.sleep(3000);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;Method 1 end&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void method2()&#123;</div><div class="line">        System.out.println(&quot;Method 2 start&quot;);</div><div class="line">        try &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                System.out.println(&quot;Method 2 execute&quot;);</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;Method 2 end&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final SynchronizedTest test = new SynchronizedTest();</div><div class="line"></div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                test.method1();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                test.method2();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　对于代码块的同步实质上需要获取Synchronized关键字后面括号中对象的monitor，由于这段代码中括号的内容都是this，而method1和method2又是通过同一的对象去调用的，所以进入同步块之前需要去竞争同一个对象上的锁，因此只能顺序执行同步块。</p>
<h3 id="四-小结"><a href="#四-小结" class="headerlink" title="四 小结"></a>四 小结</h3><p>　　内置锁是Java并发编程中最常用的用于保证线程安全的方式，其使用相对也比较简单。但是如果能够深入了解其原理，对监视器锁等底层知识有所了解，一方面可以帮助我们正确的使用Synchronized关键字，另一方面也能够帮助我们更好的理解并发编程机制，有助我们在不同的情况下选择更优的并发策略来完成任务。对平时遇到的各种并发问题，也能够从容的应对</p>
<h2 id="Synchronized的底层优化"><a href="#Synchronized的底层优化" class="headerlink" title="Synchronized的底层优化"></a>Synchronized的底层优化</h2><h3 id="一、重量级锁"><a href="#一、重量级锁" class="headerlink" title="一、重量级锁"></a>一、重量级锁</h3><p>　　上篇文章中向大家介绍了内置锁的用法及其实现的原理。现在我们应该知道，Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p>
<h3 id="二、偏向锁"><a href="#二、偏向锁" class="headerlink" title="二、偏向锁"></a>二、偏向锁</h3><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<ul>
<li><p>偏向锁获取<br>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下 Mark Word中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果没有设置，则使用 CAS 竞争锁，如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。</p>
</li>
<li><p>偏向锁的撤销：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。<br><img src="/img/synchronized/synchronized-9.png" alt=""></p>
</li>
</ul>
<h3 id="三、轻量级锁"><a href="#三、轻量级锁" class="headerlink" title="三、轻量级锁"></a>三、轻量级锁</h3><p>　　锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。锁的状态保存在对象的头文件中，以32位的JDK为例：<br><img src="/img/synchronized/synchronized-3.png" alt=""><br>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p>
<p>1、轻量级锁的加锁过程</p>
<p>　　（1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如图2.1所示。</p>
<p>　　（2）拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>　　（3）拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）。</p>
<p>　　（4）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图2.2所示。</p>
<p>　　（5）如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。<br>  <img src="/img/synchronized/synchronized-4.png" alt=""><br>  图2.1 轻量级锁CAS操作之前堆栈与对象的状态<br>  <img src="/img/synchronized/synchronized-5.png" alt=""><br>  图2.2 轻量级锁CAS操作之后堆栈与对象的状态</p>
<p>2、轻量级锁的解锁过程：</p>
<p>　　（1）通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。</p>
<p>　　（2）如果替换成功，整个同步过程就完成了。</p>
<p>　　（3）如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。</p>
<p>3、重量级锁、轻量级锁和偏向锁之间转换<br>  <img src="/img/synchronized/synchronized-6.png" alt=""></p>
<h3 id="四、其他优化"><a href="#四、其他优化" class="headerlink" title="四、其他优化"></a>四、其他优化</h3><p>1、适应性自旋（Adaptive Spinning）：从轻量级锁获取的流程中我们知道，当线程在获取轻量级锁的过程中执行CAS操作失败时，是要通过自旋来获取重量级锁的。问题在于，自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p>
<p>2、锁粗化（Lock Coarsening）：锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class StringBufferTest &#123;</div><div class="line">    StringBuffer stringBuffer = new StringBuffer();</div><div class="line"></div><div class="line">     public void append()&#123;</div><div class="line">         stringBuffer.append(&quot;a&quot;);</div><div class="line">         stringBuffer.append(&quot;b&quot;);</div><div class="line">         stringBuffer.append(&quot;c&quot;);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这里每次调用stringBuffer.append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p>
<p>3、锁消除（Lock Elimination）：锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。看下面这段程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedTest02 &#123;</div><div class="line"></div><div class="line">     public static void main(String[] args) &#123;</div><div class="line">        SynchronizedTest02 test02 = new SynchronizedTest02();</div><div class="line">        //启动预热</div><div class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        long start = System.currentTimeMillis();</div><div class="line">        for (int i = 0; i &lt; 100000000; i++) &#123;</div><div class="line">            test02.append(&quot;abc&quot;, &quot;def&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;Time=&quot; + (System.currentTimeMillis() - start));</div><div class="line">    &#125;</div><div class="line">    public void append(String str1, String str2) &#123;</div><div class="line">        StringBuffer sb = new StringBuffer();</div><div class="line">        sb.append(str1).append(str2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然StringBuffer的append是一个同步方法，但是这段程序中的StringBuffer属于一个局部变量，并且不会从该方法中逃逸出去，所以其实这过程是线程安全的，可以将锁消除。下面是我本地执行的结果：<br>  <img src="/img/synchronized/synchronized-7.png" alt=""><br>为了尽量减少其他因素的影响，这里禁用了偏向锁（-XX:-UseBiasedLocking）。通过上面程序，可以看出消除锁以后性能还是有比较大提升的。</p>
<p>　　注：可能JDK各个版本之间执行的结果不尽相同，我这里采用的JDK版本为1.6。</p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>　　本文重点介绍了JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，事，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程，这个时候就需要通过-XX:-UseBiasedLocking来禁用偏向锁。下面是这几种锁的对比：<br>  <img src="/img/synchronized/synchronized-8.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 并发编程：核心理论]]></title>
      <url>https://fudawei.github.io/2017/02/05/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/</url>
      <content type="html"><![CDATA[<h3 id="一、共享性"><a href="#一、共享性" class="headerlink" title="一、共享性"></a>一、共享性</h3><p>　　数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。最典型的场景是数据库中的数据，为了保证数据的一致性，我们通常需要共享同一个数据库中数据，即使是在主从的情况下，访问的也同一份数据，主从只是为了访问的效率和数据安全，而对同一份数据做的副本。我们现在，通过一个简单的示例来演示多线程下共享数据导致的问题：</p>
<p>代码段一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class ShareData &#123;</div><div class="line">    public static int count = 0;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final ShareData data = new ShareData();</div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            new Thread(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    try &#123;</div><div class="line">                        //进入的时候暂停1毫秒，增加并发问题出现的几率</div><div class="line">                        Thread.sleep(1);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    for (int j = 0; j &lt; 100; j++) &#123;</div><div class="line">                        data.addCount();</div><div class="line">                    &#125;</div><div class="line">                    System.out.print(count + &quot; &quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            //主程序暂停3秒，以保证上面的程序执行完成</div><div class="line">            Thread.sleep(3000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;count=&quot; + count);</div><div class="line">    &#125;</div><div class="line">    public void addCount() &#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码的目的是对count进行加一操作，执行1000次，不过这里是通过10个线程来实现的，每个线程执行100次，正常情况下，应该输出1000。不过，如果你运行上面的程序，你会发现结果却不是这样。</p>
<h3 id="二、互斥性"><a href="#二、互斥性" class="headerlink" title="二、互斥性"></a>二、互斥性</h3><p>　　资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。所以我们通常将锁分为共享锁和排它锁，也叫做读锁和写锁。如果资源不具有互斥性，即使是共享资源，我们也不需要担心线程安全。例如，对于不可变的数据共享，所有线程都只能对其进行读操作，所以不用考虑线程安全问题。但是对共享数据的写操作，一般就需要保证互斥性，上述例子中就是因为没有保证互斥性才导致数据的修改产生问题。Java 中提供多种机制来保证互斥性，最简单的方式是使用Synchronized。现在我们在上面程序中加上Synchronized再执行：</p>
<p>代码段二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class ShareData &#123;</div><div class="line"></div><div class="line">    public static int count = 0;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final ShareData data = new ShareData();</div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            new Thread(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    try &#123;</div><div class="line">                        //进入的时候暂停1毫秒，增加并发问题出现的几率</div><div class="line">                        Thread.sleep(1);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    for (int j = 0; j &lt; 100; j++) &#123;</div><div class="line">                        data.addCount();</div><div class="line">                    &#125;</div><div class="line">                    System.out.print(count + &quot; &quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            //主程序暂停3秒，以保证上面的程序执行完成</div><div class="line">            Thread.sleep(3000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;count=&quot; + count);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 增加 synchronized 关键字</div><div class="line">     */</div><div class="line">    public synchronized void addCount() &#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在再执行上述代码，会发现无论执行多少次，返回的最终结果都是1000。</p>
<h3 id="三、原子性"><a href="#三、原子性" class="headerlink" title="三、原子性"></a>三、原子性</h3><p>　　原子性就是指对数据的操作是一个独立的、不可分割的整体。换句话说，就是一次操作，是一个连续不可中断的过程，数据不会执行的一半的时候被其他线程所修改。保证原子性的最简单方式是操作系统指令，就是说如果一次操作对应一条操作系统指令，这样肯定可以能保证原子性。但是很多操作不能通过一条指令就完成。例如，对long类型的运算，很多系统就需要分成多条指令分别对高位和低位进行操作才能完成。还比如，我们经常使用的整数 i++ 的操作，其实需要分成三个步骤：（1）读取整数 i 的值；（2）对 i 进行加一操作；（3）将结果写回内存。这个过程在多线程下就可能出现如下现象：<br><img src="/img/concurrent/concurrent-1.png" alt=""><br>这也是代码段一执行的结果为什么不正确的原因。对于这种组合操作，要保证原子性，最常见的方式是加锁，如Java中的Synchronized或Lock都可以实现，代码段二就是通过Synchronized实现的。除了锁以外，还有一种方式就是CAS（Compare And Swap），即修改数据之前先比较与之前读取到的值是否一致，如果一致，则进行修改，如果不一致则重新执行，这也是乐观锁的实现原理。不过CAS在某些场景下不一定有效，比如另一线程先修改了某个值，然后再改回原来值，这种情况下，CAS是无法判断的。</p>
<h3 id="四、可见性"><a href="#四、可见性" class="headerlink" title="四、可见性"></a>四、可见性</h3><p>要理解可见性，需要先对JVM的内存模型有一定的了解，JVM的内存模型与操作系统类似，如图所示：<br><img src="/img/concurrent/concurrent-2.png" alt=""><br>从这个图中我们可以看出，每个线程都有一个自己的工作内存（相当于CPU高级缓冲区，这么做的目的还是在于进一步缩小存储系统与CPU之间速度的差异，提高性能），对于共享变量，线程每次读取的是工作内存中共享变量的副本，写入的时候也直接修改工作内存中副本的值，然后在某个时间点上再将工作内存与主内存中的值进行同步。这样导致的问题是，如果线程1对某个变量进行了修改，线程2却有可能看不到线程1对共享变量所做的修改。通过下面这段程序我们可以演示一下不可见的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class VisibilityTest &#123;</div><div class="line">    private static boolean ready;</div><div class="line">    private static int number;</div><div class="line"> </div><div class="line">    private static class ReaderThread extends Thread &#123;</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(10);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            if (!ready) &#123;</div><div class="line">                System.out.println(ready);</div><div class="line">            &#125;</div><div class="line">            System.out.println(number);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    private static class WriterThread extends Thread &#123;</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(10);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            number = 100;</div><div class="line">            ready = true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new WriterThread().start();</div><div class="line">        new ReaderThread().start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从直观上理解，这段程序应该只会输出100，ready的值是不会打印出来的。实际上，如果多次执行上面代码的话，可能会出现多种不同的结果</p>
<p>当然，这个结果也只能说是有可能是可见性造成的，当写线程（WriterThread）设置ready=true后，读线程（ReaderThread）看不到修改后的结果，所以会打印false，对于第二个结果，也就是执行if (!ready)时还没有读取到写线程的结果，但执行System.out.println(ready)时读取到了写线程执行的结果。不过，这个结果也有可能是线程的交替执行所造成的。Java 中可通过Synchronized或Volatile来保证可见性，具体细节会在后续的文章中分析。</p>
<h3 id="五、有序性"><a href="#五、有序性" class="headerlink" title="五、有序性"></a>五、有序性</h3><p>　　为了提高性能，编译器和处理器可能会对指令做重排序。重排序可以分为三种：</p>
<p>　　（1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
<p>　　（2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<br>　　（3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
<p>　　我们可以直接参考一下JSR 133 中对重排序问题的描述<br><img src="/img/concurrent/concurrent-3.png" alt=""><br>先看上图中的（1）源码部分，从源码来看，要么指令 1 先执行要么指令 3先执行。如果指令 1 先执行，r2不应该能看到指令 4 中写入的值。如果指令 3 先执行，r1不应该能看到指令 2 写的值。但是运行结果却可能出现r2==2，r1==1的情况，这就是“重排序”导致的结果。上图（2）即是一种可能出现的合法的编译结果，编译后，指令1和指令2的顺序可能就互换了。因此，才会出现r2==2，r1==1的结果。Java 中也可通过Synchronized或Volatile来保证顺序性。</p>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h3><p>　　本文对Java 并发编程中的理论基础进行了讲解，有些东西在后续的分析中还会做更详细的讨论，如可见性、顺序性等。后续的文章都会以本章内容作为理论基础来讨论。如果大家能够很好的理解上述内容，相信无论是去理解其他并发编程的文章还是在平时的并发编程的工作中，都能够对大家有很好的帮助。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[并发锁(二)]AQS]]></title>
      <url>https://fudawei.github.io/2017/02/04/%5B%E5%B9%B6%E5%8F%91%E9%94%81(%E4%BA%8C)%5DAQS/</url>
      <content type="html"><![CDATA[<p>AQS</p>
<p>首先从理论知识开始，在了解了相关原理后会针对源码进行一些分析，最后加上一些实战来描述。</p>
<p><img src="/img/lock/lock-1.png" alt=""></p>
<p>上面的继承体系中，AbstractQueuedSynchronizer是CountDownLatch/FutureTask/ReentrantLock/RenntrantReadWriteLock/Semaphore的基础，因此AbstractQueuedSynchronizer是Lock/Executor实现的前提。公平锁、不公平锁、Condition、CountDownLatch、Semaphore等放到后面的篇幅中说明。</p>
<p>完整的设计原理可以参考Doug Lea的论文  <a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="external">The java .util .concurrent Synchronizer Framework</a>   ，这里做一些简要的分析。</p>
<p>基本的思想是表现为一个同步器，支持下面两个操作：</p>
<p>获取锁：首先判断当前状态是否允许获取锁，如果是就获取锁，否则就阻塞操作或者获取失败，也就是说如果是独占锁就可能阻塞，如果是共享锁就可能失败。另外如果是阻塞线程，那么线程就需要进入阻塞队列。当状态位允许获取锁时就修改状态，并且如果进了队列就从队列中移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">while(synchronization state does not allow acquire)&#123;</div><div class="line">    enqueue current thread if not already queued;</div><div class="line">    possibly block current thread;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>dequeue current thread if it was queued;</p>
<p>释放锁:这个过程就是修改状态位，如果有线程因为状态位阻塞的话就唤醒队列中的一个或者更多线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">update synchronization state;</div><div class="line"></div><div class="line">if(state may permit a blocked thread to acquire)</div><div class="line"></div><div class="line">    unlock one or more queued threads;</div></pre></td></tr></table></figure></p>
<p>要支持上面两个操作就必须有下面的条件：</p>
<p>原子性操作同步器的状态位<br>阻塞和唤醒线程<br>一个有序的队列<br>目标明确，要解决的问题也清晰了，那么剩下的就是解决上面三个问题。</p>
<p>状态位的原子操作</p>
<p>这里使用一个32位的整数来描述状态位，前面章节的原子操作的理论知识整好派上用场，在这里依然使用CAS操作来解决这个问题。事实上这里还有一个64位版本的同步器（AbstractQueuedLongSynchronizer），这里暂且不谈。</p>
<p>阻塞和唤醒线程</p>
<p>标准的Java API里面是无法挂起（阻塞）一个线程，然后在将来某个时刻再唤醒它的。JDK 1.0的API里面有Thread.suspend和Thread.resume，并且一直延续了下来。但是这些都是过时的API，而且也是不推荐的做法。</p>
<p>在JDK 5.0以后利用JNI在LockSupport类中实现了此特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LockSupport.park()</div><div class="line">LockSupport.park(Object)</div><div class="line">LockSupport.parkNanos(Object, long)</div><div class="line">LockSupport.parkNanos(long)</div><div class="line">LockSupport.parkUntil(Object, long)</div><div class="line">LockSupport.parkUntil(long)</div><div class="line">LockSupport.unpark(Thread)</div></pre></td></tr></table></figure>
<p>上面的API中park()是在当前线程中调用，导致线程阻塞，带参数的Object是挂起的对象，这样监视的时候就能够知道此线程是因为什么资源而阻塞的。由于park()立即返回，所以通常情况下需要在循环中去检测竞争资源来决定是否进行下一次阻塞。park()返回的原因有三：</p>
<p>其他某个线程调用将当前线程作为目标调用  unpark ；<br>其他某个线程中断 当前线程；<br>该调用不合逻辑地（即毫无理由地）返回。<br>其实第三条就决定了需要循环检测了，类似于通常写的while(checkCondition()){Thread.sleep(time);}类似的功能。</p>
<p>有序队列</p>
<p>在AQS中采用CHL列表来解决有序的队列的问题。</p>
<p>  <img src="/img/lock/lock-2.png" alt=""></p>
<p>AQS采用的CHL模型采用下面的算法完成FIFO的入队列和出队列过程。</p>
<p>对于入队列(enqueue)： 采用CAS操作，每次比较尾结点是否一致，然后插入的到尾结点中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">   pred = tail;</div><div class="line">&#125; while ( !compareAndSet(pred,tail,node) );</div></pre></td></tr></table></figure>
<p>对于出队列(dequeue ):由于每一个节点也缓存了一个状态，决定是否出队列，因此当不满足条件时就需要自旋等待，一旦满足条件就将头结点设置为下一个节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (pred.status != RELEASED) ;</div><div class="line"></div><div class="line">head  = node;</div></pre></td></tr></table></figure>
<p>实际上这里自旋等待也是使用LockSupport.park()来实现的。</p>
<p>AQS里面有三个核心字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private volatile int state;</div><div class="line"></div><div class="line">private transient volatile Node head;</div><div class="line"></div><div class="line">private transient volatile Node tail;</div></pre></td></tr></table></figure>
<p>其中state描述的有多少个线程取得了锁，对于互斥锁来说state&lt;=1。head/tail加上CAS操作就构成了一个CHL的FIFO队列。下面是Node节点的属性。</p>
<p>volatile int waitStatus;   节点的等待状态，一个节点可能位于以下几种状态：</p>
<p>CANCELLED = 1： 节点操作因为超时或者对应的线程被interrupt。节点不应该不留在此状态，一旦达到此状态将从CHL队列中踢出。<br>SIGNAL = -1： 节点的继任节点是（或者将要成为）BLOCKED状态（例如通过LockSupport.park()操作），因此一个节点一旦被释放（解锁）或者取消就需要唤醒（LockSupport.unpack()）它的继任节点。<br>CONDITION = -2：表明节点对应的线程因为不满足一个条件（Condition）而被阻塞。<br>0： 正常状态，新生的非CONDITION节点都是此状态。<br>非负值标识节点不需要被通知（唤醒）。<br>volatile Node prev; 此节点的前一个节点。节点的waitStatus依赖于前一个节点的状态。</p>
<p>volatile Node next; 此节点的后一个节点。后一个节点是否被唤醒（uppark()）依赖于当前节点是否被释放。</p>
<p>volatile Thread thread; 节点绑定的线程。</p>
<p>Node nextWaiter; 下一个等待条件（Condition）的节点，由于Condition是独占模式，因此这里有一个简单的队列来描述Condition上的线程节点。</p>
<p>AQS 在J.U.C里面是一个非常核心的工具，而且也非常复杂，里面考虑到了非常多的逻辑实现，所以在后面的章节中总是不断的尝试介绍AQS的特性和实现。</p>
<p>这一个小节主要介绍了一些理论背景和相关的数据结构，在下一个小节中将根据以上知识来了解Lock.lock/unlock是如何实现的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[并发锁(一)]Lock与ReentrantLock]]></title>
      <url>https://fudawei.github.io/2017/02/03/%5B%E5%B9%B6%E5%8F%91%E9%94%81(%E4%B8%80)%5DLock%E4%B8%8EReentrantLock/</url>
      <content type="html"><![CDATA[<p>JDK 5中的锁是接口Java.util.concurrent.locks.Lock 。另外java.util.concurrent.locks.ReadWriteLock 提供了一对可供读写并发的锁。根据前面的规则，我们从java.util.concurrent.locks.Lock 的API开始。</p>
<p>void lock();</p>
<p>获取锁。</p>
<p>如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void lockInterruptibly() throws InterruptedException;</div></pre></td></tr></table></figure>
<p>如果当前线程未被中断，则获取锁。</p>
<p>如果锁可用，则获取锁，并立即返回。</p>
<p>如果锁不可用，出于线程调度目的，将禁用当前线程，并且在发生以下两种情况之一以前，该线程将一直处于休眠状态：</p>
<p>锁由当前线程获得；或者<br>其他某个线程中断 当前线程，并且支持对锁获取的中断。<br>如果当前线程：</p>
<p>在进入此方法时已经设置了该线程的中断状态；或者<br>在获取锁时被中断 ，并且支持对锁获取的中断，<br>则将抛出  InterruptedException ，并清除当前线程的已中断状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Condition newCondition();</div></pre></td></tr></table></figure></p>
<p>返回绑定到此  Lock   实例的新  Condition   实例。下一小节中会重点谈Condition，此处不做过多的介绍。</p>
<p>boolean tryLock();<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>仅在调用时锁为空闲状态才获取该锁。</p>
<p>如果锁可用，则获取锁，并立即返回值  true 。如果锁不可用，则此方法将立即返回值  false 。</p>
<p>通常对于那些不是必须获取锁的操作可能有用。</p>
<p>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</p>
<p>如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。</p>
<p>如果锁可用，则此方法将立即返回值  true 。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在发生以下三种情况之一前，该线程将一直处于休眠状态：</p>
<p>锁由当前线程获得；或者<br>其他某个线程中断当前线程，并且支持对锁获取的中断；或者<br>已超过指定的等待时间<br>如果获得了锁，则返回值  true 。</p>
<p>如果当前线程：</p>
<p>在进入此方法时已经设置了该线程的中断状态；或者<br>在获取锁时被中断，并且支持对锁获取的中断，<br>则将抛出  InterruptedException ，并会清除当前线程的已中断状态。<br>如果超过了指定的等待时间，则将返回值  false 。如果 time 小于等于 0，该方法将完全不等待。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void unlock();</div></pre></td></tr></table></figure>
<p>释放锁。对应于lock()、tryLock()、tryLock(xx)、lockInterruptibly()等操作，如果成功的话应该对应着一个unlock()，这样可以避免死锁或者资源浪费。</p>
<p>相对于比较空洞的API，来看一个实际的例子。下面的代码实现了一个类似于AtomicInteger的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">package com.ellis.study.concurrency.lock;</div><div class="line"></div><div class="line">import java.util.concurrent.locks.Lock;</div><div class="line">import java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line">public class AtomicIntegerWithLock &#123;</div><div class="line"></div><div class="line">    private int value;</div><div class="line">    private Lock lock = new ReentrantLock();</div><div class="line">	</div><div class="line">    public AtomicIntegerWithLock() &#123;</div><div class="line">        super();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public AtomicIntegerWithLock(int value) &#123;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final int get() &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            return value;</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final void set(int newValue) &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            value = newValue;</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final int getAndSet(int newValue) &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            int ret = value;</div><div class="line">            value = newValue;</div><div class="line">            return ret;</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final boolean compareAndSet(int expect, int update) &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            if (value == expect) &#123;</div><div class="line">                value = update;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            return false;</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final int getAndIncrement() &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            return value++;</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final int getAndDecrement() &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            return value--;</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final int incrementAndGet() &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            return ++value;</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final int decrementAndGet() &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            return --value;</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String toString() &#123;</div><div class="line">        return Integer.toString(get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类AtomicIntegerWithLock 是线程安全的，此结构中大量使用了Lock对象的lock/unlock方法对。同样可以看到的是对于自增和自减操作使用了++/–。之所以能够保证线程安全，是因为Lock对象的lock()方法保证了只有一个线程能够只有此锁。需要说明的是对于任何一个lock()方法，都需要一个unlock()方法与之对于，通常情况下为了保证unlock方法总是能够得到执行，unlock方法被置于finally块中。另外这里使用了java.util.concurrent.locks.ReentrantLock.ReentrantLock 对象，下一个小节中会具体描述此类作为Lock的唯一实现是如何设计和实现的。</p>
<p>尽管synchronized实现Lock的相同语义，并且在语法上比Lock要简单多，但是前者却比后者的开销要大得多。做一个简单的测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws Exception&#123;</div><div class="line">     final int max = 10;</div><div class="line">     final int loopCount = 100000;</div><div class="line">     long costTime = 0;</div><div class="line">     for (int m = 0; m &lt; max; m++) &#123;</div><div class="line">         long start1 = System.nanoTime();</div><div class="line">         final AtomicIntegerWithLock value1 = new AtomicIntegerWithLock(0);</div><div class="line">         Thread[] ts = new Thread[max];</div><div class="line">         for(int i=0;i&lt;max;i++) &#123;</div><div class="line">             ts[i] = new Thread() &#123;</div><div class="line">                 public void run() &#123;</div><div class="line">                     for (int i = 0; i &lt; loopCount; i++) &#123;</div><div class="line">                         value1.incrementAndGet();</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">             &#125;;</div><div class="line">         &#125;</div><div class="line">         for(Thread t:ts) &#123;</div><div class="line">             t.start();</div><div class="line">         &#125;</div><div class="line">         for(Thread t:ts) &#123;</div><div class="line">             t.join();</div><div class="line">         &#125;</div><div class="line">         long end1 = System.nanoTime();</div><div class="line">         costTime += (end1-start1);</div><div class="line">     &#125;</div><div class="line">     System.out.println(&quot;cost1: &quot; + (costTime));</div><div class="line">     //</div><div class="line">     System.out.println();</div><div class="line">     costTime = 0;</div><div class="line">     //</div><div class="line">     final Object lock = new Object();</div><div class="line">     for (int m = 0; m &lt; max; m++) &#123;</div><div class="line">         staticValue=0;</div><div class="line">         long start1 = System.nanoTime();</div><div class="line">         Thread[] ts = new Thread[max];</div><div class="line">         for(int i=0;i&lt;max;i++) &#123;</div><div class="line">             ts[i] = new Thread() &#123;</div><div class="line">                 public void run() &#123;</div><div class="line">                     for (int i = 0; i &lt; loopCount; i++) &#123;</div><div class="line">                         synchronized(lock) &#123;</div><div class="line">                             ++staticValue;</div><div class="line">                         &#125;</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">             &#125;;</div><div class="line">         &#125;</div><div class="line">         for(Thread t:ts) &#123;</div><div class="line">             t.start();</div><div class="line">         &#125;</div><div class="line">         for(Thread t:ts) &#123;</div><div class="line">             t.join();</div><div class="line">         &#125;</div><div class="line">         long end1 = System.nanoTime();</div><div class="line">         costTime += (end1-start1);</div><div class="line">     &#125;</div><div class="line">     //</div><div class="line">     System.out.println(&quot;cost2: &quot; + (costTime));</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int staticValue = 0;</div></pre></td></tr></table></figure>
<p>在这个例子中每次启动10个线程，每个线程计算100000次自增操作，重复测试10次，下面是某此测试的结果：</p>
<p>cost1: 624071136</p>
<p>cost2: 2057847833</p>
<p>尽管上面的例子不是非常正式的测试案例，但上面的例子在于说明，Lock的性能比synchronized的要好得多。如果可以的话总是使用Lock替代synchronized是一个明智的选择。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Shell--Expect]]></title>
      <url>https://fudawei.github.io/2017/01/24/Shell%E5%AD%A6%E4%B9%A0%E4%B9%8BExpect/</url>
      <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>   我们通过Shell可以实现简单的控制流功能，如：循环、判断等。但是对于需要交互的场合则必须通过人工来干预，有时候我们可能会需要实现和交互程序如telnet服务器等进行交互的功能。而expect就使用来实现这种功能的工具。</p>
<p>   expect是一个免费的编程工具语言，用来实现自动和交互式任务进行通信，而无需人的干预。expect是不断发展的，随着时间的流逝，其功能越来越强大，已经成为系统管理员的的一个强大助手。expect需要Tcl编程语言的支持，要在系统上运行expect必须首先安装Tcl。</p>
<h3 id="二、expect的安装"><a href="#二、expect的安装" class="headerlink" title="二、expect的安装"></a>二、expect的安装</h3><p>expect是在Tcl基础上创建起来的，所以在安装expect前我们应该先安装Tcl。</p>
<p>（一）Tcl 安装<br>主页: <a href="http://www.tcl.tk" target="_blank" rel="external">http://www.tcl.tk</a><br>下载地址: <a href="http://www.tcl.tk/software/tcltk/downloadnow84.tml" target="_blank" rel="external">http://www.tcl.tk/software/tcltk/downloadnow84.tml</a><br>1.下载源码包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://nchc.dl.sourceforge.net/sourceforge/tcl/tcl8.4.11-src.tar.gz</div></pre></td></tr></table></figure>
<p>2.解压缩源码包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar xfvz tcl8.4.11-src.tar.gz</div></pre></td></tr></table></figure>
<p>3.安装配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd tcl8.4.11/unix</div><div class="line">./configure --prefix=/usr/tcl --enable-shared</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>注意：<br>1、安装完毕以后，进入tcl源代码的根目录，把子目录unix下面的tclUnixPort.h copy到子目录generic中。</p>
<p>2、暂时不要删除tcl源代码，因为expect的安装过程还需要用。</p>
<p>（二）expect 安装 (需Tcl的库)</p>
<p>主页: <a href="http://expect.nist.gov/" target="_blank" rel="external">http://expect.nist.gov/</a></p>
<p>1.下载源码包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://sourceforge.net/projects/expect/files/Expect/5.45/expect5.45.tar.gz/download</div></pre></td></tr></table></figure>
<p>2.解压缩源码包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar xzvf expect5.45.tar.gz</div></pre></td></tr></table></figure>
<p>3.安装配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd expect5.45</div><div class="line">./configure --prefix=/usr/expect --with-tcl=/usr/tcl/lib --with-tclinclude=../tcl8.4.11/generic</div><div class="line">make</div><div class="line">make install</div><div class="line">ln -s /usr/tcl/bin/expect /usr/expect/bin/expect</div></pre></td></tr></table></figure>
<h3 id="三、Expect工作原理"><a href="#三、Expect工作原理" class="headerlink" title="三、Expect工作原理"></a>三、Expect工作原理</h3><p>   从最简单的层次来说，Expect的工作方式象一个通用化的Chat脚本工具。Chat脚本最早用于UUCP网络内，以用来实现计算机之间需要建立连接时进行特定的登录会话的自动化。</p>
<p>   Chat脚本由一系列expect-send对组成：expect等待输出中输出特定的字符，通常是一个提示符，然后发送特定的响应。例如下面的 Chat脚本实现等待标准输出出现Login:字符串，然后发送somebody作为用户名；然后等待Password:提示符，并发出响应 sillyme。</p>
<p>引用：</p>
<p>Login: somebody Password: sillyme<br>Expect最简单的脚本操作模式本质上和Chat脚本工作模式是一样的。</p>
<h3 id="四、实例详解"><a href="#四、实例详解" class="headerlink" title="四、实例详解"></a>四、实例详解</h3><ol>
<li>expect 是基于tcl 演变而来的，所以很多语法和tcl 类似，基本的语法如下<br>所示：<br>1.1 首行加上/usr/bin/expect<br>1.2 spawn: 后面加上需要执行的shell 命令，比如说spawn sudo touch testfile<br>1.3 expect: 只有spawn 执行的命令结果才会被expect 捕捉到，因为spawn 会启<br>动一个进程，只有这个进程的相关信息才会被捕捉到，主要包括：标准输入的提<br>示信息，eof 和timeout。<br>1.4 send 和send_user：send 会将expect 脚本中需要的信息发送给spawn 启动<br>的那个进程，而send_user 只是回显用户发出的信息，类似于shell 中的echo 而<br>已。</li>
</ol>
<ol>
<li>一个小例子，用于linux 下账户的建立：<br>filename: account.sh，可以使用./account.sh newaccout 来执行；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/expect</div><div class="line"></div><div class="line">set passwd &quot;mypasswd&quot;</div><div class="line">set timeout 60</div><div class="line">if &#123;$argc != 1&#125; &#123;</div><div class="line">  send &quot;usage ./account.sh \$newaccount\n&quot;</div><div class="line">  exit</div><div class="line">&#125;</div><div class="line"></div><div class="line">set user [lindex $argv [expr $argc-1]]</div><div class="line">spawn sudo useradd -s /bin/bash -g mygroup -m $user</div><div class="line">expect &#123;</div><div class="line">  &quot;assword&quot; &#123;</div><div class="line">    send_user &quot;sudo now\n&quot;</div><div class="line">    send &quot;$passwd\n&quot;</div><div class="line">    exp_continue</div><div class="line">  &#125;</div><div class="line">  eof&#123;</div><div class="line">    send_user &quot;eof\n&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">spawn sudo passwd $user</div><div class="line">expect &#123;</div><div class="line"> &quot;assword&quot; &#123;</div><div class="line">    send &quot;$passwd\n&quot;</div><div class="line">     exp_continue</div><div class="line"> &#125;</div><div class="line"> eof &#123;</div><div class="line">      send_user &quot;eof&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">spawn sudo smbpasswd -a $user</div><div class="line">expect &#123;</div><div class="line">         &quot;assword&quot; &#123;</div><div class="line">         send &quot;$passwd\n&quot;</div><div class="line">         exp_continue</div><div class="line">      &#125;</div><div class="line"></div><div class="line">     eof &#123;</div><div class="line">        send_user &quot;eof&quot;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>注意点：</li>
</ol>
<p>第3 行： 对变量赋值的方法；<br>第4 行： 默认情况下，timeout 是10 秒；<br>第6 行： 参数的数目可以用$argc 得到；<br>第11 行：参数存在$argv 当中，比如取第一个参数就是[lindex $argv 0]；并且<br>如果需要计算的话必须用expr，如计算2-1，则必须用[expr 2-1]；<br>第13 行：用spawn 来执行一条shell 命令，shell 命令根据具体情况可自行调整；<br>有文章说sudo 要加-S，经过实际测试，无需加-S 亦可；<br>第15 行：一般情况下，如果连续做两个expect，那么实际上是串行执行的，用。expect 与“{ ”之间直接必须有空格或则TAB间隔，否则会出麻烦，会报错invalid command name “expect{“<br>例子中的结构则是并行执行的，主要是看匹配到了哪一个；在这个例子中，如果<br>你写成串行的话，即<br>expect “assword”<br>send “$passwd\n”<br>expect eof<br>send_user “eof”<br>那么第一次将会正确运行，因为第一次sudo 时需要密码；但是第二次运行时由于<br>密码已经输过（默认情况下sudo 密码再次输入时间为5 分钟），则不会提示用户<br>去输入，所以第一个expect 将无法匹配到assword，而且必须注意的是如果是<br>spawn 命令出现交互式提问的但是expect 匹配不上的话，那么程序会按照timeout<br>的设置进行等待；可是如果spawn 直接发出了eof 也就是本例的情况，那么expect<br>“assword”将不会等待，而直接去执行expect eof。<br>这时就会报expect: spawn id exp6 not open，因为没有spawn 在执行，后面的<br>expect 脚本也将会因为这个原因而不再执行；所以对于类似sudo 这种命令分支<br>不定的情况，最好是使用并行的方式进行处理；<br>第17 行：仅仅是一个用户提示而已，可以删除；<br>第18 行：向spawn 进程发送password；<br>第19 行：使得spawn 进程在匹配到一个后再去匹配接下来的交互提示；<br>第21 行：eof 是必须去匹配的，在spawn 进程结束后会向expect 发送eof；如果<br>不去匹配，有时也能运行，比如sleep 多少秒后再去spawn 下一个命令，但是不<br>要依赖这种行为，很有可能今天还可以，明天就不能用了；</p>
<ol>
<li>其他<br>下面这个例子比较特殊，在整个过程中就不能expect eof 了：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/expect</div><div class="line">set timeout 30</div><div class="line">spawn ssh 10.192.224.224</div><div class="line">expect &quot;password:&quot;</div><div class="line">send &quot;mypassword\n&quot;</div><div class="line">expect &quot;*$&quot;</div><div class="line">send &quot;mkdir tmpdir\n&quot; #远程执行命令用send发送，不用spawn</div><div class="line">expect &quot;*$&quot; #注意这个地方，要与操作系统上环境变量PS1相匹配，尤其是有PS1有空格的情况下，一定在expct &quot;*$ &quot; 把空格加上，加不上你就完蛋了。我试过。</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个例子实际上是通过ssh 去登录远程机器，并且在远程机器上创佳一个目录，<br>我们看到在我们输入密码后并没有去expect eof，这是因为ssh 这个spawn 并没<br>有结束，而且手动操作时ssh 实际上也不会自己结束除非你exit；所以你只能<br>expect bash 的提示符，当然也可以是机器名等，这样才可以在远程创建一个目<br>录。<br>注意，请不要用spawn mkdir tmpdir，这样会使得上一个spawn 即ssh 结束，那<br>么你的tmpdir 将在本机建立。<br>当然实际情况下可能会要你确认ssh key，可以通过并行的expect 进行处理，不<br>多赘述。</p>
<p>6 实例：下面这个脚本是完成对单个服务器scp任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/expect</div><div class="line"></div><div class="line">set timeout 10</div><div class="line">set host [lindex $argv 0]</div><div class="line">set username [lindex $argv 1]</div><div class="line">set password [lindex $argv 2]</div><div class="line">set src_file [lindex $argv 3]</div><div class="line">set dest_file [lindex $argv 4]</div><div class="line"></div><div class="line">spawn scp  $src_file $username@$host:$dest_file</div><div class="line">expect &#123;</div><div class="line">     &quot;(yes/no)?&quot;</div><div class="line">        &#123;</div><div class="line">            send &quot;yes\n&quot;</div><div class="line">            expect &quot;*assword:&quot; &#123; send &quot;$password\n&quot;&#125;</div><div class="line">        &#125;</div><div class="line">    &quot;*assword:&quot;</div><div class="line">        &#123;</div><div class="line">            send &quot;$password\n&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">expect &quot;100%&quot;</div><div class="line">expect eof</div></pre></td></tr></table></figure></p>
<p>意代码刚开始的第一行，指定了expect的路径，与shell脚本相同，这一句指定了程序在执行时到哪里去寻找相应的启动程序。代码刚开始还设定了timeout的时间为10秒，如果在执行scp任务时遇到了代码中没有指定的异常，则在等待10秒后该脚本的执行会自动终止。<br>spawn代表在本地终端执行的语句，在该语句开始执行后，expect开始捕获终端的输出信息，然后做出对应的操作。expect代码中的捕获的(yes/no)内容用于完成第一次访问目标主机时保存密钥的操作。有了这一句，scp的任务减少了中断的情况。代码结尾的expect eof与spawn对应，表示捕获终端输出信息的终止。</p>
<p>有了这段expect的代码，还只能完成对单个远程主机的scp任务。如果需要实现批量scp的任务，则需要再写一个shell脚本来调用这个expect脚本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line"></div><div class="line">list_file=$1</div><div class="line">src_file=$2</div><div class="line">dest_file=$3</div><div class="line"></div><div class="line">cat $list_file | while    read line</div><div class="line"> do</div><div class="line">     host_ip=`echo $line | awk &apos;&#123;print $1&#125;&apos;`</div><div class="line">     username=`echo $line | awk &apos;&#123;print $2&#125;&apos;`</div><div class="line">     password=`echo $line | awk &apos;&#123;print $3&#125;&apos;`</div><div class="line">     echo &quot;$host_ip&quot;</div><div class="line">     ./expect_scp $host_ip $username $password $src_file $dest_file</div><div class="line"> done</div></pre></td></tr></table></figure></p>
<p>很简单的代码，指定了3个参数：列表文件的位置、本地源文件路径、远程主机目标文件路径。需要说明的是其中的列表文件指定了远程主机ip、用户名、密码，这些信息需要写成以下的格式：<br>IP username password<br>中间用空格或tab键来分隔，多台主机的信息需要写多行内容。<br>这样就指定了两台远程主机的信息。注意，如果远程主机密码中有“$”、“#”这类特殊字符的话，在编写列表文件时就需要在这些特殊字符前加上转义字符，否则expect在执行时会输入错误的密码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Shell--Sed]]></title>
      <url>https://fudawei.github.io/2017/01/23/Shell%E5%AD%A6%E4%B9%A0%E4%B9%8BSed/</url>
      <content type="html"><![CDATA[<h2 id="一、什么是sed？"><a href="#一、什么是sed？" class="headerlink" title="一、什么是sed？"></a>一、什么是sed？</h2><pre><code>sed 是一种在线编辑器，它一次处理一行内容。sed是非交互式的编辑器。它不会修改文件，除非使用shell重定向来保存结果。默认情况下，所有的输出行都被打印到屏幕上。
</code></pre><h2 id="二、sed的处理过程"><a href="#二、sed的处理过程" class="headerlink" title="二、sed的处理过程"></a>二、sed的处理过程</h2><p>   sed编辑器逐行处理文件（或输入），并将结果发送到屏幕。具体过程如下：首先sed把当前正在处理的行保存在一个临时缓存区中（也称为模式空间），然后处理临时缓冲区中的行，完成后把该行发送到屏幕上。sed每处理完一行就将其从临时缓冲区删除，然后将下一行读入，进行处理和显示。处理完输入文件的最后一行后，sed便结束运行。</p>
<p>   前面说到sed不会修改文件，那么现在我们可以知道是为什么了？是因为sed把每一行都存在临时缓冲区中，对这个副本进行编辑，所以不会修改原文件。</p>
<p>补充知识：</p>
<pre><code>在使用sed的过程中，我们经常会听到“定址”，那么什么是“定址”呢？

定址用于决定对哪些行进行编辑。地址的形式可以是数字、正则表达式、或二者的结合。如果没有指定地址，sed将处理输入文件的所有行。
</code></pre><p>1、地址是一个数字，则表示行号；是“$”符号，则表示最后一行。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;3p&apos; datafile   #只打印第三行</div></pre></td></tr></table></figure>
<p>2、只显示指定行范围的文件内容</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;100,200p&apos; mysql_slow_query.log  # 只查看文件的第100行到第200行</div></pre></td></tr></table></figure></p>
<p>3、地址是逗号分隔的，那么需要处理的地址是这两行之间的范围（包括这两行在内）。范围可以用数字、正则表达式、或二者的组合表示。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sed &apos;2,5d&apos; datafile</div><div class="line">#删除第二到第五行</div><div class="line">sed &apos;/My/,/You/d&apos; datafile</div><div class="line">#删除包含&quot;My&quot;的行到包含&quot;You&quot;的行之间的行</div><div class="line">sed &apos;/My/,10d&apos; datafile</div><div class="line">#删除包含&quot;My&quot;的行到第十行的内容</div></pre></td></tr></table></figure>
<p>三、sed命令和选项<br>sed命令告诉sed如何处理由地址指定的各输入行，如果没有指定地址则处理所有的输入行。</p>
<p>1、sed命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>a\</td>
<td>在当前行后添加一行或多行。多行时除最后一行外，每行末尾需用“\”续行</td>
</tr>
<tr>
<td>c\</td>
<td>用此符号后的新文本替换当前行中的文本。多行时除最后一行外，每行末尾需用”\”续行</td>
</tr>
<tr>
<td>i\</td>
<td>在当前行之前插入文本。多行时除最后一行外，每行末尾需用”\”续行</td>
</tr>
<tr>
<td>d</td>
<td>删除行</td>
</tr>
<tr>
<td>h</td>
<td>把模式空间里的内容复制到暂存缓冲区</td>
</tr>
<tr>
<td>H</td>
<td>把模式空间里的内容追加到暂存缓冲区</td>
</tr>
<tr>
<td>g</td>
<td>把暂存缓冲区里的内容复制到模式空间，覆盖原有的内容</td>
</tr>
<tr>
<td>G</td>
<td>把暂存缓冲区的内容追加到模式空间里，追加在原有内容的后面</td>
</tr>
<tr>
<td>l</td>
<td>列出非打印字符</td>
</tr>
<tr>
<td>p</td>
<td>打印行</td>
<td></td>
</tr>
<tr>
<td>n</td>
<td>读入下一输入行，并从下一条命令而不是第一条命令开始对其的处理</td>
</tr>
<tr>
<td>q</td>
<td>结束或退出sed</td>
</tr>
<tr>
<td>r</td>
<td>从文件中读取输入行</td>
</tr>
<tr>
<td>!</td>
<td>对所选行以外的所有行应用命令</td>
</tr>
<tr>
<td>s</td>
<td>用一个字符串替换另一个</td>
</tr>
<tr>
<td>g</td>
<td>在行内进行全局替换</td>
</tr>
<tr>
<td>w</td>
<td>将所选的行写入文件</td>
</tr>
<tr>
<td>x</td>
<td>交换暂存缓冲区与模式空间的内容</td>
</tr>
<tr>
<td>y</td>
<td>将字符替换为另一字符（不能对正则表达式使用y命令）</td>
</tr>
</tbody>
</table>
<p>2、sed选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td>进行多项编辑，即对输入行应用多条sed命令时使用</td>
</tr>
<tr>
<td>-n</td>
<td>取消默认的输出</td>
</tr>
<tr>
<td>-f</td>
<td>指定sed脚本的文件名</td>
</tr>
</tbody>
</table>
<h2 id="四、正则表达式元字符"><a href="#四、正则表达式元字符" class="headerlink" title="四、正则表达式元字符"></a>四、正则表达式元字符</h2><p>   与grep一样，sed也支持特殊元字符，来进行模式查找、替换。不同的是，sed使用的正则表达式是括在斜杠线”/“之间的模式。</p>
<p>   如果要把正则表达式分隔符”/“改为另一个字符，比如o，只要在这个字符前加一个反斜线，在字符后跟上正则表达式，再跟上这个字符即可。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;\o^Myop&apos; datafile</div></pre></td></tr></table></figure>
<p>常用的正则表达式如下：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>功能描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>行首定位符</td>
<td>/^my/ 匹配所有以my开头的行</td>
</tr>
<tr>
<td>$</td>
<td>行尾定位符</td>
<td></td>
<td>/my$/ 匹配所有以my结尾的行</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符以外的单个字符</td>
<td>/m..y/ 匹配包含字母m，后跟两个任意字符，再跟字母y的行</td>
</tr>
<tr>
<td>*</td>
<td>匹配零个或多个前导字符</td>
<td>/my*/ 匹配包含字母m,后跟零个或多个y字母的行</td>
</tr>
<tr>
<td>[]</td>
<td>匹配指定字符组内的任一字符</td>
<td>/[Mm]y/ 匹配包含My或my的行</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不在指定字符组内的任一字符</td>
<td>/[^Mm]y/ 匹配包含y，但y之前的那个字符不是M或m的行</td>
</tr>
<tr>
<td>..</td>
<td>保存已匹配的字符</td>
<td>1,20s/youself/\1r/ 标记元字符之间的模式，并将其保存为标签1，之后可以使用\1来引用它。最多可以定义9个标签，从左边开始编号，最左边的是第一个。此例中，对第1到第20行进行处理，you被保存为标签1，如果发现youself，则替换为your。</td>
</tr>
<tr>
<td>&amp;</td>
<td>保存查找串以便在替换串中引用</td>
<td>s/my/<strong>&amp;</strong>/  符号&amp;代表查找串。my将被替换为<strong>my</strong></td>
</tr>
<tr>
<td>\&lt;</td>
<td>词首定位符</td>
<td>/\&lt;my/ 匹配包含以my开头的单词的行</td>
</tr>
<tr>
<td>></td>
<td>词尾定位符</td>
<td>/my>/ 匹配包含以my结尾的单词的行</td>
</tr>
<tr>
<td>x{m}</td>
<td>连续m个x</td>
<td>/9{5}/匹配包含连续5个9的行</td>
</tr>
<tr>
<td>x{m,}</td>
<td>至少m个x</td>
<td>/9{5,}/ 匹配包含至少连续5个9的行</td>
</tr>
<tr>
<td>x{m,n}</td>
<td>至少m个，但不超过n个x</td>
<td>/9{5,7}/ 匹配包含连续5到7个9的行</td>
</tr>
</tbody>
</table>
<h2 id="五、sed的退出状态"><a href="#五、sed的退出状态" class="headerlink" title="五、sed的退出状态"></a>五、sed的退出状态</h2><p>   sed不向grep一样，不管是否找到指定的模式，它的退出状态都是0。只有当命令存在语法错误时，sed的退出状态才不是0。</p>
<h2 id="六、常用范例"><a href="#六、常用范例" class="headerlink" title="六、常用范例"></a>六、常用范例</h2><p>1、p命令</p>
<p>   命令p用于显示模式空间的内容。默认情况下，sed把输入行打印在屏幕上，选项-n用于取消默认的打印操作。当选项-n和命令p同时出现时,sed可打印选定的内容。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">（1）sed &apos;/my/p&apos; datafile</div><div class="line">#默认情况下，sed把所有输入行都打印在标准输出上。如果某行匹配模式my，p命令将把该行另外打印一遍。</div><div class="line"></div><div class="line">（2）sed -n &apos;/my/p&apos; datafile</div><div class="line">#选项-n取消sed默认的打印，p命令把匹配模式my的行打印一遍。</div></pre></td></tr></table></figure>
<p>2、d命令</p>
<p>   命令d用于删除输入行。sed先将输入行从文件复制到模式空间里，然后对该行执行sed命令，最后将模式空间里的内容显示在屏幕上。如果发出的是命令d，当前模式空间里的输入行会被删除，不被显示。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">（1）sed &apos;$d&apos; datafile</div><div class="line">#删除最后一行，其余的都被显示</div><div class="line"></div><div class="line">（2）sed &apos;/my/d&apos; datafile</div><div class="line">#删除包含my的行，其余的都被显示</div></pre></td></tr></table></figure>
<p>3、s命令</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">（1）sed &apos;s/^My/You/g&apos; datafile</div><div class="line">#命令末端的g表示在行内进行全局替换，也就是说如果某行出现多个My，所有的My都被替换为You。</div><div class="line"></div><div class="line">（2）sed -n &apos;1,20s/My$/You/gp&apos; datafile</div><div class="line">#取消默认输出，处理1到20行里匹配以My结尾的行，把行内所有的My替换为You，并打印到屏幕上。</div><div class="line"></div><div class="line">（3）sed &apos;s#My#Your#g&apos; datafile</div><div class="line">#紧跟在s命令后的字符就是查找串和替换串之间的分隔符。分隔符默认为正斜杠，但可以改变。无论什么字符（换行符、反斜线除外），只要紧跟s命令，就成了新的串分隔符。</div></pre></td></tr></table></figure>
<p>4、e选项</p>
<p>   -e是编辑命令，用于sed执行多个编辑任务的情况下。在下一行开始编辑前，所有的编辑动作将应用到模式缓冲区中的行上。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;1,10d&apos; -e &apos;s/My/Your/g&apos; datafile</div><div class="line">#选项-e用于进行多重编辑。第一重编辑删除第1-3行。第二重编辑将出现的所有My替换为Your。因为是逐行进行这两项编辑（即这两个命令都在模式空间的当前行上执行），所以编辑命令的顺序会影响结果。</div></pre></td></tr></table></figure>
<p>5、r命令</p>
<p>r命令是读命令。sed使用该命令将一个文本文件中的内容加到当前文件的特定位置上。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed &apos;/My/r introduce.txt&apos; datafile</div><div class="line">#如果在文件datafile的某一行匹配到模式My，就在该行后读入文件introduce.txt的内容。如果出现My的行不止一行，则在出现My的各行后都读入introduce.txt文件的内容。</div></pre></td></tr></table></figure>
<p>6、w命令</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;/hrwang/w me.txt&apos; datafile</div></pre></td></tr></table></figure>
<p>7、a\ 命令</p>
<p>   a\ 命令是追加命令，追加将添加新文本到文件中当前行（即读入模式缓冲区中的行）的后面。所追加的文本行位于sed命令的下方另起一行。如果要追加的内容超过一行，则每一行都必须以反斜线结束，最后一行除外。最后一行将以引号和文件名结束。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sed &apos;/^hrwang/a\</div><div class="line">&gt;hrwang and mjfan are husband\</div><div class="line">&gt;and wife&apos; datafile</div><div class="line">#如果在datafile文件中发现匹配以hrwang开头的行，则在该行下面追加hrwang and mjfan are husband and wife</div></pre></td></tr></table></figure>
<p>8、i\ 命令</p>
<p>i\ 命令是在当前行的前面插入新的文本。</p>
<p>9、c\ 命令</p>
<p>sed使用该命令将已有文本修改成新的文本。</p>
<p>10、n命令</p>
<p>sed使用该命令获取输入文件的下一行，并将其读入到模式缓冲区中，任何sed命令都将应用到匹配行紧接着的下一行上。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;/hrwang/&#123;n;s/My/Your/;&#125;&apos; datafile</div></pre></td></tr></table></figure>
<p>注：如果需要使用多条命令，或者需要在某个地址范围内嵌套地址，就必须用花括号将命令括起来，每行只写一条命令，或这用分号分割同一行中的多条命令。</p>
<p>11、y命令</p>
<p>该命令与UNIX/Linux中的tr命令类似，字符按照一对一的方式从左到右进行转换。例如，y/abc/ABC/将把所有小写的a转换成A，小写的b转换成B，小写的c转换成C。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed &apos;1,20y/hrwang12/HRWANG^$/&apos; datafile</div><div class="line">#将1到20行内，所有的小写hrwang转换成大写，将1转换成^,将2转换成$。</div><div class="line">#正则表达式元字符对y命令不起作用。与s命令的分隔符一样，斜线可以被替换成其它的字符。</div></pre></td></tr></table></figure>
<p>12、q命令</p>
<p> q命令将导致sed程序退出，不再进行其它的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;/hrwang/&#123;s/hrwang/HRWANG/;q;&#125;&apos; datafile</div></pre></td></tr></table></figure>
<p>13、h命令和g命令</p>
<p>为了更好说明这两个命令，我们先创建如下的文本文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#cat datafile</div><div class="line">My name is hrwang.</div><div class="line">Your name is mjfan.</div><div class="line">hrwang is mjfan&apos;s husband.</div><div class="line">mjfan is hrwang&apos;s wife.</div><div class="line"></div><div class="line">sed -e &apos;/hrwang/h&apos; -e &apos;$G&apos; datafile</div><div class="line">sed -e &apos;/hrwang/H&apos; -e &apos;$G&apos; datafile</div><div class="line">#通过上面两条命令，你会发现h会把原来暂存缓冲区的内容清除，只保存最近一次执行h时保存进去的模式空间的内容。而H命令则把每次匹配hrwnag的行都追加保存在暂存缓冲区。</div><div class="line"></div><div class="line">sed -e &apos;/hrwang/H&apos; -e &apos;$g&apos; datafile</div><div class="line">sed -e &apos;/hrwang/H&apos; -e &apos;$G&apos; datafile</div><div class="line">#通过上面两条命令，你会发现g把暂存缓冲区中的内容替换掉了模式空间中当前行的内容，此处即替换了最后一行。而G命令则把暂存缓冲区的内容追加到了模式空间的当前行后。此处即追加到了末尾。</div></pre></td></tr></table></figure>
<p>补充知识点：sed特殊用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;/root/w a.txt&apos;    #将匹配行输出到文件</div><div class="line"></div><div class="line">sed &apos;/root/r abc.txt&apos; /etc/passwd #把abc.txt的文件内容读入到root匹配行后</div><div class="line"></div><div class="line">sed -n &apos;/root/w a.txt&apos;</div><div class="line"></div><div class="line">sed -n &apos;/root/&#123;=;p&#125;&apos; /etc/passwd #打印行号和匹配root的行</div><div class="line"></div><div class="line">sed -n &apos;/root/&#123;n;d&#125;&apos; /etc/passwd #将匹配root行的下一行删除</div><div class="line"></div><div class="line">sed -n &apos;/root/&#123;N;d&#125;&apos; /etc/passwd #将匹配root行和下一行都删除</div><div class="line"></div><div class="line">sed &apos;22&#123;h;d&#125;;23,33&#123;H;d&#125;;44G&apos; pass</div></pre></td></tr></table></figure>
<h2 id="七、sed脚本编写方法"><a href="#七、sed脚本编写方法" class="headerlink" title="七、sed脚本编写方法"></a>七、sed脚本编写方法</h2><p>1、从文件读入命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -f sed.sh</div></pre></td></tr></table></figure>
<p>sed.sh文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s/root/yerik/p</div><div class="line">s/bash/csh/p</div></pre></td></tr></table></figure>
<p>2、直接运行脚本 ./sed.sh /etc/passwd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bib/sed -f</div><div class="line">s/root/yerik/p</div><div class="line">s/bash/csh/p</div></pre></td></tr></table></figure>
<h2 id="八、小技巧"><a href="#八、小技巧" class="headerlink" title="八、小技巧"></a>八、小技巧</h2><p>1、用sed 输出自己的IP 地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig eth0 |sed &apos;2p&apos; |sed &apos;s/^.*addr:/ /g&apos; |sed &apos;s/B.*$ / /g&apos;</div></pre></td></tr></table></figure>
<p>2、在sed的命令行中引用shell变量时要使用双引号，而不是通常所用的单引号。下面是一个根据name变量的内容来删除named.conf文件中zone段的脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name=&apos;zone\ &quot;localhost&quot;&apos;</div><div class="line"></div><div class="line">sed &quot;/$name/,/&#125;;/d&quot; named.conf</div></pre></td></tr></table></figure>
<p>3、保持和获取：h命令和G命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e &apos;/test/h&apos; -e &apos;$G example</div></pre></td></tr></table></figure>
<p> 在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。</p>
<p>4、保持和互换：h命令和x命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e &apos;/test/h&apos; -e &apos;/check/x&apos; example</div></pre></td></tr></table></figure>
<p>互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。</p>
<h2 id="九、练习"><a href="#九、练习" class="headerlink" title="九、练习"></a>九、练习</h2><p>1，删除文件每行的第一个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;s/^.//gp&apos; /etc/passwd</div><div class="line">sed -nr &apos;s/(.)(.*)/\2/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>2，删除文件每行的第二个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/(.)(.)(.*)/\1\3/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>3，删除文件每行的最后一个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/.$//p&apos; /etc/passwd</div><div class="line">sed -nr &apos;s/(.*)(.)/\1/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>4，删除文件每行的倒数第二个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/(.*)(.)(.)/\1\3/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>5，删除文件每行的第二个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/([^a-Z]*)([a-Z]+)([^a-Z]+)([a-Z]+)(.*)/\1\2\3\5/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>6，删除文件每行的倒数第二个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/(.*)([^a-Z]+)([a-Z]+)([^a-Z]+)([a-Z]+)([^a-Z]*)/\1\2\4\5\6/p&apos; /etc/samba/smb.conf</div></pre></td></tr></table></figure>
<p>7，删除文件每行的最后一个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/(.*)([^a-Z]+)([a-Z]+)([^a-Z]*)/\1\2\4/p&apos; /etc/samba/smb.conf</div></pre></td></tr></table></figure>
<p>8，交换每行的第一个字符和第二个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/(.)(.)(.*)/\2\1\3/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>9，交换每行的第一个单词和第二个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/([^a-Z]*)([a-Z]+)([^a-Z]+)([a-Z]+)(.*)/\1\4\3\2\5/p&apos; /etc/samba/smb.conf</div></pre></td></tr></table></figure>
<p>10，交换每行的第一个单词和最后一个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/([^a-Z]*)([a-Z]+)([^a-Z]+)([a-Z]+)(.*)/\1\4\3\2\5/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>11，删除一个文件中所有的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;s/[0-9]*//g&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>12，删除每行开头的所有空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;s/^\ *//p&apos; /etc/samba/smb.conf</div><div class="line">sed -nr &apos;s/( *)(.*)/\2/p&apos; testp</div></pre></td></tr></table></figure>
<p>13，用制表符替换文件中出现的所有空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;s/\ /\t/gp&apos; pass</div></pre></td></tr></table></figure>
<p>14，把所有大写字母用括号（）括起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/([A-Z])/(&amp;)/gp&apos; testp</div><div class="line">sed -n &apos;s/[A-Z]/(&amp;)/gp&apos; testp</div></pre></td></tr></table></figure>
<p>15，打印每行3次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;p;p&apos; pass</div></pre></td></tr></table></figure>
<p>16，隔行删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;1~2p&apos; pass</div></pre></td></tr></table></figure>
<p>17，把文件从第22行到第33行复制到第44行后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;1,21h;22h;23,33H;44G&apos; pass</div></pre></td></tr></table></figure>
<p>18，把文件从第22行到第33行移动到第44行后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;22&#123;h;d&#125;;23,33&#123;H;d&#125;;44G&apos; pass</div></pre></td></tr></table></figure>
<p>19，只显示每行的第一个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/([^a-Z]*)([a-Z]+)([^a-Z]+)(.*)/\2/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>20，打印每行的第一个单词和第三个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/([^a-Z]*)([a-Z]+)([^a-Z]+)([a-Z]+)([^a-Z]+)([a-Z]+)(.*)/\2--\4/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>21，将格式为    mm/yy/dd    的日期格式换成   mm；yy；dd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">date +%m/%Y/%d |sed -n &apos;s#/#;#gp&apos;</div></pre></td></tr></table></figure>
<p>22, 逆向输出<br>sed ‘1!G;h;$!d’ b<br>cat a.txt<br>ABC<br>DEF<br>XYZ<br>输出样式变成<br>XYZ<br>DEF<br>ABC</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Shell--Awk]]></title>
      <url>https://fudawei.github.io/2017/01/22/Shell%E5%AD%A6%E4%B9%A0%E4%B9%8BAwk/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>awk是一种很棒的语言。awk 适合于文本处理和报表生成，它还有许多精心设计的特性，允许进行需要特殊技巧程序设计。与某些语言不同，awk 的语法较为常见。它借鉴了某些语言的一些精华部分，如 C 语言、Python 和 bash（虽然在技术上，awk 比 python 和 bash 早创建）。awk 是那种一旦学会了就会成为您战略编码库的主要部分的语言。</p>
<h3 id="一-第一个-awk"><a href="#一-第一个-awk" class="headerlink" title="一. 第一个 awk"></a>一. 第一个 awk</h3><p>让我们继续，开始使用 awk，以了解其工作原理。在命令行中输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; print &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>你将会见到 /etc/passwd 文件的内容出现在眼前。现在，解释 awk 做了些什么。调用 awk 时，我们指定 /etc/passwd 作为输入文件。执行 awk 时，它依次对 /etc/passwd 中的每一行执行 print 命令。所有输出都发送到 stdout，所得到的结果与与执行catting /etc/passwd完全相同。</p>
<p>现在，解释 { print } 代码块。在 awk 中，花括号用于将几块代码组合到一起，这一点类似于 C 语言。在代码块中只有一条 print 命令。在 awk 中，如果只出现 print 命令，那么将打印当前行的全部内容。</p>
<p>这里是另一个 awk 示例，它的作用与上例完全相同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; print $0 &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure></p>
<p>在 awk 中， $0 变量表示整个当前行，所以 print 和 print $0 的作用完全一样。</p>
<p>如果你愿意，可以创建一个 awk 程序，让它输出与输入数据完全无关的数据。以下是一个示例：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; print &quot;&quot; &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>只要将 “” 字符串传递给 print 命令，它就会打印空白行。如果测试该脚本，将会发现对于 /etc/passwd 文件中的每一行，awk 都输出一个空白行。再次说明， awk 对输入文件中的每一行都执行这个脚本。以下是另一个示例：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; print &quot;hiya&quot; &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>运行这个脚本将在您的屏幕上写满 hiya。</p>
<h3 id="二-多个字段"><a href="#二-多个字段" class="headerlink" title="二. 多个字段"></a>二. 多个字段</h3><p>awk 非常善于处理分成多个逻辑字段的文本，而且让您可以毫不费力地引用 awk 脚本中每个独立的字段。以下脚本将打印出您的系统上所有用户帐户的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F&quot;:&quot; &apos;&#123; print $1 &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>　<br>上例中，在调用 awk 时，使用 -F 选项来指定 “:” 作为字段分隔符。awk 处理 print $1 命令时，它会打印出在输入文件中每一行中出现的第一个字段。以下是另一个示例： 　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F&quot;:&quot; &apos;&#123; print $1 $3 &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>以下是该脚本输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">halt7</div><div class="line">operator11</div><div class="line">root0</div><div class="line">shutdown6</div><div class="line">sync5</div><div class="line">bin1</div><div class="line">....etc.</div></pre></td></tr></table></figure>
<p>如您所见，awk 打印出 /etc/passwd 文件的第一和第三个字段，它们正好分别是用户名和用户标识字段。现在，当脚本运行时，它并不理想 – 在两个输出字段之间没有空格！如果习惯于使用 bash 或 python 进行编程，那么您会指望 print $1 $3 命令在两个字段之间插入空格。然而，当两个字符串在 awk 程序中彼此相邻时，awk 会连接它们但不在它们之间添加空格。以下命令会在这两个字段中插入空格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F&quot;:&quot; &apos;&#123; print $1 &quot; &quot; $3 &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>以这种方式调用 print 时，它将连接 $1 、” “ 和 $3 ，创建可读的输出。当然，如果需要的话，我们还可以插入一些文本标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F&quot;:&quot; &apos;&#123; print &quot;username: &quot; $1 &quot;/t/tuid:&quot; $3&quot; &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>这将产生以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">username: halt uid:7</div><div class="line">username: operator uid:11</div><div class="line">username: root uid:0</div><div class="line">username: shutdown uid:6</div><div class="line">username: sync uid:5</div><div class="line">username: bin uid:1</div><div class="line">....etc.</div></pre></td></tr></table></figure>
<h3 id="三-外部脚本"><a href="#三-外部脚本" class="headerlink" title="三. 外部脚本"></a>三. 外部脚本</h3><p>将脚本作为命令行自变量传递给 awk 对于小的单行程序来说是非常简单的，而对于多行程序，它就比较复杂。您肯定想要在外部文件中撰写脚本。然后可以向 awk 传递 -f 选项，以向它提供此脚本文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -f myscript.awk myfile.in</div></pre></td></tr></table></figure>
<p>将脚本放入文本文件还可以让您使用附加 awk 功能。例如，这个多行脚本与前面的单行脚本的作用相同，它们都打印出 /etc/passwd 中每一行的第一个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">FS=&quot;:&quot;</div><div class="line">&#125;</div><div class="line">&#123; print $1 &#125;</div></pre></td></tr></table></figure>
<p>这两个方法的差别在于如何设置字段分隔符。在这个脚本中，字段分隔符在代码自身中指定（通过设置 FS 变量），而在前一个示例中，通过在命令行上向 awk 传递 -F”:” 选项来设置 FS。通常，最好在脚本自身中设置字段分隔符，只是因为这表示您可以少输入一个命令行自变量。我们将在本文的后面详细讨论 FS 变量。</p>
<h3 id="四-BEGIN-和-END-块"><a href="#四-BEGIN-和-END-块" class="headerlink" title="四. BEGIN 和 END 块"></a>四. BEGIN 和 END 块</h3><p>通常，对于每个输入行，awk 都会执行每个脚本代码块一次。然而，在许多编程情况中，可能需要在 awk 开始处理输入文件中的文本之 前 执行初始化代码。对于这种情况，awk 允许您定义一个 BEGIN 块。我们在前一个示例中使用了 BEGIN 块。因为 awk 在开始处理输入文件之前会执行 BEGIN 块，因此它是初始化 FS（字段分隔符）变量、打印页眉或初始化其它在程序中以后会引用的全局变量的极佳位置。</p>
<p>awk 还提供了另一个特殊块，叫作 END 块。awk 在处理了输入文件中的所有行之后执行这个块。通常，END 块用于执行最终计算或打印应该出现在输出流结尾的摘要信息。</p>
<h3 id="五-规则表达式和块"><a href="#五-规则表达式和块" class="headerlink" title="五. 规则表达式和块"></a>五. 规则表达式和块</h3><p>awk 允许使用规则表达式，根据规则表达式是否匹配当前行来选择执行独立代码块。以下示例脚本只输出包含字符序列 foo 的那些行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/foo/ &#123; print &#125;</div></pre></td></tr></table></figure>
<p>当然，可以使用更复杂的规则表达式。以下脚本将只打印包含浮点数的行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/[0-9]+/.[0-9]*/ &#123; print &#125;</div></pre></td></tr></table></figure>
<h3 id="六-表达式和块"><a href="#六-表达式和块" class="headerlink" title="六. 表达式和块"></a>六. 表达式和块</h3><p>有许多其它方法可以选择执行代码块。我们可以将任意一种布尔表达式放在一个代码块之前，以控制何时执行某特定块。仅当对前面的布尔表达式求值为真时，awk 才执行代码块。以下示例脚本输出将输出其第一个字段等于 fred 的所有行中的第三个字段。如果当前行的第一个字段不等于 fred ，awk 将继续处理文件而不对当前行执行 print 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$1 == &quot;fred&quot; &#123; print $3 &#125;</div></pre></td></tr></table></figure>
<p>awk 提供了完整的比较运算符集合，包括 “==”、”&lt;”、”&gt;”、”&lt;=”、”&gt;=” 和 “!=”。另外，awk 还提供了 “~” 和 “!~” 运算符，它们分别表示“匹配”和“不匹配”。它们的用法是在运算符左边指定变量，在右边指定规则表达式。如果某一行的第五个字段包含字符序列 root ，那么以下示例将只打印这一行中的第三个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$5 ~ /root/ &#123; print $3 &#125;</div></pre></td></tr></table></figure>
<h3 id="七-条件语句"><a href="#七-条件语句" class="headerlink" title="七. 条件语句"></a>七. 条件语句</h3><p>awk 还提供了非常好的类似于 C 语言的 if 语句。如果您愿意，可以使用 if 语句重写前一个脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">if ( $5 ~ /root/ ) &#123; </div><div class="line">  print $3 </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个脚本的功能完全一样。第一个示例中，布尔表达式放在代码块外面。而在第二个示例中，将对每一个输入行执行代码块，而且我们使用 if 语句来选择执行 print 命令。这两个方法都可以使用，可以选择最适合脚本其它部分的一种方法。</p>
<p>以下是更复杂的 awk if 语句示例。可以看到，尽管使用了复杂、嵌套的条件语句， if 语句看上去仍与相应的 C 语言 if 语句一样：<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">  if ( $1 == &quot;foo&quot; ) &#123;</div><div class="line">    if ( $2 == &quot;foo&quot; ) &#123;</div><div class="line">      print &quot;uno&quot;</div><div class="line">    &#125; </div><div class="line">   else &#123;</div><div class="line">      print &quot;one&quot;</div><div class="line">    &#125;</div><div class="line">  &#125; </div><div class="line">  else if ($1 == &quot;bar&quot; ) &#123;</div><div class="line">    print &quot;two&quot;</div><div class="line">  &#125; </div><div class="line">  else &#123;</div><div class="line">   print &quot;three&quot; </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 if 语句还可以将代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">! /matchme/ &#123; print $1 $3 $4 &#125;</div><div class="line"></div><div class="line">转换成：</div><div class="line"></div><div class="line">&#123; </div><div class="line">  if ( $0 !~ /matchme/ ) &#123;</div><div class="line">  print $1 $3 $4</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个脚本都只输出 不 包含 matchme 字符序列的那些行。此外，还可以选择最适合您的代码的方法。它们的功能完全相同。</p>
<p>awk 还允许使用布尔运算符 “||”（逻辑与）和 “&amp;&amp;”（逻辑或），以便创建更复杂的布尔表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( $1 == &quot;foo&quot; ) &amp;&amp; ( $2 == &quot;bar&quot; ) &#123; print &#125;</div></pre></td></tr></table></figure>
<p>这个示例只打印第一个字段等于 foo 且 第二个字段等于 bar 的那些行。</p>
<h3 id="八-数值变量！"><a href="#八-数值变量！" class="headerlink" title="八. 数值变量！"></a>八. 数值变量！</h3><p>至今，我们不是打印字符串、整行就是特定字段。然而，awk 还允许我们执行整数和浮点运算。通过使用数学表达式，可以很方便地编写计算文件中空白行数量的脚本。以下就是这样一个脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123; x=0 &#125;</div><div class="line">  /^$/ &#123; x=x+1 &#125;</div><div class="line">END &#123; print &quot;I found &quot; x &quot; blank lines. :)&quot; &#125;</div></pre></td></tr></table></figure>
<p>在 BEGIN 块中，将整数变量 x 初始化成零。然后，awk 每次遇到空白行时，awk 将执行 x=x+1 语句，递增 x 。处理完所有行之后，执行 END 块，awk 将打印出最终摘要，指出它找到的空白行数量。</p>
<h3 id="九-字符串化变量"><a href="#九-字符串化变量" class="headerlink" title="九. 字符串化变量"></a>九. 字符串化变量</h3><p>awk 的优点之一就是“简单和字符串化”。我认为 awk 变量“字符串化”是因为所有 awk 变量在内部都是按字符串形式存储的。同时，awk 变量是“简单的”，因为可以对它执行数学操作，且只要变量包含有效数字字符串，awk 会自动处理字符串到数字的转换步骤。要理解我的观点，请研究以下这个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x=&quot;1.01&quot;</div><div class="line"># We just set x to contain the *string* &quot;1.01&quot;</div><div class="line">x=x+1</div><div class="line"># We just added one to a *string*</div><div class="line">print x</div><div class="line"># Incidentally, these are comments :)</div></pre></td></tr></table></figure>
<p>awk 将输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.01</div></pre></td></tr></table></figure>
<p>有趣吧！虽然将字符串值 1.01 赋值给变量 x ，我们仍然可以对它加一。但在 bash 和 python 中却不能这样做。首先，bash 不支持浮点运算。而且，如果 bash 有“字符串化”变量，它们并不“简单”；要执行任何数学操作，bash 要求我们将数字放到丑陋的 $( ) ) 结构中。如果使用 python，则必须在对 1.01 字符串执行任何数学运算之前，将它转换成浮点值。虽然这并不困难，但它仍是附加的步骤。如果使用 awk，它是全自动的，而那会使我们的代码又好又整洁。如果想要对每个输入行的第一个字段乘方并加一，可以使用以下脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; print ($1^2)+1 &#125;</div></pre></td></tr></table></figure>
<p>如果做一个小实验，就可以发现如果某个特定变量不包含有效数字，awk 在对数学表达式求值时会将该变量当作数字零处理。</p>
<h3 id="十-众多运算符"><a href="#十-众多运算符" class="headerlink" title="十. 众多运算符"></a>十. 众多运算符</h3><p>awk 的另一个优点是它有完整的数学运算符集合。除了标准的加、减、乘、除，awk 还允许使用前面演示过的指数运算符 “^”、模（余数）运算符 “%” 和其它许多从 C 语言中借入的易于使用的赋值操作符。</p>
<p>这些运算符包括前后加减（ i++ 、 –foo ）、加／减／乘／除赋值运算符（ a+=3 、 b*=2 、 c/=2.2 、 d-=6.2 ）。不仅如此 – 我们还有易于使用的模／指数赋值运算符（ a^=2 、 b%=4 ）。</p>
<h3 id="十一-字段分隔符"><a href="#十一-字段分隔符" class="headerlink" title="十一. 字段分隔符"></a>十一. 字段分隔符</h3><p>awk 有它自己的特殊变量集合。其中一些允许调整 awk 的运行方式，而其它变量可以被读取以收集关于输入的有用信息。我们已经接触过这些特殊变量中的一个，FS。前面已经提到过，这个变量让您可以设置 awk 要查找的字段之间的字符序列。我们使用 /etc/passwd 作为输入时，将 FS 设置成 “:”。当这样做有问题时，我们还可以更灵活地使用 FS。</p>
<p>FS 值并没有被限制为单一字符；可以通过指定任意长度的字符模式，将它设置成规则表达式。如果正在处理由一个或多个 tab 分隔的字段，您可能希望按以下方式设置 FS：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FS=&quot;/t+&quot;</div></pre></td></tr></table></figure></p>
<p>以上示例中，我们使用特殊 “+” 规则表达式字符，它表示“一个或多个前一字符”。<br>如果字段由空格分隔（一个或多个空格或 tab），您可能想要将 FS 设置成以下规则表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FS=&quot;[[:space:]+]&quot;</div></pre></td></tr></table></figure></p>
<p>这个赋值表达式也有问题，它并非必要。为什么？因为缺省情况下，FS 设置成单一空格字符，awk 将这解释成表示“一个或多个空格或 tab”。在这个特殊示例中，缺省 FS 设置恰恰是您最想要的！<br>复杂的规则表达式也不成问题。即使您的记录由单词 “foo” 分隔，后面跟着三个数字，以下规则表达式仍允许对数据进行正确的分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FS=&quot;foo[0-9][0-9][0-9]&quot;</div></pre></td></tr></table></figure></p>
<h3 id="十二-字段数量"><a href="#十二-字段数量" class="headerlink" title="十二. 字段数量"></a>十二. 字段数量</h3><p>接着我们要讨论的两个变量通常并不是需要赋值的，而是用来读取以获取关于输入的有用信息。第一个是 NF 变量，也叫做“字段数量”变量。awk 会自动将该变量设置成当前记录中的字段数量。可以使用 NF 变量来只显示某些输入行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NF == 3 &#123; print &quot;this particular record has three fields: &quot; $0 &#125;</div></pre></td></tr></table></figure>
<p>当然，也可以在条件语句中使用 NF 变量，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">  if ( NF &gt; 2 ) &#123;</div><div class="line">    print $1 &quot; &quot; $2 &quot;:&quot; $3 </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="十三-记录号"><a href="#十三-记录号" class="headerlink" title="十三. 记录号"></a>十三. 记录号</h3><p>记录号 (NR) 是另一个方便的变量。它始终包含当前记录的编号（awk 将第一个记录算作记录号 1）。迄今为止，我们已经处理了每一行包含一个记录的输入文件。对于这些情况，NR 还会告诉您当前行号。然而，当我们在本系列以后部分中开始处理多行记录时，就不会再有这种情况，所以要注意！可以象使用 NF 变量一样使用 NR 来只打印某些输入行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(NR &lt; 10 ) || (NR &gt; 100) &#123; print &quot;We are on record number 1-9 or 101+&quot; &#125;</div></pre></td></tr></table></figure>
<p>另一个示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  if ( NR &gt; 10 ) &#123;</div><div class="line">    print &quot;ok, now for the real information!&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>awk 提供了适合各种用途的附加变量。我们将在以后的文章中讨论这些变量。</p>
<h3 id="十四-多行记录"><a href="#十四-多行记录" class="headerlink" title="十四. 多行记录"></a>十四. 多行记录</h3><p>awk 是一种用于读取和处理结构化数据（如系统的 /etc/passwd 文件）的极佳工具。/etc/passwd 是 UNIX 用户数据库，并且是用冒号定界的文本文件，它包含许多重要信息，包括所有现有用户帐户和用户标识，以及其它信息。在我的 前一篇文章 中，我演示了 awk 如何轻松地分析这个文件。我们只须将 FS（字段分隔符）变量设置成 “:”。</p>
<p>正确设置了 FS 变量之后，就可以将 awk 配置成分析几乎任何类型的结构化数据，只要这些数据是每行一个记录。然而，如果要分析占据多行的记录，仅仅依靠设置 FS 是不够的。在这些情况下，我们还需要修改 RS 记录分隔符变量。RS 变量告诉 awk 当前记录什么时候结束，新记录什么时候开始。</p>
<p>譬如，让我们讨论一下如何完成处理“联邦证人保护计划”所涉及人员的地址列表的任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> Jimmy the Weasel</div><div class="line">100 Pleasant Drive</div><div class="line">San Francisco, CA 12345</div><div class="line"></div><div class="line">Big Tony</div><div class="line">200 Incognito Ave.</div><div class="line">Suburbia, WA 67890</div></pre></td></tr></table></figure>
<p>理论上，我们希望 awk 将每 3 行看作是一个独立的记录，而不是三个独立的记录。如果 awk 将地址的第一行看作是第一个字段 ($1)，街道地址看作是第二个字段 ($2)，城市、州和邮政编码看作是第三个字段 $3，那么这个代码就会变得很简单。以下就是我们想要得到的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">FS=&quot;/n&quot;</div><div class="line">RS=&quot;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面这段代码中，将 FS 设置成 “/n” 告诉 awk 每个字段都占据一行。通过将 RS 设置成 “”，还会告诉 awk 每个地址记录都由空白行分隔。一旦 awk 知道是如何格式化输入的，它就可以为我们执行所有分析工作，脚本的其余部分很简单。让我们研究一个完整的脚本，它将分析这个地址列表，并将每个记录打印在一行上，用逗号分隔每个字段。</p>
<p>address.awk<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">  FS=&quot;/n&quot;</div><div class="line">  RS=&quot;&quot;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  print $1 &quot;, &quot; $2 &quot;, &quot; $3</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果这个脚本保存为 address.awk，地址数据存储在文件 address.txt 中，可以通过输入 “awk -f address.awk address.txt” 来执行这个脚本。此代码将产生以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Jimmy the Weasel, 100 Pleasant Drive, San Francisco, CA 12345</div><div class="line">Big Tony, 200 Incognito Ave., Suburbia, WA 67890</div></pre></td></tr></table></figure></p>
<h3 id="十五-OFS-和-ORS"><a href="#十五-OFS-和-ORS" class="headerlink" title="十五. OFS 和 ORS"></a>十五. OFS 和 ORS</h3><p>在 address.awk 的 print 语句中，可以看到 awk 会连接（合并）一行中彼此相邻的字符串。我们使用此功能在同一行上的三个字段之间插入一个逗号和空格 (“, “)。这个方法虽然有用，但比较难看。与其在字段间插入 “, “ 字符串，倒不如让通过设置一个特殊 awk 变量 OFS，让 awk 完成这件事。请参考下面这个代码片断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print &quot;Hello&quot;, &quot;there&quot;, &quot;Jim!&quot;</div></pre></td></tr></table></figure>
<p>这行代码中的逗号并不是实际文字字符串的一部分。事实上，它们告诉 awk “Hello”、”there” 和 “Jim!” 是单独的字段，并且应该在每个字符串之间打印 OFS 变量。缺省情况下，awk 产生以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello there Jim!</div></pre></td></tr></table></figure>
<p>这是缺省情况下的输出结果，OFS 被设置成 “ “，单个空格。不过，我们可以方便地重新定义 OFS，这样 awk 将插入我们中意的字段分隔符。以下是原始 address.awk 程序的修订版，它使用 OFS 来输出那些中间的 “, “ 字符串：</p>
<p>address.awk 的修订版 　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line"> FS=&quot;/n&quot;</div><div class="line"> RS=&quot;&quot;</div><div class="line"> OFS=&quot;, &quot;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line"> print $1, $2, $3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>awk 还有一个特殊变量 ORS，全称是“输出记录分隔符”。通过设置缺省为换行 (“/n”) 的 OFS，我们可以控制在 print 语句结尾自动打印的字符。缺省 ORS 值会使 awk 在新行中输出每个新的 print 语句。如果想使输出的间隔翻倍，可以将 ORS 设置成 “/n/n”。或者，如果想要用单个空格分隔记录（而不换行），将 ORS 设置成 “”。</p>
<p>将多行转换成用 tab 分隔的格式</p>
<p>假设我们编写了一个脚本，它将地址列表转换成每个记录一行，且用 tab 定界的格式，以便导入电子表格。使用稍加修改的 address.awk 之后，就可以清楚地看到这个程序只适合于三行的地址。如果 awk 遇到以下地址，将丢掉第四行，并且不打印该行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cousin Vinnie</div><div class="line">Vinnie&apos;s Auto Shop</div><div class="line">300 City Alley</div><div class="line">Sosueme, OR 76543</div></pre></td></tr></table></figure>
<p>要处理这种情况，代码最好考虑每个字段的记录数量，并依次打印每个记录。现在，代码只打印地址的前三个字段。以下就是我们想要的一些代码：</p>
<p>适合具有任意多字段的地址的 address.awk 版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">  FS=&quot;/n&quot;</div><div class="line">  RS=&quot;&quot;</div><div class="line">  ORS=&quot;&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">  x=1</div><div class="line">  while ( x&lt;NF ) &#123;</div><div class="line">   print $x &quot;/t&quot;</div><div class="line">   x++</div><div class="line">  &#125;</div><div class="line">  print $NF &quot;/n&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先，将字段分隔符 FS 设置成 “/n”，将记录分隔符 RS 设置成 “”，这样 awk 可以象以前一样正确分析多行地址。然后，将输出记录分隔符 ORS 设置成 “”，它将使 print 语句在每个调用结尾 不 输出新行。这意味着如果希望任何文本从新的一行开始，那么需要明确写入 print “/n” 。</p>
<p>在主代码块中，创建了一个变量 x 来存储正在处理的当前字段的编号。起初，它被设置成 1。然后，我们使用 while 循环（一种 awk 循环结构，等同于 C 语言中的 while 循环），对于所有记录（最后一个记录除外）重复打印记录和 tab 字符。最后，打印最后一个记录和换行；此外，由于将 ORS 设置成 “”，print 将不输出换行。程序输出如下，这正是我们所期望的：</p>
<p>我们想要的输出。不算漂亮，但用 tab 定界，以便于导入电子表格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Jimmy the Weasel 100 Pleasant Drive San Francisco, CA 12345 </div><div class="line">Big Tony 200 Incognito Ave. Suburbia, WA 67890</div><div class="line">Cousin Vinnie Vinnie Auto Shop 300 City Alley Sosueme, OR 76543</div></pre></td></tr></table></figure>
<h3 id="十六-循环结构"><a href="#十六-循环结构" class="headerlink" title="十六. 循环结构"></a>十六. 循环结构</h3><p>我们已经看到了 awk 的 while 循环结构，它等同于相应的 C 语言 while 循环。awk 还有 “do…while” 循环，它在代码块结尾处对条件求值，而不象标准 while 循环那样在开始处求值。它类似于其它语言中的 “repeat…until” 循环。以下是一个示例：</p>
<p>do…while 示例<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  count=1</div><div class="line">  do &#123;</div><div class="line">  print &quot;I get printed at least once no matter what&quot; </div><div class="line">  &#125; while ( count != 1 )</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与一般的 while 循环不同，由于在代码块之后对条件求值，”do…while” 循环永远都至少执行一次。换句话说，当第一次遇到普通 while 循环时，如果条件为假，将永远不执行该循环。</p>
<p>for 循环</p>
<p>awk 允许创建 for 循环，它就象 while 循环，也等同于 C 语言的 for 循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for ( initial assignment; comparison; increment ) &#123;</div><div class="line">code block</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是一个简短示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for ( x = 1; x &lt;= 4; x++ ) &#123;</div><div class="line">  print &quot;iteration&quot;,x</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此段代码将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iteration 1</div><div class="line">iteration 2</div><div class="line">iteration 3</div><div class="line">iteration 4</div></pre></td></tr></table></figure>
<p>十七. break 和 continue<br>此外，如同 C 语言一样，awk 提供了 break 和 continue 语句。使用这些语句可以更好地控制 awk 的循环结构。以下是迫切需要 break 语句的代码片断：</p>
<p>while 死循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (1) &#123;</div><div class="line">print &quot;forever and ever...&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>while 死循环 1 永远代表是真，这个 while 循环将永远运行下去。以下是一个只执行十次的循环：</p>
<p>break 语句示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x=1</div><div class="line">while(1) &#123;</div><div class="line">  print &quot;iteration&quot;,x</div><div class="line">  if ( x == 10 ) &#123;</div><div class="line">  break</div><div class="line">  &#125;</div><div class="line">  x++</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里，break 语句用于“逃出”最深层的循环。”break” 使循环立即终止，并继续执行循环代码块后面的语句。<br>continue 语句补充了 break，其作用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">x=1</div><div class="line">while (1) &#123;</div><div class="line">   if ( x == 4 ) &#123;</div><div class="line">   x++</div><div class="line">   continue</div><div class="line">   &#125;</div><div class="line">   print &quot;iteration&quot;,x</div><div class="line">   if ( x &gt; 20 ) &#123;</div><div class="line">   break</div><div class="line">   &#125;</div><div class="line">   x++</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码打印 “iteration 1” 到 “iteration 21”，”iteration 4” 除外。如果迭代等于 4，则增加 x 并调用 continue 语句，该语句立即使 awk 开始执行下一个循环迭代，而不执行代码块的其余部分。如同 break 一样，continue 语句适合各种 awk 迭代循环。在 for 循环主体中使用时，continue 将使循环控制变量自动增加。以下是一个等价循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for ( x=1; x&lt;=21; x++ ) &#123;</div><div class="line">  if ( x == 4 ) &#123;</div><div class="line">  continue</div><div class="line">  &#125;</div><div class="line">  print &quot;iteration&quot;,x&#125;</div></pre></td></tr></table></figure>
<p>在 while 循环中时，在调用 continue 之前没有必要增加 x ，因为 for 循环会自动增加 x 。</p>
<h3 id="十八-数组"><a href="#十八-数组" class="headerlink" title="十八. 数组"></a>十八. 数组</h3><p>如果您知道 awk 可以使用数组，您一定会感到高兴。然而，在 awk 中，数组下标通常从 1 开始，而不是 0：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myarray[1]=&quot;jim&quot;</div><div class="line">myarray[2]=456</div></pre></td></tr></table></figure>
<p>awk 遇到第一个赋值语句时，它将创建 myarray ，并将元素 myarray[1] 设置成 “jim”。执行了第二个赋值语句后，数组就有两个元素了。</p>
<ol>
<li>数组迭代</li>
</ol>
<p>定义之后，awk 有一个便利的机制来迭代数组元素，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">for ( x in myarray ) &#123;</div><div class="line">print myarray[x]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码将打印数组 myarray 中的每一个元素。当对于 for 使用这种特殊的 “in” 形式时，awk 将 myarray 的每个现有下标依次赋值给 x （循环控制变量），每次赋值以后都循环一次循环代码。虽然这是一个非常方便的 awk 功能，但它有一个缺点 – 当 awk 在数组下标之间轮转时，它不会依照任何特定的顺序。那就意味着我们不能知道以上代码的输出是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jim</div><div class="line">456</div></pre></td></tr></table></figure>
<p>还是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">456</div><div class="line">jim</div></pre></td></tr></table></figure>
<p>套用 Forrest Gump 的话来说，迭代数组内容就像一盒巧克力 – 您永远不知道将会得到什么。因此有必要使 awk 数组“字符串化”，我们现在就来研究这个问题。</p>
<ol>
<li>数组下标字符串化</li>
</ol>
<p>在我的前一篇文章 中，我演示了 awk 实际上以字符串格式来存储数字值。虽然 awk 要执行必要的转换来完成这项工作，但它却可以使用某些看起来很奇怪的代码：<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a=&quot;1&quot;</div><div class="line">b=&quot;2&quot;</div><div class="line">c=a+b+3</div></pre></td></tr></table></figure></p>
<p>执行了这段代码后， c 等于 6 。由于 awk 是“字符串化”的，添加字符串 “1” 和 “2” 在功能上并不比添加数字 1 和 2 难。这两种情况下，awk 都可以成功执行运算。awk 的“字符串化”性质非常可爱 – 您可能想要知道如果使用数组的字符串下标会发生什么情况。例如，使用以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">myarr[&quot;1&quot;]=&quot;Mr. Whipple&quot;</div><div class="line">print myarr[&quot;1&quot;]</div></pre></td></tr></table></figure></p>
<p>可以预料，这段代码将打印 “Mr. Whipple”。但如果去掉第二个 “1” 下标中的引号，情况又会怎样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myarr[&quot;1&quot;]=&quot;Mr. Whipple&quot;</div><div class="line">print myarr[1]</div></pre></td></tr></table></figure>
<p>猜想这个代码片断的结果比较难。awk 将 myarr[“1”] 和 myarr[1] 看作数组的两个独立元素，还是它们是指同一个元素？答案是它们指的是同一个元素，awk 将打印 “Mr. Whipple”，如同第一个代码片断一样。虽然看上去可能有点怪，但 awk 在幕后却一直使用数组的字符串下标！</p>
<p>了解了这个奇怪的真相之后，我们中的一些人可能想要执行类似于以下的古怪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myarr[&quot;name&quot;]=&quot;Mr. Whipple&quot;</div><div class="line">print myarr[&quot;name&quot;]</div></pre></td></tr></table></figure>
<p>这段代码不仅不会产生错误，而且它的功能与前面的示例完全相同，也将打印 “Mr. Whipple”！可以看到，awk 并没有限制我们使用纯整数下标；如果我们愿意，可以使用字符串下标，而且不会产生任何问题。只要我们使用非整数数组下标，如 myarr[“name”] ，那么我们就在使用 关联数组 。从技术上讲，如果我们使用字符串下标，awk 的后台操作并没有什么不同（因为即便使用“整数”下标，awk 还是会将它看作是字符串）。但是，应该将它们称作 关联数组 – 它听起来很酷，而且会给您的上司留下印象。字符串化下标是我们的小秘密。;)</p>
<ol>
<li>数组工具</li>
</ol>
<p>谈到数组时，awk 给予我们许多灵活性。可以使用字符串下标，而且不需要连续的数字序列下标（例如，可以定义 myarr[1] 和 myarr[1000] ，但不定义其它所有元素）。虽然这些都很有用，但在某些情况下，会产生混淆。幸好，awk 提供了一些实用功能有助于使数组变得更易于管理。</p>
<p>首先，可以删除数组元素。如果想要删除数组 fooarray 的元素 1 ，输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete fooarray[1]</div></pre></td></tr></table></figure>
<p>而且，如果想要查看是否存在某个特定数组元素，可以使用特殊的 “in” 布尔运算符，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ( 1 in fooarray ) &#123;</div><div class="line">print &quot;Ayep! It&apos;s there.&quot;</div><div class="line">&#125; else &#123;</div><div class="line">print &quot;Nope! Can&apos;t find it.&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="十九-格式化输出"><a href="#十九-格式化输出" class="headerlink" title="十九. 格式化输出"></a>十九. 格式化输出</h3><p>在这篇 awk 系列的总结中，Daniel 向您介绍 awk 重要的字符串函数，以及演示了如何从头开始编写完整的支票簿结算程序。在这个过程中，您将学习如何编写自己的函数，并使用 awk 的多维数组。学完本文之后，您将掌握更多 awk 经验，可以让您创建功能更强大的脚本。</p>
<p>虽然大多数情况下 awk 的 print 语句可以完成任务，但有时我们还需要更多。在那些情况下，awk 提供了两个我们熟知的老朋友 printf() 和 sprintf()。是的，如同其它许多 awk 部件一样，这些函数等同于相应的 C 语言函数。printf() 会将格式化字符串打印到 stdout，而 sprintf() 则返回可以赋值给变量的格式化字符串。如果不熟悉 printf() 和 sprintf()，介绍 C 语言的文章可以让您迅速了解这两个基本打印函数。在 Linux 系统上，可以输入 “man 3 printf” 来查看 printf() 帮助页面。</p>
<p>以下是一些 awk sprintf() 和 printf() 的样本代码。可以看到，它们几乎与 C 语言完全相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x=1</div><div class="line">b=&quot;foo&quot;</div><div class="line">printf(&quot;%s got a %d on the last test/n&quot;,&quot;Jim&quot;,83)</div><div class="line">myout=(&quot;%s-%d&quot;,b,x)</div><div class="line">print myout</div></pre></td></tr></table></figure>
<p>此代码将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Jim got a 83 on the last test</div><div class="line">foo-1</div></pre></td></tr></table></figure>
<h3 id="二十-字符串函数"><a href="#二十-字符串函数" class="headerlink" title="二十. 字符串函数"></a>二十. 字符串函数</h3><p>awk 有许多字符串函数，这是件好事。在 awk 中，确实需要字符串函数，因为不能象在其它语言（如 C、C++ 和 Python）中那样将字符串看作是字符数组。例如，如果执行以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mystring=&quot;How are you doing today?&quot;</div><div class="line">print mystring[3]</div></pre></td></tr></table></figure>
<p>将会接收到一个错误，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk: string.gawk:59: fatal: attempt to use scalar as array</div></pre></td></tr></table></figure>
<p>噢，好吧。虽然不象 Python 的序列类型那样方便，但 awk 的字符串函数还是可以完成任务。让我们来看一下。<br>首先，有一个基本 length() 函数，它返回字符串的长度。以下是它的使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print length(mystring)</div></pre></td></tr></table></figure></p>
<p>此代码将打印值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">24</div></pre></td></tr></table></figure>
<p>好，继续。下一个字符串函数叫作 index，它将返回子字符串在另一个字符串中出现的位置，如果没有找到该字符串则返回 0。使用 mystring，可以按以下方法调用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print index(mystring,&quot;you&quot;)</div></pre></td></tr></table></figure>
<p>awk 会打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">9</div></pre></td></tr></table></figure>
<p>让我们继续讨论另外两个简单的函数，tolower() 和 toupper()。与您猜想的一样，这两个函数将返回字符串并且将所有字符分别转换成小写或大写。请注意，tolower() 和 toupper() 返回新的字符串，不会修改原来的字符串。这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print tolower(mystring)</div><div class="line">print toupper(mystring)</div><div class="line">print mystring</div></pre></td></tr></table></figure>
<p>……将产生以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">how are you doing today?</div><div class="line">HOW ARE YOU DOING TODAY?</div><div class="line">How are you doing today?</div></pre></td></tr></table></figure>
<p>到现在为止一切不错，但我们究竟如何从字符串中选择子串，甚至单个字符？那就是使用 substr() 的原因。以下是 substr() 的调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysub=substr(mystring,startpos,maxlen)</div></pre></td></tr></table></figure>
<p>mystring 应该是要从中抽取子串的字符串变量或文字字符串。startpos 应该设置成起始字符位置，maxlen 应该包含要抽取的字符串的最大长度。请注意，我说的是 最大长度 ；如果 length(mystring) 比 startpos+maxlen 短，那么得到的结果就会被截断。substr() 不会修改原始字符串，而是返回子串。以下是一个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print substr(mystring,9,3)</div></pre></td></tr></table></figure>
<p>awk 将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">you</div></pre></td></tr></table></figure>
<p>如果您通常用于编程的语言使用数组下标访问部分字符串（以及不使用这种语言的人），请记住 substr() 是 awk 代替方法。需要使用它来抽取单个字符和子串；因为 awk 是基于字符串的语言，所以会经常用到它。</p>
<p>现在，我们讨论一些更耐人寻味的函数，首先是 match()。match() 与 index() 非常相似，它与 index() 的区别在于它并不搜索子串，它搜索的是规则表达式。match() 函数将返回匹配的起始位置，如果没有找到匹配，则返回 0。此外，match() 还将设置两个变量，叫作 RSTART 和 RLENGTH。RSTART 包含返回值（第一个匹配的位置），RLENGTH 指定它占据的字符跨度（如果没有找到匹配，则返回 -1）。通过使用 RSTART、RLENGTH、substr() 和一个小循环，可以轻松地迭代字符串中的每个匹配。以下是一个 match() 调用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print match(mystring,/you/), RSTART, RLENGTH</div></pre></td></tr></table></figure>
<p>awk 将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">9 9 3</div></pre></td></tr></table></figure>
<p>字符串替换</p>
<p>现在，我们将研究两个字符串替换函数，sub() 和 gsub()。这些函数与目前已经讨论过的函数略有不同，因为它们 确实修改原始字符串 。以下是一个模板，显示了如何调用 sub()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub(regexp,replstring,mystring)</div></pre></td></tr></table></figure>
<p>调用 sub() 时，它将在 mystring 中匹配 regexp 的第一个字符序列，并且用 replstring 替换该序列。sub() 和 gsub() 用相同的自变量；唯一的区别是 sub() 将替换第一个 regexp 匹配（如果有的话），gsub() 将执行全局替换，换出字符串中的所有匹配。以下是一个 sub() 和 gsub() 调用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub(/o/,&quot;O&quot;,mystring)</div><div class="line">print mystring</div><div class="line">mystring=&quot;How are you doing today?&quot;</div><div class="line">gsub(/o/,&quot;O&quot;,mystring)</div><div class="line">print mystring</div></pre></td></tr></table></figure>
<p>必须将 mystring 复位成其初始值，因为第一个 sub() 调用直接修改了 mystring。在执行时，此代码将使 awk 输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HOw are you doing today?</div><div class="line">HOw are yOu dOing tOday?</div></pre></td></tr></table></figure>
<p>当然，也可以是更复杂的规则表达式。我把测试一些复杂规则表达式的任务留给您来完成。</p>
<p>通过介绍函数 split()，我们来汇总一下已讨论过的函数。split() 的任务是“切开”字符串，并将各部分放到使用整数下标的数组中。以下是一个 split() 调用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numelements=split(&quot;Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec&quot;,mymonths,&quot;,&quot;)</div></pre></td></tr></table></figure>
<p>调用 split() 时，第一个自变量包含要切开文字字符串或字符串变量。在第二个自变量中，应该指定 split() 将填入片段部分的数组名称。在第三个元素中，指定用于切开字符串的分隔符。split() 返回时，它将返回分割的字符串元素的数量。split() 将每一个片段赋值给下标从 1 开始的数组，因此以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print mymonths[1],mymonths[numelements]</div></pre></td></tr></table></figure>
<p>……将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Jan Dec</div></pre></td></tr></table></figure>
<p>特殊字符串形式</p>
<p>简短注释 – 调用 length()、sub() 或 gsub() 时，可以去掉最后一个自变量，这样 awk 将对 $0（整个当前行）应用函数调用。要打印文件中每一行的长度，使用以下 awk 脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">print length()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二十一-财务上的趣事"><a href="#二十一-财务上的趣事" class="headerlink" title="二十一. 财务上的趣事"></a>二十一. 财务上的趣事</h3><p>几星期前，我决定用 awk 编写自己的支票簿结算程序。我决定使用简单的 tab 定界文本文件，以便于输入最近的存款和提款记录。其思路是将这个数据交给 awk 脚本，该脚本会自动合计所有金额，并告诉我余额。以下是我决定如何将所有交易记录到 “ASCII checkbook” 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">23 Aug 2000 food - - Y Jimmy&apos;s Buffet 30.25</div></pre></td></tr></table></figure>
<p>此文件中的每个字段都由一个或多个 tab 分隔。在日期（字段 1，$1）之后，有两个字段叫做“费用分类帐”和“收入分类帐”。以上面这行为例，输入费用时，我在费用字段中放入四个字母的别名，在收入字段中放入 “-“（空白项）。这表示这一特定项是“食品费用”。:) 以下是存款的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">23 Aug 2000 - inco - Y Boss Man 2001.00</div></pre></td></tr></table></figure>
<p>在这个实例中，我在费用分类帐中放入 “-“（空白），在收入分类帐中放入 “inco”。”inco” 是一般（薪水之类）收入的别名。使用分类帐别名让我可以按类别生成收入和费用的明细分类帐。至于记录的其余部分，其它所有字段都是不需加以说明的。“是否付清？”字段（”Y” 或 “N”）记录了交易是否已过帐到我的帐户；除此之外，还有一个交易描述，和一个正的美元金额。</p>
<p>用于计算当前余额的算法不太难。awk 只需要依次读取每一行。如果列出了费用分类帐，但没有收入分类帐（为 “-“），那么这一项就是借方。如果列出了收入分类帐，但没有费用分类帐（为 “-“），那么这一项就是贷方。而且，如果同时列出了费用和收入分类帐，那么这个金额就是“分类帐转帐”；即，从费用分类帐减去美元金额，并将此金额添加到收入分类帐。此外，所有这些分类帐都是虚拟的，但对于跟踪收入和支出以及预算却非常有用。</p>
<p>代码</p>
<p>现在该研究代码了。我们将从第一行（BEGIN 块和函数定义）开始：</p>
<p>balance，第 1 部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env awk -f</div><div class="line">BEGIN &#123; </div><div class="line">FS=&quot;/t+&quot;</div><div class="line">months=&quot;Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&quot;</div><div class="line">&#125;</div><div class="line">function monthdigit(mymonth) &#123;</div><div class="line">return (index(months,mymonth)+3)/4</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先执行 “chmod +x myscript” 命令，那么将第一行 “#!…” 添加到任何 awk 脚本将使它可以直接从 shell 中执行。其余行定义了 BEGIN 块，在 awk 开始处理支票簿文件之前将执行这个代码块。我们将 FS（字段分隔符）设置成 “/t+”，它会告诉 awk 字段由一个或多个 tab 分隔。另外，我们定义了字符串 months，下面将出现的 monthdigit() 函数将使用它。</p>
<p>最后三行显示了如何定义自己的 awk 。格式很简单 – 输入 “function”，再输入名称，然后在括号中输入由逗号分隔的参数。在此之后，”{ }” 代码块包含了您希望这个函数执行的代码。所有函数都可以访问全局变量（如 months 变量）。另外，awk 提供了 “return” 语句，它允许函数返回一个值，并执行类似于 C 和其它语言中 “return” 的操作。这个特定函数将以 3 个字母字符串格式表示的月份名称转换成等价的数值。例如，以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print monthdigit(&quot;Mar&quot;)</div></pre></td></tr></table></figure>
<p>……将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3</div></pre></td></tr></table></figure>
<p>现在，让我们讨论其它一些函数。</p>
<p>财务函数</p>
<p>以下是其它三个执行簿记的函数。我们即将见到的主代码块将调用这些函数之一，按顺序处理支票簿文件的每一行，从而将相应交易记录到 awk 数组中。有三种基本交易，贷方 (doincome)、借方 (doexpense) 和转帐 (dotransfer)。您会发现这三个函数全都接受一个自变量，叫作 mybalance。mybalance 是二维数组的一个占位符，我们将它作为自变量进行传递。目前，我们还没有处理过二维数组；但是，在下面可以看到，语法非常简单。只须用逗号分隔每一维就行了。</p>
<p>我们将按以下方式将信息记录到 “mybalance” 中。数组的第一维从 0 到 12，用于指定月份，0 代表全年。第二维是四个字母的分类帐，如 “food” 或 “inco”；这是我们处理的真实分类帐。因此，要查找全年食品分类帐的余额，应查看 mybalance[0,”food”]。要查找 6 月的收入，应查看 mybalance[6,”inco”]。</p>
<p>balance，第 2 部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function doincome(mybalance) &#123;</div><div class="line">mybalance[curmonth,$3] += amount</div><div class="line">mybalance[0,$3] += amount</div><div class="line">&#125;</div><div class="line">function doexpense(mybalance) &#123;</div><div class="line">mybalance[curmonth,$2] -= amount</div><div class="line">mybalance[0,$2] -= amount</div><div class="line">&#125;</div><div class="line">function dotransfer(mybalance) &#123;</div><div class="line">mybalance[0,$2] -= amount</div><div class="line">mybalance[curmonth,$2] -= amount</div><div class="line">mybalance[0,$3] += amount</div><div class="line">mybalance[curmonth,$3] += amount</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 doincome() 或任何其它函数时，我们将交易记录到两个位置 – mybalance[0,category] 和 mybalance[curmonth, category]，它们分别表示全年的分类帐余额和当月的分类帐余额。这让我们稍后可以轻松地生成年度或月度收入／支出明细分类帐。</p>
<p>如果研究这些函数，将发现在我的引用中传递了 mybalance 引用的数组。另外，我们还引用了几个全局变量：curmonth，它保存了当前记录所属的月份的数值，$2（费用分类帐），$3（收入分类帐）和金额（$7，美元金额）。调用 doincome() 和其它函数时，已经为要处理的当前记录（行）正确设置了所有这些变量。</p>
<p>主块</p>
<p>以下是主代码块，它包含了分析每一行输入数据的代码。请记住，由于正确设置了 FS，可以用 $ 1 引用第一个字段，用 $2 引用第二个字段，依次类推。调用 doincome() 和其它函数时，这些函数可以从函数内部访问 curmonth、$2、$3 和金额的当前值。请先研究代码，在代码之后可以见到我的说明。</p>
<p>balance，第 3 部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">curmonth=monthdigit(substr($1,4,3))</div><div class="line">amount=$7</div><div class="line"></div><div class="line">#record all the categories encountered</div><div class="line">if ( $2 != &quot;-&quot; ) globcat[$2]=&quot;yes&quot;</div><div class="line">if ( $3 != &quot;-&quot; ) globcat[$3]=&quot;yes&quot;</div><div class="line">#tally up the transaction properly</div><div class="line">if ( $2 == &quot;-&quot; ) &#123;</div><div class="line">  if ( $3 == &quot;-&quot; ) &#123;</div><div class="line">  print &quot;Error: inc and exp fields are both blank!&quot;</div><div class="line">  exit 1</div><div class="line">  &#125; else &#123;</div><div class="line">  #this is income</div><div class="line">  doincome(balance)</div><div class="line">  if ( $5 == &quot;Y&quot; )   doincome(balance2)</div><div class="line">  &#125;</div><div class="line">&#125; </div><div class="line">else if ( $3 == &quot;-&quot; ) &#123;</div><div class="line">  #this is an expense </div><div class="line">  doexpense(balance)</div><div class="line">  if ( $5 == &quot;Y&quot; )   doexpense(balance2)</div><div class="line">  &#125; else &#123;</div><div class="line">  #this is a transfer</div><div class="line">  dotransfer(balance)</div><div class="line">  if ( $5 == &quot;Y&quot; )   dotransfer(balance2)</div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在主块中，前两行将 curmonth 设置成 1 到 12 之间的整数，并将金额设置成字段 7（使代码易于理解）。然后，是四行有趣的代码，它们将值写到数组 globcat 中。globcat，或称作全局分类帐数组，用于记录在文件中遇到的所有分类帐 – “inco”、”misc”、”food”、”util” 等。例如，如果 $2 == “inco”，则将 globcat[“inco”] 设置成 “yes”。稍后，我们可以使用简单的 “for (x in globcat)” 循环来迭代分类帐列表。</p>
<p>在接着的大约二十行中，我们分析字段 $2 和 $3，并适当记录交易。如果 $2==”-“ 且 $3!=”-“，表示我们有收入，因此调用 doincome()。如果是相反的情况，则调用 doexpense()；如果 $2 和 $3 都包含分类帐，则调用 dotransfer()。每次我们都将 “balance” 数组传递给这些函数，从而在这些函数中记录适当的数据。</p>
<p>您还会发现几行代码说“if ( $5 == “Y” )，那么将同一个交易记录到 balance2 中”。我们在这里究竟做了些什么？您将回忆起 $5 包含 “Y” 或 “N”，并记录交易是否已经过帐到帐户。由于仅当过帐了交易时我们才将交易记录到 balance2，因此 balance2 包含了真实的帐户余额，而 “balance” 包含了所有交易，不管是否已经过帐。可以使用 balance2 来验证数据项（因为它应该与当前银行帐户余额匹配），可以使用 “balance” 来确保没有透支帐户（因为它会考虑您开出的尚未兑现的所有支票）。</p>
<p>生成报表</p>
<p>主块重复处理了每一行记录之后，现在我们有了关于比较全面的、按分类帐和按月份划分的借方和贷方记录。现在，在这种情况下最合适的做法是只须定义生成报表的 END 块：</p>
<p>balance，第 4 部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">END &#123;</div><div class="line">bal=0</div><div class="line">bal2=0</div><div class="line">for (x in globcat) &#123;</div><div class="line">bal=bal+balance[0,x]</div><div class="line">bal2=bal2+balance2[0,x]</div><div class="line">&#125;</div><div class="line">printf(&quot;Your available funds: %10.2f/n&quot;, bal)</div><div class="line">printf(&quot;Your account balance: %10.2f/n&quot;, bal2)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个报表将打印出汇总，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Your available funds:1174.22</div><div class="line">Your account balance:2399.33</div></pre></td></tr></table></figure>
<p>在 END 块中，我们使用 “for (x in globcat)” 结构来迭代每一个分类帐，根据记录在案的交易结算主要余额。实际上，我们结算两个余额，一个是可用资金，另一个是帐户余额。要执行程序并处理您在文件 “mycheckbook.txt” 中输入的财务数据，将以上所有代码放入文本文件 “balance”，执行 “chmod +x balance”，然后输入 “./balance mycheckbook.txt”。然后 balance 脚本将合计所有交易，打印出两行余额汇总。</p>
<p>升级</p>
<p>我使用这个程序的更高级版本来管理我的个人和企业财务。我的版本（由于篇幅限制不能在此涵盖）会打印出收入和费用的月度明细分类帐，包括年度总合、净收入和其它许多内容。它甚至以 HTML 格式输出数据，因此我可以在 Web 浏览器中查看它。:) 如果您认为这个程序有用，我建议您将这些特性添加到这个脚本中。不必将它配置成要 记录 任何附加信息；所需的全部信息已经在 balance 和 balance2 里面了。只要升级 END 块就万事具备了！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring源码：核心容器]]></title>
      <url>https://fudawei.github.io/2016/12/29/Spring%E6%BA%90%E7%A0%81%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h3><pre><code>IoC也被称作依赖注入(DI)。它是一个处理对象依赖项的过程，也就是将他们一起工作的其他的对象，只有通过构造参数、工厂方法参数或者（属性注入）通过构造参数实例化或通过工厂方法返回对象后再设置属性。当创建bean后，IoC容器再将这些依赖项注入进去。这个过程基本上是反转的，因此得名控制反转（IoC）。
</code></pre><p>下图是 IoC 的高级别视图<br><img src="/img/spring/container_1.png" alt=""></p>
<p>IoC容器利用Java的POJO类和配置元数据来生成 完全配置和可执行 的系统或应用程序。而Bean在Spring中就是POJO，也可以认为Bean就是对象</p>
<p>设计实现</p>
<p>   接口设计</p>
<p>   Spring作为面向对象编程的集大成之作，我们直接从接口入手可以帮助我们更直观的了解Ioc容器的设计原理。</p>
<pre><code>注1：笔者未能找到最新的Spring 4.0 接口体系图片，所以接口体系用都是Spring-3.1 接口体系，而分析的Sping 源码版本为：Spring-4.3。其实本来打算重新绘制新的接口体系，但分析过程中也发现两者鲜有差异，所以为了节省时间，固延用了老的版本。

注2：主要参考了《Spring技术内幕》第二版，但他的思维太过跳跃，所以我重新做了编排，还有就是很多细节部分参考了《Spring源码深度解析》，当然因为源码版本的不同，也会有些许差异。
</code></pre><p>下图描述了Ioc容器中的主要接口设计</p>
<p><img src="/img/spring/container_2.png" alt=""></p>
<p>这里主要是接口体系，而具体实现体系，比如DefaultListableBeanFactory就是为了实现ConfigurableBeanFactory，从而成为一个简单Ioc容器实现。与其他Ioc容器类似，XmlBeanFactory就是为了实现BeanFactory，但都是基于DefaultListableBeanFactory的基础做了扩展。同样的，ApplicationContext也一样。        </p>
<p>  从图中我们可以简要的做出以下分析：</p>
<ul>
<li><p>从接口BeanFactory到HierarchicalBeanFactory，再到ConfigurableBeanFactory,这是一条主要的BeanFactory设计路径。在这条接口设计路径中，BeanFactory，是一条主要的BeanFactory设计路径。在这条接口设计路径中，BeanFactory接口定义了基本的Ioc容器的规范。在这个接口定义中，包括了getBean()这样的Ioc容器的基本方法（通过这个方法可以从容器中取得Bean）。而HierarchicalBeanFactory接口在继承了BeanFactory的基本接口后，增加了getParentBeanFactory()的接口功能，使BeanFactory具备了双亲Ioc容器的管理功能。在接下来的ConfigurableBeanFactory接口中，主要定义了一些对BeanFactory的配置功能，比如通过setParentBeanFactory()设置双亲Ioc容器，通过addBeanPostProcessor()配置Bean后置处理器，等等。通过这些接口设计的叠加，定义了BeanFactory就是最简单的Ioc容器的基本功能。</p>
</li>
<li><p>第二条接口设计主线是，以ApplicationContext作为核心的接口设计，这里涉及的主要接口设计有，从BeanFactory到ListableBeanFactory，再到ApplicationContext，再到我们常用的WebApplicationContext或者ConfigurableApplicationContext接口。我们常用的应用基本都是org.framework.context 包里的WebApplicationContext或者ConfigurableApplicationContext实现。在这个接口体现中，ListableBeanFactory和HierarchicalBeanFactory两个接口，连接BeanFactory接口定义和ApplicationContext应用的接口定义。在ListableBeanFactory接口中，细化了许多BeanFactory的接口功能，比如定义了getBeanDefinitionNames()接口方法；对于ApplicationContext接口，它通过继承MessageSource、ResourceLoader、ApplicationEventPublisher接口，在BeanFactory简单Ioc容器的基础上添加了许多对高级容器的特性支持。</p>
</li>
<li><p>这个接口系统是以BeanFactory和ApplicationContext为核心设计的，而BeanFactory是Ioc容器中最基本的接口，在ApplicationContext的设计中，一方面，可以看到它继承了BeanFactory接口体系中的ListableBeanFactory、AutowireCapableBeanFactory、HierarchicalBeanFactory等BeanFactory的接口，具备了BeanFactory Ioc容器的基本功能；另一方面，通过继承MessageSource、ResourceLoadr、ApplicationEventPublisher这些接口，BeanFactory为ApplicationContext赋予了更高级的Ioc容器特性。对于ApplicationContext而言，为了在Web环境中使用它，还设计了WebApplicationContext接口，而这个接口通过继承ThemeSource接口来扩充功能。</p>
</li>
</ul>
<h3 id="BeanFactory容器的设计"><a href="#BeanFactory容器的设计" class="headerlink" title="BeanFactory容器的设计"></a>BeanFactory容器的设计</h3><pre><code>恩，我们与其写繁琐的文字，不如直接阅读代码来的直接的多。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">package org.springframework.beans.factory;</div><div class="line"></div><div class="line">import org.springframework.beans.BeansException;</div><div class="line">import org.springframework.core.ResolvableType;</div><div class="line"></div><div class="line">/**</div><div class="line"> * BeanFactory作为最原始同时也最重要的Ioc容器,它主要的功能是为依赖注入 （DI） 提供支持， BeanFactory 和相关的接口，比如，BeanFactoryAware、 </div><div class="line"> * DisposableBean、InitializingBean，仍旧保留在 Spring 中，主要目的是向后兼容已经存在的和那些 Spring 整合在一起的第三方框架。在 Spring 中</div><div class="line"> * ，有大量对 BeanFactory 接口的实现。其中，最常被使用的是 XmlBeanFactory 类。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一</div><div class="line"> * 个被配置化的系统或者应用。在资源宝贵的移动设备或者基于applet的应用当中， BeanFactory 会被优先选择。否则，一般使用的是 ApplicationContext</div><div class="line"> * </div><div class="line"> * 这里定义的只是一系列的接口方法，通过这一系列的BeanFactory接口，可以使用不同的Bean的检索方法很方便地从Ioc容器中得到需要的Bean，从而忽略具体</div><div class="line"> * 的Ioc容器的实现，从这个角度上看，这些检索方法代表的是最为基本的容器入口。</div><div class="line"> *</div><div class="line"> * @author Rod Johnson</div><div class="line"> * @author Juergen Hoeller</div><div class="line"> * @author Chris Beams</div><div class="line"> * @since 13 April 2001</div><div class="line"> */</div><div class="line">public interface BeanFactory &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 转定义符&quot;&amp;&quot; 用来引用实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;a会得到那个Factory</div><div class="line">	 *</div><div class="line">	 * FactoryBean和BeanFactory 是在Spring中使用最为频繁的类，它们在拼写上很相似。一个是Factory，也就是Ioc容器或对象工厂；一个</div><div class="line">	 * 是Bean。在Spring中，所有的Bean都是由BeanFactory（也就是Ioc容器）来进行管理的。但对FactoryBean而言，这个Bean不是简单的Be</div><div class="line">	 * an，而是一个能产生或者修饰对象生成的工厂Bean，它的实现与设计模式中的工厂模式和修饰器模式类似。</div><div class="line">	 */</div><div class="line">	String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 五个不同形式的getBean方法，获取实例</div><div class="line">	 * @param name 检索所用的Bean名</div><div class="line">	 * @return Object（&lt;T&gt; T） 实例对象</div><div class="line">	 * @throws BeansException 如果Bean不能取得</div><div class="line">	 */</div><div class="line">	Object getBean(String name) throws BeansException;</div><div class="line">	&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;</div><div class="line">	&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;</div><div class="line">	Object getBean(String name, Object... args) throws BeansException;</div><div class="line">	&lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 让用户判断容器是否含有指定名字的Bean.</div><div class="line">	 * @param name 搜索所用的Bean名</div><div class="line">	 * @return boolean 是否包含其中</div><div class="line">	 */</div><div class="line">	boolean containsBean(String name);</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 查询指定名字的Bean是否是Singleton类型的Bean.</div><div class="line">	 * 对于Singleton属性，可以在BeanDefinition指定.</div><div class="line">	 * @param name 搜索所用的Bean名</div><div class="line">	 * @return boolean 是否包是Singleton</div><div class="line">	 * @throws NoSuchBeanDefinitionException 没有找到Bean</div><div class="line">	 */</div><div class="line">	boolean isSingleton(String name) throws NoSuchBeanDefinitionException;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 查询指定名字的Bean是否是Prototype类型的。</div><div class="line">	 * 与Singleton属性一样，可以在BeanDefinition指定.</div><div class="line">	 * @param name 搜索所用的Bean名</div><div class="line">	 * @return boolean 是否包是Prototype</div><div class="line">	 * @throws NoSuchBeanDefinitionException 没有找到Bean</div><div class="line">	 */</div><div class="line">	boolean isPrototype(String name) throws NoSuchBeanDefinitionException;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 查询指定了名字的Bean的Class类型是否是特定的Class类型.</div><div class="line">	 * @param name 搜索所用的Bean名</div><div class="line">	 * @param typeToMatch 匹配类型</div><div class="line">	 * @return boolean 是否是特定类型</div><div class="line">	 * @throws NoSuchBeanDefinitionException 没有找到Bean</div><div class="line">	 */</div><div class="line">	boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;</div><div class="line">	boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 查询指定名字的Bean的Class类型.</div><div class="line">	 * @param name 搜索所用的Bean名</div><div class="line">	 * @return 指定的Bean或者null(没有找到合适的Bean)</div><div class="line">	 * @throws NoSuchBeanDefinitionException 没有找到Bean</div><div class="line">	 */</div><div class="line">	Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 查询指定了名字的Bean的所有别名，这些都是在BeanDefinition中定义的</div><div class="line">	 * @param name 搜索所用的Bean名</div><div class="line">	 * @return 指定名字的Bean的所有别名 或者一个空的数组</div><div class="line">	 */</div><div class="line">	String[] getAliases(String name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>容器的基础：XmlBeanFactory</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">package org.springframework.beans.factory.xml;</div><div class="line"></div><div class="line">import org.springframework.beans.BeansException;</div><div class="line">import org.springframework.beans.factory.BeanFactory;</div><div class="line">import org.springframework.beans.factory.support.DefaultListableBeanFactory;</div><div class="line">import org.springframework.core.io.Resource;</div><div class="line"></div><div class="line">/**</div><div class="line"> * XmlBeanFactory是BeanFactory的最简单实现类</div><div class="line"> * </div><div class="line"> * XmlBeanFactory的功能是建立在DefaultListableBeanFactory这个基本容器的基础上的，并在这个基本容器的基础上实行了其他诸如</div><div class="line"> * XML读取的附加功能。XmlBeanFactory使用了DefaultListableBeanFactory作为基础类，DefaultListableBeanFactory是一个很重</div><div class="line"> * 要的Ioc实现，会在下一章进行重点论述。</div><div class="line"> *</div><div class="line"> * @author Rod Johnson</div><div class="line"> * @author Juergen Hoeller</div><div class="line"> * @author Chris Beams</div><div class="line"> * @since 15 April 2001</div><div class="line"> */</div><div class="line">public class XmlBeanFactory extends DefaultListableBeanFactory &#123;</div><div class="line"></div><div class="line">	private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 根据给定来源，创建一个XmlBeanFactory</div><div class="line">	 * @param resource  Spring中对与外部资源的抽象，最常见的是对文件的抽象，特别是XML文件。而且Resource里面通常</div><div class="line">	 * 是保存了Spring使用者的Bean定义，比如applicationContext.xml在被加载时，就会被抽象为Resource来处理。</div><div class="line">	 * @throws BeansException 载入或者解析中发生错误</div><div class="line">	 */</div><div class="line">	public XmlBeanFactory(Resource resource) throws BeansException &#123;</div><div class="line">		this(resource, null);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 根据给定来源和BeanFactory，创建一个XmlBeanFactory</div><div class="line">	 * @param resource  Spring中对与外部资源的抽象，最常见的是对文件的抽象，特别是XML文件。而且Resource里面通常</div><div class="line">	 * 是保存了Spring使用者的Bean定义，比如applicationContext.xml在被加载时，就会被抽象为Resource来处理。</div><div class="line">	 * @param parentBeanFactory 父类的BeanFactory</div><div class="line">	 * @throws BeansException 载入或者解析中发生错误</div><div class="line">	 */</div><div class="line">	public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException &#123;</div><div class="line">		super(parentBeanFactory);</div><div class="line">		this.reader.loadBeanDefinitions(resource);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最原始Ioc容器的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import org.springframework.beans.factory.BeanFactory;</div><div class="line">import org.springframework.beans.factory.xml.XmlBeanFactory;</div><div class="line">import org.springframework.core.io.ClassPathResource;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 最原始的Ioc容器使用，当然这也是Spring容器中效率最高的用法，比起繁琐的文字，阅读源码来得直观得多。</div><div class="line"> * 只需要写两行代码就行了，当然前提是要准备好Spring的配置文件</div><div class="line"> *</div><div class="line"> * @author  kay</div><div class="line"> * @since   1.0</div><div class="line"> */</div><div class="line">@SuppressWarnings(&quot;deprecation&quot;)</div><div class="line">public class SimpleBeanFactory &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ClassPathResource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);</div><div class="line">		BeanFactory beanFactory = new XmlBeanFactory(resource);		</div><div class="line">		Message message = beanFactory.getBean(&quot;message&quot;, Message.class);    //Message是自己写的测试类</div><div class="line">		message.printMessage();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是XmlBeanFactory在使用过程中涉及到的类的关系图</p>
<p><img src="/img/spring/container_1.png" alt=""></p>
<p>图中空心三角加实线代表继承、空心三角加虚线代表实现、实线箭头加虚线代表依赖、实心菱形加实线代表组合。这里用下划线代表接口，没有下划线的代表类。</p>
<p>看着非常复杂是吧，不要紧，我们以代码来做简要说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import org.springframework.beans.factory.support.DefaultListableBeanFactory;</div><div class="line">import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;</div><div class="line">import org.springframework.core.io.ClassPathResource;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 这是与SimpleBeanFactory等效的编程式使用Ioc容器</div><div class="line"> * </div><div class="line"> * 从中我也可以看到一些Ioc的基本原理，同时也揭示了Ioc实现中的一些关键类：如Resource、DefaultListableBeanFactory</div><div class="line"> * 以及BeanDefinitionReader等等</div><div class="line"> *</div><div class="line"> * @author  kay</div><div class="line"> * @since   1.0</div><div class="line"> */</div><div class="line">public class ProgramBeanFactory&#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ClassPathResource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);</div><div class="line">		DefaultListableBeanFactory factory = new DefaultListableBeanFactory();</div><div class="line">		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);</div><div class="line">		reader.loadBeanDefinitions(resource);</div><div class="line">		Message message = factory.getBean(&quot;message&quot;, Message.class);	//Message是自己写的测试类</div><div class="line">		message.printMessage();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上，可以简单说明我们在使用Ioc容器时，需要如下几个步骤：</p>
<pre><code>    1，创建Ioc配置文件的抽象资源，这个抽象资源包含了BeanDefinition的定义信息。

    2，创建一个BeanFactory，这里使用了DefaultListableBeanFactory。

    3，创建一个载入BeanDefinition的读取器，这里使用XmlBeanDefinitionReader来载入XML文件形式的BeanDefinition，通过一个回调配置给BeanFactory。

    4，从定义好的资源位置读入配置信息，具体的解析过程由XmlBeanDefinitionReader来完成。完成整个载入和注册Bean定义之后，需要的Ioc容器就建立起来了。这个时候我们就可以直接使用Ioc容器了。

恩，以下是Bean在使用过程中的解析、注册时效图，我们来一步一步分析，它是怎么在源码中实现的。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一致性HASH]]></title>
      <url>https://fudawei.github.io/2016/12/27/%E4%B8%80%E8%87%B4%E6%80%A7Hash/</url>
      <content type="html"><![CDATA[<p>   一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。</p>
<p> <strong>   一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：</strong></p>
<ol>
<li>平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li>
<li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 </li>
<li>分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 </li>
<li>负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li>
</ol>
<p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。接下来主要讲解一下一致性哈希算法是如何设计的：</p>
<h4 id="环形Hash空间"><a href="#环形Hash空间" class="headerlink" title="环形Hash空间"></a>环形Hash空间</h4><p>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图<br><img src="/img/hash/hash_1.png" alt=""></p>
<p>把数据通过一定的hash算法处理后映射到环上<br>现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图：<br>    Hash(object1) = key1；<br>    Hash(object2) = key2；<br>    Hash(object3) = key3；</p>
<p><img src="/img/hash/hash_2.png" alt=""></p>
<p>将机器通过hash算法映射到环上<br>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。<br>假设现在有NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：<br>Hash(NODE1) = KEY1;<br>Hash(NODE2) = KEY2;<br>Hash(NODE3) = KEY3;</p>
<p><img src="/img/hash/hash_3.png" alt=""></p>
<p>通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动object1存储到了NODE1中，object3存储到了NODE2中，object2、object4存储到了NODE3中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。</p>
<h4 id="机器的删除与添加"><a href="#机器的删除与添加" class="headerlink" title="机器的删除与添加"></a>机器的删除与添加</h4><p>普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。</p>
<ol>
<li>节点（机器）的删除<br> 以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图：</li>
</ol>
<p><img src="/img/hash/hash_4.png" alt=""></p>
<ol>
<li>节点（机器）的添加<br> 如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图：</li>
</ol>
<p><img src="/img/hash/hash_5.png" alt=""></p>
<p>通过按顺时针迁移的规则，那么object2被迁移到了NODE4中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p>
<h4 id="平衡性"><a href="#平衡性" class="headerlink" title="平衡性"></a>平衡性</h4><p>根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。hash算法是不保证平衡的，如上面只部署了NODE1和NODE3的情况（NODE2被删除的图），object1存储到了NODE1中，而object2、object3、object4都存储到了NODE3中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。<br>    ——“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。<br>以上面只部署了NODE1和NODE3的情况（NODE2被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：</p>
<p><img src="/img/hash/hash_6.png" alt=""></p>
<p>根据上图可知对象的映射关系：object1-&gt;NODE1-1，object2-&gt;NODE1-2，object3-&gt;NODE3-2，object4-&gt;NODE3-1。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，正真的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：</p>
<p><img src="/img/hash/hash_7.png" alt=""></p>
<p>虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设NODE1的IP地址为192.168.1.100。引入“虚拟节点”前，计算 cache A 的 hash 值：<br>Hash(“192.168.1.100”);<br>引入“虚拟节点”后，计算“虚拟节”点NODE1-1和NODE1-2的hash值：<br>Hash(“192.168.1.100#1”); // NODE1-1<br>Hash(“192.168.1.100#2”); // NODE1-2</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何减少接口响应时间]]></title>
      <url>https://fudawei.github.io/2016/12/16/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/</url>
      <content type="html"><![CDATA[<p>Premature optimization is the root of all evil.</p>
<p>　 — Donald Knuth</p>
<p>对于程序优化，我一直采取保守的态度，除非万不得已。但是随着业务的不断发展，程序越来越复杂，代码越写越多，优化似乎是终有一天会到来的事情。</p>
<p>那么对于一个典型的后台服务接口，我们可以从那些方面入手进行优化呢？</p>
<h2 id="接口拆分"><a href="#接口拆分" class="headerlink" title="接口拆分"></a>接口拆分</h2><h4 id="接口垂直拆分"><a href="#接口垂直拆分" class="headerlink" title="接口垂直拆分"></a>接口垂直拆分</h4><p>垂直拆分可以简单理解为微服务化，把一个大而复杂的服务拆分成多个相互独立，职能单一的服务，单独部署。 更细粒度拆分的好处是，能对某个具体的微服务进行特殊优化，以最大的投入产出比来解决整个服务的性能。 垂直拆分还有一个好处是，对于非必须的接口，可以很方便的进行降级处理，把坏影响隔离到核心逻辑外部。 最容易想到的优化办法是把某个对整体性能有决定性影响的微服务接口进行水平扩容。</p>
<p><strong>注意</strong>: 拆分后必定会增加外部接口调用，多少会有些额外开销，但是对于有限几个调用，拆分的还是值得的。</p>
<h4 id="接口水平拆分"><a href="#接口水平拆分" class="headerlink" title="接口水平拆分"></a>接口水平拆分</h4><p>这里说的水平拆分一定不是把一个接口部署更多份，因为这样只能解决接口的容量问题，但是不能减少接口的响应时间。 水平拆分可以简单理解成mapreduce模型，把整个计算逻辑或者数据平均分配到集群中的N个服务器去，然后由一台机器去并发调用并做结果合并。 理论上这种方式能把响应减少到1/N+合并+调用开销的时间。</p>
<p><strong>注意</strong>： 一个问题需要考虑的是，如果并发调用的接口返回的数据量比较大，可能会对合并机器的网络负载和数据序列化(CPU)有一定影响。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h4 id="接口缓存"><a href="#接口缓存" class="headerlink" title="接口缓存"></a>接口缓存</h4><p>一个有着复杂逻辑或者大量计算数据的接口，能对整个结果进行缓存再好不过了。缓存针对不同的场景会有多种策略，对于有大量并发请求的场景， 推荐一个方案：一种基于“哨兵”的分布式缓存设计，不会有损失第一个用户，也不会有定时更新缓存的额外开销</p>
<h4 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h4><p>本地缓存有两种场景，对于类似字典类型的数据，可以静态化后放入内存，定时去刷新或者采用通知机制去更新。</p>
<p>还有一种场景是用ThreadLocal缓存重复内部计算与重复的对象创建； 对于链路比较长或者循环比较深的接口，ThreadLocal减少重复计算和对象创建，从而降低RT和节约内存。</p>
<p>注意： 在有内部并发的地方使用ThreadLocal一定要注意不同线程间的数据同步。主线程的ThreadLocal数据和每个并发子线程的ThreadLocal数据要同步好<br>内部优化</p>
<h4 id="非核心流程异步化"><a href="#非核心流程异步化" class="headerlink" title="非核心流程异步化"></a>非核心流程异步化</h4><p>类似于发消息，写日志，更新缓存等不会影响接口准确性的非核心流程，可以采用异步方式进行处理，不阻塞主计算逻辑处理。</p>
<h4 id="内部并发"><a href="#内部并发" class="headerlink" title="内部并发"></a>内部并发</h4><p>如果进行水平拆分后，并发调用IO较大，可以考虑换成内部并发解决IO问题。如果内部并发涉及到每个线程更新同一个集合数据，不用忘了使用线程安全的集合。 这里有一个并发更新HashMap的case：并发环境下HashMap引起full gc排查。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优化一定不是一蹴而就的，整个优化过程是一个统计–&gt;方案–&gt;验证的闭环，需要不断试错，不断挖掘，最终达到预期。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring架构详解：Bean详解和Context组件详解]]></title>
      <url>https://fudawei.github.io/2016/12/15/Spring%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3%EF%BC%9ABean%E8%AF%A6%E8%A7%A3%E5%92%8CContext%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="Bean详解"><a href="#Bean详解" class="headerlink" title="Bean详解"></a>Bean详解</h1><p>前面已经说明了Bean组件对Spring的重要性，下面看看Bean这个组件式怎么设计的。Bean组件在Spring的org.springframework.beans包下。这个包下的所有类主要解决了三件事：Bean的定义、Bean 的创建以及对Bean的解析。对Spring的使用者来说唯一需要关心的就是Bean的创建，其他两个由Spring在内部帮你完成了，对你来说是透明的。</p>
<p>SpringBean的创建时典型的工厂模式，他的顶级接口是BeanFactory，下图是这个工厂的继承层次关系：</p>
<p><img src="/img/spring/spring_bean_factory.png" alt=""><br>BeanFactory有三个子类：ListableBeanFactory、HierarchicalBeanFactory和Autowire Capable Bean Factory。但是从上图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，他实 现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在Spring内部在操作过程中对象的传递和转化过程中，对对象的 数据访问所做的限制。例如ListableBeanFactory接口表示这些Bean是可列表的，而HierarchicalBeanFactory表示的是这些Bean是有继承关系的，也就是每个Bean有可能有父Bean。 AutowireCapableBeanFactory接口定义Bean的自动装配规则。这四个接口共同定义了Bean的集合、Bean之间的关系、以及Bean行为。</p>
<p>Bean的定义主要有BeanDefinition描述，如下图说明了这些类的层次关系：</p>
<p><img src="/img/spring/spring_BeanDefinition.png" alt=""><br>Bean的定义就是完整的描述了在Spring的配置文件中你定义的节点中所有的信息，包括各种子节点。当Spring成功解析你定义的一个节点后，在Spring的内部他就被转化 成BeanDefinition对象。以后所有的操作都是对这个对象完成的。 Bean的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过 下图中的类完成：<br><img src="/img/spring/spring_analysis.png" alt=""></p>
<h1 id="Context组件详解"><a href="#Context组件详解" class="headerlink" title="Context组件详解"></a>Context组件详解</h1><p>Context在Spring的org.springframework.context包下，前面已经讲解了Context组件在Spring中的作用，他实际上就是给Spring提供一个运行时的环境，用以保存各个对象的状态。下面看一下这个 环境是如何构建的。</p>
<p>ApplicationContext是Context的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了五个接口，这五个接口主要是扩展了Context的功能。下面是Context的类结构图：<br><img src="/img/spring/spring_context.png" alt=""></p>
<p>从上图中可以看出ApplicationContext继承了BeanFactory，这也说明了Spring容器中运行的主体对象是Bean，另外ApplicationContext继承了ResourceLoader接口，使得ApplicationContext可以访 问到任何外部资源，这将在Core中详细说明。</p>
<p>ApplicationContext的子类主要包含两个方面：</p>
<p>ConfigurableApplicationContext表示该Context是可修改的，也就是在构建Context中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的Context，即 AbstractRefreshableApplicationContext类。</p>
<p>WebApplicationContext顾名思义，就是为web准备的Context他可以直接访问到ServletContext，通常情况下，这个接口使用的少。</p>
<p>再往下分就是按照构建Context的文件类型，接着就是访问Context的方式。这样一级一级构成了完整的Context等级层次。</p>
<p>总体来说ApplicationContext必须要完成以下几件事：</p>
<p>标识一个应用环境<br>利用BeanFactory创建Bean对象<br>保存对象关系表<br>能够捕获各种事件<br>Context作为Spring的Ioc容器，基本上整合了Spring的大部分功能，或者说是大部分功能的基础。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring架构详解：spring总体架构与设计理念个内部组件的作用和关系]]></title>
      <url>https://fudawei.github.io/2016/12/15/Spring%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3%EF%BC%9ASpring%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E5%92%8C%E5%86%85%E9%83%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<p>Spring总体架构与设计理念<br>概述：</p>
<p>Spring作为现在最优秀的框架之一，已被广泛的使用。本系列文章将从以下角度对Spring的架构进行剖析：设计Spring框架总体结构的理念是什么？包含哪几个核心组件？为什么需要这些组件？它们又是如何结合在一起构成Spring的总体架构？Spring的AOP特性又是如何利用这些基础架构来工作的？</p>
<p>Spring的总体架构</p>
<p>Spring总共有十几个组件，但是真正核心的组件只有几个，下面是Spring框架的总体架构图：<br><img src="/img/spring/spring_infrastructure.png" alt=""></p>
<p>从上图中可以看出Spring框架中的核心组件只有三个：Core、Context和Beans。它们构建起了整个Spring的骨骼架构。没有它们就不可能有AOP、Web等上层的特性功能。下面也将主要从这三个组件入手分析Spring。</p>
<p>Spring的设计理念</p>
<p>前面介绍了Spring的三个核心组件，如果再在它们三个中选出核心的话，那就非Beans组件莫属了，为何这样说，其实Spring就是面向Bean的编程（BOP,Bean Oriented Programming），Bean在Spring 中才是真正的主角。</p>
<p>Bean在Spring中作用就像Object对OOP的意义一样，没有对象的概念就像没有面向对象编程，Spring中没有Bean也就没有Spring存在的意义。就像一次演出舞台都准备好了但是却没有演员一样。为什 么要Bean这种角色Bean或者为何在Spring如此重要，这由Spring框架的设计目标决定，Spring为何如此流行，我们用Spring的原因是什么，想想你会发现原来Spring解决了一个非常关键的问题他可以让 你把对象之间的依赖关系转而用配置文件来管理，也就是他的依赖注入机制。而这个注入关系在一个叫Ioc容器中管理，那Ioc容器中有又是什么就是被Bean包裹的对象。Spring正是通过把对象包装在 Bean中而达到对这些对象管理以及一些列额外操作的目的。</p>
<p>它这种设计策略完全类似于Java实现OOP的设计理念，当然了Java本身的设计要比Spring复杂太多太多，但是都是构建一个数据结构，然后根据这个数据结构设计他的生存环境，并让它在这个环境中 按照一定的规律在不停的运动，在它们的不停运动中设计一系列与环境或者与其他个体完成信息交换。这样想来回过头想想我们用到的其他框架都是大慨类似的设计理念。</p>
<p>Spring内部组件的作用和关系<br>前面说Bean是Spring中关键因素，那Context和Core又有何作用呢？前面吧Bean比作一场演出中的演员的话，那Context就是这场演出的舞台背景，而Core应该就是演出的道具了。只有他们在一起才能 具备能演出一场好戏的最基本的条件。当然有最基本的条件还不能使这场演出脱颖而出，还要他表演的节目足够的精彩，这些节目就是Spring能提供的特色功能了。</p>
<p>我们知道Bean包装的是Object，而Object必然有数据，如何给这些数据提供生存环境就是Context要解决的问题，对Context来说他就是要发现每个Bean之间的关系，为它们建立这种关系并且要维护好 这种关系。所以Context就是一个Bean关系的集合，这个关系集合又叫Ioc容器，一旦建立起这个Ioc容器后Spring就可以为你工作了。那Core组件又有什么用武之地呢？其实Core就是发现、建立和维护每 个Bean之间的关系所需要的一些列的工具，从这个角度看来，Core这个组件叫Util更能让你理解。</p>
<p>它们之间可以用下图来表示：<br><img src="/img/spring/spring_components.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java多线程编程之Promise模式]]></title>
      <url>https://fudawei.github.io/2016/11/24/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B9%8BPromise%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="Promise模式简介"><a href="#Promise模式简介" class="headerlink" title="Promise模式简介"></a>Promise模式简介</h3><p>Promise模式是一种异步编程模式 。它使得我们可以先开始一个任务的执行，并得到一个用于获取该任务执行结果的凭据对象，而不必等待该任务执行完毕就可以继续执行其他操作。等到我们需要该任务的执行结果时，再调用凭据对象的相关方法来获取。这样就避免了不必要的等待，增加了系统的并发性。这好比我们去小吃店，同时点了鸭血粉丝汤和生煎包。当我们点餐付完款后，我们拿到手的其实只是一张可借以换取相应食品的收银小票（凭据对象）而已，而不是对应的实物。由于鸭血粉丝汤可以较快制作好，故我们可以凭收银小票即刻兑换到。而生煎包的制作则比较耗时，因此我们可以先吃拿到手的鸭血粉丝汤，而不必饿着肚子等生煎包出炉再一起吃。等到我们把鸭血粉丝汤吃得差不多的时候，生煎包可能也出炉了，这时我们再凭收银小票去换取生煎包，如图所示。</p>
<p><img src="/img/concurrent-1.png" alt=""></p>
<h3 id="Promise模式的架构"><a href="#Promise模式的架构" class="headerlink" title="Promise模式的架构"></a>Promise模式的架构</h3><p>Promise模式中，客户端代码调用某个异步方法所得到的返回值仅是一个凭据对象（该对象被称为Promise，意为“承诺”）。凭借该对象，客户端代码可以获取异步方法相应的真正任务的执行结果。为了讨论方便，下文我们称异步方法对应的真正的任务为异步任务。</p>
<p>Promise模式的主要参与者有以下几种。其类图如图所示。</p>
<p><img src="/img/concurrent-2.png" alt=""></p>
<ul>
<li>Promisor：负责对外暴露可以返回Promise对象的异步方法，并启动异步任务的执行。其主要方法及职责如下。<ul>
<li>compute：启动异步任务的执行，并返回用于获取异步任务执行结果的凭据对象。</li>
</ul>
</li>
<li>Promise：包装异步任务处理结果的凭据对象。负责检测异步任务是否处理完毕、返回和存储异步任务处理结果。其主要方法及职责如下。<ul>
<li>getResult：获取与其所属Promise实例关联的异步任务的执行结果。</li>
<li>setResult：设置与其所属Promise实例关联的异步任务的执行结果。</li>
<li>isDone：检测与其所属Promise实例关联的异步任务是否执行完毕。</li>
</ul>
</li>
<li>Result：负责表示异步任务处理结果。具体类型由应用决定。</li>
<li>TaskExecutor：负责真正执行异步任务所代表的计算，并将其计算结果设置到相应的Promise实例。其主要方法及职责如下<ul>
<li>run：执行异步任务所代表的计算。<br>客户端代码获取异步任务处理结果的过程如图所示的序列图。</li>
</ul>
</li>
</ul>
<p><img src="/img/concurrent-3.png" alt=""></p>
<p>图中．获取异步任务的处理结果</p>
<p>第1步：客户端代码调用Promisor的异步方法compute。</p>
<p>第2、3步：compute方法创建Promise实例作为该方法的返回值，并返回。</p>
<p>第4步：客户端代码调用其所得到的Promise对象的getResult方法来获取异步任务处理结果。如果此时异步任务执行尚未完成，则getResult方法会阻塞（即调用方代码的运行线程暂时处于阻塞状态）。</p>
<p>异步任务的真正执行以及其处理结果的设置如图所示的序列图。</p>
<p><img src="/img/concurrent-4.png" alt=""></p>
<p>图中．设置异步任务的处理结果</p>
<p>第1步：Promisor的异步方法compute创建TaskExecutor实例。</p>
<p>第2步：TaskExecutor的run方法被执行（可以由专门的线程或者线程池 来调用run方法）。</p>
<p>第3步：run方法创建表示其执行结果的Result实例。</p>
<p>第4、5步：run方法将其处理结果设置到相应的Promise实例上。</p>
<h3 id="Promise模式实战案例解析"><a href="#Promise模式实战案例解析" class="headerlink" title="Promise模式实战案例解析"></a>Promise模式实战案例解析</h3><p>某系统的一个数据同步模块需要将一批本地文件上传到指定的目标FTP服务器上。这些文件是根据页面中的输入条件查询数据库的相应记录生成的。在将文件上传到目标服务器之前，需要对FTP客户端实例进行初始化（包括与对端服务器建立网络连接、向服务器发送登录用户和向服务器发送登录密码）。而FTP客户端实例初始化这个操作比较耗时间，我们希望它尽可能地在本地文件上传之前准备就绪。因此我们可以引入异步编程，使得FTP客户端实例初始化和本地文件上传这两个任务能够并发执行，减少不必要的等待。另一方面，我们不希望这种异步编程增加了代码编写的复杂性。这时，Promise模式就可以派上用场了：先开始FTP客户端实例的初始化，并得到一个获取FTP客户端实例的凭据对象。在不必等待FTP客户端实例初始化完毕的情况下，每生成一个本地文件，就通过凭据对象获取FTP客户端实例，再通过该FTP客户端实例将文件上传到目标服务器上。代码如清单1所示 。</p>
<p>清单1．数据同步模块的入口类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class DataSyncTask implements Runnable &#123;</div><div class="line"></div><div class="line">	private final Map&lt;String, String&gt; taskParameters;</div><div class="line">	public DataSyncTask(Map&lt;String, String&gt; taskParameters) &#123;</div><div class="line">		this.taskParameters = taskParameters;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		String ftpServer = taskParameters.get(&quot;server&quot;);</div><div class="line">		String ftpUserName = taskParameters.get(&quot;userName&quot;);</div><div class="line">		String password = taskParameters.get(&quot;password&quot;);</div><div class="line">		</div><div class="line">		//先开始初始化FTP客户端实例</div><div class="line">		Future&lt;FTPClientUtil&gt; ftpClientUtilPromise = FTPClientUtil.newInstance(</div><div class="line">		    ftpServer, ftpUserName, password);</div><div class="line">		//查询数据库生成本地文件</div><div class="line">		generateFilesFromDB();</div><div class="line">		FTPClientUtil ftpClientUtil = null;</div><div class="line">		try &#123;</div><div class="line">			// 获取初始化完毕的FTP客户端实例</div><div class="line">			ftpClientUtil = ftpClientUtilPromise.get();</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			;</div><div class="line">		&#125; catch (ExecutionException e) &#123;</div><div class="line">			throw new RuntimeException(e);</div><div class="line">		&#125;</div><div class="line">		// 上传文件</div><div class="line">		uploadFiles(ftpClientUtil);</div><div class="line">		//省略其他代码</div><div class="line">	&#125;</div><div class="line">	private void generateFilesFromDB() &#123;</div><div class="line">		// 省略其他代码</div><div class="line">	&#125;</div><div class="line">	private void uploadFiles(FTPClientUtil ftpClientUtil) &#123;</div><div class="line">		Set&lt;File&gt; files = retrieveGeneratedFiles();</div><div class="line">		for (File file : files) &#123;</div><div class="line">			try &#123;</div><div class="line">				ftpClientUtil.upload(file);</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private Set&lt;File&gt; retrieveGeneratedFiles() &#123;</div><div class="line">		Set&lt;File&gt; files = new HashSet&lt;File&gt;();</div><div class="line">		// 省略其他代码</div><div class="line">		return files;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从清单1的代码中可以看出，DataSyncTask类的run方法先开始FTP客户端实例的初始化，并得到获取相应FTP客户端实例的凭据对象ftpClientUtilPromise。接着，它直接开始查询数据库并生成本地文件。而此时，FTP客户端实例的初始化可能尚未完成。在本地文件生成之后，run方法通过调用ftpClientUtilPromise的get方法来获取相应的FTP客户端实例。此时，如果相应的FTP客户端实例的初始化仍未完成，则该调用会阻塞，直到相应的FTP客户端实例的初始化完成或者失败。run方法获取到FTP客户端实例后，调用其upload方法将文件上传到指定的FTP服务器。</p>
<p>清单1代码所引用的FTP客户端工具类FTPClientUtil的代码如清单6-2所示。</p>
<p>清单2．FTP客户端工具类源码</p>
<p>//模式角色：Promise.Promisor、Promise.Result<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">public class FTPClientUtil &#123;</div><div class="line">	private final FTPClient ftp = new FTPClient();</div><div class="line"></div><div class="line">	private final Map&lt;String, Boolean&gt; dirCreateMap = new HashMap&lt;String, Boolean&gt;();</div><div class="line"></div><div class="line">	private FTPClientUtil() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//模式角色：Promise.Promisor.compute</div><div class="line">	public static Future&lt;FTPClientUtil&gt; newInstance(final String ftpServer,</div><div class="line">	    final String userName, final String password) &#123;</div><div class="line"></div><div class="line">		Callable&lt;FTPClientUtil&gt; callable = new Callable&lt;FTPClientUtil&gt;() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public FTPClientUtil call() throws Exception &#123;</div><div class="line">				FTPClientUtil self = new FTPClientUtil();</div><div class="line">				self.init(ftpServer, userName, password);</div><div class="line">				return self;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		//task相当于模式角色：Promise.Promise</div><div class="line">		final FutureTask&lt;FTPClientUtil&gt; task = new FutureTask&lt;FTPClientUtil&gt;(</div><div class="line">		    callable);</div><div class="line"></div><div class="line">		/*</div><div class="line">		下面这行代码与本案例的实际代码并不一致，这是为了讨论方便。</div><div class="line">		下面新建的线程相当于模式角色：Promise.TaskExecutor</div><div class="line">		*/</div><div class="line">		new Thread(task).start();</div><div class="line">		return task;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void init(String ftpServer, String userName, String password)</div><div class="line">	    throws Exception &#123;</div><div class="line"></div><div class="line">		FTPClientConfig config = new FTPClientConfig();</div><div class="line">		ftp.configure(config);</div><div class="line"></div><div class="line">		int reply;</div><div class="line">		ftp.connect(ftpServer);</div><div class="line"></div><div class="line">		System.out.print(ftp.getReplyString());</div><div class="line"></div><div class="line">		reply = ftp.getReplyCode();</div><div class="line"></div><div class="line">		if (!FTPReply.isPositiveCompletion(reply)) &#123;</div><div class="line">			ftp.disconnect();</div><div class="line">			throw new RuntimeException(&quot;FTP server refused connection.&quot;);</div><div class="line">		&#125;</div><div class="line">		boolean isOK = ftp.login(userName, password);</div><div class="line">		if (isOK) &#123;</div><div class="line">			System.out.println(ftp.getReplyString());</div><div class="line"></div><div class="line">		&#125; else &#123;</div><div class="line">			throw new RuntimeException(&quot;Failed to login.&quot; + ftp.getReplyString());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		reply = ftp.cwd(&quot;~/subspsync&quot;);</div><div class="line">		if (!FTPReply.isPositiveCompletion(reply)) &#123;</div><div class="line">			ftp.disconnect();</div><div class="line">			throw new RuntimeException(&quot;Failed to change working directory.reply:&quot;</div><div class="line">			    + reply);</div><div class="line">		&#125; else &#123;</div><div class="line"></div><div class="line">			System.out.println(ftp.getReplyString());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		ftp.setFileType(FTP.ASCII_FILE_TYPE);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void upload(File file) throws Exception &#123;</div><div class="line">		InputStream dataIn = new BufferedInputStream(new FileInputStream(file),</div><div class="line">		    1024 * 8);</div><div class="line">		boolean isOK;</div><div class="line">		String dirName = file.getParentFile().getName();</div><div class="line">		String fileName = dirName + &apos;/&apos; + file.getName();</div><div class="line">		ByteArrayInputStream checkFileInputStream = new ByteArrayInputStream(</div><div class="line">		    &quot;&quot;.getBytes());</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">			if (!dirCreateMap.containsKey(dirName)) &#123;</div><div class="line">				ftp.makeDirectory(dirName);</div><div class="line">				dirCreateMap.put(dirName, null);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">				isOK = ftp.storeFile(fileName, dataIn);</div><div class="line">			&#125; catch (IOException e) &#123;</div><div class="line">				throw new RuntimeException(&quot;Failed to upload &quot; + file, e);</div><div class="line">			&#125;</div><div class="line">			if (isOK) &#123;</div><div class="line">				ftp.storeFile(fileName + &quot;.c&quot;, checkFileInputStream);</div><div class="line"></div><div class="line">			&#125; else &#123;</div><div class="line"></div><div class="line">				throw new RuntimeException(&quot;Failed to upload &quot; + file + &quot;,reply:&quot; + </div><div class="line">&quot;,&quot;+ ftp.getReplyString());</div><div class="line">			&#125;</div><div class="line">		&#125; finally &#123;</div><div class="line">			dataIn.close();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void disconnect() &#123;</div><div class="line">		if (ftp.isConnected()) &#123;</div><div class="line">			try &#123;</div><div class="line">				ftp.disconnect();</div><div class="line">			&#125; catch (IOException ioe) &#123;</div><div class="line">				// 什么也不做</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>FTPClientUtil类封装了FTP客户端，其构造方法是private修饰的，因此其他类无法通过new来生成相应的实例，而是通过其静态方法newInstance来获得实例。不过newInstance方法的返回值并不是一个FTPClientUtil实例，而是一个可以获取FTPClientUtil实例的凭据对象java.util.concurrent.Future（具体说是java.util.concurrent.FutureTask，它实现了java.util.concurrent.Future接口）实例。因此，FTPClientUtil既相当于Promise模式中的Promisor参与者实例，又相当于Result参与者实例。而newInstance方法的返回值java.util.concurrent.FutureTask实例既相当于Promise参与者实例，又相当于TaskExecutor参与者实例：newInstance方法的返回值java.util.concurrent.FutureTask实例不仅负责该方法真正处理结果（初始化完毕的FTP客户端实例）的存储和获取，还负责执行异步任务（调用FTPClientUtil实例的init方法），并设置任务的处理结果。</p>
<p>从如清单2所示的Promise客户端代码（DataSyncTask类的run方法）来看，使用Promise模式的异步编程并没有本质上增加编程的复杂性：客户端代码的编写方式与同步编程并没有太大差别，唯一一点差别就是获取FTP客户端实例的时候多了一步对java.util.concurrent.FutureTask实例的get方法的调用。</p>
<h3 id="Promise模式的评价与实现考量"><a href="#Promise模式的评价与实现考量" class="headerlink" title="Promise模式的评价与实现考量"></a>Promise模式的评价与实现考量</h3><p>Promise模式既发挥了异步编程的优势——增加系统的并发性，减少不必要的等待，又保持了同步编程的简单性：有关异步编程的细节，如创建新的线程或者提交任务到线程池执行等细节，都被封装在Promisor参与者实例中，而Promise的客户端代码则无须关心这些细节，其编码方式与同步编程并无本质上差别。这点正如清单6-1代码所展示的，客户端代码仅仅需要调用FTPClientUtil的newInstance静态方法，再调用其返回值的get方法，即可获得一个初始化完毕的FTP客户端实例。这本质上还是同步编程。当然，客户端代码也不能完全无视Promise模式的异步编程这一特性：为了减少客户端代码在调用Promise的getResult方法时出现阻塞的可能，客户端代码应该尽可能早地调用Promisor的异步方法，并尽可能晚地调用Promise的getResult方法。这当中间隔的时间可以由客户端代码用来执行其他操作，同时这段时间可以给TaskExecutor用于执行异步任务。</p>
<p>Promise模式一定程度上屏蔽了异步、同步编程的差异。前文我们一直说Promisor对外暴露的compute方法是个异步方法。事实上，如果compute方法是一个同步方法，那么Promise模式的客户端代码的编写方式也是一样的。也就是说，无论compute方法是一个同步方法还是异步方法，Promise客户端代码的编写方式都是一样的。例如，本章案例中FTPClientUtil的newInstance方法如果改成同步方法，我们只需要将其方法体中的语句new Thread(task).start();改为task.run();即可。而该案例中的其他代码无须更改。这就在一定程度上屏蔽了同步、异步编程的差异。而这可以给代码调试或者问题定位带来一定的便利。比如，我们的本意是要将compute方法设计成一个异步方法，但在调试代码的时候发现结果不对，那么我们可以尝试临时将其改为同步方法。若此时原先存在的问题不再出现，则说明问题是compute方法被编码为异步方法后所产生的多线程并发访问控制不正确导致的。</p>
<ol>
<li>异步方法的异常处理</li>
</ol>
<p>如果Promisor的compute方法是个异步方法，那么客户端代码在调用完该方法后异步任务可能尚未开始执行。另外，异步任务运行在自己的线程中，而不是compute方法的调用方线程中。因此，异步任务执行过程中产生的异常无法在compute方法中抛出。为了让Promise模式的客户端代码能够捕获到异步任务执行过程中出现的异常，一个可行的办法是让TaskExecutor在执行任务捕获到异常后，将异常对象“记录”到Promise实例的一个专门的实例变量上，然后由Promise实例的getResult方法对该实例变量进行检查。若该实例变量的值不为null，则getResult方法抛出异常。这样，Promise模式的客户端代码通过捕获getResult方法抛出的异常即可“知道”异步任务执行过程中出现的异常。JDK中提供的类java.util.concurrent.FutureTask就是采用这种方法对compute异步方法的异常进行处理的。</p>
<ol>
<li>轮询（Polling）</li>
</ol>
<p>客户端代码对Promise的getResult的调用可能由于异步任务尚未执行完毕而阻塞，这实际上也是一种等待。虽然我们可以通过尽可能早地调用compute方法并尽可能晚地调用getResult方法来减少这种等待的可能性，但是它仍然可能会出现。某些场景下，我们可能根本不希望进行任何等待。此时，我们需要在调用Promise的getResult方法之前确保异步任务已经执行完毕。因此，Promise需要暴露一个isDone方法用于检测异步任务是否已执行完毕。JDK提供的类java.util.concurrent.FutureTask的isDone方法正是出于这种考虑，它允许我们在“适当”的时候才调用Promise的getResult方法（相当于FutureTask的get方法）。</p>
<ol>
<li>异步任务的执行</li>
</ol>
<p>本章案例中，异步任务的执行我们是通过新建一个线程，由该线程去调用TaskExecutor的run方法来实现的（见清单6-2）。这只是为了讨论方便。如果系统中同时存在多个线程调用Promisor的异步方法，而每个异步方法都启动了各自的线程去执行异步任务，这可能导致一个JVM中启动的线程数量过多，增加了线程调度的负担，从而反倒降低了系统的性能。因此，如果Promise模式的客户端并发量比较大，则需要考虑由线程池负责执行TaskExecutor的run方法来实现异步任务的执行。例如，如清单2所示的异步任务如果改用线程池去执行，我们只需要将代码改为类似如清单3所示的代码即可。</p>
<p>清单3．用线程池执行异步任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">public class FTPClientUtil &#123;</div><div class="line">	private volatilestatic ThreadPoolExecutor threadPoolExecutor;</div><div class="line"></div><div class="line">	static &#123;</div><div class="line">		threadPoolExecutor = new ThreadPoolExecutor(1,Runtime.getRuntime()</div><div class="line">		    .availableProcessors() * 2, </div><div class="line">		    60, </div><div class="line">		    TimeUnit.SECONDS,</div><div class="line">		    new ArrayBlockingQueue&lt;Runnable&gt;(10), new ThreadFactory() &#123;</div><div class="line">			    public Thread newThread(Runnable r) &#123;</div><div class="line">				    Thread t = new Thread(r);</div><div class="line">				    t.setDaemon(true);</div><div class="line">				    return t;</div><div class="line">			    &#125;</div><div class="line">		    &#125;, new ThreadPoolExecutor.CallerRunsPolicy());</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private final FTPClient ftp = new FTPClient();</div><div class="line">	private final Map&lt;String, Boolean&gt; dirCreateMap = new HashMap&lt;String, Boolean&gt;();</div><div class="line"></div><div class="line">	//私有构造器</div><div class="line">	private FTPClientUtil() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static Future&lt;FTPClientUtil&gt; newInstance(final String ftpServer,</div><div class="line">	    final String userName, final String password) &#123;</div><div class="line"></div><div class="line">		Callable&lt;FTPClientUtil&gt; callable = new Callable&lt;FTPClientUtil&gt;() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public FTPClientUtil call() throws Exception &#123;</div><div class="line">				FTPClientUtil self = new FTPClientUtil();</div><div class="line">				self.init(ftpServer, userName, password);</div><div class="line">				return self;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;;</div><div class="line">		final FutureTask&lt;FTPClientUtil&gt; task = new FutureTask&lt;FTPClientUtil&gt;(</div><div class="line">		    callable);</div><div class="line"></div><div class="line">		threadPoolExecutor.execute(task);</div><div class="line">		return task;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void init(String ftpServer, String userName, String password)</div><div class="line">	    throws Exception &#123;</div><div class="line">		//省略与清单6-2中相同的代码</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void upload(File file) throws Exception &#123;</div><div class="line">		//省略与清单6-2中相同的代码</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void disconnect() &#123;</div><div class="line">		//省略与清单2中相同的代码</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Promise模式的可复用实现代码</p>
<p>JDK1.5开始提供的接口java.util.concurrent.Future可以看成是Promise模式中Promise参与者的抽象，其声明如下：</p>
<p>public interface Future<v><br>该接口的类型参数V相当于Promise模式中的Result参与者。该接口定义的方法及其与Promise参与者相关方法之间的对应关系如表6-1所示。</v></p>
<p>表1．接口java.util.concurrent.Future与Promise参与者的对应关系</p>
<p><img src="/img/concurrent-5.png" alt=""></p>
<p>接口java.util.concurrent.Future的实现类java.util.concurrent.FutureTask可以看作Promise模式的Promise参与者实例。</p>
<p>如清单2所示的代码中的异步方法newInstance展示了如何使用java.util.concurrent.FutureTask来作为Promise参与者。</p>
<p>Java标准库实例</p>
<p>JAX-WS 2.0 API中用于支持调用Web Service的接口javax.xml.ws.Dispatch就使用了Promise模式。该接口用于异步调用Web Service的方法声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Response&lt;T&gt;invokeAsync(T msg)</div></pre></td></tr></table></figure>
<p>该方法不等对端服务器给响应就返回了（即实现了异步调用Web Service），从而避免了Web Service客户端进行不必要的等待。而客户端需要其调用的Web Service的响应时，可以调用invokeAsync方法的返回值的相关方法来获取。invokeAsync的返回值类型为javax.xml.ws.Response，它继承自java.util.concurrent.Future。因此，javax.xml.ws.Dispatch相当于Promise模式中的Promisor参与者实例，其异步方法invokeAsync(T msg)的返回值相当于Promise参与者实例</p>
<p>相关模式</p>
<ol>
<li>Guarded Suspension模式</li>
</ol>
<p>Promise模式的客户端代码调用Promise的getResult方法获取异步任务处理结果时，如果异步任务已经执行完毕，则该调用会直接返回。否则，该调用会阻塞直到异步任务处理结束或者出现异常。这种通过线程阻塞而进行的等待可以看作Guarded Suspension模式的一个实例。只不过，一般情况下Promise参与者我们可以直接使用JDK中提供的类java.util.concurrent.FutureTask来实现，而无须自行编码。关于java.util.concurrent.FutureTask如何实现通过阻塞去等待异步方法执行结束，感兴趣的读者可以去阅读JDK标准库的源码。</p>
<ol>
<li>Active Object模式</li>
</ol>
<p>Active Object模式可以看成是包含了Promise模式的复合模式。其Proxy参与者相当于Promise模式的Promisor参与者。Proxy参与者的异步方法返回值相当于Promise模式的Promise参与者实例。Active Object模式的Scheduler参与者相当于Promise模式的TaskExecutor参与者。</p>
<ol>
<li>Master-Slave模式</li>
</ol>
<p>Master-Slave模式中，Slave参与者返回其对子任务的处理结果可能需要使用Promise模式。此时，Slave参与者相当于Promise模式的Promisor参与者，其subService方法的返回值是一个Promise模式的Promise参与者实例。</p>
<ol>
<li>Factory Method模式</li>
</ol>
<p>Promise模式中的Promisor参与者可以看成是Factory Method模式的一个例子：Promisor的异步方法可以看成一个工厂方法，该方法的返回值是一个Promise实例。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Spark源码四]图解作业生命周期]]></title>
      <url>https://fudawei.github.io/2016/10/25/%5BSpark%E6%BA%90%E7%A0%81%E5%9B%9B%5D%E5%9B%BE%E8%A7%A3%E4%BD%9C%E4%B8%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p>这一章我们探索了Spark作业的运行过程，但是没把整个过程描绘出来，好，跟着我走吧，let you know！<br><img src="/img/spark4.1.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Spark源码三】作业运行过程]]></title>
      <url>https://fudawei.github.io/2016/10/25/%5BSpark%E6%BA%90%E7%A0%81%E4%B8%89%5D%E4%BD%9C%E4%B8%9A%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>官方给的例子里面，一执行collect方法就能出结果，那我们就从collect开始看吧，进入RDD，找到collect方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def collect(): Array[T] = &#123;</div><div class="line">    val results = sc.runJob(this, (iter: Iterator[T]) =&gt; iter.toArray)</div><div class="line">    Array.concat(results: _*)</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>它进行了两个操作：</p>
<p>1、调用SparkContext的runJob方法，把自身的引用传入去，再传了一个匿名函数（把Iterator转换成Array数组）<br>2、把result结果合并成一个Array，注意results是一个Array[Array[T]]类型，所以第二句的那个写法才会那么奇怪。这个操作是很重的一个操作，如果结果很大的话，这个操作是会报OOM的，因为它是把结果保存在Driver程序的内存当中的result数组里面。</p>
<p>我们点进去runJob这个方法吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">val callSite = getCallSite</div><div class="line">    val cleanedFunc = clean(func)</div><div class="line">    dagScheduler.runJob(rdd, cleanedFunc, partitions, callSite, allowLocal, resultHandler, localProperties.get)</div><div class="line">    rdd.doCheckpoint()</div></pre></td></tr></table></figure>
<p>追踪下去，我们会发现经过多个不同的runJob同名函数调用之后，执行job作业靠的是dagScheduler，最后把结果通过resultHandler保存返回。</p>
<p>DAGScheduler如何划分作业</p>
<p>好的，我们继续看DAGScheduler的runJob方法，提交作业，然后等待结果，成功什么都不做，失败抛出错误，我们接着看submitJob方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> val start = System.nanoTime</div><div class="line">// 记录作业成功与失败的数据结构，一个作业的Task数量是和分片的数量一致的，Task成功之后调用resultHandler保存结果。</div><div class="line">val waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties)</div><div class="line">val awaitPermission = null.asInstanceOf[scala.concurrent.CanAwait]</div><div class="line">waiter.completionFuture.ready(Duration.Inf)(awaitPermission)</div><div class="line">waiter.completionFuture.value.get match &#123;</div><div class="line">  case scala.util.Success(_) =&gt;</div><div class="line">    logInfo(&quot;Job %d finished: %s, took %f s&quot;.format</div><div class="line">      (waiter.jobId, callSite.shortForm, (System.nanoTime - start) / 1e9))</div><div class="line">  case scala.util.Failure(exception) =&gt;</div><div class="line">    logInfo(&quot;Job %d failed: %s, took %f s&quot;.format</div><div class="line">      (waiter.jobId, callSite.shortForm, (System.nanoTime - start) / 1e9))</div><div class="line">    // SPARK-8644: Include user stack trace in exceptions coming from DAGScheduler.</div><div class="line">    val callerStackTrace = Thread.currentThread().getStackTrace.tail</div><div class="line">    exception.setStackTrace(exception.getStackTrace ++ callerStackTrace)</div><div class="line">    throw exception</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>val jobId = nextJobId.getAndIncrement()
val func2 = func.asInstanceOf[(TaskContext, Iterator[_]) =&gt; _]

val waiter = new JobWaiter(this, jobId, partitions.size, resultHandler)
eventProcessActor ! JobSubmitted(jobId, rdd, func2, partitions.toArray, allowLocal, callSite, waiter, properties)
</code></pre><p>走到这里，感觉有点儿绕了，为什么到了这里，还不直接运行呢，还要给DAGSchedulerEventProcessLoop发送一个JobSubmitted请求呢，new一个线程和这个区别有多大？</p>
<p>不管了，搜索一下DAGSchedulerEventProcessLoop吧，结果发现它是一个DAGSchedulerEventProcessLoop，它的定义也在DAGScheduler这个类里面。它的receive方法里面定义了12种事件的处理方法，这里我们只需要看JobSubmitted的就行，它也是调用了自身的handleJobSubmitted方法。但是这里很奇怪，没办法打断点调试，但是它的结果倒是能返回的，因此我们得用另外一种方式，打开test工程，找到scheduler目录下的DAGSchedulerSuite这个类，我们自己写一个test方法，首先我们要在import那里加上import org.apache.spark.SparkContext._  ，然后加上这一段测试代码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下恢复rm删除的数据]]></title>
      <url>https://fudawei.github.io/2016/10/19/ubuntu%E4%B8%8B%E6%81%A2%E5%A4%8Drm%E5%88%A0%E9%99%A4%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<h1 id="1-论“备份”的重要性"><a href="#1-论“备份”的重要性" class="headerlink" title="1. 论“备份”的重要性"></a>1. 论“备份”的重要性</h1><p>今天手真快，Tab补全文件名后回车，昨天一天写的代码就被我remove了。虽然自己写了脚本备份系统和home目录，但系统是1天一备份，home是2天一次增量备份。又恰巧昨晚没有备份home，并且Git也没有提交，欲哭无泪的感觉5555~~。</p>
<p>被remove掉的文件其实是可以恢复的，删除命令只是在文件节点中作了删除标记，并不是真正清空内容，但是其他用户和一些有写盘动作的进程会很快覆盖这些数据。所以要想恢复磁盘信息，必须马上停止任何写磁盘操作。</p>
<p>我是将整个磁盘卸载下来，用转接线挂到同学笔记本上才恢复成功的，下面将介绍具体的恢复过程。<br><a id="more"></a></p>
<h1 id="2-恢复工具介绍"><a href="#2-恢复工具介绍" class="headerlink" title="2. 恢复工具介绍"></a>2. 恢复工具介绍</h1><p>针对Linux下的EXT文件系统来说，常用的误删恢复工具有debugfs、ext3grep、extundelete等等。extundelete是一个开源的数据恢复工具，支持ext3、ext4文件系统。</p>
<p>我的系统是Ubuntu15.04，文件系统是ext4。尝试了debugfs来恢复，但没有成功。如果文件系统不是ext4的同学可以尝试下该方式，这里有篇参考文档。</p>
<h1 id="3-extundelete恢复文件"><a href="#3-extundelete恢复文件" class="headerlink" title="3. extundelete恢复文件"></a>3. extundelete恢复文件</h1><ul>
<li>安装extundelete</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">     sudo apt-get install extundelete</div><div class="line">```        </div><div class="line">- 任何的文件恢复工具，在使用前，均要将要恢复的分区卸载或挂载为只读，防止数据被覆盖使用。</div></pre></td></tr></table></figure>
<pre><code>umount /dev/sdb2 
mount -o remount,ro /dev/sdb2
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- 如果删的文件和操作系统是在同一个分区上，就只有把硬盘卸下来，挂载到另一台主机上。我就是这么干的^_^。</div><div class="line"></div><div class="line">- 在另一台主机上用df -h查看挂载分区。我的分区是/dev/sdb2。</div><div class="line"></div><div class="line">- 在该主机上执行：</div></pre></td></tr></table></figure>
<pre><code>extundelete /dev/sdb2 --restore-file /home/zhangchengfei/server.scala
extundelete执行完毕后在当前目录生产一个RECOVERED_FILES目录，里面即是恢复出来的文件。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 如果想恢复某个文件夹的内容，可以使用下面命令：</div></pre></td></tr></table></figure>
<pre><code>extundelete /dev/sdb2 --restore-directory /hom/zhangchengfei/tmp
</code></pre><p>```</p>
<ul>
<li>关于extundelete更多的使用细节，可以用extundelete -h进行查看，本文不再叙述。</li>
</ul>
<ul>
<li><p>总结经验</p>
<p>其实良好的备份和同步习惯才是最重要的，绝对比恢复数据要更简单。常见的备份策略有tar，rsync，git等等。为了防止以后rm误删数据，还有种做法是自己重新定义rm，每次不是直接删除文件或文件夹，而是将它们move到你指定的一个目录下存放。具体的实现可以上google搜索。</p>
</li>
</ul>
<p>看这篇博客的朋友一定是遇到和我一样的窘境，祝好运O(∩_∩)O~~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Btree]]></title>
      <url>https://fudawei.github.io/2016/10/19/Btree/</url>
      <content type="html"><![CDATA[<h1 id="1-前言："><a href="#1-前言：" class="headerlink" title="1.前言："></a>1.前言：</h1><p>动态查找树主要有：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree），红黑树 (Red-Black Tree )，B-tree/B+-tree/ B*-tree (B~Tree)。前三者是典型的二叉查找树结构，其查找的时间复杂度O(log2N)与树的深度相关，那么降低树的深度自然对查找效率是有所提高的；还有一个实际问题：就是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下（为什么会出现这种情况，待会在外部存储器-磁盘中有所解释），那么如何减少树的深度（当然是不能减少查询的数据量），一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。</p>
<p>这样我们就提出了一个新的查找树结构——多路查找树。根据平衡二叉树的启发，自然就想到平衡多路查找树结构，也就是这篇文章所要阐述的主题B~tree(B树结构)，B-tree这棵神奇的树是在Rudolf Bayer, Edward M. McCreight(1970)写的一篇论文《Organization and Maintenance of Large Ordered Indices》中首次提出。具体介绍可以参考wikipedia中的介绍：<a href="http://en.wikipedia.org/wiki/B-tree，其中还阐述了B-tree名字来源以及相关的开源地址。" target="_blank" rel="external">http://en.wikipedia.org/wiki/B-tree，其中还阐述了B-tree名字来源以及相关的开源地址。</a></p>
<p>在开始介绍B~tree之前，先了解下相关的硬件知识，才能很好的了解为什么需要B~tree这种外存数据结构。</p>
<h1 id="2-外存储器—磁盘"><a href="#2-外存储器—磁盘" class="headerlink" title="2.外存储器—磁盘"></a>2.外存储器—磁盘</h1><p>计算机存储设备一般分为两种：内存储器(main memory)和外存储器(external memory)。内存存取速度快，但容量小，价格昂贵，而且不能长期保存数据(在不通电情况下数据会消失)。</p>
<p>外存储器—磁盘是一种直接存取的存储设备(DASD)。它是以存取时间变化不大为特征的。可以直接存取任何字符组，且容量大、速度较其它外存设备更快。</p>
<h2 id="2-1磁盘的构造"><a href="#2-1磁盘的构造" class="headerlink" title="2.1磁盘的构造"></a>2.1磁盘的构造</h2><p>磁盘时一个扁平的圆盘(与电唱机的唱片类似)。盘面上有许多称为磁道的圆圈，数据就记录在这些磁道上。磁盘可以是单片的，也可以是由若干盘片组成的盘组，每一盘片上有两个面。如下图6片盘组为例，除去最顶端和最底端的外侧面不存储数据之外，一共有10个面可以用来保存信息。</p>
<p><img src="/img/btree_1.png" alt=""></p>
<p>当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头(又叫磁头) 下通过时，就可以进行数据的读 / 写了。</p>
<p>一般磁盘分为固定头盘(磁头固定)和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。</p>
<p>活动头盘 (如上图)的磁头是可移动的。每一个盘面上只有一个磁头(磁头是双向的，因此正反盘面都能读写)。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的(行动整齐划一)。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面。因此，柱面的个数也就是盘面上的磁道数。</p>
<h2 id="2-2磁盘的读-写原理和效率"><a href="#2-2磁盘的读-写原理和效率" class="headerlink" title="2.2磁盘的读/写原理和效率"></a>2.2磁盘的读/写原理和效率</h2><p>磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号(磁道上的盘块)。</p>
<p>读/写磁盘上某一指定数据需要下面3个步骤：</p>
<p>(1)  首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找。</p>
<p>(2)  如上图6盘组示意图中，所有磁头都定位到了10个盘面的10条磁道上(磁头都是双向的)。这时根据盘面号来确定指定盘面上的磁道。</p>
<p>(3) 盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。</p>
<p>经过上面三个步骤，指定数据的存储位置就被找到。这时就可以开始读/写操作了。</p>
<p>访问某一具体信息，由3部分时间组成：</p>
<p>● 查找时间(seek time) Ts: 完成上述步骤(1)所需要的时间。这部分时间代价最高，最大可达到0.1s左右。</p>
<p>● 等待时间(latency time) Tl: 完成上述步骤(3)所需要的时间。由于盘片绕主轴旋转速度很快，一般为7200转/分(电脑硬盘的性能指标之一, 家用的普通硬盘的转速一般有5400rpm(笔记本)、7200rpm几种)。因此一般旋转一圈大约0.0083s。</p>
<p>● 传输时间(transmission time) Tt: 数据通过系统总线传送到内存的时间，一般传输一个字节(byte)大概0.02us=2*10^(-8)s</p>
<p>磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。</p>
<p>所以，在大规模数据存储方面，大量数据存储在外存磁盘中，而在外存磁盘中读取/写入块(block)中某数据时，首先需要定位到磁盘中的某块，如何有效地查找磁盘中的数据，需要一种合理高效的外存数据结构，就是下面所要重点阐述的B-tree结构，以及相关的变种结构：B+-tree结构和B*-tree结构。</p>
<h1 id="3-B-tree"><a href="#3-B-tree" class="headerlink" title="3.B-tree"></a>3.B-tree</h1><p>B-tree又叫平衡多路查找树。一棵m阶的B-tree (m叉树)的特性如下：</p>
<p>（其中ceil(x)是一个取上限的函数）</p>
<p>1)  树中每个结点至多有m个孩子；</p>
<p>2)  除根结点和叶子结点外，其它每个结点至少有有ceil(m / 2)个孩子；</p>
<p>3)  若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；</p>
<p>4)  所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，实际上这些结点不存在，指向这些结点的指针都为null)；</p>
<p>5)  每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：</p>
<pre><code>a)   Ki (i=1...n)为关键字，且关键字按顺序排序K(i-1)&lt; Ki。

b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。

c)   关键字的个数n必须满足： ceil(m / 2)-1 &lt;= n &lt;= m-1。
</code></pre><p>B-tree中的每个结点根据实际情况可以包含大量的关键字信息和分支(当然是不能超过磁盘块的大小，根据磁盘驱动(disk drives)的不同，一般块的大小在1k~4k左右)；这样树的深度降低了，这就意味着查找一个元素只要很少结点从外存磁盘中读入内存，很快访问到要查找的数据。</p>
<p><img src="/img/btree_2.png" alt=""></p>
<p>为了简单，这里用少量数据构造一棵3叉树的形式。上面的图中比如根结点，其中17表示一个磁盘文件的文件名；小红方块表示这个17文件的内容在硬盘中的存储位置；p1表示指向17左子树的指针。</p>
<p>其结构可以简单定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line"></div><div class="line">    /*文件数*/</div><div class="line"></div><div class="line">    int  file_num;</div><div class="line"></div><div class="line">    /*文件名(key)*/</div><div class="line"></div><div class="line">    char * file_name[max_file_num];</div><div class="line"></div><div class="line">    /*指向子节点的指针*/</div><div class="line"></div><div class="line">     BTNode * BTptr[max_file_num+1];</div><div class="line"></div><div class="line">     /*文件在硬盘中的存储位置*/</div><div class="line"></div><div class="line">     FILE_HARD_ADDR offset[max_file_num];</div><div class="line"></div><div class="line">&#125;BTNode;</div></pre></td></tr></table></figure>
<p>假如每个盘块可以正好存放一个B-tree的结点（正好存放2个文件名）。那么一个BTNode结点就代表一个盘块，而子树指针就是存放另外一个盘块的地址。</p>
<p>模拟查找文件29的过程：</p>
<p> (1) 根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作1次】</p>
<p> (2) 此时内存中有两个文件名17，35和三个存储其他磁盘页面地址的数据。根据算法我们发现17&lt;29&lt;35，因此我们找到指针p2。</p>
<p> (3) 根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作2次】</p>
<p> (4) 此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现26&lt;29&lt;30，因此我们找到指针p2。</p>
<p> (5) 根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作3次】</p>
<p> (6) 此时内存中有两个文件名28，29。根据算法我们查找到文件29，并定位了该文件内存的磁盘地址。</p>
<p>分析上面的过程，发现需要3次磁盘IO操作和3次内存查找操作。关于内存中的文件名查找，由于是一个有序表结构，可以利用折半查找提高效率。至于3次磁盘IO操作时影响整个B-tree查找效率的决定因素。</p>
<p>当然，如果我们使用平衡二叉树的磁盘存储结构来进行查找，磁盘IO操作最少4次，最多5次。而且文件越多，B-tree比平衡二叉树所用的磁盘IO操作次数将越少，效率也越高。</p>
<p>上面仅仅介绍了对于B-tree这种结构的查找过程，还有树节点的插入与删除过程，以及相关的算法和代码的实现，将在以后的深入学习中给出相应的实例。</p>
<p>上面简单介绍了利用B-tree这种结构如何访问外存磁盘中的数据的情况，下面咱们通过另外一个实例来对这棵B-tree的插入（insert）,删除（delete）基本操作进行详细的介绍：</p>
<p>下面以一棵5阶B-tree实例进行讲解(如下图所示)：</p>
<p>其满足上述条件：除根结点和叶子结点外，其它每个结点至少有ceil(5/2)=3个孩子（至少2个关键字）；当然最多5个孩子（最多4个关键字）。下图中关键字为大写字母，顺序为字母升序。</p>
<p>结点定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef struct&#123;</div><div class="line"></div><div class="line">   int Count;         // 当前节点中关键元素数目</div><div class="line"></div><div class="line">   ItemType Key[4];   // 存储关键字元素的数组</div><div class="line"></div><div class="line">   long Branch[5];    // 伪指针数组，(记录数目)方便判断合并和分裂的情况</div><div class="line"></div><div class="line">&#125; NodeType;</div></pre></td></tr></table></figure>
<p><img src="/img/btree_3.png" alt=""></p>
<p>插入（insert）操作：插入一个元素时，首先在B-tree中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素，注意：如果叶子结点空间足够，这里需要向右移动该叶子结点中大于新插入关键字的元素，如果空间满了以致没有足够的空间去添加新的元素，则将该结点进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中（当然，如果父结点空间满了，也同样需要“分裂”操作），而且当结点中关键元素向右移动了，相关的指针也需要向右移。如果在根结点插入新元素，空间满了，则进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。</p>
<p>咱们通过一个实例来逐步讲解下。插入以下字符字母到空的5阶B-tree中：C N G A H E K Q M F W L T Z D P R X Y S，5序意味着一个结点最多有5个孩子和4个关键字，除根结点外其他结点至少有2个关键字，首先，结点空间足够，4个字母插入相同的结点中，如下图：</p>
<p><img src="/img/btree_4.png" alt=""></p>
<p>当咱们试着插入H时，结点发现空间不够，以致将其分裂成2个结点，移动中间元素G上移到新的根结点中，在实现过程中，咱们把A和C留在当前结点中，而H和N放置新的其右邻居结点中。如下图：</p>
<p><img src="/img/btree_5.png" alt=""></p>
<p>当咱们插入E,K,Q时，不需要任何分裂操作</p>
<p><img src="/img/btree_6.png" alt=""></p>
<p>插入M需要一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中</p>
<p><img src="/img/btree_7.png" alt=""></p>
<p>插入F,W,L,T不需要任何分裂操作</p>
<p><img src="/img/btree_8.png" alt=""></p>
<p>插入Z时，最右的叶子结点空间满了，需要进行分裂操作，中间元素T上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在2个关键字元素。</p>
<p><img src="/img/btree_9.png" alt=""></p>
<p>插入D时，导致最左边的叶子结点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P,R,X,Y陆续插入不需要任何分裂操作。</p>
<p><img src="/img/btree_10.png" alt=""></p>
<p>最后，当插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中，注意以前在父节点中的第三个指针在修改后包括D和G节点中。这样具体插入操作的完成，下面介绍删除操作，删除操作相对于插入操作要考虑的情况多点。</p>
<p><img src="/img/btree_11.png" alt=""></p>
<p>删除(delete)操作：首先查找B-tree中需删除的元素,如果该元素在B-tree中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况.。</p>
<p>删除元素，移动相应元素之后，如果某结点中元素数目小于ceil(m/2)-1，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。那咱们通过下面实例来详细了解吧。</p>
<p>以上述插入操作构造的一棵5阶B-tree为例，依次删除H,T,R,E。</p>
<p>首先删除元素H，当然首先查找H，H在一个叶子结点中，且该叶子结点元素数目3大于最小元素数目ceil(m/2)-1=2，则操作很简单，咱们只需要移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）</p>
<p><img src="/img/btree_12.png" alt=""></p>
<p>下一步，删除T,因为T没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者W(字母升序的下个元素)，将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该孩子结点中元素个数大于2，无需进行合并操作。</p>
<p><img src="/img/btree_13.png" alt=""></p>
<p>下一步删除R，R在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目ceil(5/2)-1=2,如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中，在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。下一步删除R，R在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目ceil(5/2)-1=2,如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中，在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。</p>
<p><img src="/img/btree_14.png" alt=""></p>
<p>最后一步删除E，删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2）,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点。</p>
<p><img src="/img/btree_15.png" alt=""></p>
<p>也许你认为这样删除操作已经结束了，其实不然，在看看上图，对于这种特殊情况，你立即会发现父节点只包含一个元素G，没达标，这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）有一个以上的元素（Q右边还有元素），然后咱们将M下移到元素很少的子结点中，将Q上移到M的位置，这时，Q的左子树将变成M的右子树，也就是含有N，P结点被依附在M的右指针上。所以在这个实例中，咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。</p>
<p><img src="/img/btree_16.png" alt=""></p>
<p>为了进一步详细讨论删除的情况。再举另外一个实例：</p>
<p>这里是一棵不同的5阶B-tree，那咱们试着删除C</p>
<p><img src="/img/btree_17.png" alt=""></p>
<p>于是将删除元素C的右子结点中的D元素上移到C的位置，但是出现上移元素后，只有一个元素的结点的情况。</p>
<p><img src="/img/btree_18.png" alt=""></p>
<p>又因为含有E的结点，其相邻兄弟结点才刚脱贫（最少元素个数为2），不可能向父节点借元素，所以只能进行合并操作，于是这里将含有A,B的左兄弟结点和含有E的结点进行合并成一个结点。</p>
<p><img src="/img/btree_19.png" alt=""></p>
<p>这样又出现只含有一个元素F结点的情况，这时，其相邻的兄弟结点是丰满的（元素个数为3&gt;最小元素个数2），这样就可以想父结点借元素了，把父结点中的J下移到该结点中，相应的如果结点中J后有元素则前移，然后相邻兄弟结点中的第一个元素（或者最后一个元素）上移到父节点中，后面的元素（或者前面的元素）前移（或者后移）；注意含有K，L的结点以前依附在M的左边，现在变为依附在J的右边。这样每个结点都满足B-tree结构性质。</p>
<p><img src="/img/btree_20.png" alt=""></p>
<h1 id="4-B-tree"><a href="#4-B-tree" class="headerlink" title="4.B+-tree"></a>4.B+-tree</h1><p>B+-tree：是应文件系统所需而产生的一种B-tree的变形树。</p>
<p>一棵m阶的B+-tree和m阶的B-tree的差异在于：</p>
<pre><code>1.有n棵子树的结点中含有n个关键字； (B-tree是n棵子树有n-1个关键字)

2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (B-tree的叶子节点并没有包括全部需要查找的信息)

3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (B-tree的非终节点也包含需要查找的有效信息)
</code></pre><p><img src="/img/btree_21.png" alt=""></p>
<p>a)      为什么说B+树比B-tree更适合实际应用中操作系统的文件索引和数据库索引？</p>
<p>1) B+-tree的磁盘读写代价更低</p>
<p>B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B-tree更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<pre><code>举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+-tree内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B-tree就比B+-tree多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。
</code></pre><p>2) B+-tree的查询效率更加稳定</p>
<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p>b)      B+-tree的应用: VSAM(虚拟存储存取法)文件(来源论文the ubiquitous Btree 作者：D COMER - 1979 )</p>
<p><img src="/img/btree_22.png" alt=""></p>
<p>关于B+-tree的详细介绍将在以后的学习中给出实例，待写。。。</p>
<h1 id="5-B-tree"><a href="#5-B-tree" class="headerlink" title="5.B*-tree"></a>5.B*-tree</h1><p>B<em>-tree是B+-tree的变体，在B+-tree的非根和非叶子结点再增加指向兄弟的指针；B</em>-tree定义了非叶子结点关键字个数至少为(2 /3)*M，即块的最低使用率为2/3（代替B+树的1/2）。给出了一个简单实例，如下图所示：</p>
<p><img src="/img/btree_23.png" alt=""></p>
<p>B+-tree的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+-tree的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。</p>
<p>B*-tree的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。</p>
<p>所以，B*-tree分配新结点的概率比B+-tree要低，空间使用率更高；</p>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h1><pre><code>B-tree，B+-tree，B*-tree总结如下： 

 B-tree：有序数组+平衡多叉树；

 B+-tree：有序数组链表+平衡多叉树；

 B*-tree：一棵丰满的B+-tree。



  在大规模数据存储的文件系统中，B~tree系列数据结构，起着很重要的作用，对于存储不同的数据，节点相关的信息也是有所不同，这里根据自己的理解，画的一个查找以职工号为关键字，职工号为38的记录的简单示意图。(这里假设每个物理块容纳3个索引，磁盘的I/O操作的基本单位是块（block),磁盘访问很费时，采用B+-tree有效的减少了访问磁盘的次数。）
</code></pre><p>对于像MySQL，DB2，Oracle等数据库中的索引结构有待深入的了解才行，不过网上可以找到很多B-tree相关的开源代码可以用来研究。</p>
<p><img src="/img/btree_24.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Spark源码二】RDD讲解]]></title>
      <url>https://fudawei.github.io/2016/10/10/%5BSpark%E6%BA%90%E7%A0%81%E4%BA%8C%5DRDD%E8%AE%B2%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>1、什么是RDD？</p>
<p> RDD的全名是Resilient Distributed Dataset，意思是容错的分布式数据集，每一个RDD都会有5个特征：</p>
<p>1、有一个分片列表。就是能被切分，和hadoop一样的，能够切分的数据才能并行计算。<br>2、有一个函数计算每一个分片，这里指的是下面会提到的compute函数。<br>3、对其他的RDD的依赖列表，依赖还具体分为宽依赖和窄依赖，但并不是所有的RDD都有依赖。<br>4、可选：key-value型的RDD是根据哈希来分区的，类似于mapreduce当中的Paritioner接口，控制key分到哪个reduce。<br>5、可选：每一个分片的优先计算位置（preferred locations），比如HDFS的block的所在位置应该是优先计算的位置。</p>
<p>我们一项一项按着看。首先我们找到RDD这个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//对一个分片进行计算，得出一个可遍历的结果</div><div class="line">def compute(split: Partition, context: TaskContext): Iterator[T]</div><div class="line">//只调用一次，返回RDD分区</div><div class="line">protected def getPartitions: Array[Partition]</div><div class="line"> //也只会调用一次，返回依赖的Rdd</div><div class="line">protected def getDependencies: Seq[Dependency[_]] = deps</div></pre></td></tr></table></figure>
<p>多种RDD之间的转换<br>下面用一个实例讲解一下吧，就拿我们常用的一段代码来讲吧，然后会把我们常用的RDD都会讲到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val hdfsFile = sc.textFile(args(1))</div><div class="line">val flatMapRdd = hdfsFile.flatMap(s =&gt; s.split(&quot; &quot;))</div><div class="line">val filterRdd = flatMapRdd.filter(_.length == 2)</div><div class="line">val mapRdd = filterRdd.map(word =&gt; (word, 1))</div><div class="line">val reduce = mapRdd.reduceByKey(_ + _)</div></pre></td></tr></table></figure>
<p>这里涉及到多个RDD，首先sc.textFile得到一个HadoopRDD经过map之后MapPartitionsRDD经过flatMap之后为MapPartitionsRDD，经过filter之后MapPartitionsRDD经过map之后隐式转换未PairRDDFunctions静reduceByKey后转化为ShuffledRDD</p>
<p>我们先看一下<br>问题导读：<br>1.什么是RDD?<br>2.如何实现RDD转换？</p>
<p>1、什么是RDD？<br>上一章讲了Spark提交作业的过程，这一章我们要讲RDD。简单的讲，RDD就是Spark的input，知道input是啥吧，就是输入的数据。</p>
<p>RDD的全名是Resilient Distributed Dataset，意思是容错的分布式数据集，每一个RDD都会有5个特征：</p>
<p>1、有一个分片列表。就是能被切分，和hadoop一样的，能够切分的数据才能并行计算。<br>2、有一个函数计算每一个分片，这里指的是下面会提到的compute函数。<br>3、对其他的RDD的依赖列表，依赖还具体分为宽依赖和窄依赖，但并不是所有的RDD都有依赖。<br>4、可选：key-value型的RDD是根据哈希来分区的，类似于mapreduce当中的Paritioner接口，控制key分到哪个reduce。<br>5、可选：每一个分片的优先计算位置（preferred locations），比如HDFS的block的所在位置应该是优先计算的位置。</p>
<p>对应着上面这几点，我们在RDD里面能找到这4个方法和1个属性，别着急，下面我们会慢慢展开说这5个东东。</p>
<p>//只计算一次<br>  protected def getPartitions: Array[Partition]<br>  //对一个分片进行计算，得出一个可遍历的结果<br>  def compute(split: Partition, context: TaskContext): Iterator[T]<br>  //只计算一次，计算RDD对父RDD的依赖<br>  protected def getDependencies: Seq[Dependency[_]] = deps<br>  //可选的，分区的方法，针对第4点，类似于mapreduce当中的Paritioner接口，控制key分到哪个reduce<br>  @transient val partitioner: Option[Partitioner] = None<br>  //可选的，指定优先位置，输入参数是split分片，输出结果是一组优先的节点位置<br>  protected def getPreferredLocations(split: Partition): Seq[String] = Nil<br>复制代码</p>
<p>2、多种RDD之间的转换<br>下面用一个实例讲解一下吧，就拿我们常用的一段代码来讲吧，然后会把我们常用的RDD都会讲到。</p>
<p>val hdfsFile = sc.textFile(args(1))<br>    val flatMapRdd = hdfsFile.flatMap(s =&gt; s.split(“ “))<br>    val filterRdd = flatMapRdd.filter(<em>.length == 2)<br>    val mapRdd = filterRdd.map(word =&gt; (word, 1))<br>    val reduce = mapRdd.reduceByKey(</em> + _)<br>复制代码</p>
<p>这里涉及到很多个RDD，textFile是一个HadoopRDD经过map后的MappredRDD，经过flatMap是一个FlatMappedRDD，经过filter方法之后生成了一个FilteredRDD，经过map函数之后，变成一个MappedRDD，通过隐式转换成 PairRDD，最后经过reduceByKey。</p>
<p>我们首先看textFile的这个方法，进入SparkContext这个方法，找到它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def textFile(</div><div class="line">     path: String,</div><div class="line">     minPartitions: Int = defaultMinPartitions): RDD[String] = withScope &#123;</div><div class="line">   assertNotStopped()</div><div class="line">   hadoopFile(path, classOf[TextInputFormat], classOf[LongWritable], classOf[Text],</div><div class="line">     minPartitions).map(pair =&gt; pair._2.toString).setName(path)</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这个方法能读取hdfs文件、本地文件以及hadoop支持的其他文本文件，里面调用了hadoopFile,接着看这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">def hadoopFile[K, V](</div><div class="line">      path: String,</div><div class="line">      inputFormatClass: Class[_ &lt;: InputFormat[K, V]],</div><div class="line">      keyClass: Class[K],</div><div class="line">      valueClass: Class[V],</div><div class="line">      minPartitions: Int = defaultMinPartitions): RDD[(K, V)] = withScope &#123;</div><div class="line">    assertNotStopped()</div><div class="line">    // A Hadoop configuration can be about 10 KB, which is pretty big, so broadcast it.</div><div class="line">    val confBroadcast = broadcast(new SerializableConfiguration(hadoopConfiguration))</div><div class="line">    val setInputPathsFunc = (jobConf: JobConf) =&gt; FileInputFormat.setInputPaths(jobConf, path)</div><div class="line">    new HadoopRDD(</div><div class="line">      this,</div><div class="line">      confBroadcast,</div><div class="line">      Some(setInputPathsFunc),</div><div class="line">      inputFormatClass,</div><div class="line">      keyClass,</div><div class="line">      valueClass,</div><div class="line">      minPartitions).setName(path)</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>hadoopFile方法内静hadoop的配置文件放到广播变量，人后new 了一个HadoopRDD然后调用setName返回HadoopRDD，<br>以下构造HadoopRDD的参数<br>   sc:spark上下文<br> 　broadcastedConf：广播变量配置（hadoop的配置文件<br> 　initLocalJobConfFuncOpt:用于初始化HadoopRDD的job配置文件<br>   inputFormatClass:格式化读取数据文件<br> 　keyClass：为inputFormatClass指定的key<br> 　valueClass： inputFormatClass的Class<br> 　minPartitions：　HadoopRDD最小分区数<br>我们看一下HadoopRDD的主要方法：<br>首先getPartitions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">override def getPartitions: Array[Partition] = &#123;</div><div class="line">    val jobConf = getJobConf()</div><div class="line">    // add the credentials here as this can be called before SparkContext initialized</div><div class="line">    SparkHadoopUtil.get.addCredentials(jobConf)</div><div class="line">    val inputFormat = getInputFormat(jobConf)</div><div class="line">    val inputSplits = inputFormat.getSplits(jobConf, minPartitions)</div><div class="line">    val array = new Array[Partition](inputSplits.size)</div><div class="line">    for (i &lt;- 0 until inputSplits.size) &#123;</div><div class="line">      array(i) = new HadoopPartition(id, i, inputSplits(i))</div><div class="line">    &#125;</div><div class="line">    array</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>HadoopRDD按照inputSplits.size分割数据来分区的,然后把分片HadoopPartition包装到到array里面返回。</p>
<p>我们接下来看compute方法，它的输入值是一个Partition，返回是一个Iterator[(K, V)]类型的数据，这里面我们只需要关注2点即可。</p>
<p>1、把Partition转成HadoopPartition，然后通过InputSplit创建一个RecordReader<br>2、重写Iterator的getNext方法，通过创建的reader调用next方法读取下一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">override def compute(theSplit: Partition, context: TaskContext): InterruptibleIterator[(K, V)] = &#123;</div><div class="line">    val iter = new NextIterator[(K, V)] &#123;</div><div class="line"></div><div class="line">      val split = theSplit.asInstanceOf[HadoopPartition]</div><div class="line">      logInfo(&quot;Input split: &quot; + split.inputSplit)</div><div class="line">      val jobConf = getJobConf()</div><div class="line"></div><div class="line">      val inputMetrics = context.taskMetrics().inputMetrics</div><div class="line">      val existingBytesRead = inputMetrics.bytesRead</div><div class="line"></div><div class="line">      // Sets the thread local variable for the file&apos;s name</div><div class="line">      split.inputSplit.value match &#123;</div><div class="line">        case fs: FileSplit =&gt; InputFileNameHolder.setInputFileName(fs.getPath.toString)</div><div class="line">        case _ =&gt; InputFileNameHolder.unsetInputFileName()</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // Find a function that will return the FileSystem bytes read by this thread. Do this before</div><div class="line">      // creating RecordReader, because RecordReader&apos;s constructor might read some bytes</div><div class="line">      val getBytesReadCallback: Option[() =&gt; Long] = split.inputSplit.value match &#123;</div><div class="line">        case _: FileSplit | _: CombineFileSplit =&gt;</div><div class="line">          SparkHadoopUtil.get.getFSBytesReadOnThreadCallback()</div><div class="line">        case _ =&gt; None</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // For Hadoop 2.5+, we get our input bytes from thread-local Hadoop FileSystem statistics.</div><div class="line">      // If we do a coalesce, however, we are likely to compute multiple partitions in the same</div><div class="line">      // task and in the same thread, in which case we need to avoid override values written by</div><div class="line">      // previous partitions (SPARK-13071).</div><div class="line">      def updateBytesRead(): Unit = &#123;</div><div class="line">        getBytesReadCallback.foreach &#123; getBytesRead =&gt;</div><div class="line">          inputMetrics.setBytesRead(existingBytesRead + getBytesRead())</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      var reader: RecordReader[K, V] = null</div><div class="line">      val inputFormat = getInputFormat(jobConf)</div><div class="line">      HadoopRDD.addLocalConfiguration(new SimpleDateFormat(&quot;yyyyMMddHHmm&quot;).format(createTime),</div><div class="line">        context.stageId, theSplit.index, context.attemptNumber, jobConf)</div><div class="line">      reader = inputFormat.getRecordReader(split.inputSplit.value, jobConf, Reporter.NULL)</div><div class="line"></div><div class="line">      context.addTaskCompletionListener&#123; context =&gt; closeIfNeeded() &#125;</div><div class="line">      val key: K = reader.createKey()</div><div class="line">      val value: V = reader.createValue()</div><div class="line"></div><div class="line">      override def getNext(): (K, V) = &#123;</div><div class="line">       ......</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      override def close() &#123;</div><div class="line">       ......</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    new InterruptibleIterator[(K, V)](context, iter)</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>从这里我们可以看得出来compute方法是通过分片来获得Iterator接口，以遍历分片的数据。</p>
<p>getPreferredLocations方法就更简单了，直接调用InputSplit的getLocations方法获得所在的位置。</p>
<p>2.2 依赖<br>下面我们看RDD里面的map方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def map[U: ClassTag](f: T =&gt; U): RDD[U] = withScope &#123;</div><div class="line">    val cleanF = sc.clean(f)</div><div class="line">    new MapPartitionsRDD[U, T](this, (context, pid, iter) =&gt; iter.map(cleanF))</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>直接new了一个MapPartitionsRDD然后讲函数穿进去，我们杀进MapPartitionsRDD<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private[spark] class MapPartitionsRDD[U: ClassTag, T: ClassTag](</div><div class="line">    var prev: RDD[T],</div><div class="line">    f: (TaskContext, Int, Iterator[T]) =&gt; Iterator[U],  // (TaskContext, partition index, iterator)</div><div class="line">    preservesPartitioning: Boolean = false)</div><div class="line">  extends RDD[U](prev) &#123;</div><div class="line"></div><div class="line">  override val partitioner = if (preservesPartitioning) firstParent[T].partitioner else None</div><div class="line"></div><div class="line">  override def getPartitions: Array[Partition] = firstParent[T].partitions</div><div class="line"></div><div class="line">  override def compute(split: Partition, context: TaskContext): Iterator[U] =</div><div class="line">    f(context, split.index, firstParent[T].iterator(split, context))</div><div class="line">  // 清空父RDD</div><div class="line">  override def clearDependencies() &#123;</div><div class="line">    super.clearDependencies()</div><div class="line">    prev = null</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先看一下RDD对应的构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def this(@transient oneParent: RDD[_]) =</div><div class="line">    this(oneParent.context, List(new OneToOneDependency(oneParent)))</div></pre></td></tr></table></figure></p>
<p>就这样你会发现它把RDD复制给了deps，HadoopRDD成了我们杀进MapPartitionsRDD的父依赖了，这个OneToOneDependency是一个窄依赖，子RDD直接依赖于父RDD，继续看firstParent。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected[spark] def firstParent[U: ClassTag]: RDD[U] = &#123;</div><div class="line">   dependencies.head.rdd.asInstanceOf[RDD[U]]</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>由此我们可以得出两个结论：</p>
<p>1、getPartitions直接沿用了父RDD的分片信息<br>2、compute函数是在父RDD遍历每一行数据时套一个匿名函数f进行处理<br>好吧，现在我们可以理解compute函数真正是在干嘛的了</p>
<p>它的两个显著作用：</p>
<p>1、在没有依赖的条件下，根据分片的信息生成遍历数据的Iterable接口<br>2、在有前置依赖的条件下，在父RDD的Iterable接口上给遍历每个元素的时候再套上一个方法</p>
<p>我们看看点击进入map(f)的方法进去看一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def map[B](f: A =&gt; B): Iterator[B] = new AbstractIterator[B] &#123;</div><div class="line">    def hasNext = self.hasNext</div><div class="line">    def next() = f(self.next())</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>map方法将数据集的每一个数据按照f函数执行后返回数据</p>
<p>我们接着看RDD的flatMap方法，你会发现它和map函数几乎没什么区别，但是flatMap和map的效果还是差别挺大的。</p>
<p>比如((1,2),(3,4)), 如果是调用了flatMap函数，我们访问到的就是(1,2,3,4)4个元素；如果是map的话，我们访问到的就是(1,2),(3,4)两个元素。</p>
<p>有兴趣的可以去看看FlatMappedRDD和FilteredRDD</p>
<p>2.3 reduceByKey<br>下面我们看一下reduceByKey的实现。<br>reduceByKey隐藏的比较深，并没有在RDD中，而是在因式转换为PairRDDFunctions才可以使用，所以我们去PairRDDFunctions找一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> def reduceByKey(func: (V, V) =&gt; V): RDD[(K, V)] = self.withScope &#123;</div><div class="line">   reduceByKey(defaultPartitioner(self), func)</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">def defaultPartitioner(rdd: RDD[_], others: RDD[_]*): Partitioner = &#123;</div><div class="line">  val bySize = (Seq(rdd) ++ others).sortBy(_.partitions.length).reverse</div><div class="line">  for (r &lt;- bySize if r.partitioner.isDefined &amp;&amp; r.partitioner.get.numPartitions &gt; 0) &#123;</div><div class="line">    return r.partitioner.get</div><div class="line">  &#125;</div><div class="line">  if (rdd.context.conf.contains(&quot;spark.default.parallelism&quot;)) &#123;</div><div class="line">    new HashPartitioner(rdd.context.defaultParallelism)</div><div class="line">  &#125; else &#123;</div><div class="line">    new HashPartitioner(bySize.head.partitions.length)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">def reduceByKey(partitioner: Partitioner, func: (V, V) =&gt; V): RDD[(K, V)] = self.withScope &#123;</div><div class="line">   combineByKeyWithClassTag[V]((v: V) =&gt; v, func, func, partitioner)</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>我们可以看到reduceByKeyreduceByKeyWithClassTag方法，有心去可以看一下<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">def combineByKeyWithClassTag[C](</div><div class="line">     createCombiner: V =&gt; C,</div><div class="line">     mergeValue: (C, V) =&gt; C,</div><div class="line">     mergeCombiners: (C, C) =&gt; C,</div><div class="line">     partitioner: Partitioner,</div><div class="line">     mapSideCombine: Boolean = true,</div><div class="line">     serializer: Serializer = null)(implicit ct: ClassTag[C]): RDD[(K, C)] = self.withScope &#123;</div><div class="line">   require(mergeCombiners != null, &quot;mergeCombiners must be defined&quot;) // required as of Spark 0.9.0</div><div class="line">   if (keyClass.isArray) &#123;</div><div class="line">     if (mapSideCombine) &#123;</div><div class="line">       throw new SparkException(&quot;Cannot use map-side combining with array keys.&quot;)</div><div class="line">     &#125;</div><div class="line">     if (partitioner.isInstanceOf[HashPartitioner]) &#123;</div><div class="line">       throw new SparkException(&quot;Default partitioner cannot partition array keys.&quot;)</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   val aggregator = new Aggregator[K, V, C](</div><div class="line">     self.context.clean(createCombiner),  //设置句聚合函数</div><div class="line">     self.context.clean(mergeValue),   //valueMrege函数</div><div class="line">     self.context.clean(mergeCombiners)) // 最终结果的整合函数</div><div class="line">   if (self.partitioner == Some(partitioner)) &#123;</div><div class="line">   //不存在自定义分区</div><div class="line">     self.mapPartitions(iter =&gt; &#123;</div><div class="line">       val context = TaskContext.get()</div><div class="line">       new InterruptibleIterator(context, aggregator.combineValuesByKey(iter, context))</div><div class="line">     &#125;, preservesPartitioning = true)</div><div class="line">   &#125; else &#123;</div><div class="line">   //不存在自定义分区</div><div class="line">     new ShuffledRDD[K, V, C](self, partitioner)</div><div class="line">       .setSerializer(serializer)</div><div class="line">       .setAggregator(aggregator)</div><div class="line">       .setMapSideCombine(mapSideCombine)</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> .......</div><div class="line"> </div><div class="line"> override def getDependencies: Seq[Dependency[_]] = &#123;</div><div class="line">   val serializer = userSpecifiedSerializer.getOrElse &#123;</div><div class="line">     val serializerManager = SparkEnv.get.serializerManager</div><div class="line">     if (mapSideCombine) &#123;</div><div class="line">       serializerManager.getSerializer(implicitly[ClassTag[K]], implicitly[ClassTag[C]])</div><div class="line">     &#125; else &#123;</div><div class="line">       serializerManager.getSerializer(implicitly[ClassTag[K]], implicitly[ClassTag[V]])</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   //</div><div class="line">   List(new ShuffleDependency(prev, part, serializer, keyOrdering, aggregator, mapSideCombine))</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>reduce流程可以总结为<br>1、将分区包装秤HashPartitioner分区<br>2、如果没有自定义分区则，直接执行combineCombinersByKey<br>3、  如果有自定义分区，则对shuffle自行combineCombinersByKey</p>
<p>下面我们先看MapPartitionsRDD，我把和别的RDD有别的两行给拿出来了，很明显的区别，f方法是套在iterator的外边，这样才能对iterator的所有数据做一个合并。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> override val partitioner = if (preservesPartitioning) firstParent[T].partitioner else None</div><div class="line">  override def compute(split: Partition, context: TaskContext) =</div><div class="line">    f(context, split.index, firstParent[T].iterator(split, context))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们看Aggregator的combineValuesByKey的方法吧。</p>
<p>def combineValuesByKey(iter: Iterator[_ &lt;: Product2[K, V]],<br>                         context: TaskContext): Iterator[(K, C)] = {<br>    // 是否使用外部排序，是由参数spark.shuffle.spill，默认是true<br>    if (!externalSorting) {<br>      val combiners = new AppendOnlyMap[K,C]<br>      var kv: Product2[K, V] = null<br>      val update = (hadValue: Boolean, oldValue: C) =&gt; {<br>        if (hadValue) mergeValue(oldValue, kv._2) else createCombiner(kv.<em>2)<br>      }<br>      // 用map来去重，用update方法来更新值，如果没值的时候，返回值，如果有值的时候，通过mergeValue方法来合并<br>      // mergeValue方法就是我们在reduceByKey里面写的那个匿名函数，在这里就是（</em> + _）<br>      while (iter.hasNext) {<br>        kv = iter.next()<br>        combiners.changeValue(kv._1, update)<br>      }<br>      combiners.iterator<br>    } else {<br>      // 用了一个外部排序的map来去重，就不停的往里面插入值即可，基本原理和上面的差不多，区别在于需要外部排序<br>      val combiners = new ExternalAppendOnlyMap<a href="createCombiner, mergeValue, mergeCombiners">K, V, C</a><br>      while (iter.hasNext) {<br>        val (k, v) = iter.next()<br>        combiners.insert(k, v)<br>      }<br>      combiners.iterator<br>}</p>
<p>这个就是一个很典型的按照key来做合并的方法了，我们继续看ShuffledRDD吧。</p>
<p>ShuffledRDD和之前的RDD很明显的特征是</p>
<p>1、它的依赖传了一个Nil（空列表）进去，表示它没有依赖。<br>2、它的compute计算方式比较特别，这个在之后的文章说，过程比较复杂。<br>3、它的分片默认是采用HashPartitioner，数量和前面的RDD的分片数量一样，也可以不一样，我们可以在reduceByKey的时候多传一个分片数量即可。</p>
<p>在new完ShuffledRDD之后又来了一遍mapPartitionsWithContext，不过调用的匿名函数变成了combineCombinersByKey。</p>
<p>combineCombinersByKey和combineValuesByKey的逻辑基本相同，只是输入输出的类型有区别。combineCombinersByKey只是做单纯的合并，不会对输入输出的类型进行改变，combineValuesByKey会把iter[K, V]的V值变成iter[K, C]。</p>
<p>case class Aggregator[K, V, C] (<br>　　createCombiner: V =&gt; C,<br>　　mergeValue: (C, V) =&gt; C,<br>　　mergeCombiners: (C, C) =&gt; C)<br>　　……<br>}<br>复制代码</p>
<p>这个方法会根据我们传进去的匿名方法的参数的类型做一个自动转换。<br>到这里，作业都没有真正执行，只是将RDD各种嵌套，我们通过RDD的id和类型的变化观测到这一点，RDD[1]-&gt;RDD[2]-&gt;RDD[3]……</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Spark源码一】spark-submit提交作业过程]]></title>
      <url>https://fudawei.github.io/2016/09/27/%5BSpark%E6%BA%90%E7%A0%81%E4%B8%80%5Dspark-submit%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/</url>
      <content type="html"><![CDATA[<p>使用spark已经有一段时间了，今天开始读spark源码。<br>首先从spark提交作业开始。下图为spark的架构，以及Spark的APP运行图。它通过一个Driver来和集群通信，集群负责作业的分配。今天我要讲的是如何创建这个Driver Program的过程。</p>
<p><img src="/img/spark_architecture.png" alt=""><br>这个是Spark的App运行图，它通过一个Driver来和集群通信，集群负责作业的分配。今天我要讲的是如何创建这个Driver Program的过程。</p>
<h1 id="作业提交"><a href="#作业提交" class="headerlink" title="作业提交"></a>作业提交</h1><p>作业提交方法以及参数<br>我们先看一下用Spark Submit提交的方法吧，下面是从官方上面摘抄的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> Run on a Spark standalone cluster</div><div class="line">./bin/spark-submit \</div><div class="line">  --class org.apache.spark.examples.SparkPi \</div><div class="line">  --master spark://207.184.161.138:7077 \</div><div class="line">  --executor-memory 20G \</div><div class="line">  --total-executor-cores 100 \</div><div class="line">  /path/to/examples.jar \</div><div class="line">  1000</div></pre></td></tr></table></figure>
<p>这个是提交到standalone集群的方式，打开spark-submit这文件，我们会发现它最后是调用了org.apache.spark.deploy.SparkSubmit这个类。</p>
<p>直接打开这个类，找到main入口，发现代码很简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def main(args: Array[String]): Unit = &#123;</div><div class="line">   val appArgs = new SparkSubmitArguments(args)</div><div class="line">   if (appArgs.verbose) &#123;</div><div class="line">     // scalastyle:off println</div><div class="line">     printStream.println(appArgs)</div><div class="line">     // scalastyle:on println</div><div class="line">   &#125;</div><div class="line">   appArgs.action match &#123;</div><div class="line">     case SparkSubmitAction.SUBMIT =&gt; submit(appArgs)</div><div class="line">     case SparkSubmitAction.KILL =&gt; kill(appArgs)</div><div class="line">     case SparkSubmitAction.REQUEST_STATUS =&gt; requestStatus(appArgs)</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>该方法做两件事：<br>1、这里SparkSubmitArguments类初始化过程将会加载spark默认配置文件的配置信息、运行环境信息，另外会将提交的参数覆盖默认配置（并且校验参数的合法性）<br>2、通过反射调用class主方法</p>
<p>有兴趣可以看一下SparkSubmitArguments，一下为默认环境配置信息的代码（loadEnvironmentArguments()方法内部）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">master = Option(master)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.master&quot;))</div><div class="line">      .orElse(env.get(&quot;MASTER&quot;))</div><div class="line">      .orNull</div><div class="line">    driverExtraClassPath = Option(driverExtraClassPath)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.driver.extraClassPath&quot;))</div><div class="line">      .orNull</div><div class="line">    driverExtraJavaOptions = Option(driverExtraJavaOptions)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.driver.extraJavaOptions&quot;))</div><div class="line">      .orNull</div><div class="line">    driverExtraLibraryPath = Option(driverExtraLibraryPath)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.driver.extraLibraryPath&quot;))</div><div class="line">      .orNull</div><div class="line">    driverMemory = Option(driverMemory)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.driver.memory&quot;))</div><div class="line">      .orElse(env.get(&quot;SPARK_DRIVER_MEMORY&quot;))</div><div class="line">      .orNull</div><div class="line">    driverCores = Option(driverCores)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.driver.cores&quot;))</div><div class="line">      .orNull</div><div class="line">    executorMemory = Option(executorMemory)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.executor.memory&quot;))</div><div class="line">      .orElse(env.get(&quot;SPARK_EXECUTOR_MEMORY&quot;))</div><div class="line">      .orNull</div><div class="line">    executorCores = Option(executorCores)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.executor.cores&quot;))</div><div class="line">      .orElse(env.get(&quot;SPARK_EXECUTOR_CORES&quot;))</div><div class="line">      .orNull</div><div class="line">    totalExecutorCores = Option(totalExecutorCores)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.cores.max&quot;))</div><div class="line">      .orNull</div><div class="line">    name = Option(name).orElse(sparkProperties.get(&quot;spark.app.name&quot;)).orNull</div><div class="line">    jars = Option(jars).orElse(sparkProperties.get(&quot;spark.jars&quot;)).orNull</div><div class="line">    ivyRepoPath = sparkProperties.get(&quot;spark.jars.ivy&quot;).orNull</div><div class="line">    packages = Option(packages).orElse(sparkProperties.get(&quot;spark.jars.packages&quot;)).orNull</div><div class="line">    packagesExclusions = Option(packagesExclusions)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.jars.excludes&quot;)).orNull</div><div class="line">    deployMode = Option(deployMode).orElse(env.get(&quot;DEPLOY_MODE&quot;)).orNull</div><div class="line">    numExecutors = Option(numExecutors)</div><div class="line">      .getOrElse(sparkProperties.get(&quot;spark.executor.instances&quot;).orNull)</div><div class="line">    keytab = Option(keytab).orElse(sparkProperties.get(&quot;spark.yarn.keytab&quot;)).orNull</div><div class="line">    principal = Option(principal).orElse(sparkProperties.get(&quot;spark.yarn.principal&quot;)).orNull</div></pre></td></tr></table></figure></p>
<p>……</p>
<h1 id="提交流程"><a href="#提交流程" class="headerlink" title="提交流程"></a>提交流程</h1><p>Driver程序的部署模式有两种，client和cluster，默认是client。client的话默认就是直接在本地运行了Driver程序了，cluster模式还会兜一圈把作业发到集群上面去运行。(指定部署模式需要用参数–deploy-mode来指定，或者在环境变量当中添加DEPLOY_MODE变量来指定。)</p>
<p>下面讲的是cluster的部署方式，兜一圈的这种情况。</p>
<p>yarn模式的话mainClass是org.apache.spark.deploy.yarn.Client，standalone的mainClass是org.apache.spark.deploy.Client。<br>这次我们讲org.apache.spark.deploy.Client，yarn的话有时间单独讲，目前超哥还是推荐使用standalone的方式部署spark，具体原因不详，据说是因为资源调度方面的问题。</p>
<h1 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h1><p>我们首先看一下Client的实现，首先找到这个类。<br>main函数中主要有一下几行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val rpcEnv = RpcEnv.create(&quot;driverClient&quot;, Utils.localHostName(), 0, conf, new  SecurityManager(conf))</div><div class="line">val masterEndpoints = driverArgs.masters.map(RpcAddress.fromSparkURL).</div><div class="line">      map(rpcEnv.setupEndpointRef(_, Master.ENDPOINT_NAME))</div><div class="line">rpcEnv.setupEndpoint(&quot;client&quot;, new ClientEndpoint(rpcEnv, driverArgs, masterEndpoints, conf))</div><div class="line">rpcEnv.awaitTermination()</div></pre></td></tr></table></figure></p>
<pre><code>这里看到一个rpcEnv，最后还调用了awaitTermination()方法，好像时启动了什么。另外Client继承了RpcEndpoint（ThreadSafeRpcEndpoint），浏览一下RpcEnv和RpcEndpoint的内容，其实就时用做发消息的，之前听说spark用的actor模式，每个进程之间可以看作是一个个独立的实体，他们之间是毫无关联的。但是，他们可以通过消息来通信。所有的任务都是通过消息通信完成。据说spark使用的是akka框架，但RpcEnv和RpcEndpoint没看到akka的实现，只有netty的实现，有可能spark已经讲akka实现移除了。至于actor模型有兴趣大家可自行百度。
</code></pre><p><strong>为了便于阅读源码我们看一下RpcEndpoint中比较重要的几个函数：</strong><br>onStart()             //rpcEndpoint启动时执行的操作<br>onStop()              //rpcEndpoint停止时执行的操作<br>receive()             //接受并处理RpcEndpointRef.send发送的信息<br>receiveAndReply()     //接受并处理RpcEndpointRef.ask发送的信息</p>
<p>接下来看一下启动时client做了那些操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">override def onStart(): Unit = &#123;</div><div class="line">   driverArgs.cmd match &#123;</div><div class="line">     case &quot;launch&quot; =&gt;</div><div class="line">       // TODO: We could add an env variable here and intercept it in `sc.addJar` that would</div><div class="line">       //       truncate filesystem paths similar to what YARN does. For now, we just require</div><div class="line">       //       people call `addJar` assuming the jar is in the same directory.</div><div class="line">       val mainClass = &quot;org.apache.spark.deploy.worker.DriverWrapper&quot;</div><div class="line"></div><div class="line">       val classPathConf = &quot;spark.driver.extraClassPath&quot;</div><div class="line">       val classPathEntries = sys.props.get(classPathConf).toSeq.flatMap &#123; cp =&gt;</div><div class="line">         cp.split(java.io.File.pathSeparator)</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       val libraryPathConf = &quot;spark.driver.extraLibraryPath&quot;</div><div class="line">       val libraryPathEntries = sys.props.get(libraryPathConf).toSeq.flatMap &#123; cp =&gt;</div><div class="line">         cp.split(java.io.File.pathSeparator)</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       val extraJavaOptsConf = &quot;spark.driver.extraJavaOptions&quot;</div><div class="line">       val extraJavaOpts = sys.props.get(extraJavaOptsConf)</div><div class="line">         .map(Utils.splitCommandString).getOrElse(Seq.empty)</div><div class="line">       val sparkJavaOpts = Utils.sparkJavaOpts(conf)</div><div class="line">       val javaOpts = sparkJavaOpts ++ extraJavaOpts</div><div class="line">       val command = new Command(mainClass,</div><div class="line">         Seq(&quot;&#123;&#123;WORKER_URL&#125;&#125;&quot;, &quot;&#123;&#123;USER_JAR&#125;&#125;&quot;, driverArgs.mainClass) ++ driverArgs.driverOptions,</div><div class="line">         sys.env, classPathEntries, libraryPathEntries, javaOpts)</div><div class="line"></div><div class="line">       val driverDescription = new DriverDescription(</div><div class="line">         driverArgs.jarUrl,</div><div class="line">         driverArgs.memory,</div><div class="line">         driverArgs.cores,</div><div class="line">         driverArgs.supervise,</div><div class="line">         command)</div><div class="line">       ayncSendToMasterAndForwardReply[SubmitDriverResponse](</div><div class="line">         RequestSubmitDriver(driverDescription))</div><div class="line"></div><div class="line">     case &quot;kill&quot; =&gt;</div><div class="line">       val driverId = driverArgs.driverId</div><div class="line">       ayncSendToMasterAndForwardReply[KillDriverResponse](RequestKillDriver(driverId))</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>从上面的代码看得出来，它需要设置master的连接地址，最后提交了一个RequestSubmitDriver的信息。在receive方法里面，就是等待接受回应了，有两个Response分别对应着这里的launch和kill。这里发送的message信息是RequestSubmitDriver，顺便看一下ayncSendToMasterAndForwardReply实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private def ayncSendToMasterAndForwardReply[T: ClassTag](message: Any): Unit = &#123;</div><div class="line">   for (masterEndpoint &lt;- masterEndpoints) &#123;</div><div class="line">     masterEndpoint.ask[T](message).onComplete &#123;</div><div class="line">       case Success(v) =&gt; self.send(v)</div><div class="line">       case Failure(e) =&gt;</div><div class="line">         logWarning(s&quot;Error sending messages to master $masterEndpoint&quot;, e)</div><div class="line">     &#125;(forwardMessageExecutionContext)</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>注意：这里调用的是masterEndpoint.ask.</p>
<p><strong>小结：</strong></p>
<p>Client通过实现rpc框架实现了请求、接收请求、传递的消息、注册的地址和端口这些功能。</p>
<h1 id="Master端"><a href="#Master端" class="headerlink" title="Master端"></a>Master端</h1><p>接下来我们继续看Master段的代码</p>
<p>Master类同样继承了RpcEndpoint。Client端发送消息使用的时ask所以我们看一下receiveAndReply函数，找一下对应的消息接受处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = &#123;</div><div class="line"> case RequestSubmitDriver(description) =&gt;</div><div class="line">      if (state != RecoveryState.ALIVE) &#123;</div><div class="line">        val msg = s&quot;$&#123;Utils.BACKUP_STANDALONE_MASTER_PREFIX&#125;: $state. &quot; +</div><div class="line">          &quot;Can only accept driver submissions in ALIVE state.&quot;</div><div class="line">        context.reply(SubmitDriverResponse(self, false, None, msg))</div><div class="line">      &#125; else &#123;</div><div class="line">        logInfo(&quot;Driver submitted &quot; + description.command.mainClass)</div><div class="line">        val driver = createDriver(description)</div><div class="line">        persistenceEngine.addDriver(driver)</div><div class="line">        waitingDrivers += driver</div><div class="line">        drivers.add(driver)</div><div class="line">        //调度</div><div class="line">        schedule()</div><div class="line">        // 告诉client，提交成功了，把driver.id告诉它</div><div class="line">        context.reply(SubmitDriverResponse(self, true, Some(driver.id),</div><div class="line">          s&quot;Driver successfully submitted as $&#123;driver.id&#125;&quot;))</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>接下来看调度方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">private def schedule(): Unit = &#123;</div><div class="line">  if (state != RecoveryState.ALIVE) &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  // 首先调度Driver程序，从workers里面随机抽一些出来</div><div class="line">  val shuffledAliveWorkers = Random.shuffle(workers.toSeq.filter(_.state == WorkerState.ALIVE))</div><div class="line">  val numWorkersAlive = shuffledAliveWorkers.size</div><div class="line">  var curPos = 0</div><div class="line">  for (driver &lt;- waitingDrivers.toList) &#123; // iterate over a copy of waitingDrivers</div><div class="line">    // We assign workers to each waiting driver in a round-robin fashion. For each driver, we</div><div class="line">    // start from the last worker that was assigned a driver, and continue onwards until we have</div><div class="line">    // explored all alive workers.</div><div class="line">    var launched = false</div><div class="line">    var numWorkersVisited = 0</div><div class="line">    while (numWorkersVisited &lt; numWorkersAlive &amp;&amp; !launched) &#123;</div><div class="line">      val worker = shuffledAliveWorkers(curPos)</div><div class="line">      numWorkersVisited += 1</div><div class="line">      //判断内存和CPU资源是否足够，</div><div class="line">      if (worker.memoryFree &gt;= driver.desc.mem &amp;&amp; worker.coresFree &gt;= driver.desc.cores) &#123;</div><div class="line">        launchDriver(worker, driver)  //向worker发送信息，worker预留内存</div><div class="line">        waitingDrivers -= driver</div><div class="line">        launched = true</div><div class="line">      &#125;</div><div class="line">      curPos = (curPos + 1) % numWorkersAlive</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  //在worker上启动executor</div><div class="line">  startExecutorsOnWorkers()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里仔细看一下worker启动executor的方法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">private def scheduleExecutorsOnWorkers(</div><div class="line">     app: ApplicationInfo,</div><div class="line">     usableWorkers: Array[WorkerInfo],</div><div class="line">     spreadOutApps: Boolean): Array[Int] = &#123;</div><div class="line">   ......</div><div class="line">   ......</div><div class="line">   ......</div><div class="line">   while (freeWorkers.nonEmpty) &#123;</div><div class="line">     freeWorkers.foreach &#123; pos =&gt;</div><div class="line">       var keepScheduling = true</div><div class="line">       while (keepScheduling &amp;&amp; canLaunchExecutor(pos)) &#123;</div><div class="line">         coresToAssign -= minCoresPerExecutor</div><div class="line">         assignedCores(pos) += minCoresPerExecutor</div><div class="line"></div><div class="line">         // If we are launching one executor per worker, then every iteration assigns 1 core</div><div class="line">         // to the executor. Otherwise, every iteration assigns cores to a new executor.</div><div class="line">         if (oneExecutorPerWorker) &#123;</div><div class="line">           assignedExecutors(pos) = 1</div><div class="line">         &#125; else &#123;</div><div class="line">           assignedExecutors(pos) += 1</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         //spreadout 意味着分配executor时会尽可能均匀的分布到所有的worker节点上，否则会想将一个worker的资源分             //配完才会去其他的worker分配executor</div><div class="line">         if (spreadOutApps) &#123;</div><div class="line">           keepScheduling = false</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     freeWorkers = freeWorkers.filter(canLaunchExecutor)</div><div class="line">   &#125;</div><div class="line">   assignedCores</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>它的调度器是这样的，先调度Driver程序，然后再调度App，调度App的方式是从各个worker的里面和App进行匹配，看需要分配多少个cpu。<br>那我们接下来看两个方法launchDriver和launchExecutor即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private def launchDriver(worker: WorkerInfo, driver: DriverInfo) &#123;</div><div class="line">   logInfo(&quot;Launching     &quot; + driver.id + &quot; on worker &quot; + worker.id)</div><div class="line">   worker.addDriver(driver)</div><div class="line">   driver.worker = Some(worker)</div><div class="line">   worker.endpoint.send(LaunchDriver(driver.id, driver.desc))</div><div class="line">   driver.state = DriverState.RUNNING</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>给worker发送了一个LaunchDriver的消息，下面在看launchExecutor的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private def launchExecutor(worker: WorkerInfo, exec: ExecutorDesc): Unit = &#123;</div><div class="line">    logInfo(&quot;Launching executor &quot; + exec.fullId + &quot; on worker &quot; + worker.id)</div><div class="line">    worker.addExecutor(exec)</div><div class="line">    worker.endpoint.send(LaunchExecutor(masterUrl,</div><div class="line">      exec.application.id, exec.id, exec.application.desc, exec.cores, exec.memory))</div><div class="line">    exec.application.driver.send(</div><div class="line">      ExecutorAdded(exec.id, worker.id, worker.hostPort, exec.cores, exec.memory))</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>  它要做的事情多一点，除了给worker发送LaunchExecutor指令外，还需要给driver发送ExecutorAdded的消息，说你的任务已经有人干了。</p>
<p>在继续Worker讲之前，我们先看看它是怎么注册进来的，每个Worker启动之后，会自动去请求Master去注册自己，具体我们可以看receive的方法里面的RegisterWorker这一段，它需要上报自己的内存、Cpu、地址、端口等信息，注册成功之后返回RegisteredWorker信息给它，说已经注册成功了</p>
<h1 id="Worker执行"><a href="#Worker执行" class="headerlink" title="Worker执行"></a>Worker执行</h1><p>同样的，我们到Worker里面在receive方法找LaunchDriver和LaunchExecutor就可以找到我们要的东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">case LaunchDriver(driverId, driverDesc) =&gt;</div><div class="line">      logInfo(s&quot;Asked to launch driver $driverId&quot;)</div><div class="line">      val driver = new DriverRunner(</div><div class="line">        conf,</div><div class="line">        driverId,</div><div class="line">        workDir,</div><div class="line">        sparkHome,</div><div class="line">        driverDesc.copy(command = Worker.maybeUpdateSSLSettings(driverDesc.command, conf)),</div><div class="line">        self,</div><div class="line">        workerUri,</div><div class="line">        securityMgr)</div><div class="line">      drivers(driverId) = driver</div><div class="line">      driver.start()</div><div class="line"></div><div class="line">      coresUsed += driverDesc.cores</div><div class="line">      memoryUsed += driverDesc.mem</div></pre></td></tr></table></figure>
<p>这里运行LaunchDriver时，只是预分配了内存和CPU资源，接下来看一下start方法吧，start方法里面，其实是new Thread().start()，run方法里面是通过传过来的DriverDescription构造的一个命令，丢给ProcessBuilder去执行命令，结束之后调用。</p>
<p>worker ！DriverStateChanged通知worker，worker再通过master ! DriverStateChanged通知master，释放掉worker的cpu和内存。</p>
<p>接下来看一下看一下LaunchExecutor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">case LaunchExecutor(masterUrl, appId, execId, appDesc, cores_, memory_) =&gt;</div><div class="line">     if (masterUrl != activeMasterUrl) &#123;</div><div class="line">       logWarning(&quot;Invalid Master (&quot; + masterUrl + &quot;) attempted to launch executor.&quot;)</div><div class="line">     &#125; else &#123;</div><div class="line">       try &#123;</div><div class="line">         logInfo(&quot;Asked to launch executor %s/%d for %s&quot;.format(appId, execId, appDesc.name))</div><div class="line"></div><div class="line">         // Create the executor&apos;s working directory</div><div class="line">         val executorDir = new File(workDir, appId + &quot;/&quot; + execId)</div><div class="line">         if (!executorDir.mkdirs()) &#123;</div><div class="line">           throw new IOException(&quot;Failed to create directory &quot; + executorDir)</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         // Create local dirs for the executor. These are passed to the executor via the</div><div class="line">         // SPARK_EXECUTOR_DIRS environment variable, and deleted by the Worker when the</div><div class="line">         // application finishes.</div><div class="line">         val appLocalDirs = appDirectories.getOrElse(appId,</div><div class="line">           Utils.getOrCreateLocalRootDirs(conf).map &#123; dir =&gt;</div><div class="line">             val appDir = Utils.createDirectory(dir, namePrefix = &quot;executor&quot;)</div><div class="line">             Utils.chmod700(appDir)</div><div class="line">             appDir.getAbsolutePath()</div><div class="line">           &#125;.toSeq)</div><div class="line">         appDirectories(appId) = appLocalDirs</div><div class="line">         val manager = new ExecutorRunner(</div><div class="line">           appId,</div><div class="line">           execId,</div><div class="line">           appDesc.copy(command = Worker.maybeUpdateSSLSettings(appDesc.command, conf)),</div><div class="line">           cores_,</div><div class="line">           memory_,</div><div class="line">           self,</div><div class="line">           workerId,</div><div class="line">           host,</div><div class="line">           webUi.boundPort,</div><div class="line">           publicAddress,</div><div class="line">           sparkHome,</div><div class="line">           executorDir,</div><div class="line">           workerUri,</div><div class="line">           conf,</div><div class="line">           appLocalDirs, ExecutorState.RUNNING)</div><div class="line">         executors(appId + &quot;/&quot; + execId) = manager</div><div class="line">         manager.start()</div><div class="line">         coresUsed += cores_</div><div class="line">         memoryUsed += memory_</div><div class="line">         sendToMaster(ExecutorStateChanged(appId, execId, manager.state, None, None))</div><div class="line">       &#125; catch &#123;</div><div class="line">         case e: Exception =&gt;</div><div class="line">           logError(s&quot;Failed to launch executor $appId/$execId for $&#123;appDesc.name&#125;.&quot;, e)</div><div class="line">           if (executors.contains(appId + &quot;/&quot; + execId)) &#123;</div><div class="line">             executors(appId + &quot;/&quot; + execId).kill()</div><div class="line">             executors -= appId + &quot;/&quot; + execId</div><div class="line">           &#125;</div><div class="line">           sendToMaster(ExecutorStateChanged(appId, execId, ExecutorState.FAILED,</div><div class="line">             Some(e.toString), None))</div><div class="line">       &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>﻿同理，LaunchExecutor执行完毕了，通过worker ! ExecutorStateChanged通知worker，然后worker通过master ! ExecutorStateChanged通知master，释放掉worker的cpu和内存。</p>
<p>下面我们再梳理一下这个过程，只包括Driver注册，Driver运行之后的过程在之后的文章再说，比较复杂。</p>
<p>1、Client通过获得Url地址获得RpcEndPointRef（master的actor引用）,然后通过RpcEndPointRef给Master发送注册Driver请求（RequestSubmitDriver）<br>2、Master接收到请求之后就开始调度了，从workers列表里面找出可以用的Worker<br>3、通过Worker的actor引用RpcEndPointRef给可用的Worker发送启动Driver请求（LaunchDriver）<br>4、调度完毕之后，给Client回复注册成功消息(SubmitDriverResponse)<br>5、Worker接收到LaunchDriver请求之后，通过传过来的DriverDescription的信息构造出命令来，通过ProcessBuilder执行<br>6、ProcessBuilder执行完命令之后，通过DriverStateChanged通过Worker<br>7、Worker最后把DriverStateChanged汇报给Master</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis数据结构和对象-(一)简单动态字符串]]></title>
      <url>https://fudawei.github.io/2016/09/25/Redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%AF%B9%E8%B1%A1--%EF%BC%88%E4%B8%80%EF%BC%89%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h1 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h1><p>Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。</p>
<p>在 Redis 里面， C 字符串只会作为字符串字面量（string literal）， 用在一些无须对字符串值进行修改的地方， 比如打印日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; redisLog(REDIS_WARNING,&quot;Redis is now ready to exit, bye bye...&quot;);</div></pre></td></tr></table></figure>
<p>当 Redis 需要的不仅仅是一个字符串字面量， 而是一个可以被修改的字符串值时， Redis 就会使用 SDS 来表示字符串值： 比如在 Redis 的数据库里面， 包含字符串值的键值对在底层都是由 SDS 实现的。</p>
<p>举个例子， 如果客户端执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET msg &quot;hello world&quot;</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>那么 Redis 将在数据库中创建了一个新的键值对， 其中：</p>
<p>键值对的键是一个字符串对象， 对象的底层实现是一个保存着字符串 “msg” 的 SDS 。<br>键值对的值也是一个字符串对象， 对象的底层实现是一个保存着字符串 “hello world” 的 SDS 。<br>又比如说， 如果客户端执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis&gt; RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</div><div class="line">(integer) 3</div></pre></td></tr></table></figure>
<p>那么 Redis 将在数据库中创建一个新的键值对， 其中：</p>
<p>键值对的键是一个字符串对象， 对象的底层实现是一个保存了字符串 “fruits” 的 SDS 。<br>键值对的值是一个列表对象， 列表对象包含了三个字符串对象， 这三个字符串对象分别由三个 SDS 实现： 第一个 SDS 保存着字符串 “apple” ， 第二个 SDS 保存着字符串 “banana” ， 第三个 SDS 保存着字符串 “cherry” 。<br>除了用来保存数据库中的字符串值之外， SDS 还被用作缓冲区（buffer）： AOF 模块中的 AOF 缓冲区， 以及客户端状态中的输入缓冲区， 都是由 SDS 实现的， 在之后介绍 AOF 持久化和客户端状态的时候， 我们会看到 SDS 在这两个模块中的应用。</p>
<h2 id="SDS-的定义"><a href="#SDS-的定义" class="headerlink" title="SDS 的定义"></a>SDS 的定义</h2><p>每个 sds.h/sdshdr 结构表示一个 SDS 值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">struct sdshdr &#123;</div><div class="line"></div><div class="line">    // 记录 buf 数组中已使用字节的数量</div><div class="line">    // 等于 SDS 所保存字符串的长度</div><div class="line">    int len;</div><div class="line"></div><div class="line">    // 记录 buf 数组中未使用字节的数量</div><div class="line">    int free;</div><div class="line"></div><div class="line">    // 字节数组，用于保存字符串</div><div class="line">    char buf[];</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>图 2-1 展示了一个 SDS 示例：</p>
<ul>
<li>free 属性的值为 0 ， 表示这个 SDS 没有分配任何未使用空间。</li>
<li>len 属性的值为 5 ， 表示这个 SDS 保存了一个五字节长的字符串。</li>
<li>buf 属性是一个 char 类型的数组， 数组的前五个字节分别保存了 ‘R’ 、 ‘e’ 、 ‘d’ 、 ‘i’ 、 ‘s’ 五个字符， 而最后一个字节则保存了空字符 ‘\0’ 。</li>
</ul>
<p><img src="/img/sds1.png" alt=""></p>
<p>SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面， 并且为空字符分配额外的 1 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的， 所以这个空字符对于 SDS 的使用者来说是完全透明的。</p>
<p>遵循空字符结尾这一惯例的好处是， SDS 可以直接重用一部分 C 字符串函数库里面的函数。</p>
<p>举个例子， 如果我们有一个指向图 2-1 所示 SDS 的指针 s ， 那么我们可以直接使用 stdio.h/printf 函数， 通过执行以下语句：</p>
<p>printf(“%s”, s-&gt;buf);<br>来打印出 SDS 保存的字符串值 “Redis” ， 而无须为 SDS 编写专门的打印函数。</p>
<p>图 2-2 展示了另一个 SDS 示例:</p>
<ul>
<li>这个 SDS 和之前展示的 SDS 一样， 都保存了字符串值 “Redis” 。</li>
<li>这个 SDS 和之前展示的 SDS 的区别在于， 这个 SDS 为 buf 数组分配了五字节未使用空间， 所以它的 free 属性的值为 5 （图中使用五个空格来表示五字节的未使用空间）。</li>
</ul>
<p><img src="/img/sds-2.png" alt=""></p>
<p>接下来的详细地说明未使用空间在 SDS 中的作用。</p>
<h2 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h2><p>根据传统， C 语言使用长度为 N+1 的字符数组来表示长度为 N 的字符串， 并且字符数组的最后一个元素总是空字符 ‘\0’ 。</p>
<p>比如说， 图 2-3 就展示了一个值为 “Redis” 的 C 字符串：<br><img src="/img/sds-2.png" alt=""></p>
<p>C 语言使用的这种简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求， 本节接下来的内容将详细对比 C 字符串和 SDS 之间的区别， 并说明 SDS 比 C 字符串更适用于 Redis 的原因。</p>
<p><em>常数复杂度获取字符串长度</em></p>
<p>因为 C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 O(N) 。</p>
<p>举个例子， 图 2-4 展示了程序计算一个 C 字符串长度的过程。</p>
<p><img src="/img/sds-c-1.png" alt=""><br><img src="/img/sds-c-2.png" alt=""><br><img src="/img/sds-c-3.png" alt=""><br><img src="/img/sds-c-4.png" alt=""><br><img src="/img/sds-c-5.png" alt=""><br><img src="/img/sds-c-6.png" alt=""></p>
<p>和 C 字符串不同， 因为 SDS 在 len 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1) 。</p>
<p>举个例子， 对于图 2-5 所示的 SDS 来说， 程序只要访问 SDS 的 len 属性， 就可以立即知道 SDS 的长度为 5 字节：<br><img src="/img/sds-c-7.png" alt=""></p>
<p>又比如说， 对于图 2-6 展示的 SDS 来说， 程序只要访问 SDS 的 len 属性， 就可以立即知道 SDS 的长度为 11 字节。![]<img src="/img/sds-c-8.png" alt=""></p>
<p>置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的， 使用 SDS 无须进行任何手动修改长度的工作。</p>
<p>通过使用 SDS 而不是 C 字符串， Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1) ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈。</p>
<p>比如说， 因为字符串键在底层使用 SDS 来实现， 所以即使我们对一个非常长的字符串键反复执行 STRLEN 命令， 也不会对系统性能造成任何影响， 因为 STRLEN 命令的复杂度仅为 O(1) 。</p>
<p><em>杜绝缓冲区溢出</em></p>
<p>除了获取字符串长度的复杂度高之外， C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。</p>
<p>举个例子， <string.h>/strcat 函数可以将 src 字符串中的内容拼接到 dest 字符串的末尾：</string.h></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">char *strcat(char *dest, const char *src);</div><div class="line"></div><div class="line">```因为 C 字符串不记录自身的长度， 所以 strcat 假定用户在执行这个函数时， 已经为 dest 分配了足够多的内存， 可以容纳 src 字符串中的所有内容， 而一旦这个假定不成立时， 就会产生缓冲区溢出。</div><div class="line"></div><div class="line">举个例子， 假设程序里有两个在内存中紧邻着的 C 字符串 s1 和 s2 ， 其中 s1 保存了字符串 &quot;Redis&quot; ， 而 s2 则保存了字符串 &quot;MongoDB&quot;， 如图 2-7 所示。</div><div class="line">![](/img/sds-c-9.png)</div><div class="line"></div><div class="line">如果一个程序员决定通过执行：</div></pre></td></tr></table></figure>
<p>strcat(s1, “ Cluster”);<br>```<br>将 s1 的内容修改为 “Redis Cluster” ， 但粗心的他却忘了在执行 strcat 之前为 s1 分配足够的空间， 那么在 strcat 函数执行之后， s1 的数据将溢出到 s2 所在的空间中， 导致 s2 保存的内容被意外地修改， 如图 2-8 所示。<br><img src="/img/sds-c-9.png" alt=""></p>
<p>与 C 字符串不同， SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性： 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。</p>
<p>举个例子， SDS 的 API 里面也有一个用于执行拼接操作的 sdscat 函数， 它可以将一个 C 字符串拼接到给定 SDS 所保存的字符串的后面， 但是在执行拼接操作之前， sdscat 会先检查给定 SDS 的空间是否足够， 如果不够的话， sdscat 就会先扩展 SDS 的空间， 然后才执行拼接操作。</p>
<p>比如说， 如果我们执行：</p>
<p>sdscat(s, “ Cluster”);<br>其中 SDS 值 s 如图 2-9 所示， 那么 sdscat 将在执行拼接操作之前检查 s 的长度是否足够， 在发现 s 目前的空间不足以拼接 “ Cluster”之后， sdscat 就会先扩展 s 的空间， 然后才执行拼接 “ Cluster” 的操作， 拼接操作完成之后的 SDS 如图 2-10 所示。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis数据结构和对象-(四)整数集合]]></title>
      <url>https://fudawei.github.io/2016/09/24/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%AF%B9%E8%B1%A1--%EF%BC%88%E5%9B%9B%EF%BC%89%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p>
<p>举个例子， 如果我们创建一个只包含五个元素的集合键， 并且集合中的所有元素都是整数值， 那么这个集合键的底层实现就会是整数集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">redis&gt; SADD numbers 1 3 5 7 9</div><div class="line">(integer) 5</div><div class="line"></div><div class="line">redis&gt; OBJECT ENCODING numbers</div><div class="line">&quot;intset&quot;</div></pre></td></tr></table></figure>
<p>下面将对整数集合及其相关操作的实现原理进行介绍。</p>
<h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。</p>
<p>每个 intset.h/intset 结构表示一个整数集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct intset &#123;</div><div class="line"></div><div class="line">    // 编码方式</div><div class="line">    uint32_t encoding;</div><div class="line"></div><div class="line">    // 集合包含的元素数量</div><div class="line">    uint32_t length;</div><div class="line"></div><div class="line">    // 保存元素的数组</div><div class="line">    int8_t contents[];</div><div class="line"></div><div class="line">&#125; intset;</div></pre></td></tr></table></figure></p>
<p>contents 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
<p>length 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。</p>
<p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值：</p>
<ul>
<li>如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是 一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。</li>
<li>如果 encoding 属性的值为 INTSET_ENC_INT32 ， 那么 contents 就是一个 int32_t 类型的数组， 数组里的每个项都是 一个 int32_t 类型的整数值 （最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ）。</li>
<li>如果 encoding 属性的值为 INTSET_ENC_INT64 ， 那么 contents 就是一个 int64_t 类型的数组， 数组里的每个项都是一个 int64_t 类型的整数值 （最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ）。</li>
</ul>
<p>图 6-1 展示了一个整数集合示例：</p>
<ul>
<li>encoding 属性的值为 INTSET_ENC_INT16 ， 表示整数集合的底层实现为 int16_t 类型的数组， 而集合保存的都是 int16_t 类型的整数值。</li>
<li>length 属性的值为 5 ， 表示整数集合包含五个元素。</li>
<li>contents 数组按从小到大的顺序保存着集合中的五个元素。<br>因为每个集合元素都是 int16_t 类型的整数值， 所以 contents 数组的大小等于 sizeof(int16_t) <em> 5 = 16 </em> 5 = 80 位。<br><img src="/img/intlist-1.png" alt=""></li>
</ul>
<p>图 6-2 展示了另一个整数集合示例：</p>
<ul>
<li>encoding 属性的值为 INTSET_ENC_INT64 ， 表示整数集合的底层实现为 int64_t 类型的数组， 而数组中保存的都是 int64_t 类型的整数值。</li>
<li>length 属性的值为 4 ， 表示整数集合包含四个元素。</li>
<li>contents 数组按从小到大的顺序保存着集合中的四个元素。<br>因为每个集合元素都是 int64_t 类型的整数值， 所以 contents 数组的大小为 sizeof(int64_t) <em> 4 = 64 </em> 4 = 256 位。<br><img src="/img/intlist-2.png" alt=""></li>
</ul>
<p>虽然 contents 数组保存的四个整数值中， 只有 -2675256175807981027 是真正需要用 int64_t 类型来保存的， 而其他的 1 、 3 、 5 三个值都可以用 int16_t 类型来保存， 不过根据整数集合的升级规则， 当向一个底层为 int16_t 数组的整数集合添加一个 int64_t 类型的整数值时， 整数集合已有的所有元素都会被转换成 int64_t 类型， 所以 contents 数组保存的四个整数值都是 int64_t 类型的， 不仅仅是-2675256175807981027 。</p>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<ul>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ul>
<p>举个例子， 假设现在有一个 INTSET_ENC_INT16 编码的整数集合， 集合中包含三个 int16_t 类型的元素， 如图 6-3 所示<br><img src="/img/intlist-3.png" alt=""></p>
<p>因为每个元素都占用 16 位空间， 所以整数集合底层数组的大小为 3 * 16 = 48 位， 图 6-4 展示了整数集合的三个元素在这 48 位里的位置。<br><img src="/img/intlist-4.png" alt=""></p>
<p>现在， 假设我们要将类型为 int32_t 的整数值 65535 添加到整数集合里面， 因为 65535 的类型 int32_t 比整数集合当前所有元素的类型都要长， 所以在将 65535 添加到整数集合之前， 程序需要先对整数集合进行升级。</p>
<p>升级首先要做的是， 根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配。</p>
<p>整数集合目前有三个元素， 再加上新元素 65535 ， 整数集合需要分配四个元素的空间， 因为每个 int32_t 整数值需要占用 32 位空间， 所以在空间重分配之后， 底层数组的大小将是 32 * 4 = 128 位， 如图 6-5 所示。<br><img src="/img/intlist-5.png" alt=""></p>
<p>然程序对底层数组进行了空间重分配， 但数组原有的三个元素 1 、 2 、 3 仍然是 int16_t 类型， 这些元素还保存在数组的前 48 位里面， 所以程序接下来要做的就是将这三个元素转换成 int32_t 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。</p>
<p>首先， 因为元素 3 在 1 、 2 、 3 、 65535 四个元素中排名第三， 所以它将被移动到 contents 数组的索引 2 位置上， 也即是数组 64 位至 95 位的空间内， 如图 6-6 所示。</p>
<p><img src="/img/intlist-6.png" alt=""></p>
<p>接着， 因为元素 2 在 1 、 2 、 3 、 65535 四个元素中排名第二， 所以它将被移动到 contents 数组的索引 1 位置上， 也即是数组的 32位至 63 位的空间内， 如图 6-7 所示。</p>
<p><img src="/img/intlist-7.png" alt=""></p>
<p>之后， 因为元素 1 在 1 、 2 、 3 、 65535 四个元素中排名第一， 所以它将被移动到 contents 数组的索引 0 位置上， 也即是数组的 0 位至 31 位的空间内， 如图 6-8 所示。</p>
<p><img src="/img/intlist-8.png" alt=""></p>
<p>然后， 因为元素 65535 在 1 、 2 、 3 、 65535 四个元素中排名第四， 所以它将被添加到 contents 数组的索引 3 位置上， 也即是数组的96 位至 127 位的空间内， 如图 6-9 所示。</p>
<p><img src="/img/intlist-9.png" alt=""></p>
<p>最后， 程序将整数集合 encoding 属性的值从 INTSET_ENC_INT16 改为 INTSET_ENC_INT32 ， 并将 length 属性的值从 3 改为 4 ， 设置完成之后的整数集合如图 6-10 所示。</p>
<p><img src="/img/intlist-10.png" alt=""></p>
<p>因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。</p>
<p>其他类型的升级操作， 比如从 INTSET_ENC_INT16 编码升级为 INTSET_ENC_INT64 编码， 或者从 INTSET_ENC_INT32 编码升级为 INTSET_ENC_INT64 编码， 升级的过程都和上面展示的升级过程类似。</p>
<p>升级之后新元素的摆放位置</p>
<p>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：</p>
<ul>
<li>在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 0 ）；</li>
<li>在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 length-1 ）。</li>
</ul>
<h2 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h2><p>整数集合的升级策略有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。</p>
<p><strong>提升灵活性</strong></p>
<p>因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。</p>
<p>比如说， 我们一般只使用 int16_t 类型的数组来保存 int16_t 类型的值， 只使用 int32_t 类型的数组来保存 int32_t 类型的值， 诸如此类。</p>
<p>但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 int16_t 、 int32_t 或者 int64_t 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</p>
<p><strong>节约内存</strong></p>
<p>当然， 要让一个数组可以同时保存 int16_t 、 int32_t 、 int64_t 三种类型的值， 最简单的做法就是直接使用 int64_t 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 int16_t 类型或者 int32_t 类型的值， 数组都需要使用 int64_t 类型的空间去保存它们， 从而出现浪费内存的情况。</p>
<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
<p>比如说， 如果我们一直只向整数集合添加 int16_t 类型的值， 那么整数集合的底层实现就会一直是 int16_t 类型的数组， 只有在我们要将int32_t 类型或者 int64_t 类型的值添加到集合时， 程序才会对数组进行升级。</p>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<p>举个例子， 对于图 6-11 所示的整数集合来说， 即使我们将集合里唯一一个真正需要使用 int64_t 类型来保存的元素 4294967295 删除了， 整数集合的编码仍然会维持 INTSET_ENC_INT64 ， 底层数组也仍然会是 int64_t 类型的， 如图 6-12 所示。</p>
<p><img src="/img/intlist-11.png" alt=""><br><img src="/img/intlist-12.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis数据结构和对象-(三)跳跃表]]></title>
      <url>https://fudawei.github.io/2016/09/24/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%AF%B9%E8%B1%A1--%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><p>它是一种有序数据结构,通过在每个节点中维持多个 指向其他节点<br>的指针,从而达到快速访问节点的目的。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h2><p>Redis使用跳跃表作为有序集合键的底层实现之一,如果一个有序集合包含的元素数量比较多,又或者有序集合中元素的成(member)是比较长的字符串时,Redis就会使用跳跃表来作为有序集合键的底层实现。<br>另外,在集群节点中跳跃表被用作内部数据结构。除此之外在Redis中在无他用</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h2><p>跳跃表由zskiplistNode和zskiplist两个结构定义,其中zskiplistNode用<br>于表示跳跃表节点,而zskiplist用于保存跳跃表节点的相关信息。</p>
<p><img src="/img/skipList-1.png" alt=""></p>
<p>上图为zskiplist结构,其中</p>
<ul>
<li>header指向跳跃表的表头节点。</li>
<li>tail指向表尾节点。</li>
<li>level记录层数最大的那个节点的层数(注意:表头节点的层数不计算在内),是1-32之间的一个随机数,越大的数出现的概率越小。</li>
</ul>
<p>下图右为zskiplist结构,其中层(level):L1、L2、L3等标记各个节点的层,每个层都有前进指针和跨度,当程序从表头向表尾进行遍历时,访问会沿着层的前进指针进行。</p>
<p><strong>跨度</strong>:层的跨度(level[i].span属性)用于记录两个节点间的距离,节点间的跨度越大,它们相聚的就越远,指向NULL的所有前进指针的跨度都为0,因为它们没有连向任何节点。跨度跟遍历操作无关,是用来计算排位的(可根据排位获取元素节点),如下图,查找分值为3.0、对象为o3的节点时,只经过了一个层,并且层的跨度为3,所以该节点在跳跃表中的排位为3。</p>
<p><img src="/img/skipList-2.png" alt=""></p>
<ul>
<li><strong>后退(backward)指针</strong>:BW标记节点的后退指针,它指向位于当前节点的前一个节点,后退指针在程序从表尾向表头遍历时使用,与前进指针不同,后退针每次只能后退至前一个节点,因为每个节点只有一个后退指针。</li>
<li><strong>分值</strong>(score):1.0、2.0和3.0是节点所保存的分值,分值是一个double类型的浮点数,可重复,用于节点排序(分值相同则按在字典中大小排)。</li>
<li><strong>成员对象</strong>(obj):o1、o2和o3是节点所保存的成员对象,成员对象是一个指针,它指向一个字符串对象,而字符串对象则保存着一个SDS值,并且是唯一的。<br><em>注意:表头节点跟其他节点一样,也有后退指针、分值、成员对象等属性,但都不会被用到,故在图中没有画出。</em></li>
</ul>
<h2 id="跳跃表API"><a href="#跳跃表API" class="headerlink" title="跳跃表API"></a>跳跃表API</h2><p><img src="/img/skipList-3.png" alt=""></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>a.跳表具有如下性质:</p>
<ol>
<li>由很多层结构组成</li>
<li>每一层都是一个有序的链表</li>
<li>最底层(Level 1)的链表包含所有元素</li>
<li>如果一个元素出现在 Level i 的链表中,则它在 Level i 之下的链表也都会出现。</li>
<li>每个节点包含两个指针,一个指向同一链表中的下一个元素,一个指向下面一层的元素。</li>
</ol>
<p>b.插入</p>
<p>先确定该元素要占据的层数 K(采用丢硬币的方式,这完全是随机的)<br>然后在 Level 1 … Level K 各个层的链表都插入元素。<br>例子:插入 119, K = 2<br><img src="/img/skipList-4.png" alt=""></p>
<p>如果 K 大于链表的层数,则要添加新的层。<br>例子:插入 119, K = 4<br><img src="/img/skipList-5.png" alt=""></p>
<p>c.删除<br>三个步骤:</p>
<ol>
<li>在跳跃表中查找到这个元素的位置(如果未找到,则退出)</li>
<li>将该元素所在整列从表中删除</li>
<li>将多余的“空链”删除<br><img src="/img/skipList-6.png" alt=""></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis数据结构和对象-(二)字典]]></title>
      <url>https://fudawei.github.io/2016/09/22/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%AF%B9%E8%B1%A1--%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%97%E5%85%B8/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  字典，简单说就是存储key-value键值数据，与Java的HashMap 实现类似，Redis中的字典不要求有序，因此为了降低编码的难度 使用哈希表作为字典的底层实现。Redis的字典是使用一个桶bucket，通过对key进行hash得到的索引值index，然后将key-value的数 据存在桶的index位置，Redis处理hash碰撞的方式是链表，两个不同的key hash得到相同的索引值，那么就使用链表解决冲突。使用链表自然当存储的数据巨大的时候，字典不免会退化成多个链表，效率大大降低，Redis采用 rehash的方式对桶进行扩容来解决这种退化。</p>
<h2 id="1、结构"><a href="#1、结构" class="headerlink" title="1、结构"></a>1、结构</h2><p> <img src="/img/dict.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 字典</div><div class="line"> * 每个字典使用两个哈希表，用于实现渐进式 rehash</div><div class="line"> */</div><div class="line">typedef struct dict &#123;</div><div class="line"></div><div class="line">    dictType *type;  // 特定于类型的处理函数</div><div class="line">    void *privdata;   // 类型处理函数的私有数据</div><div class="line">    dictht ht[2];   // 哈希表（2个）</div><div class="line">    int rehashidx;   // 记录 rehash 进度的标志，值为-1 表示 rehash 未进行</div><div class="line">    int iterators;  // 当前正在运作的安全迭代器数量</div><div class="line"></div><div class="line">&#125; dict;</div><div class="line"></div><div class="line">typedef struct dictType &#123;</div><div class="line">    unsigned int (*hashFunction)(const void *key); //hash函数指针</div><div class="line">    void *(*keyDup)(void *privdata, const void *key); //键复制函数指针</div><div class="line">    void *(*valDup)(void *privdata, const void *obj); //值复制函数指针</div><div class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2); //键比较函数指针</div><div class="line">    void (*keyDestructor)(void *privdata, void *key); //键构造函数指针</div><div class="line">    void (*valDestructor)(void *privdata, void *obj); //值构造函数指针</div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure>
<h2 id="2-哈希表"><a href="#2-哈希表" class="headerlink" title="2.哈希表"></a>2.哈希表</h2><p>  字典所使用的哈希表实现由 dict.h/dictht 类型定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 哈希表</div><div class="line"> */</div><div class="line">typedef struct dictht &#123;</div><div class="line">    dictEntry **table;       // 哈希表节点指针数组（俗称桶，bucket）</div><div class="line">    unsigned long size;      // 指针数组的大小</div><div class="line">    unsigned long sizemask;  // 指针数组的长度掩码，用于计算索引值</div><div class="line">    unsigned long used;      // 哈希表现有的节点数量</div><div class="line">&#125; dictht</div></pre></td></tr></table></figure></p>
<p>table 属性是一个数组， 数组的每个元素都是一个指向 dictEntry 结构的指针。<br>每个 dictEntry 都保存着一个键值对， 以及一个指向另一个 dictEntry 结构的指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 哈希表节点</div><div class="line"> */</div><div class="line">typedef struct dictEntry &#123;</div><div class="line">   void *key;      // 键</div><div class="line">   union &#123;</div><div class="line">       void *val;</div><div class="line">       uint64_t u64;</div><div class="line">       int64_t s64;</div><div class="line">   &#125; v; // 值</div><div class="line">  struct dictEntry *next; // 链往后继节点</div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<p>next 属性指向另一个 dictEntry 结构， 多个 dictEntry 可以通过 next 指针串连成链表， 从这里可以看出， dictht 使用链地址法来处理键碰撞： 当多个不同的键拥有相同的哈希值时，哈希表用一个链表将这些键连接起来。</p>
<h2 id="3-哈希算法"><a href="#3-哈希算法" class="headerlink" title="3.哈希算法"></a>3.哈希算法</h2><p>使用字典设置的哈希函数，计算键 key的哈希值<br>hash = dict -&gt; type -&gt; hashFunction(key);<br>使用哈希表的sizemask 属性和哈希值，计算出索引值<br>根据情况不同，ht[x] 可以是 ht[0] 或者ht[1]<br>index = hash &amp; dict-&gt;ht[x].sizemask;</p>
<p>Redis使用的hash算法有以下两种：</p>
<ol>
<li>MurmurHash2 32 bit 算法：这种算法的分布率和速度都非常好，具体信息请参考 MurmurHash 的主页：<a href="http://code.google.com/p/smhasher/" target="_blank" rel="external">http://code.google.com/p/smhasher/</a> 。</li>
<li>基于djb算法实现的一个大小写无关散列算法：</li>
<li>具体信息请参考<br><a href="http://www.cse.yorku.ca/~oz/hash.html" target="_blank" rel="external">http://www.cse.yorku.ca/~oz/hash.html</a> 。</li>
</ol>
<h2 id="4-解决键冲突"><a href="#4-解决键冲突" class="headerlink" title="4.解决键冲突"></a>4.解决键冲突</h2><p>多个建被分配到同一个索引上面时，我们称这些键发生了冲突（collision）。<br>redis哈希表使用 链地址法来解决键冲突，每个哈希表节点都有一个next指指，多个哈希表节点 构成一个单向链表</p>
<p>字典添加元素<br>根据字典当前的状态，将一个key-value元素添加到字典中可能会引起一系列复制的操作：<br>如果字典未初始化（即字典的0号哈希表ht[0]的table为空），那么需要调用dictExpand函数对它初始化；<br>如果插入的元素key已经存在，那么添加元素失败；<br>如果插入元素时，引起碰撞，需要使用链表来处理碰撞；<br>如果插入元素时，引起程序满足Rehash的条件时，先调用dictExpand函数扩展哈希表的size，然后准备渐进式Rehash操作。<br>字典添加元素的流程图：</p>
<p><img src="/img/dict_flow.png" alt=""></p>
<h2 id="字典Rehash解析"><a href="#字典Rehash解析" class="headerlink" title="字典Rehash解析"></a>字典Rehash解析</h2><p>Rehash的触发机制：当每次添加新元素时，都会对工作哈希 表ht[0]进行检查，如果used（哈希表中元素的数目）与size（桶的大小）比率ratio满足以下任一条件，将激活字典的Rehash机 制：ratio=used / size， ratio &gt;= 1并且dict_can_resize 为真；ratio 大 于 变 量 dict_force_resize_ratio 。</p>
<h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>负载因子 = 哈希表已保存节点数量/哈希表大小<br>load_factor = ht[0].used/ht[0].size<br>Rehash执行过程：<br>创建一个比ht[0].used至少两倍的ht[1].table；将原ht[0].table中所有元素迁移到ht[1].table；清空原来ht[0]，将ht[1]替换成ht[0]<br>    扩展操作 那么ht[1]的大小为 第一个大于等于ht[0].used*2的 2的n次方幂  (负载因子 大于等于1  大于等于5)<br>    收缩操作 那么ht[1]的大小为 第一个大于等于ht[0].used的 2的n次方幂  （负载因子 小于0.1时 触发）</p>
<h2 id="为什么是2的n次方？"><a href="#为什么是2的n次方？" class="headerlink" title="为什么是2的n次方？"></a>为什么是2的n次方？</h2><p>即底层数组的长度总是为2的n次方。<br>当length总是 2 的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率</p>
<p>渐进式Rehash主要由两个函数来进行：<br>_dictRehashStep:当对字典进行添加、查找、删除、随机获取元素都会执行一次，其每次在开始Rehash后，将ht[0].table的第一个不为空的索引上的所有节点全部迁移到ht[1].table;<br>dictRehashMilliseconds:由Redis服务器常规任务程序(serverCron)执行，以毫秒为单位，在一定时间内，以每次执行100步rehash操作。</p>
<h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>   Rehash的触发机制：当每次添加新元素时，都会对工作哈希表ht[0]进行检查，如果used（哈希表中元素的数目）与size（桶的大小）比率ratio满足以下任一条件，将激活字典的Rehash机制：ratio=used / size， ratio &gt;= 1并且dict_can_resize 为真；ratio 大 于 变 量 dict_force_resize_ratio 。</p>
<h2 id="Rehash执行过程："><a href="#Rehash执行过程：" class="headerlink" title="Rehash执行过程："></a>Rehash执行过程：</h2><p>创建一个比ht[0].used至少两倍的ht[1].table；将原ht[0].table中所有元素迁移到ht[1].table；清空原来ht[0]，将ht[1]替换成ht[0]<br>渐进式Rehash主要由两个函数来进行：</p>
<hr>
<p>dictRehashMilliseconds:由Redis服务器常规任务程序(serverCron)执行，以毫秒为单位，在一定时间内，以每次执行100步rehash操作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dubbo入门]]></title>
      <url>https://fudawei.github.io/2016/09/05/Dubbo%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="Dubbo入门"><a href="#Dubbo入门" class="headerlink" title="Dubbo入门"></a>Dubbo入门</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p>
<center><img src="http://dubbo.io/dubbo-architecture-roadmap.jpg-version=1&amp;modificationDate=1331143666000.jpg" alt=""></center>

<ul>
<li>单一应用架构<ul>
<li>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。</li>
<li>此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</li>
</ul>
</li>
<li>垂直应用架构<ul>
<li>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。</li>
<li>此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</li>
</ul>
</li>
<li>分布式服务建构<ul>
<li>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。</li>
<li>此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</li>
</ul>
</li>
<li>流动计算架构<ul>
<li>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。</li>
<li>此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。</li>
</ul>
</li>
</ul>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><center><img src="http://dubbo.io/dubbo-service-governance.jpg-version=1&amp;modificationDate=1331887614000.jpg" alt=""></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在大规模服务化之前，应用可能只是通过RMI或Hessian等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过F5等硬件进行负载均衡。</p>
<ul>
<li><strong>当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。</strong><br>此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover，降低对F5硬件负载均衡器的依赖，也能减少部分成本。</li>
<li><strong>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</strong><br>这时，需要自动画出应用间的依赖关系图，以帮助架构师理清理关系</li>
<li><p><strong>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</strong><br>为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀      值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p>
<p>以上是Dubbo最基本的几个需求，更多服务治理问题参见：</p>
<p><a href="http://code.alibabatech.com/blog/experience_1402/service-governance-process.html" target="_blank" rel="external">http://code.alibabatech.com/blog/experience_1402/service-governance-process.html</a></p>
</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><center><img src="http://dubbo.io/dubbo-architecture.jpg-version=1&amp;modificationDate=1330892870000.jpg" alt=""></center>

<p> <strong>节点角色说明：</strong></p>
<ul>
<li>Provider: 暴露服务的服务提供方</li>
<li>Consumer: 调用远程服务的服务消费方。</li>
<li>Registry: 服务注册与发现的注册中心。</li>
<li>Monitor: 统计服务的调用次调和调用时间的监控中心。</li>
<li>Container: 服务运行容器。</li>
</ul>
<p> <strong>调用关系说明：</strong></p>
<ul>
<li>0、服务容器负责启动，加载，运行服务提供者</li>
<li>1、服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>2、服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>3、注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>4、服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li><p>5、服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<p><strong>连通性：</strong></p>
</li>
<li><p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</p>
</li>
<li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</li>
<li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销</li>
<li>服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销</li>
<li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</li>
<li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li>
<li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li>
<li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者<br><strong>(2) 健状性：</strong></li>
</ul>
<ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li><p>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</p>
<p><strong>(3) 伸缩性：</strong></p>
</li>
<li>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</li>
<li><p>服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</p>
<p><strong>(4) 升级性：</strong></p>
</li>
<li><p>当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力：</p>
<center> <img src="http://dubbo.io/dubbo-architecture-future.jpg-version=1&amp;modificationDate=1329978098000.jpg" alt=""> </center>
</li>
<li><p>Deployer: 自动部署服务的本地代理.</p>
</li>
<li>Repository: 仓库用于存储服务应用发布包。</li>
<li>Scheduler: 调度中心基于访问压力自动增减服务提供者。</li>
<li>Admin: 统一管理控制台。</li>
</ul>
<p>###用法</p>
<p> <strong>本地服务：(Spring配置)</strong></p>
<p>location.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=“xxxService” class=“com.xxx.XxxServiceImpl” /&gt;</div><div class="line"></div><div class="line">&lt;bean id=“xxxAction” class=“com.xxx.XxxAction”&gt;</div><div class="line">    &lt;property name=“xxxService” ref=“xxxService” /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p> <strong>远程服务：(Spring配置)</strong></p>
<p>在本地服务的基础上，只需做简单配置，即可完成远程化：</p>
<ul>
<li>将上面的local.xml配置拆分成两份，将服务定义部分放在服务提供方remote-provider.xml，将服务引用部分放在服务消费方remote-consumer.xml。</li>
<li>并在提供方增加暴露服务配置<dubbo:service>，在消费方增加引用服务配置<dubbo:reference>。</dubbo:reference></dubbo:service></li>
</ul>
<p><em>remote-provider.xml</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=“xxxService” class=“com.xxx.XxxServiceImpl” /&gt; &lt;!-- 和本地服务一样实现远程服务 --&gt;</div><div class="line"> </div><div class="line">&lt;dubbo:service interface=“com.xxx.XxxService” ref=“xxxService” /&gt; &lt;!-- 增加暴露远程服务配置 --&gt;</div></pre></td></tr></table></figure></p>
<p><em>remote-consumer.xml</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:reference id=“xxxService” interface=“com.xxx.XxxService” /&gt; &lt;!-- 增加引用远程服务配置 --&gt;</div><div class="line"></div><div class="line">&lt;bean id=“xxxAction” class=“com.xxx.XxxAction”&gt; &lt;!-- 和本地服务一样使用远程服务 --&gt;</div><div class="line">    &lt;property name=“xxxService” ref=“xxxService” /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h3 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h3><ul>
<li>Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。</li>
<li>如果不想使用Spring配置，而希望通过API的方式进行调用（不推荐），请参见：API配置 (+)</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[有趣代码注释]]></title>
      <url>https://fudawei.github.io/2016/07/12/%E6%9C%89%E8%B6%A3%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A/</url>
      <content type="html"><![CDATA[<h3 id="佛祖保佑"><a href="#佛祖保佑" class="headerlink" title="佛祖保佑"></a>佛祖保佑</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                   _ooOoo_</div><div class="line">                  o8888888o</div><div class="line">                  88" . "88</div><div class="line">                  (| -_- |)</div><div class="line">                  O\  =  /O</div><div class="line">               ____/`---'\____</div><div class="line">             .'  \\|     |//  `.</div><div class="line">            /  \\|||  :  |||//  \</div><div class="line">           /  _||||| -:- |||||-  \</div><div class="line">           |   | \\\  -  /// |   |</div><div class="line">           | \_|  ''\---/''  |   |</div><div class="line">           \  .-\__  `-`  ___/-. /</div><div class="line">         ___`. .'  /--.--\  `. . __</div><div class="line">      ."" '&lt;  `.___\_&lt;|&gt;_/___.'  &gt;'"".</div><div class="line">     | | :  `- \`.;`\ _ /`;.`/ - ` : | |</div><div class="line">     \  \ `-.   \_ __\ /__ _/   .-` /  /</div><div class="line">======`-.____`-.___\_____/___.-`____.-'======</div><div class="line">                   `=---='</div><div class="line">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</div><div class="line">         佛祖保佑       永无BUG</div><div class="line">*/</div><div class="line"><span class="comment">//          佛曰:  </span></div><div class="line"><span class="comment">//                  写字楼里写字间，写字间里程序员；  </span></div><div class="line"><span class="comment">//                  程序人员写程序，又拿程序换酒钱。  </span></div><div class="line"><span class="comment">//                  酒醒只在网上坐，酒醉还来网下眠；  </span></div><div class="line"><span class="comment">//                  酒醉酒醒日复日，网上网下年复年。  </span></div><div class="line"><span class="comment">//                  但愿老死电脑间，不愿鞠躬老板前；  </span></div><div class="line"><span class="comment">//                  奔驰宝马贵者趣，公交自行程序员。  </span></div><div class="line"><span class="comment">//                  别人笑我忒疯癫，我笑自己命太贱；  </span></div><div class="line"><span class="comment">//                  不见满街漂亮妹，哪个归得程序员？</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="神兽草泥马"><a href="#神兽草泥马" class="headerlink" title="神兽草泥马"></a>神兽草泥马</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">*</div><div class="line">*          ┌─┐       ┌─┐</div><div class="line">*       ┌──┘ ┴───────┘ ┴──┐</div><div class="line">*       │                 │</div><div class="line">*       │       ───       │</div><div class="line">*       │  ─┬┘       └┬─  │</div><div class="line">*       │                 │</div><div class="line">*       │       ─┴─       │</div><div class="line">*       │                 │</div><div class="line">*       └───┐         ┌───┘</div><div class="line">*           │         │</div><div class="line">*           │         │</div><div class="line">*           │         │</div><div class="line">*           │         └──────────────┐</div><div class="line">*           │                        │</div><div class="line">*           │                        ├─┐</div><div class="line">*           │                        ┌─┘</div><div class="line">*           │                        │</div><div class="line">*           └─┐  ┐  ┌───────┬──┐  ┌──┘</div><div class="line">*             │ ─┤ ─┤       │ ─┤ ─┤</div><div class="line">*             └──┴──┘       └──┴──┘</div><div class="line">*                 神兽保佑</div><div class="line">*                 代码无BUG!</div><div class="line">*/</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *   ┏┓　　　┏┓</div><div class="line"> * ┏┛┻━━━┛┻┓</div><div class="line"> * ┃　　　　　　　┃</div><div class="line"> * ┃　　　━　　　┃</div><div class="line"> * ┃　┳┛　┗┳　┃</div><div class="line"> * ┃　　　　　　　┃</div><div class="line"> * ┃　　　┻　　　┃</div><div class="line"> * ┃　　　　　　　┃</div><div class="line"> * ┗━┓　　　┏━┛</div><div class="line"> *    ┃　　　┃   </div><div class="line"> *    ┃　　　┃   </div><div class="line"> *    ┃　　　┗━━━┓</div><div class="line"> *    ┃　　　　　　　┣┓</div><div class="line"> *    ┃　　　　　　　┏┛</div><div class="line"> *    ┗┓┓┏━┳┓┏┛</div><div class="line"> *      ┃┫┫　┃┫┫</div><div class="line"> *      ┗┻┛　┗┻┛</div><div class="line"> *        神兽保佑 </div><div class="line"> *        代码无BUG! </div><div class="line"> */</div></pre></td></tr></table></figure>
<h3 id="胜利手势"><a href="#胜利手势" class="headerlink" title="胜利手势"></a>胜利手势</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//                      d*##$.</span></div><div class="line"><span class="comment">// zP"""""$e.           $"    $o</span></div><div class="line"><span class="comment">//4$       '$          $"      $</span></div><div class="line"><span class="comment">//'$        '$        J$       $F</span></div><div class="line"><span class="comment">// 'b        $k       $&gt;       $</span></div><div class="line"><span class="comment">//  $k        $r     J$       d$</span></div><div class="line"><span class="comment">//  '$         $     $"       $~</span></div><div class="line"><span class="comment">//   '$        "$   '$E       $</span></div><div class="line"><span class="comment">//    $         $L   $"      $F ...</span></div><div class="line"><span class="comment">//     $.       4B   $      $$$*"""*b</span></div><div class="line"><span class="comment">//     '$        $.  $$     $$      $F</span></div><div class="line"><span class="comment">//      "$       R$  $F     $"      $</span></div><div class="line"><span class="comment">//       $k      ?$ u*     dF      .$</span></div><div class="line"><span class="comment">//       ^$.      $$"     z$      u$$$$e</span></div><div class="line"><span class="comment">//        #$b             $E.dW@e$"    ?$</span></div><div class="line"><span class="comment">//         #$           .o$$# d$$$$c    ?F</span></div><div class="line"><span class="comment">//          $      .d$$#" . zo$&gt;   #$r .uF</span></div><div class="line"><span class="comment">//          $L .u$*"      $&amp;$$$k   .$$d$$F</span></div><div class="line"><span class="comment">//           $$"            ""^"$$$P"$P9$</span></div><div class="line"><span class="comment">//          JP              .o$$$$u:$P $$</span></div><div class="line"><span class="comment">//          $          ..ue$"      ""  $"</span></div><div class="line"><span class="comment">//         d$          $F              $</span></div><div class="line"><span class="comment">//         $$     ....udE             4B</span></div><div class="line"><span class="comment">//          #$    """"` $r            @$</span></div><div class="line"><span class="comment">//           ^$L        '$            $F</span></div><div class="line"><span class="comment">//             RN        4N           $</span></div><div class="line"><span class="comment">//              *$b                  d$</span></div><div class="line"><span class="comment">//               $$k                 $F</span></div><div class="line"><span class="comment">//               $$b                $F</span></div><div class="line"><span class="comment">//                 $""               $F</span></div><div class="line"><span class="comment">//                 '$                $</span></div><div class="line"><span class="comment">//                  $L               $</span></div><div class="line"><span class="comment">//                  '$               $</span></div><div class="line"><span class="comment">//                   $               $</span></div></pre></td></tr></table></figure>
<h3 id="围棋棋盘"><a href="#围棋棋盘" class="headerlink" title="围棋棋盘"></a>围棋棋盘</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//                             _______________________________________  </span></div><div class="line"><span class="comment">//                            /  ___________________________________  \</span></div><div class="line"><span class="comment">//     _--""""--_            /  /_/_/_/_/_|_|_|_|_|_|_|_|_|_\_\_\_\_\  \</span></div><div class="line"><span class="comment">//    /          \          /  /_/_/_/_J__L_L_L_|_|_|_J_J_J__L_\_\_\_\  \</span></div><div class="line"><span class="comment">//   /\          /\        /  /_/_/_J__L_J__L_L_|_|_|_J_J__L_J__L_\_\_\  \</span></div><div class="line"><span class="comment">//   L ""-____-"" J       /  /_/_J__L_J__L_J_J__L_|_J__L_L_J__L_J__L_\_\  \</span></div><div class="line"><span class="comment">//   \            /      /  /_/__L_/__L_J__L_J__L_|_J__L_J__L_J__\_J__\_\  \</span></div><div class="line"><span class="comment">//    \_        _/      /  /_J__/_J__/__L_J__|__L_|_J__|__L_J__\__L_\__L_\  \</span></div><div class="line"><span class="comment">//  _--"""""--_"       /  /  F /  F J  J  |  F J  |  F J  |  F  F J  \ J  \  \</span></div><div class="line"><span class="comment">// /           \      /  /--/-J--/--L--|--L-J--J--|--L--L-J--|--J--\--L-\--\  \</span></div><div class="line"><span class="comment">///\           /\    /  /__/__L_J__J___L_J__J__|__|__|__L__L_J___L__L_J__\__\  \</span></div><div class="line"><span class="comment">//L ""-_____-"" J   /  /  /  /  F  F  J  J  |  |  |  |  |  F  F  J  J  \  \  \  \</span></div><div class="line"><span class="comment">//\             /  /  /--/--/--/--J---L--|--|--|--o--|--|--|--J---L--\--\--\--\  \</span></div><div class="line"><span class="comment">// \_         _/  /  /__/__J__J___L__J___L__L__L__|__J__J__J___L__J___L__L__\__\  \</span></div><div class="line"><span class="comment">//   "--___--"   /  /  /   F  F  J   F  J  J   F  |  J   F  F  J   F  J  J   \  \  \</span></div><div class="line"><span class="comment">//              /  /--/---/--J---L--J---L--|--J---|---L--|--J---L--J---L--\---\--\  \</span></div><div class="line"><span class="comment">//             /  /__J___/___L__/___L__J___L__J___|___L__J___L__J___\__J___\___L__\  \</span></div><div class="line"><span class="comment">//            /  /   F  J   /  J   J   |  J   J   |   F   F  |   F   F  \   F  J   \  \</span></div><div class="line"><span class="comment">//           /  /---/---L--J---L---L---L--|---|---|---|---|--J---J---J---L--J---\---\  \</span></div><div class="line"><span class="comment">//          /  /___/___/___L__J___J___J___|___|___|___|___|___L___L___L__J___\___\___\  \</span></div><div class="line"><span class="comment">//         /  /   /   /   /   F   F   F   F   F   |   J   J   J   J   J   \   \   \   \  \</span></div><div class="line"><span class="comment">//        /  /___/___J___J___J___J___J____L___L___|___J___J____L___L___L___L___L___\___\  \</span></div><div class="line"><span class="comment">//       /  /   /    F   F   F   |   |   J    F   |   J    F   |   |   J   J   J    \   \  \</span></div><div class="line"><span class="comment">//      /  /___J____/___/___J____L___L___|___J____|____L___|___J___J____L___\___\____L___\  \</span></div><div class="line"><span class="comment">//     /  /    F   /   J    F   J   J    |   J    |    F   |    F   F   J    F   \   J    \  \</span></div><div class="line"><span class="comment">//    /  /____/___J____L___/____L___|____L___|____|____|___J____|___J____\___J____L___\____\  \</span></div><div class="line"><span class="comment">//   /  /    /    F   /   J    J    F   J    F    |    J    F   J    F    F   \   J    \    \  \</span></div><div class="line"><span class="comment">//  /  /____/____/___J____L____|____L___J____L____|____J____L___J____|____J____L___\____\____\  \</span></div><div class="line"><span class="comment">// /                                                                                             \</span></div><div class="line"><span class="comment">///_______________________________________________________________________________________________\</span></div><div class="line"><span class="comment">//|                                                                                               |</span></div><div class="line"><span class="comment">//| hs                                                                                            |</span></div><div class="line"><span class="comment">//|_______________________________________________________________________________________________|</span></div></pre></td></tr></table></figure>
<h3 id="书本"><a href="#书本" class="headerlink" title="书本"></a>书本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//                .-~~~~~~~~~-._       _.-~~~~~~~~~-.</span></div><div class="line"><span class="comment">//            __.'              ~.   .~              `.__</span></div><div class="line"><span class="comment">//          .'//                  \./                  \\`.</span></div><div class="line"><span class="comment">//        .'//                     |                     \\`.</span></div><div class="line"><span class="comment">//      .'// .-~"""""""~~~~-._     |     _,-~~~~"""""""~-. \\`.</span></div><div class="line"><span class="comment">//    .'//.-"                 `-.  |  .-'                 "-.\\`.</span></div><div class="line"><span class="comment">//  .'//______.============-..   \ | /   ..-============.______\\`.</span></div><div class="line"><span class="comment">//.'______________________________\|/______________________________`.</span></div></pre></td></tr></table></figure>
<h3 id="微软金典图标"><a href="#微软金典图标" class="headerlink" title="微软金典图标"></a>微软金典图标</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                       __</div><div class="line">                  ,-~¨^  ^¨-,           _,</div><div class="line">                 /          / ;^-._...,¨/</div><div class="line">                /          / /         /</div><div class="line">               /          / /         /</div><div class="line">              /          / /         /</div><div class="line">             /,.-:''-,_ / /         /</div><div class="line">             _,.-:--._ ^ ^:-._ __../</div><div class="line">           /^         / /¨:.._¨__.;</div><div class="line">          /          / /      ^  /</div><div class="line">         /          / /         /</div><div class="line">        /          / /         /</div><div class="line">       /_,.--:^-._/ /         /</div><div class="line">      ^            ^¨¨-.___.:^  (R) - G33K</div><div class="line">     </div><div class="line">      */</div></pre></td></tr></table></figure>
<h3 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">          ___                _</div><div class="line">         / __|___  ___  __ _| |___</div><div class="line">        | (_ / _ \/ _ \/ _` |   -_)</div><div class="line">         \___\___/\___/\__, |_\___|</div><div class="line">                       |___/</div><div class="line">         </div><div class="line">        */</div></pre></td></tr></table></figure>
<h3 id="奥运五环"><a href="#奥运五环" class="headerlink" title="奥运五环"></a>奥运五环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">             _.-"""""-._         _.-"""""-._         _.-"""""-._</div><div class="line">          ,'           `.     ,'           `.     ,'           `.</div><div class="line">         /               \   /               \   /               \</div><div class="line">        |                 | |                 | |                 |</div><div class="line">       |                   |                   |                   |</div><div class="line">       |                   |                   |                   |</div><div class="line">        |             _.-"|"|"-._         _.-"|"|"-._             |</div><div class="line">         \          ,'   /   \   `.     ,'   /   \   `.          /</div><div class="line">          `.       /   ,'     `.   \   /   ,'     `.   \       ,'</div><div class="line">            `-..__|..-'         `-..|_|..-'         `-..|__..-'</div><div class="line">                 |                   |                   |</div><div class="line">                 |                   |                   |</div><div class="line">                  |                 | |                 |</div><div class="line">                   \               /   \               /</div><div class="line">                    `.           ,'     `.           ,'</div><div class="line">                      `-..___..-'         `-..___..-'</div><div class="line"></div><div class="line">        */</div></pre></td></tr></table></figure>
<h3 id="七龙珠比克"><a href="#七龙珠比克" class="headerlink" title="七龙珠比克"></a>七龙珠比克</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                      _.---..._</div><div class="line">                  ./^         ^-._</div><div class="line">                ./^C===.         ^\.   /\</div><div class="line">               .|'     \\        _ ^|.^.|</div><div class="line">          ___.--'_     ( )  .      ./ /||</div><div class="line">         /.---^T\      ,     |     / /|||</div><div class="line">        C'   ._`|  ._ /  __,-/    / /-,||</div><div class="line">             \ \/    ;  /O  / _    |) )|,</div><div class="line">              i \./^O\./_,-^/^    ,;-^,'</div><div class="line">               \ |`--/ ..-^^      |_-^</div><div class="line">                `|  \^-           /|:</div><div class="line">                 i.  .--         / '|.</div><div class="line">                  i   =='       /'  |\._</div><div class="line">                _./`._        //    |.  ^-ooo.._</div><div class="line">         _.oo../'  |  ^-.__./X/   . `|    |#######b</div><div class="line">        d####     |'      ^^^^   /   |    _\#######</div><div class="line">        #####b ^^^^^^^^--. ...--^--^^^^^^^_.d######</div><div class="line">        ######b._         Y            _.d#########</div><div class="line">        ##########b._     |        _.d#############</div><div class="line"></div><div class="line">                                       "Piccolo" no. 2</div><div class="line">                                          (from Dragonball Z)</div><div class="line">                                               --- Steven J. Simmons</div><div class="line">        */</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                             /^_.-^  _  --^=_</div><div class="line">                          ./'-^__    _&gt;=\^^==^-.</div><div class="line">                          |'/^^_/  /^    \ \.^\\\/\</div><div class="line">                         ,|/| '  /'  _____\ `\|.^.|</div><div class="line">                         |'/   /_--^^ .   ^^-./ /||</div><div class="line">                         |/,--^  ,     |     / /||'</div><div class="line">                       ._|/   \ /  __,-/    / /-,||</div><div class="line">                       \ '/    ;  /O  / _    |) )|,</div><div class="line">                        i \./^O\./_,-^/^    ,;-^,'</div><div class="line">                         \ |`--/ ..-^^      |_-^</div><div class="line">                          `|  \^-_,/^Y\      | ^^\</div><div class="line">                          _i.  \".--V_/     /| \. ^\._____...--.&gt;^^^^^^-------...._</div><div class="line">                         /  i   ^--^^     /'|' |\. |./'        |                  ;</div><div class="line">       ___...----/^^^^---|.  `._\  /^   /' |'_/' \ `|         |'               ,/'</div><div class="line">                |'        \   _|^-.__./'__.^^\     .|        ,|            _.-^</div><div class="line">                `\       ,|`_./^^-----^^._    ` ./ /        /^        _.-^^/</div><div class="line">                         |'  ^                  /-^                ./^    /</div><div class="line">       \                 `\_     __.-&lt;       _,/                 ./'     |'</div><div class="line">        `\.        `i       ^^--/._____...--^            .      ./       |.</div><div class="line">          `|        |                                   /       /        `|</div><div class="line"></div><div class="line"></div><div class="line">                                       "Piccolo"</div><div class="line">                                          (from Dragonball Z)</div><div class="line">                                               --- Steven J. Simmons         </div><div class="line">       */</div></pre></td></tr></table></figure>
<h3 id="七龙珠孙悟空"><a href="#七龙珠孙悟空" class="headerlink" title="七龙珠孙悟空"></a>七龙珠孙悟空</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                           _</div><div class="line">                           \"-._ _.--"~~"--._</div><div class="line">                            \   "            ^.    ___</div><div class="line">                            /                  \.-~_.-~</div><div class="line">                     .-----'     /\/"\ /~-._      /</div><div class="line">                    /  __      _/\-.__\L_.-/\     "-.</div><div class="line">                   /.-"  \    ( ` \_o&gt;"&lt;o_/  \  .--._\</div><div class="line">                  /'      \    \:     "     :/_/     "`</div><div class="line">                          /  /\ "\    ~    /~"</div><div class="line">                          \ I  \/]"-._ _.-"[</div><div class="line">                       ___ \|___/ ./    l   \___   ___</div><div class="line">                  .--v~   "v` ( `-.__   __.-' ) ~v"   ~v--.</div><div class="line">               .-&#123;   |     :   \_    "~"    _/   :     |   &#125;-.</div><div class="line">              /   \  |           ~-.,___,.-~           |  /   \</div><div class="line">             ]     \ |                                 | /     [</div><div class="line">             /\     \|     :                     :     |/     /\</div><div class="line">            /  ^._  _K.___,^                     ^.___,K_  _.^  \</div><div class="line">           /   /  "~/  "\                           /"  \~"  \   \</div><div class="line">          /   /    /     \ _          :          _ /     \    \   \</div><div class="line">        .^--./    /       Y___________l___________Y       \    \.--^.</div><div class="line">        [    \   /        |        [/    ]        |        \   /    ]</div><div class="line">        |     "v"         l________[____/]________j  -Row   &#125;r"     /</div><div class="line">        &#125;------t          /                       \       /`-.     /</div><div class="line">        |      |         Y                         Y     /    "-._/</div><div class="line">        &#125;-----v'         |         :               |     7-.     /</div><div class="line">        |   |_|          |         l               |    / . "-._/</div><div class="line">        l  .[_]          :          \              :  r[]/_.  /</div><div class="line">         \_____]                     "--.             "-.____/</div><div class="line"></div><div class="line">                                            "Dragonball Z"</div><div class="line">                                                        ---Row</div><div class="line">         </div><div class="line">        */</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                               MMMMM</div><div class="line">                                 MMMMMM</div><div class="line">                                   MMMMMMM</div><div class="line">                                    MMMMMMMM     .</div><div class="line">                                     MMMMMMMMM</div><div class="line">                                     HMMMMMMMMMM</div><div class="line">                                      MMMMMMMMMMMM  M</div><div class="line">                                      MMMMMMMMMMMMM  M</div><div class="line">                                       MMMMMMMMMMMMM  M</div><div class="line">                                       MMMMMMMMMMMMM:</div><div class="line">                                       oMMMMMMMMMMMMMM</div><div class="line">             .MMMMMMMMMMMMMMo           MMMMMMMMMMMMMMM M</div><div class="line">       MMMMMMMMMMMMMMMMMMMMMMMMMMM      MMMMMMMMMMMMMMMM</div><div class="line">         MMMMMMMMMMMMMMMMMMMMMMMMMMMM.  oMMMMMMMMMMMMMMM.M</div><div class="line">           MMMMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMMMMMMMMMMMMM</div><div class="line">             MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">               oMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                   MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:                     H</div><div class="line">                    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM                  .         MMM</div><div class="line">                     MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM              M       MMMMMM</div><div class="line">                      .MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM          M   MMMMMMMMMM</div><div class="line">               MM.      MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM       M MMMMMMMMMMMM</div><div class="line">                   MM    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    .MMMMMMMMMMMMMM</div><div class="line">                     MM  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                       MM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">              .MMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMM.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                 HMMMMMMMMMMMMMMMMMMMMM.MMMMMMMMM.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                    MMMMMMMMMMMMMMM MMM.oMMMMMMM..MMMMMMMMM:MMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                      MMMMMMMMMMMMMM MM..MMMMMMM...MMMMMMM. MMMMMMMMMMMMMMMMMMMMM</div><div class="line">                        MMMMMMMMMMMMMMM ..MMMMMM...MMMMMM ..MMMMMMMMMMMMMMMMMMM</div><div class="line">                         MMMMMMM:M.MMM.M.. MMMMM M..MMMMM...MMMMMMMMMMMMMMMMMM  MMM</div><div class="line">                           MMMM. .M..MM.M...MMMMMM..MMMMM.. MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM .</div><div class="line">                            MMMM..M....M.....:MMM .MMMMMM..MMMMMMM...MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                             MMM.M.. ...M......MM.MMMMM.......MHM.M  .MMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                        MMMMMMMM..MM. . MMM.....MMMMMM.M.....M ..MM..M MMMMMMMMMMMMMMMMMMM</div><div class="line">                           .MMMMMHMM. ..MMMM. MMM............o..... . .MMMMMMMMMMMMMMM</div><div class="line">                              MMM. M... .........................M..:.MMMMMMMMMMMM</div><div class="line">                                oMMM............ .................M.M.MMMMMMMMM</div><div class="line">                                   .....MM........................ . MMMMMM</div><div class="line">                                  M.....M.....................o.MM.MMMMMMMM.</div><div class="line">                                   M........................M.. ...MMMMMMMMMMMMMo</div><div class="line">                                     :....MMM..............MMM..oMMMMMMM</div><div class="line">                                      M...MMM.............MMMMMMM</div><div class="line">                                         .............:MMMMMMMM</div><div class="line">                                         M..... MMM.....M</div><div class="line">                                         M M.............</div><div class="line">                                         ................M</div><div class="line">                                      ooM.................MM  MoMMMMMoooM</div><div class="line">                                 MMoooM......................MoooooooH..oMM</div><div class="line">                             MHooooMoM.....................MMooooooM........M</div><div class="line">                           oooooooMoooM......... o........MoooooooM............</div><div class="line">                           Mooooooooooo.......M.........Moooooooo:..............M</div><div class="line">                          MooMoooooooooM...M........:Mooooooooooo:..............M</div><div class="line">                         M..oooooooooooo .........Mooooooooooooooo..............M</div><div class="line">                        M...Mooo:oooooooo.M....ooooooooooooooooooo..M...........M</div><div class="line">                         ...oooooMoooooooM..Mooooooooooooo:oooooooM.M...........M.</div><div class="line">                        M...ooooooMoo:ooooMoooooooooooooHoooooooooH:M. ...........:</div><div class="line">                        M..MoooooooMoooooooooooooooooo:ooooooMooooMoM..............M</div><div class="line">                        M..ooooooooooMooooooooooooooHoooooooMooHooooM...............M</div><div class="line">                        ...ooooooooooooooooooo:MooooooooooooooMoMoooM................</div><div class="line">                       M...oooooooooooooooooooooooooooooooooooooMooMM................M</div><div class="line">                       ...MooooooooooooooooooooooooooooooooooooooooMo ................</div><div class="line">                       ...MooooooooooooooooooooooooooooooooooooooooM M................M</div><div class="line">                      M...ooooooooooooooooooooooooooooooooooooooooM   ................M</div><div class="line">                      ...MoooooooooooooooooooooooooooooooooooooooMM   .:...............</div><div class="line">                      .....MooooooooooooooooooooooooooooooooooooMoo       .............M</div><div class="line">                      M...... ooooooooooooooooooooooooooooooooooooM       M..............M</div><div class="line">                      M........MooooMMM MM MM  MMMMMMMMMooooooooM         M...............M</div><div class="line">                      .........HM     M:  MM :MMMMMM          M           M...............</div><div class="line">                     M..........M     M   MoM M                           M................M</div><div class="line">                     M.........:M  MoH  M M M MooooHoooMM.   M             M...............M</div><div class="line">                     M..........Moooo MMooM    oooooMooooooooM              M..............H</div><div class="line">                     M.........MooooM  Mooo  : ooooooMooooMoooM              M........ . .o.M</div><div class="line">                     H..  .....ooooo   oooo  M MooooooooooooooM               M... MMMMMMMMMMM</div><div class="line">                     MMMMMMMMMMooooM M oooo  .  ooooooMooooooooM              .MMMMMMMMMMMMMMM</div><div class="line">                     MMMMMMMMMMooooH : ooooH    oooooooooooooooo               MMMMMMMMMMMMMMM</div><div class="line">                     MMMMMMMMMMoooo    ooooM    Moooooooooooooooo              .MMMMMMMMMMMMMMM</div><div class="line">                     MMMMMMMMMMoooo    ooooM    MooooooooooooooooM              MMMMMMMMMMMMMMM</div><div class="line">                     MMMMMMMMMMoooM    ooooM     ooooooooooooooooo               MMMMMMMMMMM:M</div><div class="line">                     MMMMMMMMMMoooM   MooooM     oooooooooooMoooooo               MH...........</div><div class="line">                      . ......Mooo.   MooooM     oooooooooooooooooo              M............M</div><div class="line">                     M.M......oooo    MooooM     Moooooooooooooooooo:           .........M.....</div><div class="line">                     M.M.....Moooo    MooooM      ooooooooooooooooooM            .M............</div><div class="line">                     .......MooooH    MooooM      oooooooooMoooooooooo          M..o...M..o....M</div><div class="line">                     .o....HMooooM    MooooH      MooooooooMooooooooooM          .:M...M.......M</div><div class="line">                    M..M.....MoooM    :oooo:    .MooooooooHooMoooooooooM         M M... ..oM.M</div><div class="line">                     M...M.:.Mooo. MMMMooooo   oooooooooooMoooooooooooooM          ....M. M</div><div class="line">                      M:M..o.Moooooooooooooo MooooooooooooooMooooooooooooM          .Mo</div><div class="line">                             MooooooooooooooMooooooooooooMoMoooooooooooooo</div><div class="line">                             Mooooooooooooooo:ooooooooooooooooooooooooooooo</div><div class="line">                             ooooooooooooooooMooooooooooMoooooooooooooooooo</div><div class="line">                             ooooooooooooooooMoooooooooooMooooooooooooooooHo</div><div class="line">                             ooMooooooooooooooMoooooooooooooooooooooooooooMoM</div><div class="line">                            MooMoooooooooooooo.ooooooooooooooooooooooooooo:oM</div><div class="line">                            MoooooooooooooooooooooooooooooooooooooooooooooooM</div><div class="line">                            MoooMooooooooooooooMooooooooooooooooooooooooooooo.</div><div class="line">                            MoooMooooooooooooooMoooooooooooooooooooooooooMooooM</div><div class="line">                            MooooooooooooooooooMoooooooooooooooooooooooooMoooooM</div><div class="line">                            MooooMoooooooooooooMoooooooooooooooooooooooooMoHooooM</div><div class="line">                            ooooooMooooooooooooooooooooooooooooooooooooooooMoMoooM</div><div class="line">                           MooooooooooooooooooooMooooooooooooooooooooooooooMoooooH:</div><div class="line">                           MoooooooMooooooooooooMoooooooooooooooooooooooooooooHoooM</div><div class="line">                           MooooooooMoooooooooooMoooooooooooooooooooooooooMoooMooooM</div><div class="line">                           Moooooooooooooooooooooooooooooooooooooooooooooo.oooMooooo</div><div class="line">                           MoooooooooooooooooooooooooooooooooooooooooooooMoooooooooM</div><div class="line">                            MooooooooooooooooooooMoooooooooooooooooooooooooooooooooM</div><div class="line">                             MooooooooooooooooooooMHooooooooooooooooooooMoooo:ooooo</div><div class="line">                              MMooooooooooooooooooMoMHoooooooooooooooooooooooMooooo</div><div class="line">                               MMoooooooooooooooMMooo MMooooooooooooooooooooooooooM</div><div class="line">                               MMMoooooooooooooMooooo  oooooooooooooooooooooMooooo</div><div class="line">                               MooMMoooooooooMoooMMoM  ooooHooooooooooooooooMooooM</div><div class="line">                               MooooMooooooMooooMoooM  MoooooMoooooooooooooMooooo</div><div class="line">                               ooooooMMooooooooMooooM  MoooooooooMooooooooooooooM</div><div class="line">                               HooooooMoooooooMooooM    HoooooooHooMooooooooooooo</div><div class="line">                                oooMoooooooooHoooM         MoooooooooMoooooooooM</div><div class="line">                                 HooooooooooooHM             MooooooooMMoooooooM</div><div class="line">                                  MMMMMMMMMMMMMM                Moooooo:MooooHMM</div><div class="line">                                   MMMMMMM: ...                  MMMMMMMMMMMMMM</div><div class="line">                                  M............M                  MMMMMMMMM ....</div><div class="line">                                  M.MM..........                  M.............M</div><div class="line">                               M ..............MM                 M..............</div><div class="line">                            MMMMM............MMMM                 ..MMMMMMMM ....M</div><div class="line">                          MMMMMMMMMMMMMMMMMMMMMMMM               MMMMMMMMMMMMM...M</div><div class="line">                       .MMMMMMMMMMMMMMMMMMMMMMMMMM               MMMMMMMMMMMMMMMMMM</div><div class="line">                       MMMMMMMMMMMMMMMMMMMMMMMMM                MMMMMMMMMMMMMMMMMMM</div><div class="line">                       :MMMMMMMMMMMMMMMMMMH                     MMMMMMMMMMMMMMMMMMM</div><div class="line">                          By EBEN Jérôme                        MMMMMMMMMMMMMMMMMM</div><div class="line">                                                                MMMMMMMMMMMMMMM</div><div class="line">                                                                 HMMMMMM</div><div class="line">        </div><div class="line">       */</div></pre></td></tr></table></figure>
<h3 id="皮卡丘"><a href="#皮卡丘" class="headerlink" title="皮卡丘"></a>皮卡丘</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">       quu..__</div><div class="line">        $$$b  `---.__</div><div class="line">         "$$b        `--.                          ___.---uuudP</div><div class="line">          `$$b           `.__.------.__     __.---'      $$$$"              .</div><div class="line">            "$b          -'            `-.-'            $$$"              .'|</div><div class="line">              ".                                       d$"             _.'  |</div><div class="line">                `.   /                              ..."             .'     |</div><div class="line">                  `./                           ..::-'            _.'       |</div><div class="line">                   /                         .:::-'            .-'         .'</div><div class="line">                  :                          ::''\          _.'            |</div><div class="line">                 .' .-.             .-.           `.      .'               |</div><div class="line">                 : /'$$|           .@"$\           `.   .'              _.-'</div><div class="line">                .'|$u$$|          |$$,$$|           |  &lt;            _.-'</div><div class="line">                | `:$$:'          :$$$$$:           `.  `.       .-'</div><div class="line">                :                  `"--'             |    `-.     \</div><div class="line">               :##.       ==             .###.       `.      `.    `\</div><div class="line">               |##:                      :###:        |        &gt;     &gt;</div><div class="line">               |#'     `..'`..'          `###'        x:      /     /</div><div class="line">                \                                   xXX|     /    ./</div><div class="line">                 \                                xXXX'|    /   ./</div><div class="line">                 /`-.                                  `.  /   /</div><div class="line">                :    `-  ...........,                   | /  .'</div><div class="line">                |         ``:::::::'       .            |&lt;    `.</div><div class="line">                |             ```          |           x| \ `.:``.</div><div class="line">                |                         .'    /'   xXX|  `:`M`M':.</div><div class="line">                |    |                    ;    /:' xXXX'|  -'MMMMM:'</div><div class="line">                `.  .'                   :    /:'       |-'MMMM.-'</div><div class="line">                 |  |                   .'   /'        .'MMM.-'</div><div class="line">                 `'`'                   :  ,'          |MMM&lt;</div><div class="line">                   |                     `'            |tbap\</div><div class="line">                    \                                  :MM.-'</div><div class="line">                     \                 |              .''</div><div class="line">                      \.               `.            /</div><div class="line">                       /     .:::::::.. :           /</div><div class="line">                      |     .:::::::::::`.         /</div><div class="line">                      |   .:::------------\       /</div><div class="line">                     /   .''               &gt;::'  /</div><div class="line">                     `',:                 :    .'</div><div class="line">                                          `:.:'</div><div class="line"></div><div class="line">        </div><div class="line">       */</div></pre></td></tr></table></figure>
<h3 id="电脑图像"><a href="#电脑图像" class="headerlink" title="电脑图像"></a>电脑图像</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                    ,----------------,              ,---------,</div><div class="line">               ,-----------------------,          ,"        ,"|</div><div class="line">             ,"                      ,"|        ,"        ,"  |</div><div class="line">            +-----------------------+  |      ,"        ,"    |</div><div class="line">            |  .-----------------.  |  |     +---------+      |</div><div class="line">            |  |                 |  |  |     | -==----'|      |</div><div class="line">            |  |  I LOVE DOS!    |  |  |     |         |      |</div><div class="line">            |  |  Bad command or |  |  |/----|`---=    |      |</div><div class="line">            |  |  C:\&gt;_          |  |  |   ,/|==== ooo |      ;</div><div class="line">            |  |                 |  |  |  // |(((( [33]|    ,"</div><div class="line">            |  `-----------------'  |," .;'| |((((     |  ,"</div><div class="line">            +-----------------------+  ;;  | |         |,"</div><div class="line">               /_)______________(_/  //'   | +---------+</div><div class="line">          ___________________________/___  `,</div><div class="line">         /  oooooooooooooooo  .o.  oooo /,   \,"-----------</div><div class="line">        / ==ooooooooooooooo==.o.  ooo= //   ,`\--&#123;)B     ,"</div><div class="line">       /_==__==========__==_ooo__ooo=_/'   /___________,"</div><div class="line">        </div><div class="line">       */</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                                   _________</div><div class="line">                                  /         /.</div><div class="line">           .-------------.       /_________/ |</div><div class="line">          /             / |      |         | |</div><div class="line">         /+============+\ |      | |====|  | |</div><div class="line">         ||C:\&gt;        || |      |         | |</div><div class="line">         ||            || |      | |====|  | |</div><div class="line">         ||            || |      |   ___   | |</div><div class="line">         ||            || |      |  |166|  | |</div><div class="line">         ||            ||/@@@    |   ---   | |</div><div class="line">         \+============+/    @   |_________|./.</div><div class="line">                            @          ..  ....'</div><div class="line">         ..................@     __.'.'  ''</div><div class="line">        /oooooooooooooooo//     ///</div><div class="line">       /................//     /_/</div><div class="line">       ------------------</div><div class="line">       */</div></pre></td></tr></table></figure>
<h3 id="龙"><a href="#龙" class="headerlink" title="龙"></a>龙</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">        11111111111111111111111111111111111111001111111111111111111111111</div><div class="line">        11111111111111111111111111111111111100011111111111111111111111111</div><div class="line">        11111111111111111111111111111111100001111111111111111111111111111</div><div class="line">        11111111111111111111111111111110000111111111111111111111111111111</div><div class="line">        11111111111111111111111111111000000111111111111111111111111111111</div><div class="line">        11111111111111111111111111100000011110001100000000000000011111111</div><div class="line">        11111111111111111100000000000000000000000000000000011111111111111</div><div class="line">        11111111111111110111000000000000000000000000000011111111111111111</div><div class="line">        11111111111111111111111000000000000000000000000000000000111111111</div><div class="line">        11111111111111111110000000000000000000000000000000111111111111111</div><div class="line">        11111111111111111100011100000000000000000000000000000111111111111</div><div class="line">        11111111111111100000110000000000011000000000000000000011111111111</div><div class="line">        11111111111111000000000000000100111100000000000001100000111111111</div><div class="line">        11111111110000000000000000001110111110000000000000111000011111111</div><div class="line">        11111111000000000000000000011111111100000000000000011110001111111</div><div class="line">        11111110000000011111111111111111111100000000000000001111100111111</div><div class="line">        11111111000001111111111111111111110000000000000000001111111111111</div><div class="line">        11111111110111111111111111111100000000000000000000000111111111111</div><div class="line">        11111111111111110000000000000000000000000000000000000111111111111</div><div class="line">        11111111111111111100000000000000000000000000001100000111111111111</div><div class="line">        11111111111111000000000000000000000000000000111100000111111111111</div><div class="line">        11111111111000000000000000000000000000000001111110000111111111111</div><div class="line">        11111111100000000000000000000000000000001111111110000111111111111</div><div class="line">        11111110000000000000000000000000000000111111111110000111111111111</div><div class="line">        11111100000000000000000001110000001111111111111110001111111111111</div><div class="line">        11111000000000000000011111111111111111111111111110011111111111111</div><div class="line">        11110000000000000001111111111111111100111111111111111111111111111</div><div class="line">        11100000000000000011111111111111111111100001111111111111111111111</div><div class="line">        11100000000001000111111111111111111111111000001111111111111111111</div><div class="line">        11000000000001100111111111111111111111111110000000111111111111111</div><div class="line">        11000000000000111011111111111100011111000011100000001111111111111</div><div class="line">        11000000000000011111111111111111000111110000000000000011111111111</div><div class="line">        11000000000000000011111111111111000000000000000000000000111111111</div><div class="line">        11001000000000000000001111111110000000000000000000000000001111111</div><div class="line">        11100110000000000001111111110000000000000000111000000000000111111</div><div class="line">        11110110000000000000000000000000000000000111111111110000000011111</div><div class="line">        11111110000000000000000000000000000000001111111111111100000001111</div><div class="line">        11111110000010000000000000000001100000000111011111111110000001111</div><div class="line">        11111111000111110000000000000111110000000000111111111110110000111</div><div class="line">        11111110001111111100010000000001111100000111111111111111110000111</div><div class="line">        11111110001111111111111110000000111111100000000111111111111000111</div><div class="line">        11111111001111111111111111111000000111111111111111111111111100011</div><div class="line">        11111111101111111111111111111110000111111111111111111111111001111</div><div class="line">        11111111111111111111111111111110001111111111111111111111100111111</div><div class="line">        11111111111111111111111111111111001111111111111111111111001111111</div><div class="line">        11111111111111111111111111111111100111111111111111111111111111111</div><div class="line">        11111111111111111111111111111111110111111111111111111111111111111</div><div class="line"></div><div class="line"></div><div class="line">        */</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                                                    __----~~~~~~~~~~~------___</div><div class="line">                                         .  .   ~~//====......          __--~ ~~</div><div class="line">                         -.            \_|//     |||\\  ~~~~~~::::... /~</div><div class="line">                      ___-==_       _-~o~  \/    |||  \\            _/~~-</div><div class="line">              __---~~~.==~||\=_    -_--~/_-~|-   |\\   \\        _/~</div><div class="line">          _-~~     .=~    |  \\-_    '-~7  /-   /  ||    \      /</div><div class="line">        .~       .~       |   \\ -_    /  /-   /   ||      \   /</div><div class="line">       /  ____  /         |     \\ ~-_/  /|- _/   .||       \ /</div><div class="line">       |~~    ~~|--~~~~--_ \     ~==-/   | \~--===~~        .\</div><div class="line">                '         ~-|      /|    |-~\~~       __--~~</div><div class="line">                            |-~~-_/ |    |   ~\_   _-~            /\</div><div class="line">                                 /  \     \__   \/~                \__</div><div class="line">                             _--~ _/ | .-~~____--~-/                  ~~==.</div><div class="line">                            ((-&gt;/~   '.|||' -_|    ~~-/ ,              . _||</div><div class="line">                                       -_     ~\      ~~---l__i__i__i--~~_/</div><div class="line">                                       _-~-__   ~)  \--______________--~~</div><div class="line">                                     //.-~~~-~_--~- |-------~~~~~~~~</div><div class="line">                                            //.-~~~--\</div><div class="line"></div><div class="line">        </div><div class="line">       */</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//                       )      (</span></div><div class="line"><span class="comment">//                  /+++=))    ((=+++\</span></div><div class="line"><span class="comment">//             /++++++++//      \\+++++++++\</span></div><div class="line"><span class="comment">//          /++++++++++//(  /\  )\\++++++++++\</span></div><div class="line"><span class="comment">//        /+++++++++++//  \\^^//  \\+++++++++++\</span></div><div class="line"><span class="comment">//     _/++++++++++++//  &#123;&#123;@::@&#125;&#125;  \\++++++++++++\_</span></div><div class="line"><span class="comment">//    /+++++++++++++((     &#123;\/&#125;     ))+++++++++++++\</span></div><div class="line"><span class="comment">//   /+++++++++++++++\\    &lt;**&gt;    //+++++++++++++++\</span></div><div class="line"><span class="comment">//  /+++++++++++++++++\\  / VV \  //+++++++++++++++++\</span></div><div class="line"><span class="comment">// /+++++++++++++++++++\\/******\//+++++++++++++++++++\</span></div><div class="line"><span class="comment">//|+/|++++++++++/\++++++(***/\***)++++++/\++++++++++|\+\</span></div><div class="line"><span class="comment">//|/ |+/\+/\+/\/  \+/\++\**|**|**/++/\+/  \/\+/\+/\+| \|</span></div><div class="line"><span class="comment">//v  |/  V  V  V   V  \+\|*|**|*|/+/  V   v  V  V  \|  v</span></div><div class="line"><span class="comment">//   v                 /*|*|**|*|*\...              v</span></div><div class="line"><span class="comment">//                    (**|*|**|*|**). .</span></div><div class="line"><span class="comment">//                   __\*|*|**|*|*/__. .</span></div><div class="line"><span class="comment">//                  (vvv(VVV)(VVV)vvv). .</span></div><div class="line"><span class="comment">//                      ............../ /</span></div><div class="line"><span class="comment">//                     / ............../</span></div><div class="line"><span class="comment">//                     ((</span></div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                 ___====-_  _-====___</div><div class="line">           _--^^^#####//      \\#####^^^--_</div><div class="line">        _-^##########// (    ) \\##########^-_</div><div class="line">       -############//  |\^^/|  \\############-</div><div class="line">     _/############//   (@::@)   \\############\_</div><div class="line">    /#############((     \\//     ))#############\</div><div class="line">   -###############\\    (oo)    //###############-</div><div class="line">  -#################\\  / VV \  //#################-</div><div class="line"> -###################\\/      \//###################-</div><div class="line">_#/|##########/\######(   /\   )######/\##########|\#_</div><div class="line">|/ |#/\#/\#/\/  \#/\##\  |  |  /##/\#/  \/\#/\#/\#| \|</div><div class="line">`  |/  V  V  `   V  \#\| |  | |/#/  V   '  V  V  \|  '</div><div class="line">   `   `  `      `   / | |  | | \   '      '  '   '</div><div class="line">                    (  | |  | |  )</div><div class="line">                   __\ | |  | | /__</div><div class="line">                  (vvv(VVV)(VVV)vvv)</div><div class="line">                  </div><div class="line">*/</div></pre></td></tr></table></figure>
<p><a href="http://shiyousan.com/post/635479912728885400" target="_blank" rel="external">参考博客</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[帮程序员和站长减压放松的10个良心网站]]></title>
      <url>https://fudawei.github.io/2016/06/23/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E5%92%8C%E7%AB%99%E9%95%BF%E5%87%8F%E5%8E%8B%E6%94%BE%E6%9D%BE%E7%9A%8410%E4%B8%AA%E8%89%AF%E5%BF%83%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<h3 id="1-Calm"><a href="#1-Calm" class="headerlink" title="1.Calm"></a>1.<a href="http://www.calm.com/" target="_blank" rel="external">Calm</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%997.jpg" alt=""></center>

<ul>
<li><p>这是同类型中最火的网站了，站如其名，「平和」，通过自然的图像（阳光下的暖流、淙淙的小溪等）与缓缓的音乐，帮你在短时间内放松下来</p>
</li>
<li><p>左侧有时间设定，从2分钟到20分钟，右底部可以改变音频、图像，调节音量等。还有IOS客户端下载呦</p>
</li>
</ul>
<h3 id="2-Do-Nothing-For-2-Minutes"><a href="#2-Do-Nothing-For-2-Minutes" class="headerlink" title="2.Do Nothing For 2 Minutes"></a>2.<a href="http://www.donothingfor2minutes.com/" target="_blank" rel="external">Do Nothing For 2 Minutes</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%999.jpg" alt=""></center>

<ul>
<li><p>木头人，两分钟，这是一个简单到极致的网站，当你打开的时候，自动开始计时，这时间你不能触碰键盘和鼠标，否则2分钟会重置</p>
</li>
<li><p>你需要做的，就是放下手头的工作，静静地享受潮声，这也很棒，不是吗？两分钟足够你冷静下来，休息一下了</p>
</li>
</ul>
<a id="more"></a>
<h3 id="3-Get-Relaxed"><a href="#3-Get-Relaxed" class="headerlink" title="3.Get Relaxed"></a>3.<a href="http://www.getrelaxed.com/" target="_blank" rel="external">Get Relaxed</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%992.jpg" alt=""></center>

<ul>
<li><p>如果两分钟不足以让你彻底放松，试试这个。如下图，打开网站后，头枕着双手往后仰，欣赏自然风光，聆听网站为你精心挑选的音乐</p>
</li>
<li><p>图像3秒一换，有15种，每种持续大概2 – 4分钟，现在，开始吧！</p>
</li>
<li><p>提醒：网站有简陋广告，稍微影响体验</p>
</li>
</ul>
<h3 id="4-LoungeV-Studio"><a href="#4-LoungeV-Studio" class="headerlink" title="4.LoungeV Studio"></a>4.<a href="http://www.loungev.com/" target="_blank" rel="external">LoungeV Studio</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%996.jpg" alt=""></center>

<ul>
<li>前三个都是图像，现在来个新鲜的。这个网站提供高清的自然风光视频 + 音乐。有沙滩、瀑布、水下景色等等，网站背景是一个温馨的客厅，右侧有视频可选，对喜欢看视频的同学来说，还是蛮不错的</li>
</ul>
<h3 id="5-A-Soft-Murmur"><a href="#5-A-Soft-Murmur" class="headerlink" title="5.A Soft Murmur"></a>5.<a href="http://asoftmurmur.com/" target="_blank" rel="external">A Soft Murmur</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%991.jpg" alt=""></center>

<ul>
<li><p>这个网站太棒了！博主玩了好久都舍不得停下来。网站让你自由创造美妙的声音。你可以通过混合不同的声音（雨声、火柴燃烧的声音、打雷声、海潮声…..不一而足。但是，总有一款令你爱不释手！）当然，声音的大小也可以自己调节</p>
</li>
<li><p>如果你对混合的声音非常满意，也可以分享到脸书、谷歌等….</p>
</li>
</ul>
<h3 id="6-Nature-Sounds-For-Me"><a href="#6-Nature-Sounds-For-Me" class="headerlink" title="6.Nature Sounds For Me"></a>6.<a href="http://naturesoundsfor.me/" target="_blank" rel="external">Nature Sounds For Me</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%998.jpg" alt=""></center>

<ul>
<li><p>这个比上面那个界面稍逊，但是玩起来更嗨！它提供的声音除了以上的自然类声音，还有很多你想不到的：绵羊咩咩、骏马跺脚喷气、不同的鸟叫声，甚至是心脏跳动、厨房叮当的声音，不仅令人身临其境，而且搭配起来简直不能更欢乐！</p>
</li>
<li><p>当然，它还有IOS客户端。</p>
</li>
</ul>
<h3 id="7-Noisli"><a href="#7-Noisli" class="headerlink" title="7.Noisli"></a>7.<a href="http://www.noisli.com/" target="_blank" rel="external">Noisli</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%9910.jpg" alt=""></center>


<ul>
<li><p>这个网站根据你的情绪变化，选择不同的音乐和背景颜色。颜色大多朴素平和，背景声音也有对应的图标可以选择。还有一点贴心的设计是，网站右侧有便签本，你可以一边享受静谧时光一边随手记点事。</p>
</li>
<li><p>为了造福大众，网站还提供IOS 版。</p>
</li>
</ul>
<h3 id="8-Soundrown"><a href="#8-Soundrown" class="headerlink" title="8.Soundrown"></a>8.<a href="http://soundrown.com/" target="_blank" rel="external">Soundrown</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%995.jpg" alt=""></center>

<ul>
<li>网站一进去，有3个关键词：放松、专注、逃离。的确，它成功做到了这一点。它有10种不同的声音帮助你放松心情，也可以混合使用。不同的声音对应不同的背景，网站非常有设计感，相信你会重新回来体验一次</li>
</ul>
<h3 id="9-The-Thoughts-Room"><a href="#9-The-Thoughts-Room" class="headerlink" title="9.The Thoughts Room"></a>9.<a href="http://thequietplaceproject.com/" target="_blank" rel="external">The Thoughts Room</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%993.jpg" alt=""></center>

<ul>
<li>一句话简洁：世界的秘密——树洞类网站。你可以在这里向全世界倾诉你的任何想法，网站支持37种语言，不过看了一下，没有中国…</li>
</ul>
<h3 id="10-Raining-Fm"><a href="#10-Raining-Fm" class="headerlink" title="10.Raining.Fm"></a>10.<a href="http://raining.fm/" target="_blank" rel="external">Raining.Fm</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%994.jpg" alt=""></center>

<ul>
<li>有时候，我们需要的仅仅是一点点雨声来帮助我们平静。网站专门提供雨声，因为单一，所以也更加专业。网站有3种不同的雨声类型，右侧有定时器可以在你放松时提醒你，简单也好用的一个网站，赞一个</li>
</ul>
<p>参考博客：<a href="https://www.licoy.cn/624.html" target="_blank" rel="external">传送门</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[优秀网站和博客]]></title>
      <url>https://fudawei.github.io/2016/06/23/%E4%BC%98%E7%A7%80%E7%BD%91%E7%AB%99%E5%92%8C%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><ul>
<li><p><a href="http://stormzhang.com/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="external">Android学习之路</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/af2de05aadff#rd" target="_blank" rel="external">国内外开发者的信息</a> 这里面收集了很多国内外开发者的信息, 大家可以去看看</p>
</li>
<li><p><a href="http://www.lrdup.net/" target="_blank" rel="external">键盘上的舞者</a> 东哥博客，主要是ios，其他编程啊之类的东西都有，很不错的一个站点，极力推荐</p>
</li>
<li><p><a href="http://blog.csdn.net/whjkm" target="_blank" rel="external">Just do it!</a> 杰哥博客，极力推荐</p>
</li>
</ul>
<ul>
<li><p><a href="https://www.licoy.cn/resource-sharing/fun-station" target="_blank" rel="external">憧憬点滴记忆</a>  比较综合的一个博客，技术文章，资源，项目，音乐，WEB等等都有</p>
</li>
<li><p><a href="http://tutuge.me/" target="_blank" rel="external">土土哥的技术Blog</a> 阿里的大神，iOS，Android等</p>
</li>
<li><p><a href="http://openhome.cc/Gossip/index.html" target="_blank" rel="external">台湾博主</a> 台湾的一个博主，有很多资料，主要是有Java资料，不过是繁体字</p>
</li>
<li><p><a href="http://0opslab.com/" target="_blank" rel="external">方丈</a> Java,JS,linux,python等等</p>
</li>
<li><p><a href="http://www.hollischuang.com/" target="_blank" rel="external">hollis blog</a> 有Java，框架，操作系统，以及其他综合类的很多文章，非常不错</p>
</li>
<li><p><a href="http://www.hankcs.com/program/java/" target="_blank" rel="external">码农场</a> C++,JAVA,机器算法，算法，软件等</p>
</li>
<li><p><a href="http://blog.csdn.net/lmj623565791" target="_blank" rel="external">Hongyang</a> Android,大神级别的博客啊！每一篇的文章的质量都很高，简直可以当电子书来看了</p>
</li>
<li><p><a href="http://blog.csdn.net/bboyfeiyu/article/list/2" target="_blank" rel="external">Mr.Simple的专栏</a> Android,写过《Android开发进阶 从小工到专家》《Android源码设计模式解析与实战》</p>
</li>
<li><p><a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="external">任玉刚</a> Android开发艺术探索这本书的作者</p>
</li>
<li><p><a href="http://blog.csdn.net/wwj_748" target="_blank" rel="external">巫山老妖</a> Android</p>
</li>
<li><p><a href="http://blog.csdn.net/aigestudio" target="_blank" rel="external">AigeStudio</a> Android</p>
</li>
<li><p><a href="http://blog.csdn.net/eclipsexys" target="_blank" rel="external">eclipse_xu</a> 《Android群英传》的作者</p>
</li>
<li><p><a href="http://blog.csdn.net/sinyu890807/" target="_blank" rel="external">郭霖的专栏</a> 《第一行代码的作者》</p>
</li>
<li><p><a href="http://blog.csdn.net/zhaokaiqiang1992" target="_blank" rel="external">赵凯强CSDN</a> <a href="http://kaizige.vip/" target="_blank" rel="external">赵凯强Hexo</a></p>
</li>
<li><p><a href="http://blog.csdn.net/xiangzhihong8" target="_blank" rel="external">xiangzhihong8的专栏</a></p>
</li>
<li><p><a href="http://blog.csdn.net/lzyzsd?viewmode=list" target="_blank" rel="external">大头鬼Bruce</a> 我是看他的博客写RxJava的</p>
</li>
<li><p><a href="http://blog.csdn.net/nugongahou110" target="_blank" rel="external">阿拉灯神灯的专栏</a> 学习Android自定义控件的好地方</p>
</li>
<li><p><a href="http://blog.csdn.net/qq_23547831?viewmode=contents" target="_blank" rel="external">一片枫叶的专栏</a> Android产品研发系列</p>
</li>
<li><p><a href="http://wuxiaolong.me/archives/" target="_blank" rel="external">吴小龙同學</a> Android</p>
</li>
<li><p><a href="http://android-developers.blogspot.com/" target="_blank" rel="external">Android Developers Blog</a> Android官网博客, 在上面可以关注Android最新的进展与最权威的博客(需翻墙)</p>
</li>
<li><p><a href="http://hukai.me/" target="_blank" rel="external">胡凯</a> 目前就职于腾讯上海从事Android开发的工作, 发起 Google Android 官方培训课程中文版翻译, 这课程是学习Android应用开发的绝佳资料</p>
</li>
<li><p><a href="http://www.trinea.cn/" target="_blank" rel="external">Trinea</a>  目前在滴滴负责 Android 客户端技术, 他是开源库项目收集达人, 你想要的开源库上面都有, 并且发起 Android 开源项目源码解析, 在使用开源库的同时也可以知道其中原理, 大家可以去关注一下, <a href="http://p.codekk.com/" target="_blank" rel="external">地址</a></p>
</li>
<li><p><a href="http://blog.daimajia.com/" target="_blank" rel="external">代码家</a> 90后Android大神, 称作库达人, 博主收集了很多Android开源库, 博主自己也做了很多开源库, 非常值得学习</p>
</li>
<li><p><a href="http://stormzhang.com/" target="_blank" rel="external">stormzhang</a> 博主是上海薄荷科技开发主管, 他的博客分享了他从编程白痴到自学 Android 一路走过的经验, 写了一篇 <a href="http://stormzhang.com/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="external">Android学习之路</a> 帮助了无数人, 里面还有很多好的文章非常适合新手入门, 并且是微信公众号「AndroidDeveloper」的运营者</p>
</li>
<li><p><a href="http://www.lightskystreet.com/" target="_blank" rel="external">light_sky</a> Android开发工程师, 目前在北京工作. Google big fan, 热爱开源, 热爱分享, 活跃于GitHub、G+、Twitter, 捕捉Android最新资讯和技术, ViewPagerIndicator 开源项目分析者</p>
</li>
<li><p><a href="http://blog.csdn.net/lmj623565791/" target="_blank" rel="external">张鸿洋</a> Android,张鴻洋是 CSDN 博客专家, 博主在 CSDN 所发布的每一篇文章都是干货, 都很值得大家去学习</p>
</li>
<li><p><a href="http://blog.csdn.net/xyz_lmn" target="_blank" rel="external">张兴业</a> Android,张兴业同样也是 CSDN 博客专家, 博主专注移动互联网开发，关注移动支付业务</p>
</li>
<li><p><a href="http://blog.csdn.net/lzyzsd/" target="_blank" rel="external">hi大头鬼hi</a> hi大头鬼hi 是阿里巴巴集团的一名 Android 工程师, 擅长 Android, RxJava, RxAndroid, ReactNative, Node.js, 大前端, 可谓是全栈工程师, 如果你对 RxJava 技术感兴趣, 不妨到他的博客看看, 他写了一系列有关 RxJava 的介绍</p>
</li>
</ul>
<h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><ul>
<li><p><a href="http://www.v2ex.com/?tab=tech" target="_blank" rel="external">v2ex</a> 国内的IT论坛</p>
</li>
<li><p><a href="http://stackoverflow.com/" target="_blank" rel="external">stackoverflow</a> 全球最大的IT论坛</p>
</li>
<li><p><a href="https://segmentfault.com/t/android" target="_blank" rel="external">SegmentFault</a> SegmentFault 是一个专注于解决编程问题, 提高开发技能的社区</p>
</li>
<li><p><a href="http://www.eoeandroid.com/forum.php" target="_blank" rel="external">eoe 移动开发者社区</a> 让移动开发更简单, 做最棒的开发者社区</p>
</li>
<li><p><a href="http://www.apkbus.com/" target="_blank" rel="external">APKBUS 安卓巴士</a> APKBUS 安卓巴士是一家服务于中国移动开发者学习与成长需要的综合社区服务平台</p>
</li>
<li><p><a href="http://chinagdg.org/" target="_blank" rel="external">谷歌开发者社区(GDG)</a> GDG 是 Google Developer Groups 的缩写, 中文名称是谷歌开发者社区</p>
</li>
<li><p><a href="http://gold.xitu.io/welcome" target="_blank" rel="external">掘金-稀土</a>  一个高质量的技术社区</p>
</li>
</ul>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><h3 id="技术网站"><a href="#技术网站" class="headerlink" title="技术网站"></a>技术网站</h3><ul>
<li><p><a href="https://www.livecoding.tv/" target="_blank" rel="external">livecoding</a> 代码直播平台</p>
</li>
<li><p><a href="https://handmadehero.org" target="_blank" rel="external">handMadeHero</a> 游戏开发视频网站</p>
</li>
<li><p><a href="https://next.36kr.com/posts/collections/61" target="_blank" rel="external">NEXT</a> H5界面制作工具集合</p>
</li>
</ul>
<h3 id="技术杂志周刊"><a href="#技术杂志周刊" class="headerlink" title="技术杂志周刊"></a>技术杂志周刊</h3><ul>
<li><p><a href="http://gank.io/" target="_blank" rel="external">干货集中营</a> 每个工作日推送最近比较火的技术和好看的妹纸</p>
</li>
<li><p><a href="http://www.androidweekly.cn/" target="_blank" rel="external">Android开发技术周报</a> 每周看一看有什么新技术和好东西出现</p>
</li>
</ul>
<h3 id="工具网站"><a href="#工具网站" class="headerlink" title="工具网站"></a>工具网站</h3><ul>
<li><p><a href="http://tool.oschina.net/" target="_blank" rel="external">在线工具</a> 常用的编程在线工具，录入正则表达式，API，RGB对照表之类的</p>
</li>
<li><p><a href="http://www.easyicon.net/" target="_blank" rel="external">easyicon</a> icon图标搜索引擎，非常不错的东西</p>
</li>
</ul>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul>
<li><p><a href="http://tool.oschina.net/apidocs/api" target="_blank" rel="external">常用 API</a> 常用API文档索引合集</p>
</li>
<li><p><a href="http://www.runoob.com" target="_blank" rel="external">runoob</a> 编程语言参考手册，有语法，使用规范之类的，包含很多语言</p>
</li>
<li><p><a href="https://github.com/JustinSDK/JavaSE6Tutorial" target="_blank" rel="external">Java SE 6 技术手册</a></p>
</li>
</ul>
<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><ul>
<li><p><a href="http://www.jianshu.com/p/af2de05aadff#rd" target="_blank" rel="external">Android 学习资料收集</a></p>
</li>
<li><p><a href="https://developer.android.com/training/index.html" target="_blank" rel="external">Android官方培训课程</a> 官方出品，必属精品。（需科学上网）</p>
</li>
<li><p><a href="http://www.nowcoder.com/" target="_blank" rel="external">牛客网</a> 面试题网站</p>
</li>
</ul>
<h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><ul>
<li><p><a href="https://github.com/googlesamples/android-UniversalMusicPlayer" target="_blank" rel="external">Google play music</a> 一个跨多个平台音乐播放器</p>
</li>
<li><p><a href="http://www.android-gems.com/category" target="_blank" rel="external">Android Gems</a>  将GitHub上优秀的Android开源项目做好各种分类，再也不需要在GitHub上瞎找了</p>
</li>
<li><p><a href="https://github.com/MiCode/Notes" target="_blank" rel="external">MIUI 便签</a> MiCode 便签是小米便签的社区开源版, 由 MIUI 团队（ww.miui.com）发起并贡献第一批代码, 遵循 NOTICE 文件所描述的开源协议</p>
</li>
<li><p><a href="https://github.com/eoecn/android-app" target="_blank" rel="external">eoe 客户端</a>     eoe 社区Android客户端</p>
</li>
</ul>
<h3 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h3><ul>
<li><p><a href="http://alamkanak.github.io/android-libraries-and-resources/" target="_blank" rel="external">Android Libraries and Resources</a></p>
</li>
<li><p><a href="http://android-arsenal.com/" target="_blank" rel="external">Android Arsenal</a> (一个专门收集 android 开源库的网站, 网站经常更新)</p>
</li>
<li><p><a href="http://www.jcodecraeer.com/plus/list.php?tid=31" target="_blank" rel="external">泡在网上的日子</a></p>
</li>
<li><p><a href="https://github.com/Trinea/android-open-project" target="_blank" rel="external">Android 开源项目汇总</a> (Trinea 大神收集的)</p>
</li>
<li><p><a href="http://codekk.com/open-source-project-analysis" target="_blank" rel="external">Android 开源项目源码分析</a> (在懂得使用这些开源项目同时, 也应该了解当中的原理)</p>
</li>
</ul>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><ul>
<li><p><a href="http://www.zhihu.com/question/19775981" target="_blank" rel="external">有哪些 Android 大牛的 blog 值得推荐?</a></p>
</li>
<li><p><a href="http://www.zhihu.com/question/23804819" target="_blank" rel="external">GitHub 上都有哪些值得关注学习的 Android项目?</a></p>
</li>
</ul>
<h3 id="素材和设计"><a href="#素材和设计" class="headerlink" title="素材和设计"></a>素材和设计</h3><ul>
<li><p><a href="http://tool.c7sky.com/webcolor/" target="_blank" rel="external">常用色彩搭配表</a></p>
</li>
<li><p><a href="http://www.colorhunt.co/" target="_blank" rel="external">ColorHunt-色彩搭配</a></p>
</li>
<li><p><a href="http://www.materialpalette.com/" target="_blank" rel="external">在线 Material Design 界面调色板</a></p>
</li>
<li><p><a href="http://www.materialup.com/" target="_blank" rel="external">Material Design设计模板与素材</a></p>
</li>
<li><p><a href="https://icons8.com/" target="_blank" rel="external">App Icon 图标</a></p>
</li>
<li><p><a href="https://iconstore.co/" target="_blank" rel="external">Icon Store</a></p>
</li>
</ul>
<h3 id="影视网站"><a href="#影视网站" class="headerlink" title="影视网站"></a>影视网站</h3><ul>
<li><p><a href="http://www.zhaifu.cc/bl/dianying/" target="_blank" rel="external">腐宅资源站</a> 各种电影电视剧动画资源</p>
</li>
<li><p><a href="http://www.565k.com/" target="_blank" rel="external">565k</a> 各种电影</p>
</li>
</ul>
<h3 id="音乐网站"><a href="#音乐网站" class="headerlink" title="音乐网站"></a>音乐网站</h3><ul>
<li><p><a href="http://www.mtyyw.com" target="_blank" rel="external">麦田音乐网</a> 主要是轻音乐，民谣，电台，歌单，摇滚，原声，影像，还有有文艺范的画，故事等等……</p>
</li>
<li><p><a href="https://music.douban.com/" target="_blank" rel="external">豆瓣音乐</a> 豆瓣，情怀，不解释</p>
</li>
<li><p><a href="http://www.top100.cn/" target="_blank" rel="external">巨鲸音乐</a> 看起来挺简洁，符合我的风格，先试试</p>
</li>
<li><p><a href="https://yahoo.streetvoice.com/" target="_blank" rel="external">奇摩音乐</a> 看起来还不错的样子~</p>
</li>
<li><p><a href="http://music.weibo.com/" target="_blank" rel="external">微博音乐</a> 草根比较多，应该还可以~</p>
</li>
</ul>
<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul>
<li><p><a href="https://book.douban.com/subject/26599539/" target="_blank" rel="external">Android群英传</a> 这是一本进阶的书 <a href="http://pan.baidu.com/s/1c2gGl6C" target="_blank" rel="external">传送门</a></p>
</li>
<li><p><a href="https://book.douban.com/subject/26599538/" target="_blank" rel="external">Android开发艺术探索</a> 网上的好评如潮，是一本进阶的好书</p>
</li>
<li><p><a href="https://book.douban.com/subject/26644935/" target="_blank" rel="external">Android源码设计模式解析与实战</a></p>
</li>
<li><p><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="external">Effective Java</a></p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><a href="https://bandwagonhost.com/index.php" target="_blank" rel="external">搬瓦工</a> 美国的VPS网站，最低大概120人民币一年</li>
</ul>
<a id="more"></a>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis学习笔记]]></title>
      <url>https://fudawei.github.io/2016/06/09/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="MyBatis-接触"><a href="#MyBatis-接触" class="headerlink" title="MyBatis 接触"></a>MyBatis 接触</h3><p>configure.xml</p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!DOCTYPE configuration PUBLIC “-//mybatis.org//DTD Config 3.0//EN”<br>“<a href="http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;" target="_blank" rel="external">http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</a></p>
<configuration><br>    <typealiases><br>        <typealias alias="User" type="com.yihaomen.mybatis.model.User"><br>    </typealias></typealiases><br><br>    <environments default="development"><br>        <environment id="development"><br>        <transactionmanager type="JDBC"><br>            <datasource type="POOLED"><br>            <property name="driver" value="com.mysql.jdbc.Driver"><br>            <property name="url" value="jdbc:mysql://127.0.0.1:3306/test"><br>            <property name="username" value="root"><br>            <property name="password" value="root"><br>            </property></property></property></property></datasource><br>        </transactionmanager></environment><br>    </environments><br><br>    <mappers><br>        <mapper resource="com/yihaomen/mybatis/model/User.xml"><br>    </mapper></mappers><br></configuration>

<p>user.xml</p>
<mapper namespace="com.yihaomen.mybatis.models.UserMapper"><br>    <select id="selectUserByID" parametertype="int" resulttype="User"><br>        select * from <code>user</code> where id = #{id}<br>    </select><br></mapper>


<p>public class Test {<br>    private static SqlSessionFactory sqlSessionFactory;<br>    private static Reader reader;</p>
<pre><code>static {
    try {
        reader = Resources.getResourceAsReader(&quot;Configuration.xml&quot;);
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

public static void main(String[] args) {
    SqlSession session = sqlSessionFactory.openSession();
    try {
        User user = (User) session.selectOne(
                &quot;com.yihaomen.mybatis.models.UserMapper.selectUserByID&quot;, 1);
        System.out.println(user.getUserAddress());
        System.out.println(user.getUserName());
    } finally {
        session.close();
    }
}
</code></pre><p>}</p>
<h3 id="使用接口实现"><a href="#使用接口实现" class="headerlink" title="使用接口实现"></a>使用接口实现</h3><p>user.xml ,改变namespace的值，指向接口</p>
<mapper namespace="com.yihaomen.mybatis.inter.IUserOperation"><br>    <select id="selectUserByID" parametertype="int" resulttype="User"><br>        select * from <code>user</code> where id = #{id}<br>    </select><br></mapper>

<p>public static void main(String[] args) {<br>        SqlSession session = sqlSessionFactory.openSession();<br>        try {<br>            IUserOperation userOperation = session.getMapper(IUserOperation.class);<br>            User user = userOperation.selectUserByID(1);<br>            System.out.println(user.getUserAddress());<br>            System.out.println(user.getUserName());<br>        } finally {<br>            session.close();<br>        }<br>    }</p>
<h3 id="mybatis实现数据的增删改查"><a href="#mybatis实现数据的增删改查" class="headerlink" title="mybatis实现数据的增删改查"></a>mybatis实现数据的增删改查</h3><p>一、 查找<br>User.xml 配置</p>
<mapper namespace="com.yihaomen.mybatis.inter.IUserOperation"><br>    <select id="selectUserByID" parametertype="int" resulttype="User"><br>        select <em> from <code>user</code> where id = #{id}<br>    </em></select><br>    <resultmap type="User" id="resultListUser"><br>        <id column="id" property="id"><br>        <result column="userName" property="userName"><br>        <result column="userAge" property="userAge"><br>        <result column="userAddress" property="userAddress"><br>    </result></result></result></id></resultmap><br>    <select id="selectUsers" parametertype="string" resultmap="resultListUser"><br>        select  from user where userName like #{userName}<br>    </select><br></mapper>

<p>接口增加方法<br>public interface IUserOperation {<br>    public User selectUserByID(int id);<br>    public List<user> selectUsers(String userName);<br>}</user></p>
<p>测试类<br>    public static void main(String[] args) {<br>        Test testUser = new Test();<br>        testUser.getUserList(“%”);<br>    }</p>
<pre><code>public void getUserList(String userName){
    SqlSession session = sqlSessionFactory.openSession();
    try {
        IUserOperation userOperation = session
                .getMapper(IUserOperation.class);
        List&lt;User&gt; users = userOperation.selectUsers(userName);
        for (User user : users) {
            System.out.println(user.getId() + &quot;:&quot; + user.getUserName()
                    + &quot;:&quot; + user.getUserAddress());
        }
    } finally {
        session.close();
    }
}
</code></pre><p>二、 增加<br>user.xml</p>
<insert id="addUser" parametertype="User" usegeneratedkeys="true" keyproperty="id"><br>        insert into user(userName,userAge,userAddress)<br>             values(#{userName},#{userAge},#{userAddress})<br></insert>

<p>public interface IUserOperation {<br>    public User selectUserByID(int id);<br>    public List<user> selectUsers(String userName);<br>    public void addUser(User user);<br>}</user></p>
<p>public static void main(String[] args) {<br>        User user = new User();<br>        user.setUserAddress(“人民广场”);<br>        user.setUserName(“飞鸟”);<br>        user.setUserAge(20);<br>        SqlSession session = sqlSessionFactory.openSession();<br>        try {<br>            IUserOperation userOperation = session.getMapper(IUserOperation.class);<br>            userOperation.addUser(user);<br>            session.commit();<br>            System.out.println(“id : “+user.getId());<br>        } catch (Exception e) {<br>            // TODO: handle exception<br>        }finally{<br>            session.close();<br>        }<br>    }</p>
<p>三、更新数据</p>
<update id="updateUser" parametertype="User"><br>        update user set userName=#{userName},userAge=#{userAge},userAddress=#{userAddress} where id=#{id}<br></update>

<p>public interface IUserOperation {<br>    public User selectUserByID(int id);<br>    public List<user> selectUsers(String userName);<br>    public void addUser(User user);<br>    public void updateUser(User user);<br>}</user></p>
<p>public static void main(String[] args) {<br>        SqlSession session = sqlSessionFactory.openSession();<br>        try {<br>            IUserOperation userOperation = session.getMapper(IUserOperation.class);<br>            User user = userOperation.selectUserByID(4);<br>            user.setUserAddress(“hell”);<br>            userOperation.updateUser(user);<br>            session.commit();<br>        } catch (Exception e) {<br>            // TODO: handle exception<br>        }finally{<br>            session.close();<br>        }<br>    }</p>
<p>四、删除数据<br> <delete id="deleteUser" parametertype="int"><br>        delete from user where id=#{id}<br> </delete></p>
<p> public interface IUserOperation {<br>    public User selectUserByID(int id);<br>    public List<user> selectUsers(String userName);<br>    public void addUser(User user);<br>    public void updateUser(User user);<br>    public void deleteUser(int id);<br>}</user></p>
<p>public static void main(String[] args) {<br>        SqlSession session = sqlSessionFactory.openSession();<br>        try {<br>            IUserOperation userOperation = session.getMapper(IUserOperation.class);<br>            userOperation.deleteUser(4);<br>            session.commit();<br>        } catch (Exception e) {<br>            // TODO: handle exception<br>        }finally{<br>            session.close();<br>        }<br>    }<br>五、表关联<br>    别名：<br>    <typealiases><br>        <typealias alias="Article" type="com.yihaomen.mybatis.model.Article"><br>    </typealias></typealiases></p>
<pre><code>&lt;resultMap id=&quot;resultUserArticleList&quot; type=&quot;com.yihaomen.mybatis.model.Article&quot;&gt;  // 写全类名，否则提示找不到类
    &lt;id property=&quot;id&quot; column=&quot;aid&quot;/&gt;
    &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;
    &lt;result property=&quot;content&quot; column=&quot;content&quot;/&gt;

    &lt;association property=&quot;user&quot; javaType=&quot;User&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
        &lt;result property=&quot;userName&quot; column=&quot;userName&quot;/&gt;
        &lt;result property=&quot;userAddress&quot; column=&quot;userAddress&quot;/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;getUserArticles&quot; parameterType=&quot;int&quot; resultMap=&quot;resultUserArticleList&quot;&gt;
   select user.id,user.userName,user.userAddress,article.id aid,article.title,article.content from user,article
          where user.id=article.userid and user.id=#{id}
&lt;/select&gt;
</code></pre><p>public class Article {<br>    private int id;<br>    private User user;<br>    private String title;<br>    private String content;<br>}</p>
<p>public interface IUserOperation {<br>    public User selectUserByID(int id);<br>    public List<user> selectUsers(String userName);<br>    public void addUser(User user);<br>    public void updateUser(User user);<br>    public void deleteUser(int id);<br>    public List<article> getUserArticles(int id);<br>}</article></user></p>
<p>public void getUserArticles(int userid){<br>        SqlSession session = sqlSessionFactory.openSession();<br>        try {<br>            IUserOperation userOperation = session.getMapper(IUserOperation.class);<br>            List<article> articles = userOperation.getUserArticles(userid);<br>            for (Article article : articles) {<br>                System.out.println(article.getTitle()+”:”+article.getContent()+”:”+article.getUser().getUserName()+”:”<br>                        +article.getUser().getUserAddress());<br>            }<br>        } catch (Exception e) {<br>        } finally{<br>            session.close();<br>        }<br>    }</article></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常见的网络攻击原理分析]]></title>
      <url>https://fudawei.github.io/2016/06/09/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>常见网络攻击手段原理分析</p>
<h3 id="TCP-SYN拒绝服务攻击"><a href="#TCP-SYN拒绝服务攻击" class="headerlink" title="TCP SYN拒绝服务攻击"></a>TCP SYN拒绝服务攻击</h3><p>一般情况下，一个TCP连接的建立需要经过三次握手的过程，即：<br>1、 建立发起者向目标计算机发送一个TCP SYN报文；<br>2、 目标计算机收到这个SYN报文后，在内存中创建TCP连接控制块（TCB），然后向发起者回送一个TCP ACK报文，等待发起者的回应；<br>3、 发起者收到TCP ACK报文后，再回应一个ACK报文，这样TCP连接就建立起来了。<br>利用这个过程，一些恶意的攻击者可以进行所谓的TCP SYN拒绝服务攻击：<br>1、 攻击者向目标计算机发送一个TCP SYN报文；<br>2、 目标计算机收到这个报文后，建立TCP连接控制结构（TCB），并回应一个ACK，等待发起者的回应；<br>3、 而发起者则不向目标计算机回应ACK报文，这样导致目标计算机一致处于等待状态。<br>可以看出，目标计算机如果接收到大量的TCP SYN报文，而没有收到发起者的第三次ACK回应，会一直等待，处于这样尴尬状态的半连接如果很多，则会把目标计算机的资源（TCB控制结构，TCB，一般情况下是有限的）耗尽，而不能响应正常的TCP连接请求。</p>
<h3 id="ICMP洪水"><a href="#ICMP洪水" class="headerlink" title="ICMP洪水"></a>ICMP洪水</h3><p>正常情况下，为了对网络进行诊断，一些诊断程序，比如PING等，会发出ICMP响应请求报文（ICMP ECHO），接收计算机接收到ICMP ECHO后，会回应一个ICMP ECHO Reply报文。而这个过程是需要CPU处理的，有的情况下还可能消耗掉大量的资源，比如处理分片的时候。这样如果攻击者向目标计算机发送大量的ICMP ECHO报文（产生ICMP洪水），则目标计算机会忙于处理这些ECHO报文，而无法继续处理其它的网络数据报文，这也是一种拒绝服务攻击（DOS）。</p>
<h3 id="UDP洪水"><a href="#UDP洪水" class="headerlink" title="UDP洪水"></a>UDP洪水</h3><p>原理与ICMP洪水类似，攻击者通过发送大量的UDP报文给目标计算机，导致目标计算机忙于处理这些UDP报文而无法继续处理正常的报文。</p>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>根据TCP协议规范，当一台计算机收到一个TCP连接建立请求报文（TCP SYN）的时候，做这样的处理：<br>1、 如果请求的TCP端口是开放的，则回应一个TCP ACK报文，并建立TCP连接控制结构（TCB）；<br>2、 如果请求的TCP端口没有开放，则回应一个TCP RST（TCP头部中的RST标志设为1）报文，告诉发起计算机，该端口没有开放。</p>
<p>相应地，如果IP协议栈收到一个UDP报文，做如下处理：<br>1、 如果该报文的目标端口开放，则把该UDP报文送上层协议（UDP）处理，不回应任何报文（上层协议根据处理结果而回应的报文例外）；<br>2、 如果该报文的目标端口没有开放，则向发起者回应一个ICMP不可达报文，告诉发起者计算机该UDP报文的端口不可达。</p>
<p>利用这个原理，攻击者计算机便可以通过发送合适的报文，判断目标计算机哪些TCP或UDP端口是开放的，过程如下：<br>1、 发出端口号从0开始依次递增的TCP SYN或UDP报文（端口号是一个16比特的数字，这样最大为65535，数量很有限）；<br>2、 如果收到了针对这个TCP报文的RST报文，或针对这个UDP报文的ICMP不可达报文，则说明这个端口没有开放；<br>3、 相反，如果收到了针对这个TCP SYN报文的ACK报文，或者没有接收到任何针对该UDP报文的ICMP报文，则说明该TCP端口是开放的，UDP端口可能开放（因为有的实现中可能不回应ICMP不可达报文，即使该UDP端口没有开放）。</p>
<p>这样继续下去，便可以很容易的判断出目标计算机开放了哪些TCP或UDP端口，然后针对端口的具体数字，进行下一步攻击，这就是所谓的端口扫描攻击。</p>
<h3 id="分片IP报文攻击"><a href="#分片IP报文攻击" class="headerlink" title="分片IP报文攻击"></a>分片IP报文攻击</h3><p>为了传送一个大的IP报文，IP协议栈需要根据链路接口的MTU对该IP报文进行分片，通过填充适当的IP头中的分片指示字段，接收计算机可以很容易的把这些IP分片报文组装起来。<br>目标计算机在处理这些分片报文的时候，会把先到的分片报文缓存起来，然后一直等待后续的分片报文，这个过程会消耗掉一部分内存，以及一些IP协议栈的数据结构。如果攻击者给目标计算机只发送一片分片报文，而不发送所有的分片报文，这样攻击者计算机便会一直等待（直到一个内部计时器到时），如果攻击者发送了大量的分片报文，就会消耗掉目标计算机的资源，而导致不能相应正常的IP报文，这也是一种DOS攻击。</p>
<h3 id="SYN比特和FIN比特同时设置"><a href="#SYN比特和FIN比特同时设置" class="headerlink" title="SYN比特和FIN比特同时设置"></a>SYN比特和FIN比特同时设置</h3><p>在TCP报文的报头中，有几个标志字段：<br>1、 SYN：连接建立标志，TCP SYN报文就是把这个标志设置为1，来请求建立连接；<br>2、 ACK：回应标志，在一个TCP连接中，除了第一个报文（TCP SYN）外，所有报文都设置该字段，作为对上一个报文的相应；<br>3、 FIN：结束标志，当一台计算机接收到一个设置了FIN标志的TCP报文后，会拆除这个TCP连接；<br>4、 RST：复位标志，当IP协议栈接收到一个目标端口不存在的TCP报文的时候，会回应一个RST标志设置的报文；<br>5、 PSH：通知协议栈尽快把TCP数据提交给上层程序处理。</p>
<p>正常情况下，SYN标志（连接请求标志）和FIN标志（连接拆除标志）是不能同时出现在一个TCP报文中的。而且RFC也没有规定IP协议栈如何处理这样的畸形报文，因此，各个操作系统的协议栈在收到这样的报文后的处理方式也不同，攻击者就可以利用这个特征，通过发送SYN和FIN同时设置的报文，来判断操作系统的类型，然后针对该操作系统，进行进一步的攻击。</p>
<h3 id="没有设置任何标志的TCP报文攻击"><a href="#没有设置任何标志的TCP报文攻击" class="headerlink" title="没有设置任何标志的TCP报文攻击"></a>没有设置任何标志的TCP报文攻击</h3><p>正常情况下，任何TCP报文都会设置SYN，FIN，ACK，RST，PSH五个标志中的至少一个标志，第一个TCP报文（TCP连接请求报文）设置SYN标志，后续报文都设置ACK标志。有的协议栈基于这样的假设，没有针对不设置任何标志的TCP报文的处理过程，因此，这样的协议栈如果收到了这样的报文，可能会崩溃。攻击者利用了这个特点，对目标计算机进行攻击。</p>
<h3 id="设置了FIN标志却没有设置ACK标志的TCP报文攻击"><a href="#设置了FIN标志却没有设置ACK标志的TCP报文攻击" class="headerlink" title="设置了FIN标志却没有设置ACK标志的TCP报文攻击"></a>设置了FIN标志却没有设置ACK标志的TCP报文攻击</h3><p>正常情况下，ACK标志在除了第一个报文（SYN报文）外，所有的报文都设置，包括TCP连接拆除报文（FIN标志设置的报文）。但有的攻击者却可能向目标计算机发送设置了FIN标志却没有设置ACK标志的TCP报文，这样可能导致目标计算机崩溃。</p>
<h3 id="死亡之PING"><a href="#死亡之PING" class="headerlink" title="死亡之PING"></a>死亡之PING</h3><p>TCP/IP规范要求IP报文的长度在一定范围内（比如，0－64K），但有的攻击计算机可能向目标计算机发出大于64K长度的PING报文，导致目标计算机IP协议栈崩溃。</p>
<h3 id="地址猜测攻击"><a href="#地址猜测攻击" class="headerlink" title="地址猜测攻击"></a>地址猜测攻击</h3><p>跟端口扫描攻击类似，攻击者通过发送目标地址变化的大量的ICMP ECHO报文，来判断目标计算机是否存在。如果收到了对应的ECMP ECHO REPLY报文，则说明目标计算机是存在的，便可以针对该计算机进行下一步的攻击。<br>[page]</p>
<h3 id="泪滴攻击"><a href="#泪滴攻击" class="headerlink" title="泪滴攻击"></a>泪滴攻击</h3><p>对于一些大的IP包，需要对其进行分片传送，这是为了迎合链路层的MTU（最大传输单元）的要求。比如，一个4500字节的IP包，在MTU为1500的链路上传输的时候，就需要分成三个IP包。<br>在IP报头中有一个偏移字段和一个分片标志（MF），如果MF标志设置为1，则表面这个IP包是一个大IP包的片断，其中偏移字段指出了这个片断在整个IP包中的位置。例如，对一个4500字节的IP包进行分片（MTU为1500），则三个片断中偏移字段的值依次为：0，1500，3000。这样接收端就可以根据这些信息成功的组装该IP包。<br>如果一个攻击者打破这种正常情况，把偏移字段设置成不正确的值，即可能出现重合或断开的情况，就可能导致目标操作系统崩溃。比如，把上述偏移设置为0，1300，3000。这就是所谓的泪滴攻击。</p>
<h3 id="带源路由选项的IP报文"><a href="#带源路由选项的IP报文" class="headerlink" title="带源路由选项的IP报文"></a>带源路由选项的IP报文</h3><p>为了实现一些附加功能，IP协议规范在IP报头中增加了选项字段，这个字段可以有选择的携带一些数据，以指明中间设备（路由器）或最终目标计算机对这些IP报文进行额外的处理。<br>源路由选项便是其中一个，从名字中就可以看出，源路由选项的目的，是指导中间设备（路由器）如何转发该数据报文的，即明确指明了报文的传输路径。比如，让一个IP报文明确的经过三台路由器R1，R2，R3，则可以在源路由选项中明确指明这三个路由器的接口地址，这样不论三台路由器上的路由表如何，这个IP报文就会依次经过R1，R2，R3。而且这些带源路由选项的IP报文在传输的过程中，其源地址不断改变，目标地址也不断改变，因此，通过合适的设置源路由选项，攻击者便可以伪造一些合法的IP地址，而蒙混进入网络。</p>
<h3 id="带记录路由选项的IP报文"><a href="#带记录路由选项的IP报文" class="headerlink" title="带记录路由选项的IP报文"></a>带记录路由选项的IP报文</h3><p>记录路由选项也是一个IP选项，携带了该选项的IP报文，每经过一台路由器，该路由器便把自己的接口地址填在选项字段里面。这样这些报文在到达目的地的时候，选项数据里面便记录了该报文经过的整个路径。<br>通过这样的报文可以很容易的判断该报文经过的路径，从而使攻击者可以很容易的寻找其中的攻击弱点。</p>
<h3 id="未知协议字段的IP报文"><a href="#未知协议字段的IP报文" class="headerlink" title="未知协议字段的IP报文"></a>未知协议字段的IP报文</h3><p>在IP报文头中，有一个协议字段，这个字段指明了该IP报文承载了何种协议 ，比如，如果该字段值为1，则表明该IP报文承载了ICMP报文，如果为6，则是TCP，等等。目前情况下，已经分配的该字段的值都是小于100的，因此，一个带大于100的协议字段的IP报文，可能就是不合法的，这样的报文可能对一些计算机操作系统的协议栈进行破坏。</p>
<h3 id="IP地址欺骗"><a href="#IP地址欺骗" class="headerlink" title="IP地址欺骗"></a>IP地址欺骗</h3><p>一般情况下，路由器在转发报文的时候，只根据报文的目的地址查路由表，而不管报文的源地址是什么，因此，这样就 可能面临一种危险：如果一个攻击者向一台目标计算机发出一个报文，而把报文的源地址填写为第三方的一个IP地址，这样这个报文在到达目标计算机后，目标计算机便可能向毫无知觉的第三方计算机回应。这便是所谓的IP地址欺骗攻击。<br>比较著名的SQL Server蠕虫病毒，就是采用了这种原理。该病毒（可以理解为一个攻击者）向一台运行SQL Server解析服务的服务器发送一个解析服务的UDP报文，该报文的源地址填写为另外一台运行SQL Server解析程序（SQL Server 2000以后版本）的服务器，这样由于SQL Server 解析服务的一个漏洞，就可能使得该UDP报文在这两台服务器之间往复，最终导致服务器或网络瘫痪。</p>
<h3 id="WinNuke攻击"><a href="#WinNuke攻击" class="headerlink" title="WinNuke攻击"></a>WinNuke攻击</h3><p>NetBIOS作为一种基本的网络资源访问接口，广泛的应用于文件共享，打印共享，进程间通信（IPC），以及不同操作系统之间的数据交换。一般情况下，NetBIOS是运行在LLC2链路协议之上的，是一种基于组播的网络访问接口。为了在TCP/IP协议栈上实现NetBIOS，RFC规定了一系列交互标准，以及几个常用的TCP/UDP端口：<br>139：NetBIOS会话服务的TCP端口；<br>137：NetBIOS名字服务的UDP端口；<br>136：NetBIOS数据报服务的UDP端口。<br>WINDOWS操作系统的早期版本（WIN95/98/NT）的网络服务（文件共享等）都是建立在NetBIOS之上的，因此，这些操作系统都开放了139端口（最新版本的WINDOWS 2000/XP/2003等，为了兼容，也实现了NetBIOS over TCP/IP功能，开放了139端口）。<br>WinNuke攻击就是利用了WINDOWS操作系统的一个漏洞，向这个139端口发送一些携带TCP带外（OOB）数据报文，但这些攻击报文与正常携带OOB数据报文不同的是，其指针字段与数据的实际位置不符，即存在重合，这样WINDOWS操作系统在处理这些数据的时候，就会崩溃。</p>
<h3 id="Land攻击"><a href="#Land攻击" class="headerlink" title="Land攻击"></a>Land攻击</h3><p>LAND攻击利用了TCP连接建立的三次握手过程，通过向一个目标计算机发送一个TCP SYN报文（连接建立请求报文）而完成对目标计算机的攻击。与正常的TCP SYN报文不同的是，LAND攻击报文的源IP地址和目的IP地址是相同的，都是目标计算机的IP地址。这样目标计算机接收到这个SYN报文后，就会向该报文的源地址发送一个ACK报文，并建立一个TCP连接控制结构（TCB），而该报文的源地址就是自己，因此，这个ACK报文就发给了自己。这样如果攻击者发送了足够多的SYN报文，则目标计算机的TCB可能会耗尽，最终不能正常服务。这也是一种DOS攻击。</p>
<h3 id="Script-ActiveX攻击"><a href="#Script-ActiveX攻击" class="headerlink" title="Script/ActiveX攻击"></a>Script/ActiveX攻击</h3><p>Script是一种可执行的脚本，它一般由一些脚本语言写成，比如常见的JAVA SCRIPT，VB SCRIPT等。这些脚本在执行的时候，需要一个专门的解释器来翻译，翻译成计算机指令后，在本地计算机上运行。这种脚本的好处是，可以通过少量的程序写作，而完成大量的功能。<br>这种SCRIPT的一个重要应用就是嵌入在WEB页面里面，执行一些静态WEB页面标记语言（HTML）无法完成的功能，比如本地计算，数据库查询和修改，以及系统信息的提取等。这些脚本在带来方便和强大功能的同时，也为攻击者提供了方便的攻击途径。如果攻击者写一些对系统有破坏的SCRIPT，然后嵌入在WEB页面中，一旦这些页面被下载到本地，计算机便以当前用户的权限执行这些脚本，这样，当前用户所具有的任何权限，SCRIPT都可以使用，可以想象这些恶意的SCRIPT的破坏程度有多强。这就是所谓的SCRIPT攻击。<br>ActiveX是一种控件对象，它是建立在MICROSOFT的组件对象模型（COM）之上的，而COM则几乎是Windows操作系统的基础结构。可以简单的理解，这些控件对象是由方法和属性构成的，方法即一些操作，而属性则是一些特定的数据。这种控件对象可以被应用程序加载，然后访问其中的方法或属性，以完成一些特定的功能。可以说，COM提供了一种二进制的兼容模型（所谓二进制兼容，指的是程序模块与调用的编译环境，甚至操作系统没有关系）。但需要注意的是，这种对象控件不能自己执行，因为它没有自己的进程空间，而只能由其它进程加载，并调用其中的方法和属性，这时候，这些控件便在加载进程的进程空间运行，类似与操作系统的可加载模块，比如DLL库。<br>ActiveX控件可以嵌入在WEB页面里面，当浏览器下载这些页面到本地后，相应地也下载了嵌入在其中的ActiveX控件，这样这些控件便可以在本地浏览器进程空间中运行（ActiveX空间没有自己的进程空间，只能由其它进程加载并调用），因此，当前用户的权限有多大，ActiveX的破坏性便有多大。如果一个恶意的攻击者编写一个含有恶意代码的ActiveX控件，然后嵌入在WEB页面中，被一个浏览用户下载后执行，其破坏作用是非常大的。这便是所谓的ActiveX攻击。</p>
<h3 id="Smurf攻击"><a href="#Smurf攻击" class="headerlink" title="Smurf攻击"></a>Smurf攻击</h3><p>ICMP ECHO请求包用来对网络进行诊断，当一台计算机接收到这样一个报文后，会向报文的源地址回应一个ICMP ECHO REPLY。一般情况下，计算机是不检查该ECHO请求的源地址的，因此，如果一个恶意的攻击者把ECHO的源地址设置为一个广播地址，这样计算机在恢复REPLY的时候，就会以广播地址为目的地址，这样本地网络上所有的计算机都必须处理这些广播报文。如果攻击者发送的ECHO 请求报文足够多，产生的REPLY广播报文就可能把整个网络淹没。这就是所谓的smurf攻击。<br>除了把ECHO报文的源地址设置为广播地址外，攻击者还可能把源地址设置为一个子网广播地址，这样，该子网所在的计算机就可能受影响。</p>
<h3 id="虚拟终端（VTY）耗尽攻击"><a href="#虚拟终端（VTY）耗尽攻击" class="headerlink" title="虚拟终端（VTY）耗尽攻击"></a>虚拟终端（VTY）耗尽攻击</h3><p>这是一种针对网络设备的攻击，比如路由器，交换机等。这些网络设备为了便于远程管理，一般设置了一些TELNET用户界面，即用户可以通过TELNET到该设备上，对这些设备进行管理。<br>一般情况下，这些设备的TELNET用户界面个数是有限制的，比如，5个或10个等。这样，如果一个攻击者同时同一台网络设备建立了5个或10个TELNET连接，这些设备的远程管理界面便被占尽，这样合法用户如果再对这些设备进行远程管理，则会因为TELNET连接资源被占用而失败。</p>
<h3 id="路由协议攻击"><a href="#路由协议攻击" class="headerlink" title="路由协议攻击"></a>路由协议攻击</h3><p>网络设备之间为了交换路由信息，常常运行一些动态的路由协议，这些路由协议可以完成诸如路由表的建立，路由信息的分发等功能。常见的路由协议有RIP，OSPF，IS-IS，BGP等。这些路由协议在方便路由信息管理和传递的同时，也存在一些缺陷，如果攻击者利用了路由协议的这些权限，对网络进行攻击，可能造成网络设备路由表紊乱（这足可以导致网络中断），网络设备资源大量消耗，甚至导致网络设备瘫痪。<br>下面列举一些常见路由协议的攻击方式及原理：</p>
<ul>
<li><p>针对RIP协议的攻击<br>RIP，即路由信息协议，是通过周期性（一般情况下为30S）的路由更新报文来维护路由表的，一台运行RIP路由协议的路由器，如果从一个接口上接收到了一个路由更新报文，它就会分析其中包含的路由信息，并与自己的路由表作出比较，如果该路由器认为这些路由信息比自己所掌握的要有效，它便把这些路由信息引入自己的路由表中。<br>这样如果一个攻击者向一台运行RIP协议的路由器发送了人为构造的带破坏性的路由更新报文，就很容易的把路由器的路由表搞紊乱，从而导致网络中断。<br>如果运行RIP路由协议的路由器启用了路由更新信息的HMAC验证，则可从很大程度上避免这种攻击。</p>
</li>
<li><p>针对OSPF路由协议的攻击<br>OSPF，即开放最短路径优先，是一种应用广泛的链路状态路由协议。该路由协议基于链路状态算法，具有收敛速度快，平稳，杜绝环路等优点，十分适合大型的计算机网络使用。OSPF路由协议通过建立邻接关系，来交换路由器的本地链路信息，然后形成一个整网的链路状态数据库，针对该数据库，路由器就可以很容易的计算出路由表。<br>可以看出，如果一个攻击者冒充一台合法路由器与网络中的一台路由器建立邻接关系，并向攻击路由器输入大量的链路状态广播（LSA，组成链路状态数据库的数据单元），就会引导路由器形成错误的网络拓扑结构，从而导致整个网络的路由表紊乱，导致整个网络瘫痪。<br>当前版本的WINDOWS 操作系统（WIN 2K/XP等）都实现了OSPF路由协议功能，因此一个攻击者可以很容易的利用这些操作系统自带的路由功能模块进行攻击。<br>跟RIP类似，如果OSPF启用了报文验证功能（HMAC验证），则可以从很大程度上避免这种攻击。</p>
</li>
<li>针对IS-IS路由协议的攻击<br>IS-IS路由协议，即中间系统到中间系统，是ISO提出来对ISO的CLNS网络服务进行路由的一种协议，这种协议也是基于链路状态的，原理与OSPF类似。IS-IS路由协议经过 扩展，可以运行在IP网络中，对IP报文进行选路。这种路由协议也是通过建立邻居关系，收集路由器本地链路状态的手段来完成链路状态数据库同步的。该协议的邻居关系建立比OSPF简单，而且也省略了OSPF特有的一些特性，使该协议简单明了，伸缩性更强。<br>对该协议的攻击与OSPF类似，通过一种模拟软件与运行该协议的路由器建立邻居关系，然后传颂给攻击路由器大量的链路状态数据单元（LSP），可以导致整个网络路由器的链路状态数据库不一致（因为整个网络中所有路由器的链路状态数据库都需要同步到相同的状态），从而导致路由表与实际情况不符，致使网络中断。<br>与OSPF类似，如果运行该路由协议的路由器启用了IS-IS协议单元（PDU）HMAC验证功能，则可以从很大程度上避免这种攻击。</li>
</ul>
<h3 id="针对设备转发表的攻击"><a href="#针对设备转发表的攻击" class="headerlink" title="针对设备转发表的攻击"></a>针对设备转发表的攻击</h3><ul>
<li>为了合理有限的转发数据，网络设备上一般都建立一些寄存器表项，比如MAC地址表，ARP表，路由表，快速转发表，以及一些基于更多报文头字段的表格，比如多层交换表，流项目表等。这些表结构都存储在设备本地的内存中，或者芯片的片上内存中，数量有限。如果一个攻击者通过发送合适的数据报，促使设备建立大量的此类表格，就会使设备的存储结构消耗尽，从而不能正常的转发数据或崩溃。<br>下面针对几种常见的表项，介绍其攻击原理：</li>
<li>针对MAC地址表的攻击<br>MAC地址表一般存在于以太网交换机上，以太网通过分析接收到的数据幀的目的MAC地址，来查本地的MAC地址表，然后作出合适的转发决定。<br>这些MAC地址表一般是通过学习获取的，交换机在接收到一个数据幀后，有一个学习的过程，该过程是这样的：<br>a) 提取数据幀的源MAC地址和接收到该数据幀的端口号；<br>b) 查MAC地址表，看该MAC地址是否存在，以及对应的端口是否符合；<br>c) 如果该MAC地址在本地MAC地址表中不存在，则创建一个MAC地址表项；<br>d) 如果存在，但对应的出端口跟接收到该数据幀的端口不符，则更新该表；<br>e) 如果存在，且端口符合，则进行下一步处理。</li>
</ul>
<p>分析这个过程可以看出，如果一个攻击者向一台交换机发送大量源MAC地址不同的数据幀，则该交换机就可能把自己本地的MAC地址表学满。一旦MAC地址表溢出，则交换机就不能继续学习正确的MAC表项，结果是可能产生大量的网络冗余数据，甚至可能使交换机崩溃。<br>而构造一些源MAC地址不同的数据幀，是非常容易的事情。</p>
<ul>
<li>针对ARP表的攻击<br>ARP表是IP地址和MAC地址的映射关系表，任何实现了IP协议栈的设备，一般情况下都通过该表维护IP地址和MAC地址的对应关系，这是为了避免ARP解析而造成的广播数据报文对网络造成冲击。ARP表的建立一般情况下是通过二个途径：<br>1、 主动解析，如果一台计算机想与另外一台不知道MAC地址的计算机通信，则该计算机主动发ARP请求，通过ARP协议建立（前提是这两台计算机位于同一个IP子网上）；<br>2、 被动请求，如果一台计算机接收到了一台计算机的ARP请求，则首先在本地建立请求计算机的IP地址和MAC地址的对应表。</li>
</ul>
<p>因此，如果一个攻击者通过变换不同的IP地址和MAC地址，向同一台设备，比如三层交换机发送大量的ARP请求，则被攻击设备可能会因为ARP缓存溢出而崩溃。<br>针对ARP表项，还有一个可能的攻击就是误导计算机建立正确的ARP表。根据ARP协议，如果一台计算机接收到了一个ARP请求报文，在满足下列两个条件的情况下，该计算机会用ARP请求报文中的源IP地址和源MAC地址更新自己的ARP缓存：<br>1、 如果发起该ARP请求的IP地址在自己本地的ARP缓存中；<br>2、 请求的目标IP地址不是自己的。</p>
<p>可以举一个例子说明这个过程，假设有三台计算机A，B，C，其中B已经正确建立了A和C计算机的ARP表项。假设A是攻击者，此时，A发出一个ARP请求报文，该请求报文这样构造：<br>1、 源IP地址是C的IP地址，源MAC地址是A的MAC地址；<br>2、 请求的目标IP地址是A的IP地址。</p>
<p>这样计算机B在收到这个ARP请求报文后（ARP请求是广播报文，网络上所有设备都能收到），发现B的ARP表项已经在自己的缓存中，但MAC地址与收到的请求的源MAC地址不符，于是根据ARP协议，使用ARP请求的源MAC地址（即A的MAC地址）更新自己的ARP表。<br>这样B的ARP混存中就存在这样的错误ARP表项：C的IP地址跟A的MAC地址对应。这样的结果是，B发给C的数据都被计算机A接收到。</p>
<ul>
<li>针对流项目表的攻击<br>有的网络设备为了加快转发效率，建立了所谓的流缓存。所谓流，可以理解为一台计算机的一个进程到另外一台计算机的一个进程之间的数据流。如果表现在TCP/IP协议上，则是由（源IP地址，目的IP地址，协议号，源端口号，目的端口号）五元组共同确定的所有数据报文。<br>一个流缓存表一般由该五元组为索引，每当设备接收到一个IP报文后，会首先分析IP报头，把对应的五元组数据提取出来，进行一个HASH运算，然后根据运算结果查询流缓存，如果查找成功，则根据查找的结果进行处理，如果查找失败，则新建一个流缓存项，查路由表，根据路由表查询结果填完整这个流缓存，然后对数据报文进行转发（具体转发是在流项目创建前还是创建后并不重要）。<br>可以看出，如果一个攻击者发出大量的源IP地址或者目的IP地址变化的数据报文，就可能导致设备创建大量的流项目，因为不同的源IP地址和不同的目标IP地址对应不同的流。这样可能导致流缓存溢出。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大型网站技术架构核心原理与案例分析]]></title>
      <url>https://fudawei.github.io/2016/05/12/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="大型网站总览"><a href="#大型网站总览" class="headerlink" title="大型网站总览"></a>大型网站总览</h3><p>大型网站目标：打造一个高可用、高性能、易扩展、可伸缩且安全的网站<br>大型网站特点：高并发大流量、高可用、海量数据、用户分布广泛网络情况复杂、需求快速变更、渐进式发展<br>大型网站发展历程：先是应用和服务分开部署，然后使用缓存改善网站性能，80%的业务访问几种在20%的数据上，把这一小部分的数据缓存在内存中，可以减少数据库的压力，提高整个网站的数据访问速度，改善数据库的写入性能。缓存分两种：应用服务器上的本地缓存和缓存在专门的分布式缓存服务器上的远程缓存，部署大内存的服务器作为专门的缓存服务器此时，数据访问压力缓解，瓶颈在于应用服务器的请求连接有限，可以通过负载均衡调度服务器，将访问请求分发到应用服务器集群中的任何一台服务器上采用缓存后，缓存访问不命中，魂村过期和全部的写操作需要访问数据库，当用户达到一定规模时，数据库因为负载压力过高成为瓶颈，目前大多数数据库提供主从热备功能，实现数据库读写分离，改善数据库负载压力。为了加速网站访问速度，使用CDN和反向代理。CDN和反向代理的原理都是缓存，区别在与CDN部署在网络提供商的机房，使用户在请求网站服务时，可以从距离最近的网络提供商机房获取数据；而反向代理则部署在网站的中心机房，当用户请求到达中心机房时，首先访问的服务器时反向代理服务器，如果反向代理服务器缓存着用户请求的资源，就将其直接返回给用户。数据库读写分离后，进一步就是拆分数据，业务分库，将不同业务的数据库部署在不同的物理服务器上，进而分布式数据库，还可以采用NoSQL和非数据库查询技术如搜索引擎。继而业务拆分，将网站业务分成不同的产品线。最后是分布式服务，既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理，商品管理，那么可以将这些共用的业务提取出来，独立部署，同构分布式服务调用共用业务服务完成具体业务操作。<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-11/20476640.jpg" alt="网站分布式服务架构图"></p>
<h4 id="分布式可能带来的问题"><a href="#分布式可能带来的问题" class="headerlink" title="分布式可能带来的问题"></a>分布式可能带来的问题</h4><ol>
<li>分布式服务调用必须通过网络，可能会对性能造成比较严重的影响</li>
<li>服务器越多，服务宕机的概率也就越大，使网站可用性降低</li>
<li>保持数据一致性也非常困难</li>
<li>分布式事务也难以保证，开发管理维护困难</li>
</ol>
<h3 id="大型网站的架构模式"><a href="#大型网站的架构模式" class="headerlink" title="大型网站的架构模式"></a>大型网站的架构模式</h3><ol>
<li>分层，分成应用层，服务层，数据层等</li>
<li>分割，业务分割，由不同团队维护</li>
<li>分布式<br>3.1 分布式应用和服务  不同应用复用共同的服务，便于业务功能扩展<br>3.2 分布式静态资源   动静分离，静态资源分布式部署可以减轻应用服务器负载压力，使用独立域名加快浏览器并发加载的速度<br>3.3 分布式数据和存储   对传统的关系数据库分布式部署，也使用NoSQL<br>3.4 分布式计算<br>还有支持网站线上服务器配置实时更新的分布式配置；分布式环境下实现并发和协同的分布式锁，支持云存储的分布式文件系统等</li>
<li>集群，提高可用性</li>
<li>缓存<br>5.1 CDN，如视频网站和门户网站会将用户访问量大的热点内容缓存在CDN<br>5.2 反向代理，缓存网站静态资源，无需将请求继续转发给应用服务器就能返回给用户<br>5.3 本地缓存<br>5.4 分布式缓存</li>
<li>异步<br>降低软件耦合性，除了分层、分割、分布还有一个重要手段就是异步，在单一服务器内部通过多线程共享内存队列的方式实现异步；在分布式系统中，多个服务器集群同构分布式消息队列实现异步，可以提高系统可用性、加快网站响应速度、消除并发访问高峰</li>
<li>冗余 冷备份、热备份</li>
<li>自动化<br>自动化代码管理、自动化测试、自动化安全检测、自动化部署、自动化监控、自动化报警、自动化失效转移、自动化失效恢复、自动化降低、自动化分配资源</li>
<li>安全<br>通过手机校验码和密码进行身份认证<br>登录、交易等操作需要对网络通信进行加密，网站服务器上存储的敏感数据也进行加密处理<br>防止机器人程序滥用网络资源攻击，使用验证码进行识别<br>对于XSS攻击，SQL注入，进行编码转换等<br>对于垃圾信息、敏感信息进行过滤<br>对交易转账等重要操作根据交易模式和交易信息进行风险控制</li>
</ol>
<p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-11/12633389.jpg" alt="微博架构"><br>在早期，用户发表微博后将这条微博插入到数据库所有粉丝的订阅列表中，当用户量比较大时，发布微博会引起大量的数据库写操作，性能急剧下降；后来微博改用异步推拉结合的模式，用户发表微博后，系统将微博写入消息放入消息队列后立即返回，用户响应迅速，消息队列消费者任务将微博推送给所有当前在线粉丝的订阅列表中，非在线用户登录后再根据关注列表拉取微博订阅列表。由于刷新频繁，采用多级缓存策略，在线用户的微博和近期微博缓存在分布式缓存急群众，对于微博中最常见的刷微博，几乎全部都是缓存访问操作，可以获得很好的性能。</p>
<h4 id="可用性-amp-amp-伸缩性-amp-amp-扩展性"><a href="#可用性-amp-amp-伸缩性-amp-amp-扩展性" class="headerlink" title="可用性 &amp;&amp; 伸缩性 &amp;&amp; 扩展性"></a>可用性 &amp;&amp; 伸缩性 &amp;&amp; 扩展性</h4><p>可用性：衡量一个系统架构设计是否满足高可用性，就是假设系统中任何一台或者多台服务器宕机时，以及出现各种不可预期的问题时，系统整体是否依然可用<br>伸缩性：是指通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。<br>扩展性：衡量架构扩展性好坏的标准就是在网站增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或很少改动既有业务功能就可以上线新产品</p>
<h3 id="网站的高性能架构"><a href="#网站的高性能架构" class="headerlink" title="网站的高性能架构"></a>网站的高性能架构</h3><p>网站性能测试主要指标有响应时间、并发数、吞吐量、性能计数器等<br>并发数： 网站系统用户数&gt;&gt;网站在线用户数&gt;&gt;网站并发用户数<br>测试程序通过多线程模拟并发用户的办法来测试系统的并发处理能力，在两次请求之间加一个随机等待时间，这个时间被称为思考时间<br>吞吐量：TPS(每秒事务数) HPS(每秒HTTP请求数)、QPS(每秒查询数)<br>性能计数器：System Load，对象与线程数、内存使用、CPU使用、磁盘与网络I/O等指标<br>性能测试方法：<br>性能是一个总称，具体细分为：性能测试、负载测试、压力测试、稳定性测试<br>为了更好的模拟生产环境，稳定性测试也应不均匀的读系统施加压力。</p>
<h4 id="Web前端性能优化"><a href="#Web前端性能优化" class="headerlink" title="Web前端性能优化"></a>Web前端性能优化</h4><ol>
<li>减少http请求<br>合并CSS,合并javascript，合并图片将浏览器一次请求需要的javascript，css合并成一个文件，图片也可以合并，多张图片合并成一张，可通过css偏移响应鼠标点击操作，构造不同的url</li>
<li>使用浏览器缓存<br>通过设置HTTP头中cache-control和expires的属性，设定浏览器缓存</li>
<li>启用压缩<br>可有效减少通信传输的数据量。文本文件的压缩效率可达80%以上</li>
<li>减少Cookie传输<br>减少Cookie中传输的数据量，可以考虑静态资源使用独立域名访问，避免请求资源时发送Cookie，减少Cookie传输的次数。<br>还有CDN加速，反向代理</li>
</ol>
<h4 id="应用服务器性能优化"><a href="#应用服务器性能优化" class="headerlink" title="应用服务器性能优化"></a>应用服务器性能优化</h4><p>可以对数据缓存，也可以对文件缓存，还可以对页面片段缓存<br>网站性能优化第一定律：优先考虑使用缓存优化性能</p>
<ol>
<li>缓存的基本原理：<br>一方面缓存访问速度快，可以减少数据访问的时间；另一方面如果缓存的数据是经过计算处理得到的，那被缓存的数据无需重复计算即可使用，减少计算量。<br>缓存本质是一个内存Hash表数据缓存以key,value形式存储在内存中，读写时间复杂度为O(1)。缓存主要用来存放那些读写比很高，很少变化的数据，如商品的类目信息，热门词的搜索列表信息，热门商品信息等，应用程序读取数据时，先到缓存中读取，读不到或数据已失效，再访问数据库，并将数据写入缓存。<br>二八定律：即80%的访问落在20%的数据上，因此利用Hash表和内存的告诉访问特性，将这20%的数据缓存起来，可很好的改善系统性能，提高数据读取速度，降低存储访问压力。</li>
<li>异步处理</li>
<li>使用集群</li>
<li>代码优化<br>4.1 多线程<br>解决线程安全的手段有：</li>
<li>将对象设计为无状态对象，java web开发中常用的Servlet对象就设计为无状态对象</li>
<li>使用局部对象</li>
<li>并发访问资源上锁<br>3.资源复用 ：单例和对象池</li>
</ol>
<h4 id="存储性能优化"><a href="#存储性能优化" class="headerlink" title="存储性能优化"></a>存储性能优化</h4><p>B+树是一种专门针对磁盘存储而优化的N叉排序树，目前NoSQL都采用LSM树作为主要数据结构，LSM树可以看做是一个N阶合并树。当数据访问以写操作为主，而读操作集中在最近写入的数据上时，使用LSM树可以极大程度减少磁盘的访问次数，加快访问速度。<br>RAID磁盘阵列 、 HDFS</p>
<h3 id="第五章-网站高可用架构"><a href="#第五章-网站高可用架构" class="headerlink" title="第五章 网站高可用架构"></a>第五章 网站高可用架构</h3><p>应用层：会通过负载均衡将一组服务器组成一个集群共同对外提供服务，当负载均衡器通过心跳检测等手段监控到某台应用服务器不可用时，就将其从集群列表中剔除，并将请求分发到集群中其他可用的服务器上。<br>服务层：分布式服务调用框架会在应用层客户端程序中实现软件负载均衡，并通过服务注册中心对提供服务的服务器进行心跳检测，发现有服务不可用，立即通知客户端程序修改服务访问列表，剔除不可用的服务。<br>数据层：主从复制</p>
<h4 id="高可用的应用"><a href="#高可用的应用" class="headerlink" title="高可用的应用"></a>高可用的应用</h4><ol>
<li>通过负载均衡进行无状态服务的失效转移</li>
<li>应用服务器集群的Session管理<br>2.1 Session复制，通信量太大，不适用<br>2.2 Session绑定，将来源于同一IP的请求分发到同一台服务器上，即Session绑定在某台服务器，会话黏滞，缺点，宕机会丢失Session<br>2.3 利用Cookie记录Session，将Session记录在客户端，每次请求服务器的时候，将Session放在请求中发送给服务器，服务器处理完请求后再将修改过的session响应给客户端。缺点：受Cookie大小限制、关闭Cookie不起作用<br>2.3 Session服务器，利用独立部署的Session服务区集群统一管理Session,应用服务器每次读写Session时，都访问Session服务器（无状态和有状态的Session服务器）</li>
</ol>
<h4 id="高可用的服务"><a href="#高可用的服务" class="headerlink" title="高可用的服务"></a>高可用的服务</h4><p>可复用的服务模块为业务产品提供基础公共服务，大型网站中这些服务通常都独立分布式部署，被具体应用远程调用。可复用的服务和应用一样，也是无状态的服务，因此可以使用类似负载均衡的失效转移策略实现高可用的服务</p>
<ol>
<li>分级管理<br>将服务器进行分级管理，核心应用和服务优先使用更好的硬件，显然，用户及时付款购物比能不能评价商品更重要，所以订单、支付服务比评价服务有更高优先级。高优先级的服务需要部署在不同的物理机上。</li>
<li>超时设置<br>由于服务端宕机、线程死锁等原因，可能导致应用程序对服务端调用失去响应，应在应用程序中设置服务调用的超时时间，一旦超时，根据服务调度策略，选择重试或失效转移</li>
<li>异步调用<br>应用对服务的调用通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。</li>
<li>服务降级<br>降级有两种：拒绝服务或关闭服务，淘宝在双十一系统最繁忙时段关闭“评价”，“确认收货”服务，保证核心交易服务的顺利完成</li>
<li>幂等性<br>幂等性就是重复多次执行结果不变，作用一样，比如设置性别为男。转账操作不符合幂等性</li>
</ol>
<h4 id="高可用的数据"><a href="#高可用的数据" class="headerlink" title="高可用的数据"></a>高可用的数据</h4><p>缓存服务器宕机引起缓存数据丢失导致服务器复杂压力过高应该通过其他手段解决，而不是提高缓存服务本身的高可用。理想情况下任何一台服务器宕机引起的缓存失效都只影响应用缓存数据的一小部分，不会对应用性能和数据库负载造成太大影响。<br>CAP理论认为，一个提供数据服务的存储系统无法同时满足数据一致性(Consistency)，数据可用性(Availibility)，分区容忍性(Partition Tolerance)，分区容忍性是必须的，一般都会保证可用性和分区容忍性，在一定程度上放弃一致性<br>数据一致性分为</p>
<ol>
<li>数据强一致<br>各个副本的数据在物理存储中总是一致的，数据更新操作结果和操作响应总是一致的，即操作响应通知更新失败，那么数据一定没有被更新，而不是处于不确定状态</li>
<li>数据用户一致<br>即数据在物理存储中的各个副本的数据可能是不一致的，但终端用户访问时，同构纠错和校验机制，可以确定一个一致的且正确的数据返回给用户</li>
<li><p>数据最终一致<br>系统经过一段时间的自我恢复和修正，数据最终达到一致。</p>
</li>
<li><p>数据备份<br>主从热备</p>
</li>
<li>失效转移<br>失效确认 - 访问转移 - 数据恢复</li>
</ol>
<h4 id="高可用的软件质量保证"><a href="#高可用的软件质量保证" class="headerlink" title="高可用的软件质量保证"></a>高可用的软件质量保证</h4><ol>
<li>网站发布<br>发布过程中，每次关闭的服务器都是集群中的一小部分，并在发布完成后立即可以访问，因此整个发布过程不影响用户使用</li>
<li>自动化测试<br>Web自动化测试，ThoughtWorks开发的Selenium，可以模拟用户操作进行测试，包括Web功能测试和浏览器兼容测试</li>
<li>预发布验证<br>预发布服务器是一种特殊用途的服务器，它和线上的正式服务器唯一的不同就是没有配置在负载均衡服务器上，外部用户u无法访问。</li>
<li>代码控制</li>
<li>灰度发布</li>
<li>监控数据采集<br>服务端日志手机、客户端浏览器日志收集、服务器性能监控、数据报告<br>监控管理： 系统报警、失效转移、自动优雅降级</li>
</ol>
<h3 id="第六章-网站的伸缩性架构"><a href="#第六章-网站的伸缩性架构" class="headerlink" title="第六章 网站的伸缩性架构"></a>第六章 网站的伸缩性架构</h3><p>通过纵向分离部署实现系统伸缩性<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-12/76643763.jpg" alt="通过纵向分离部署实现系统伸缩性"><br>通过横向分离部署实现系统伸缩性<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-12/78440186.jpg" alt="通过横向分离部署实现系统伸缩性"></p>
<h4 id="应用服务器集群的伸缩性设计"><a href="#应用服务器集群的伸缩性设计" class="headerlink" title="应用服务器集群的伸缩性设计"></a>应用服务器集群的伸缩性设计</h4><ol>
<li>HTTP重定向负载均衡<br>根据用户的HTTP请求计算一台真实的Web服务器地址，并将该Web服务器地址写入HTTP重定向响应中返回给浏览器，浏览器请求真实的Web服务器地址</li>
<li>DNS域名解析负载均衡<br>A记录中配置的多个服务器构成一个集群，可以实现负载均衡，同时DNS还支持基于地理位置的域名解析，解析成距离用户最近的一个服务器地址。缺点是当下线某台服务器后，即使修改了DNS的A记录，要使其生效也需要较长时间，这段时间，DNS依然会将域名解析到已经下线的服务器。改造：大型网站总是部分利用DNS域名解析，利用域名解析作为第一级负载均衡手段，得到的一组服务器并不是实际提供Web服务的服务器，而是同样提供负载均衡服务的内部服务器，再将请求分发到真实的Web服务器上</li>
<li>反向代理负载均衡</li>
<li>IP负载均衡<br>修改目的IP进行负载，IP负载均衡在内核进程完成数据分发，较反向代理负载均衡有更好性能。缺点：集群的最大响应数据吞吐量不得不受制于负载均衡服务器网卡带宽，能不能使真实数据从真实物理服务器直接返回给用户呢</li>
<li>数据链路层负载均衡<br>修改数据的目的mac地址，不修改目的IP地址，Web服务器集群所有服务器的虚拟IP地址都和负载服务器的IP地址相同，因此数据可以正常传输。网关服务器直接将数据包发送到用户浏览器，响应数据不需要通过负载均衡服务器。在linux平台最好的链路层负载均衡产品是LVS(Linux Virtual Server)</li>
</ol>
<h4 id="负载均衡算法："><a href="#负载均衡算法：" class="headerlink" title="负载均衡算法："></a>负载均衡算法：</h4><p>轮询：依次分发到每台应用服务器<br>加权轮询：高性能的服务分配更多请求<br>随机：随机数本身就很均衡<br>最少连接：将新到的请求分发到最少连接的服务器上<br>原地址散列：根据请求来源的IP地址进行HASH计算，这样来自同一个IP地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，实现会话黏滞</p>
<p>传统的加缓存服务器的办法是在网站访问量最少的时候扩容，然后通过模拟请求的方法逐渐预热缓存，使缓存服务器中的数据重新分布<br>分布式缓存的一致性Hash算法实现Key到缓存服务器的Hash映射，由此可能产生一个负载不均匀问题，可以增加一个虚拟层来解决。</p>
<h3 id="网站的可扩展架构"><a href="#网站的可扩展架构" class="headerlink" title="网站的可扩展架构"></a>网站的可扩展架构</h3><p>模块分布式部署以后具体聚合方式主要有分布式消息队列和分布式服务</p>
<h4 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h4><p>事件驱动架构(Event Driver Architecture EDA)<br>通过在低耦合的模块之间传输时间消息，以保持模块的松散耦合，典型的EDA就是生产消费者模式</p>
<ul>
<li>在伸缩性方面，由于消息队列服务器上的数据可以看做是被即时处理的，因此类似于无状态的服务器，伸缩性设计比较简单。将新服务器加入分布式消息队列集群中，通知生产者服务器更改消息队列服务器列表即可</li>
<li>在可用性方面，为了避免消费者进程处理缓慢，分布式消息队列服务器内存空间不足造成的问题，如果内存队列已满，会将消息写入磁盘，消息推送模块在将内存队列消息处理完以后，将磁盘内容加载到内存队列继续处理。<br>为了避免消息队列服务器宕机造成消息丢失，会将消息成功发送到消息队列的消息存储在消息生产服务器，等消息真正被消息消费者服务器处理后才删除消息。在消息服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中其他的服务器发布消息。<h4 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h4>阿里巴巴分布式开源框架Dubbo<br>Dubbo的远程服务通信模块支持多种通信协议和数据序列化协议，使用NIO通信框架，具有较高的网络通信性能。<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-12/46986723.jpg" alt="Dubbo"></li>
</ul>
<h3 id="网站的安全架构"><a href="#网站的安全架构" class="headerlink" title="网站的安全架构"></a>网站的安全架构</h3><ul>
<li>对于XSS攻击<br>跨站点攻击，指黑客通过篡改网页，注入恶意脚本，在用户浏览网页时候，控制用户浏览器进行恶意操作的一种攻击方式<br>有两种，一种是反射性，攻击者诱使用户点击一个嵌入恶意脚本的连接，达到攻击目的<br>另外一种是持久性XSS攻击，黑客提交含有恶意脚本的请求，保存在被攻击的Web站点的数据库中，用户浏览网页时，恶意脚本被包含在正常页面中，达到攻击目的。</li>
<li>SQL注入攻击和OS注入攻击一般都因为采用了开源的组件，或者黑客利用错误回显推测数据库结构。解决方案增加过滤，使用参数绑定</li>
<li>CSRF 跨站点请求伪造，攻击者通过跨站请求，以合法用户的身份进行非法操作，如转账交易，发表评论等。主要手法是利用跨站请求，在用户不知情的情况下，以用户的身份伪造请求，其核心是利用了浏览器Cookie或服务器Session策略，盗取用户身份。<br>解决方案：表单Token,验证码、Http请求头的Referer域中记录着请求来源，可通过检查请求来源，验证其是否合法，很多网站使用这个功能实现图片防盗链（如果图片访问的页面来源不是来自自己网站的网页就拒绝）</li>
</ul>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><table>
<thead>
<tr>
<th>项目名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tair</td>
<td>分布式Key/Value存储引擎，分为持久化和非持久化两种使用方式</td>
</tr>
<tr>
<td>TFS</td>
<td>一个分布式文件系统，适用于海量小文件存储</td>
</tr>
<tr>
<td>OceanBase</td>
<td>分布式数据库系统，支持千亿级别的读写事务</td>
</tr>
<tr>
<td>TDDL</td>
<td>对应用透明的分库分表层和具有众多特性的动态数据源</td>
</tr>
<tr>
<td>GeoDNS</td>
<td>基于开源域名服务器软件BIND的增强版本，域名解析到距离用户最近的服务器</td>
</tr>
<tr>
<td>LVS</td>
<td>基于Linux的开源负载均衡服务器</td>
</tr>
<tr>
<td>Squid</td>
<td>基于Linux的开源反向代理服务器</td>
</tr>
<tr>
<td>Lighttpd</td>
<td>轻量服务器，一般用来做图片服务器</td>
</tr>
<tr>
<td>Memcached</td>
<td>无中心高性能的开源分布式缓存系统</td>
</tr>
<tr>
<td>Lucene</td>
<td>Apache出品，Java开发的开源全文搜索引擎</td>
</tr>
</tbody>
</table>
<p>如果有词条信息更新，应用服务器使用Invalidation Notification服务通知使Squid缓存失效，重新访问应用服务器更新词条。</p>
<h3 id="大型网站典型故障案例"><a href="#大型网站典型故障案例" class="headerlink" title="大型网站典型故障案例"></a>大型网站典型故障案例</h3><ul>
<li>写日志也会引发故障<br>上线不久就出现服务器报警，硬盘可用空间低于警戒值，发现log文件迅速增加，不断消耗磁盘空间<br>原因分析：开发人员将log的level全局配置为Debug，这样一次简单的请求就会产生大量log内容<br>经验教训：日志输出级别至少为warn,有些开源的第三方组件也会不恰当的输出太多Error日志，需要注意</li>
<li>高并发访问数据引发的故障<br>某条SQL语句被放在了首页执行，首页是最频繁的网页，被首页调用就频繁执行了<br>经验教训：首页不应该访问数据库，首页需要的数据可以从缓存服务器或者搜索引擎服务器获取；首页最好是静态的。</li>
<li>高并发情况下锁引发的异常<br>某个单例多处使用锁，远程调用的操作也被加了锁，这个操作只是偶尔执行，但执行一次耗时过长，引起其他操作响应超时<br>经验教训：使用锁要谨慎</li>
<li>缓存引发的异常<br>原因：关闭了部分缓存服务器，导致网站全部瘫痪<br>经验教训：当缓存已不仅仅是改善性能，而是成为网站架构不可或缺的一部分时，对缓存的管理就需要提高到和其他服务器一样的级别</li>
<li>应用启动不同步引发的故障<br>某应用发布后，服务器立即崩溃<br>在发布时，Apache和JBoss同时启动个，由于JBoss启动时需要加载很多应用并初始化，花费时间较长，结果JBos还没有完全启动,Apache就已经完全启动开始接受请求，大量请求阻塞在JBoss最终导致崩溃。<br>经验教训：可以在应用程序中加入一个特定动态页面，启动脚本启动JBoss，然后在脚本中不断用curl命令访问这个页面，直到收到OK，才启动Apache</li>
<li>大文件读写独占磁盘引发故障<br>发现大部分文件只有几百KB，有几个文件非常大，有数百兆，读写这些大文件一次需要几十秒，这段时间，磁盘基本被这个文件操作独占，导致其他用户的文件操作缓慢<br>经验教训：存储的使用需要根据不同文件类型和用途进行管理，图片都是小文件，应该使用专用的存储服务器，不能和大文件共用存储。批处理用的大文件可以使用其他类型的分布式文件系统</li>
<li>不规范的流程引发的故障<br>发布该应用后出现大量数据库读操作，而这些数据本来应该从分布式缓存读取，检查缓存发现数据被缓存了。检查代码发现访问缓存的那行代码被注释掉了。<br>经验教训：提交代码前使用diff命令进行代码比较，确认没有提交不该提交的代码。</li>
</ul>
<p>###大型网站技术一览<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-12/31632202.jpg" alt="网站系统架构层次"></p>
<ul>
<li>前端架构<ol>
<li>浏览器优化</li>
<li>CDN</li>
<li>动静分离，静态资源独立部署<br>静态资源，如JS、CSS文件部署在专门的服务器集群上，和Web应用动态内容服务分离，并适用专门的二级域名。</li>
<li>图片服务<br>用户上传的图片，如产品图片、用户头像等，图片服务器同样适用独立部署的图片服务器集群，并适用独立二级域名</li>
<li>反向代理<br>部署在网站机房，在应用服务器、静态资源服务器、图片服务器前，提供页面缓存服务</li>
<li>DNS<br>域名服务，将域名解析成IP地址，利用DNS可以实现DNS负载均衡，配置CDN也需要修改DNS，使域名解析后指向CDN服务器</li>
</ol>
</li>
<li>应用层架构<ol>
<li>页面渲染<br>将分别开发维护的动态内容和静态页面模板集成，组合成最终显示给用户的完整页面</li>
<li>负载均衡<br>通过负载均衡技术将用户请求分发到不同的服务器上，以应用大量用户同时访问时产生的高并发负载压力</li>
<li>Session管理<br>需要专门的机制管理Session，使集群内甚至跨集群的应用服务可以共享Session</li>
<li>动态页面静态化<br>对于访问量特别大而更新又不很频繁的动态页面，可以将其静态化，即生成一个静态页面，利用静态页面的优化手段加速用户访问，如CDN，访问代理</li>
<li>业务拆分<br>业务拆分，降低系统耦合度，也利于数据库分库</li>
<li>虚拟化服务器<br>将一台物理服务器虚拟化为多台虚拟服务器，对于并发访问较低的业务，更容易用较少的资源构建高可用的应用服务器集群<br>*　服务层架构　</li>
<li>分布式消息<br>利用消息队列机制，实现业务和业务，业务和服务之间的异步消息发送及低耦合的业务关系</li>
<li>分布式服务<br>提供高性能、低耦合、易复用、易管理的分布式服务，在网站实现面向服务架构（SOA）</li>
<li>分布式缓存<br>通过可伸缩的服务器集群提供大规模热点数据的缓存服务，是网站性能优化的重要手段</li>
<li>分布式配置<br>系统运行需要配置许多参数，如果这些参数需要修改，比如分布式缓存集群加入新的缓存服务器，需要修改应用程序客户端的缓存服务器列表皮遏制，并重启应用程序服务器，分布式配置在系统运行期间提供配置动态推送服务，将配置修改实时推送到应用系统，无需重启服务器</li>
</ol>
</li>
<li>存储层架构<ol>
<li>分布式文件</li>
<li>关系数据库<br>在应用程序的数据访问层增加数据库访问路由功能，根据业务配置将数据库访问路由到不同的物理数据库上，可实现关系数据库的分布式访问</li>
<li>NoSQL数据局</li>
<li>数据同步<br>主从热备</li>
</ol>
</li>
<li>后台架构<ol>
<li>搜索引擎</li>
<li>数据仓库</li>
<li>推荐系统</li>
</ol>
</li>
<li>数据采集与监控<ol>
<li>浏览器数据采集<br>在网站页面中嵌入ＪＳ脚本采集用户浏览器环境与操作记录，分析用户行为　</li>
<li>服务器业务数据采集<br>采集在服务器端记录的用户请求操作日志；采集应用程序运行期业务数据，比如待处理消息数目等。</li>
</ol>
</li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>不要企图去设计一个大型网站！大型网站不是设计出来的，而是逐步演化出来的<br>垄断、牌照、行业壁垒、国有资本、行政资源，这些在传统行业呼风唤雨的魔法到了互联网领域只会被嘲笑、被捉弄。庞大只是笨拙而已，壁垒只会画地为牢<br>互联网是一种精神，一种开放、分享、自由的精神；越是付出不问汇报，越是获得丰厚的回报；越是不设边界，越是拥有整个世界。互联网是一种颠覆，打碎所有的藩篱，给所有人平等表达和获取的机会，每个人都可以发出自己的声音。互联网是一种建设，重塑人们的思维方式和社会运行方式，建设一个任何人彼此理解信任的大同世界。互联网正在并将继续改变这个世界，一切才刚刚开始，你我正生逢其时！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mysql学习笔记]]></title>
      <url>https://fudawei.github.io/2016/05/12/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<ol>
<li><p>Linux平台安装Mysql失败是因为/etc/my.cnf 的设置是系统的错误路径，可以将$MySQL_HOME/support_files/目录下面的配置文件复制到/etc/my.cnf</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp ./support_files/my_medium.cnf  /etc/my.cnf</div></pre></td></tr></table></figure>
</li>
<li><p>myslq忘记登录密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqladmin -u root -p password &quot;newpwd&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>mysql丢失密码</p>
<ul>
<li><p>windows平台</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">net stop mysql</div><div class="line">mysqld --skip-grant-tables</div><div class="line">打开另一个命令行窗口</div><div class="line">mysql -u root</div><div class="line">update mysql.user set password=password(&apos;newpwd&apos;) where user=&apos;root&apos;</div><div class="line">		and host=&apos;localhost&apos;</div><div class="line">加载权限表</div><div class="line">flush privileges;</div></pre></td></tr></table></figure>
</li>
<li><p>linux平台</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysqld_safe --skip-grant-tables user=mysql</div><div class="line">mysql -u root</div><div class="line">update mysql.user set password=password(&apos;newpwd&apos;) where user=&apos;root&apos;</div><div class="line">		and host=&apos;localhost&apos;</div><div class="line">加载权限表</div><div class="line">flush privileges;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>4.InnoDB 和 MyISAM区别<br>InnoDB 支持事务安全，行锁；空间使用比较高，内存使用高，批量插入速度低<br>MyISAM不支持事务安全，表锁；空间使用比较低，内存使用低，批量插入速度高</p>
<ul>
<li><p>使用mysqldump备份数据库中的某个表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysqldump -uroot -p chuan test &gt; C:/aa.sql</div><div class="line">备份数据库chuan中的test数据表</div></pre></td></tr></table></figure>
</li>
<li><p>使用mysqldump备份多个数据库中的表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysqldump -uroot -p --databases chuan mysql &gt; C:/aa.sql</div><div class="line">备份数据库chuan 和数据库mysql</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* 还原数据库</div></pre></td></tr></table></figure></p>
<p>mysql -uroot -p [dbname] &lt; file.sql<br>指明数据库名称和sql文件位置<br>或者<br>use dbname<br>source file.sql<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">常用</div><div class="line">SHOW ENGINES</div><div class="line">SHOW VARIABLES LIKE &apos;have%&apos;</div><div class="line">ALTER TABLE account ENGINE=INNODB</div><div class="line">DESC  account</div><div class="line"></div><div class="line">USE mysql</div><div class="line">SELECT HOST,USER,PASSWORD FROM USER</div><div class="line"></div><div class="line">SELECT MD5(&apos;root&apos;)</div><div class="line"></div><div class="line">### 数据导入导出</div></pre></td></tr></table></figure></p>
<p>SELECT * FROM test INTO OUTFILE “C:/dd.txt”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; 注意： 在windows上默认换行符号为&quot;\r\n&quot;,而命令默认换行符为&quot;\n&quot;,改为</div></pre></td></tr></table></figure></p>
<p>SELECT * FROM test INTO OUTFILE “C:/dc.txt”  LINES TERMINATED BY ‘\r\n’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 使用select命令生成文本文件</div></pre></td></tr></table></figure></p>
<p>SELECT * FROM test INTO OUTFILE “C:/test.txt”<br>FIELDS<br>TERMINATED BY ‘,’     – 设置字段之间的分割符<br>ENCLOSED BY ‘\”‘      – 设置字段的包围符号<br>ESCAPED BY ‘\’’       – 设置如何写入或读取特殊字符，默认为“\”<br>LINES TERMINATED BY ‘\r\n’   – 设置每行结尾的字符，默认为”\n”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* 使用mysqldump命令同时生成sql文件和文本文件</div></pre></td></tr></table></figure></p>
<p>mysqldump -T C:/soft chuan test -uroot -p<br>–fields-terminated-by=,<br>–fields-optionally-enclosed-by=\”<br>–fields-escaped-by=?<br>–lines-terminated-by=\r\n<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">输出 ==&gt;</div></pre></td></tr></table></figure></p>
<p>“1”,”one”<br>“2”,”two”<br>“3”,”three”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 使用load命令导入文本文件</div></pre></td></tr></table></figure></p>
<p>LOAD DATA INFILE ‘C:/soft/test.txt’ INTO TABLE chuan.test<br>FIELDS<br>TERMINATED BY ‘,’<br>ENCLOSED BY ‘\”‘<br>ESCAPED BY ‘\’’<br>LINES TERMINATED BY ‘\r\n’<br>```</p>
<p>MySQL 的高级特性</p>
<ol>
<li>查询缓存<br>SET SESSION QUERY_CACHE_TYPE=  ON;   ##开启缓存功能<br>SET SESSION QUERY_CACHE_TYPE = OFF<br>SELECT @@QUERY_CACHE_TYPE AS result  ## 查看是否开启缓存功能</li>
</ol>
<p>SHOW VARIABLES LIKE ‘have_query_cache’   ## 查看缓存大小<br>SELECT @@global.query_cache_size     ## 为0 表示缓存内存大小为0，查询缓存功能不起作用，默认为0</p>
<p>SET @@global.query_cache_size = 1000000  ## 将缓存大小设为1MB<br>COMMIT;</p>
<p>SELECT @@global.query_cache_limit;   ## 查看缓存的上限</p>
<p>SHOW VARIABLES LIKE ‘%query_cache%’   ## 查看缓存的相关参数情况<br>各变量如下：<br>have_query_cache    YES    设置是否支持查询缓存区<br>query_cache_limit    1000000   可以缓存的最大结果集<br>query_cache_min_res_unit    4096   用来设置分配内存块的最小体积，单位 字节<br>query_cache_size      0    设置查询缓存使用的总内存字节数，必须是1024字节的倍数<br>query_cache_type     ON    设置是否启用查询缓存。OFF 不进行缓存；ON 表示出了SQL_NO_CACHE的查询以外，缓存所有结果；DEMAND 仅缓存SQL_CACHE<br>query_cache_wlock_invalidate     OFF  设置是否允许在其他连接处于lock状态时，使用缓存结果，默认OFF</p>
<p>SHOW STATUS LIKE ‘Qcache_hits’  查看缓存命中次数<br>增加一条记录，跟该表相关的查询缓存会被清空，然后重新查询，命中次数不发生变化，说明本次查询没有直接从缓存中取到数据</p>
<p>可以修改 /etc/my.cnf 配置文件<br>[mysqld]<br>query_cache_size = 1000000<br>query_cache_limit = 2000000</p>
<p>show  variables like ‘Qcache%’<br>Qcache_queries_in_cache   在缓存中已注册的查询数目<br>Qcache_inserts       被加入到缓存中的查询数目<br>Qcache_hits      缓存采样数的数目<br>Qcache_lowmem_pruns     因为缺少内存而被从缓存中删除的查询数目<br>Qcache_not_cached      没有被缓存的查询数目<br>Qcache_free_memory     查询缓存的空闲内存总数<br>Qcache_free_blocks     查询缓存的空闲内存块总数<br>Qcache_total_blocks   查询缓存中的块的总数目<br>如果空闲内存块总是总内存块的一半左右，表示存在严重的内部碎片，通常使用flush query cache命令整理碎片，然后 采用reset query cache清理查询缓存<br>如果碎片很少，但是缓存命中率低，说明设置的缓存内存空间小，服务器频繁删除旧的查询缓存，腾出空间，保证新的查询缓存，参数Qcache_lowmem_prunes增加，如果此值增长过快，可能 1.如果存在大量空闲块，则是因为碎片的存在引起的   2. 空闲内存较少，可以适当增加缓存大小。</p>
<p>分区表<br>SHOW VARIABLES LIKE ‘%partition%’  查看是否支持分区</p>
<ol>
<li>range分区<br>CREATE TABLE emp(<br> empNo VARCHAR(20) NOT NULL,<br> empName VARCHAR(20),<br> deptNo INT,<br> birthdate DATE,<br> salary INT<br>)<br>PARTITION BY RANGE(salary)<br>(<br> PARTITION p1 VALUES LESS THAN(1000),<br> PARTITION p2 VALUES LESS THAN(2000),<br> PARTITION p3 VALUES LESS THAN(3000)<br>)<br>INSERT INTO emp VALUES(1000,’kobe’,12,’1888-08-08’,1500);<br>INSERT INTO emp VALUES(1000,’kobe’,12,’1888-08-08’,3500);<br>第二条插入失败，因为分区找不到符合条件的表让其插入 。<br>改为如下：<br>CREATE TABLE emp(<br> empNo VARCHAR(20) NOT NULL,<br> empName VARCHAR(20),<br> deptNo INT,<br> birthdate DATE,<br> salary INT<br>)<br>PARTITION BY RANGE(salary)<br>(<br> PARTITION p1 VALUES LESS THAN(1000),<br> PARTITION p2 VALUES LESS THAN(2000),<br> PARTITION p3 VALUES LESS THAN(3000),<br> PARTITION p4 VALUES LESS THAN(4000)     //也可以使用表达式   eg: less than maxValue<br>)<br>INSERT INTO emp VALUES(1000,’kobe’,12,’1888-08-08’,1500);<br>INSERT INTO emp VALUES(1000,’kobe’,12,’1888-08-08’,3500);<br>插入成功<br>range分区常常使用在以下几种情况：</li>
<li>如果要删除某个时间段的数据，只需要删除分区即可。alter table emp drop partion p0 的效率高于 delete from emp where 子句</li>
<li>如果使用包含日期或者时间的列可以考虑使用Range分区</li>
<li><p>经常行运行直接依赖于分割表的列的查询。比如where year(birth) = 1999 group by empno 此时mysql数据库可以很迅速的确定只有分区P2需要扫描</p>
</li>
<li><p>LIST分区<br>list分区类似range分区，区别在于，list分区中每个分区的定义和选择是基于某列的值从属于一个集合，而range分区是从属于一个连续区间值的集合<br>PARTITION BY LIST(deptNo)<br>(<br>PARTITION p1 VALUES IN (10,20),<br>PARTITION p2 VALUES IN (30),<br>PARTITION p3 VALUES IN (40)<br>)<br>INSERT INTO emp VALUES(1000,’kobe’,10,’1888-08-08’,1500);<br>INSERT INTO emp VALUES(1000,’kobe’,30,’1888-08-08’,3500);<br>插入数据的部门编号不在分区值列表中时，那么执行失败<br>INSERT INTO emp VALUES(1000,’kobe’,15,’1888-08-08’,3500);</p>
</li>
<li><p>HASH分区<br>用户索要做的就是基于将要被哈希的列值指定一个列值或表达式，以及指定被分区的表将要被分割的分区数量<br>CREATE TABLE emp(<br>empNo VARCHAR(20) NOT NULL,<br>empName VARCHAR(20),<br>deptNo INT,<br>birthdate DATE,<br>salary INT<br>)<br>PARTITION BY HASH(YEAR(birthdate)) PARTITIONS  4</p>
</li>
<li><p>线性HASH分区</p>
</li>
<li>KEY分区<br>partition by key(birthdate) partitions 4</li>
<li>复合分区<br>复合分区是分区表中每个分区的再次分割，子分区既可以使用HASH分区，也可以使用KEY分区<br>CREATE TABLE emp(<br> empNo VARCHAR(20) NOT NULL,<br> empName VARCHAR(20),<br> deptNo INT,<br> birthdate DATE,<br> salary INT<br>)<br>PARTITION BY RANGE(salary)<br>SUBPARTITION BY HASH(YEAR(birthdate))<br>SUBPARTITIONS 3<br>(<br> PARTITION p1 VALUES LESS THAN(2000),<br> PARTITION p2 VALUES LESS THAN(5000)<br>)</li>
</ol>
<p>SQL性能优化<br>case 1:<br>CREATE TABLE emp(<br>    id INTEGER PRIMARY KEY AUTO_INCREMENT,<br>    deptNo INTEGER,<br>    col3 INTEGER,<br>    col4 INTEGER<br>)<br>INSERT INTO emp VALUES(1,1,2,3);<br>INSERT INTO emp VALUES(2,3,4,5);<br>INSERT INTO emp VALUES(3,4,5,6);</p>
<p>EXPLAIN SELECT id FROM emp WHERE deptno=2 AND col3 &gt; 1 ORDER BY col4 DESC<br>ALTER TABLE emp ADD INDEX index_1(deptno,col3,col4)<br>// 因为按照BTree索引的原理，先排序deptno,如果遇到相同的deptno就会进行对col3进行排序<br>// 如果遇到相同的col3就会对 col4排序<br>DROP INDEX index_1 ON emp<br>ALTER TABLE emp ADD INDEX index_1(deptno,col4)</p>
<p>case 2: 多表查询优化的例子<br>CREATE TABLE table1(<br>    id INTEGER PRIMARY KEY,<br>    tid INTEGER NOT NULL<br>);<br>CREATE TABLE table2(<br>    id INTEGER PRIMARY KEY     AUTO_INCREMENT,<br>    tid INTEGER NOT NULL<br>);<br>INSERT INTO table1 VALUES(1,1);<br>INSERT INTO table1 VALUES(2,2);<br>INSERT INTO table1 VALUES(3,3);<br>INSERT INTO table1 VALUES(4,4);</p>
<p>INSERT INTO table2 VALUES(1,5);<br>INSERT INTO table2 VALUES(2,6);<br>INSERT INTO table2 VALUES(3,7);<br>INSERT INTO table2 VALUES(4,8);<br>优化前：第二张表检索4行数据，且extra没有使用索引<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-10/38631395.jpg" alt=""><br>添加索引 alter table table2 add index(tid)<br>优化后:第二张表检索1行数据，且extra使用索引<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-10/69687340.jpg" alt=""></p>
<p>利用Profiling分析查询语句<br>set profiling = 1 开启profiling<br>show profiles<br>show profile for query 8;<br>show profile cpu for query 8;<br>show profile block io for query 8;</p>
<ul>
<li>索引<br>使用like关键词，只有”%”不在第一个位置，索引才会起作用<br>使用多列索引的查询语句，只有查询语句使用了索引的第一个字段时，索引才会被使用<br>使用OR关键词前后两个条件中的列都是索引时，查询中才使用索引，否则不使用索引。</li>
<li>优化Insert语句<ol>
<li>一次性插入多值<br>eg: insert into books values(1,’book’),(2,’book2’),(3,’book3’)</li>
<li>通常可以锁定表以加速插入数据<br>lock tables test write; insert …; unlock tables;<br>如果不加锁定表，每一次执行insert语句完成后，索引缓冲区都会被写到磁盘上，而加入锁定后索引缓冲区仅被写到磁盘上1次</li>
</ol>
</li>
<li>优化Order By<br>建立索引，使用索引字段order by</li>
<li>优化group by<br>使用order by null 的group by语句减少了文件排序的步骤</li>
<li>优化嵌套查询<br>使用连接查询不需要建立临时表，其速度比子查询要快。</li>
<li>优化数据库结构<ol>
<li>将字段很多的表分解成多个表，可以按照重要性和使用频率分开</li>
<li>增加中间表，把需要经常联合查询的数据插入到中间表中。类似于视图</li>
<li>增加冗余字段</li>
</ol>
</li>
</ul>
<p>彻底删除mysql<br>yum remove mysql mysql-server mysql-libs compat-mysql51<br>rm -rf /var/lib/mysql<br>rm /etc/my.cnf<br>查看是否还有mysql软件：<br>rpm -qa|grep mysql<br>有的话继续删除</p>
<p>MySQL源码安装</p>
<ol>
<li>首先下载mysql-5.5.24.tar.gz 和 cmake-2.8.4.tar.gz 两个源文件</li>
<li>安装MySQL源文件包是采用cmake安装的，首先安装cmake</li>
<li>tar -zxvf cmake-2.8.4.tar.gz , cd cmake-2.8.4</li>
<li>./configure -&gt; make -&gt; make install</li>
<li>mkdir -p /usr/local/mysql    mkdir -p /usr/local/mysql/data</li>
<li>tar zxvf mysql-5.5.24.tar.gz</li>
<li>cmake -DCMAKE_INSTALL_PREFIX=/usr/loca/mysql -DMYSQL_DATADIR=/usr/loca/mysql/data -DDEFAULT_CHARSET=utf8<br>-DDEFAULT_COLLATION=utf8_general_ci   -DEXTRA_CHARSET=all</li>
<li>make -&gt; make install</li>
<li>cp ./support_files/my-medium.cnf /etc/my.cnf</li>
<li>./scripts/mysql_install_db –user=mysql</li>
<li>vim .bash_profile<br>PATH=$PATH:$HOME/bin:/usr/local/mysql/bin:/usr/local/mysql/lib<br>source .bash_profile</li>
<li>echo $PATH 检查路径是否生效</li>
<li>./bin/mysqld_safe –user=mysql &amp; 启动mysql服务</li>
</ol>
<p>安装apache服务器<br>./configure –prefix=/usr/local/apache<br>make<br>make install<br>然后  cd /usr/local/apache/bin    ./apachectl -t 检查配置文件语法是否正确<br>vim /etc/profile 添加环境变量   source  profile  使之生效<br>apachetl start  启动服务</p>
<p>Sysstat软件包集成如下工具<br><a href="http://sebastien.godard.pagesperso-orange.fr/" target="_blank" rel="external">http://sebastien.godard.pagesperso-orange.fr/</a><br>iostat 提供CPU和使用率及硬盘吞吐效率的数据<br>mpstat 提供单个处理器或多个处理器相关数据<br>sar  负责收集、报告并存储系统活跃的信息<br>sar1  负责收集并存储每天系统动态信息到一个二进制的文件中<br>sar2  负责把每天的系统活跃信息写入总结性的报告中<br>sadc  系统动态数据收集工具，收集的数据被写入一个二进制的文件中<br>sadf  显示被sar工具通过多种格式收集的数据</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大数据]]></title>
      <url>https://fudawei.github.io/2016/05/04/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>http是比TCP更高层次的应用层协议，只有底层协议建立之后才能建立更高层协议的连接，因此需要建立TCP连接<br>Web服务器以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>
<h3 id="HTTPS和HTTP区别："><a href="#HTTPS和HTTP区别：" class="headerlink" title="HTTPS和HTTP区别："></a>HTTPS和HTTP区别：</h3><ol>
<li>HTTPS协议需要到CA申请证书，免费证书较少，一般需要交费</li>
<li>HTTP的信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议</li>
<li>HTTP和HTTPS使用完全不同的连接方式，用的端口也不一样，HTTP是80，HTTPS是443</li>
<li>HTTPS是由SSL+HTTP构建的可进行加密传输，身份认证的网络协议，比HTTP安全</li>
</ol>
<h3 id="Cookie属性"><a href="#Cookie属性" class="headerlink" title="Cookie属性"></a>Cookie属性</h3><p>String name 该Cookie的名称，一旦创建，不可更改<br>Object value 该Cookie的值，如果为Unicode字符，需要为字符编码；若为二进制，则用BASE64编码<br>int maxAge  失效时间，单位秒。如果为证书，则在maxAge秒后失效；若为负数，则为临时Cookie，关闭浏览器即失效，若为0，表示删除该Cookie<br>boolean secure  是否仅被使用安全协议传输。安全协议有HTTPS、SSL等，在网络传输前，先将数据加密，默认false<br>String domain   可以访问该Cookie的域名，如果设置为“.google.com”,则所有以“google.com”结尾的域名都可以访问该Cookie<br>String comment   该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明<br>int version   版本号</p>
<p>客户端访问服务器时，服务器吧客户端信息以某种形式记录在服务器上。客户端浏览器再次访问时只需要从该Session中查找该用户的状态<br>如果说Cookie机制是通过检查客户身上的通行证来确定客户身份的话，那么Session机制就是通过检查服务器上的客户明细表来确认客户身份的。<br>如果客户端浏览器将Cookie功能禁用或者不支持Cookie，可以通过URL地址重写来解决，将该用户Session的ID信息重写到URL地址中，服务器能够解析重写后的URL获取Session的ID，这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。</p>
<h3 id="Session属性"><a href="#Session属性" class="headerlink" title="Session属性"></a>Session属性</h3><p>void setAttribute(String attribute,Object value)<br>String getAttribute(String attribute)<br>long getCreateTime()<br>boolean isNew()<br>void invalidate() 使该Session失效</p>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP理论指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ol>
<li>一致性(Consistency,C):所有节点访问同一份最新的数据副本。在分布式系统中的所有数据备份，在同一时刻是否同样的值</li>
<li>可用性(Availability,A):对数据更新具备高可用性。在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求</li>
<li>分区容忍性(Partition  tolerance,P):当集群中的某些节点无法联系时，仍能正常提供服务。以实际效果而言，分区相当于对通信的时限要求，系统如果不能再时限内达成数据一致性，意味着发生了分区的情况，必须就当前操作在一致性和可用性之间做出选择。<br>CAP理论告诉我们，在大规模的分布式系统中，分区容忍性是基本要求，所以要对可用性和一致性有所权衡。</li>
</ol>
<h3 id="进程间通信-Interprocess-Communication-IPC"><a href="#进程间通信-Interprocess-Communication-IPC" class="headerlink" title="进程间通信(Interprocess Communication,IPC)"></a>进程间通信(Interprocess Communication,IPC)</h3><h3 id="网络服务泛型"><a href="#网络服务泛型" class="headerlink" title="网络服务泛型"></a>网络服务泛型</h3><p>java的JINI(Java Intelligent Network Infrastructure)和web service 都是属于该泛型的网络设施。Web服务使用XML和XSD标准来自我描述，用简单对象访问协议(Simple Object Access Protocol,SOAP)交换数据。使用Web服务技术，能使运行与不同机器上的不同应用无需借助其他的支持就可以相互通信。Web服务向外提供一个能够通过Web进行调用的API，即目录服务。</p>
<h3 id="java-Socket编程"><a href="#java-Socket编程" class="headerlink" title="java Socket编程"></a>java Socket编程</h3><h3 id="Web-Service优点"><a href="#Web-Service优点" class="headerlink" title="Web Service优点"></a>Web Service优点</h3><ol>
<li>良好的封装性，服务使用者只能看到对象提供的通用接口和功能列表，不用关心服务的细节</li>
<li>松耦合，只要调用接口不变，内部变更对于调用者透明</li>
<li>使用标准协议规范。基于XML的消息交换机制，其所有公共的协约都采用Internet开放标准协议进行描述、传输和交换</li>
<li>高度可继承性，屏蔽了不同软件、平台差异</li>
<li>易于构建</li>
</ol>
<p>服务描述(WSDL)位于SOAP的上一层，也是基于XML的，用以描述服务端口访问方式和使用协议的细节，通常用来辅助生成服务器和客户端代码及配置信息。<br>UDDI是一个公开的目录，服务提供中将WebService注册并发布到此目录中，而服务使用者也是通过此目录来发现能满足自己需求的服务</p>
<p>WebService角色包括服务提供者、服务注册中心和服务使用者</p>
<p>吴培君(榕舒)：peijun.wpj@alibaba-inc.com</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux必学的60个命令]]></title>
      <url>https://fudawei.github.io/2016/04/29/Linux%E5%BF%85%E5%AD%A6%E7%9A%8460%E4%B8%AA%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>Linux必学的60个命令<br>Linux命令笔记</p>
<p>IDC(Internet Data Center)<br>mkdir nihao<br>mkdir -p 123/456/789依次创建 tree 123 以树形显示<br>mkdir a b c 同时创建三个目录</p>
<p>touch text 创建空文件<br>ll text 列出详细信息<br>touch a b c<br>若文件已经存在，则touch一下可以更新文件时间</p>
<p>ls -l<br>ls -F 目录和文件分明<br>ls -R 当前目录下文件和子目录<br>ls -a 显示隐藏文件</p>
<p>cp -r text/ test/</p>
<p>ln -s a aa 创建a的软链接</p>
<p>rm -rf a   强制删除</p>
<p>cat b<br>cat -n /etc/passwd  查看的时候显示行号</p>
<p>head /etc/passwd  默认显示前10行<br>tail /etc/passwd  默认显示后10行</p>
<p>du -sh desktop/ 统计目录或者文件大小</p>
<p>file test.txt 查看文件属性<br>whereis test.txt 文件定位命令<br>whereis ls</p>
<p>wc -l test.txt统计行数<br>wc -c text.txt统计字节数<br>wc -w text.txt统计单词数</p>
<p>history查看命令历史记录<br>！2 可执行相对应命令<br>history -c 清除命令的历史记录</p>
<p>which命令<br>which ls<br>which passwd<br>which useradd 查找命令位置</p>
<p>passwd  修改当前用户密码<br>passwd wl  修改制定用户密码<br>passwd -l wl  锁住用户<br>passwd -S wl  查看用户状态<br>passwd -u wl  给用户解锁</p>
<p>useradd user1 -g group1<br>mkdir -m 700 test<br>mddir -p test/test1/test2 递归的简历目录</p>
<p>ls -R<br>ls -t<br>ls -l –color=never<br>ls -l –full-time<br>ls -F 类型</p>
<p>rm -rif test/*</p>
<p>Linux提供了大量的命令，利用它可以有效地完成大量的工<br>作，如磁盘操作、文件存取、目录操作、进程管理、文件权限设定等。所以，在Linux系统上工作离不开使用系统提供的命令。要想真正理解Linux系统，<br>就必须从Linux命令学起，通过基础的命令学习可以进一步理解Linux系统。<br>不同Linux发行版的命令数量不一样，但Linux发行版本最少的命令也有200多个。这里笔者把比较重要和使用频率最多的命令，按照它们在系统中的作用分成下面六个部分一一介绍。<br>◆ 安装和登录命令：login、shutdown、halt、reboot、install、mount、umount、chsh、exit、last；<br>◆ 文件处理命令：file、mkdir、grep、dd、find、mv、ls、diff、cat、ln；<br>◆ 系统管理相关命令：df、top、free、quota、at、lp、adduser、groupadd、kill、crontab；<br>◆ 网络操作命令：ifconfig、ip、ping、netstat、telnet、ftp、route、rlogin、rcp、finger、mail、nslookup；<br>◆ 系统安全相关命令：passwd、su、umask、chgrp、chmod、chown、chattr、sudops、who；<br>◆ 其它命令：tar、unzip、gunzip、unarj、mtools、man、unendcode、uudecode。<br>本文以Mandrake Linux 9.1(Kenrel 2.4.21)为例，介绍Linux下的安装和登录命令。<br>immortality按：请用ctrl+f在本页中查找某一部分的内容或某一命令的用法。<br>Linux必学的60个命令(1)-安装与登陆命令<br>login<br>1.作用<br>login的作用是登录系统，它的使用权限是所有用户。<br>2.格式<br>login [name][－p ][－h 主机名称]<br>3.主要参数<br>－p:通知login保持现在的环境参数。<br>－h:用来向远程登录的之间传输用户名。<br>如果选择用命令行模式登录Linux的话，那么看到的第一个Linux命令就是login：。<br>一般界面是这样的：<br>Manddrake Linux release 9.1(Bamboo) for i586<br>renrel 2.4.21－0.13mdk on i686 / tty1<br>localhost login:root<br>password:<br>上面代码中，第一行是Linux发行版本号，第二行是内核版本号和登录的虚拟控制台，我们在第三行输入登录名，按“Enter”键在Password后输入账户密码，即可登录系统。出于安全考虑，输入账户密码时字符不会在屏幕上回显，光标也不移动。<br>登录后会看到下面这个界面（以超级用户为例）：<br>[root@localhost root]#<br>last login:Tue ,Nov 18 10:00:55 on vc/1<br>上面显示的是登录星期、月、日、时间和使用的虚拟控制台。<br>4.应用技巧<br>Linux<br>是一个真正的多用户操作系统，可以同时接受多个用户登录，还允许一个用户进行多次登录。这是因为Linux和许多版本的Unix一样，提供了虚拟控制台的<br>访问方式，允许用户在同一时间从控制台（系统的控制台是与系统直接相连的监视器和键盘）进行多次登录。每个虚拟控制台可以看作是一个独立的工作站，工作台<br>之间可以切换。虚拟控制台的切换可以通过按下Alt键和一个功能键来实现，通常使用F1-F6 。<br>例如，用户登录后，按一下“Alt+<br>F2”键，用户就可以看到上面出现的“login:”提示符，说明用户看到了第二个虚拟控制台。然后只需按“Alt+<br>F1”键，就可以回到第一个虚拟控制台。一个新安装的Linux系统允许用户使用“Alt+F1”到“Alt+F6”键来访问前六个虚拟控制台。虚拟控制<br>台最有用的是，当一个程序出错造成系统死锁时，可以切换到其它虚拟控制台工作，关闭这个程序。<br>shutdown<br>1.作用<br>shutdown命令的作用是关闭计算机，它的使用权限是超级用户。<br>2.格式<br>shutdown [－h][－i][－k][－m][－t]<br>3.重要参数<br>－t：在改变到其它运行级别之前，告诉init程序多久以后关机。<br>－k：并不真正关机，只是送警告信号给每位登录者。<br>－h：关机后关闭电源。<br>－c：cancel current process取消目前正在执行的关机程序。所以这个选项当然没有时间参数，但是可以输入一个用来解释的讯息，而这信息将会送到每位使用者。<br>－F：在重启计算机时强迫fsck。<br>－time：设定关机前的时间。<br>－m: 将系统改为单用户模式。<br>－i：关机时显示系统信息。<br>4.命令说明<br>shutdown<br>命令可以安全地将系统关机。有些用户会使用直接断掉电源的方式来关闭Linux系统，这是十分危险的。因为Linux与Windows不同，其后台运行着<br>许多进程，所以强制关机可能会导致进程的数据丢失，使系统处于不稳定的状态，甚至在有的系统中会损坏硬件设备（硬盘）。在系统关机前使用<br>shutdown命令，系统管理员会通知所有登录的用户系统将要关闭，并且login指令会被冻结，即新的用户不能再登录。<br>halt<br>1.作用<br>halt命令的作用是关闭系统，它的使用权限是超级用户。<br>2.格式<br>halt [－n] [－w] [－d] [－f][－i] [－p]<br>3.主要参数说明<br>－n：防止sync系统调用，它用在用fsck修补根分区之后，以阻止内核用老版本的超级块覆盖修补过的超级块。<br>－w：并不是真正的重启或关机,只是写wtmp（/var/log/wtmp）纪录。<br>－f：没有调用shutdown，而强制关机或重启。<br>－i：关机（或重启）前，关掉所有的网络接口。<br>－f：强迫关机，不呼叫shutdown这个指令。<br>－p: 当关机的时候顺便做关闭电源的动作。<br>－d：关闭系统，但不留下纪录。　<br>4.命令说明<br>halt<br>就是调用shutdown<br>－h。halt执行时，杀死应用进程，执行sync(将存于buffer中的资料强制写入硬盘中)系统调用，文件系统写操作完成后就会停止内核。若系统的<br>运行级别为0或6，则关闭系统；否则以shutdown指令（加上－h参数）来取代。　<br>reboot<br>1.作用<br>reboot命令的作用是重新启动计算机，它的使用权限是系统管理者。<br>2.格式<br>reboot [－n] [－w] [－d] [－f][－i]<br>3.主要参数<br>－n: 在重开机前不做将记忆体资料写回硬盘的动作。<br>－w: 并不会真的重开机，只是把记录写到/var/log/wtmp文件里。<br>－d: 不把记录写到/var/log/wtmp文件里（－n这个参数包含了－d）。<br>－i: 在重开机之前先把所有与网络相关的装置停止。<br>install<br>1.作用<br>install命令的作用是安装或升级软件或备份数据，它的使用权限是所有用户。<br>2.格式<br>(1)install [选项]… 来源 目的地<br>(2)install [选项]… 来源… 目录<br>(3)install －d [选项]… 目录…<br>在<br>前两种格式中，会将复制至或将多个文件复制至已存在的，同时设定权<br>限模式及所有者/所属组。在第三种格式中，会创建所有指定的目录及它们的主目录。长选项必须用的参数在使用短选项时也是必须的。<br>3.主要参数<br>－－backup[=CONTROL]：为每个已存在的目的地文件进行备份。<br>－b：类似 －－backup，但不接受任何参数。<br>－c：(此选项不作处理)。<br>－d，－－directory：所有参数都作为目录处理，而且会创建指定目录的所有主目录。<br>－D：创建前的所有主目录，然后将复制至 ；在第一种使用格式中有用。<br>－g，－－group=组：自行设定所属组，而不是进程目前的所属组。<br>－m，－－mode=模式：自行设定权限模式 (像chmod)，而不是rwxr－xr－x。<br>－o，－－owner=所有者：自行设定所有者 (只适用于超级用户)。<br>－p，－－preserve－timestamps：以文件的访问/修改时间作为相应的目的地文件的时间属性。<br>－s，－－strip：用strip命令删除symboltable，只适用于第一及第二种使用格式。<br>－S，－－suffix=后缀：自行指定备份文件的。<br>－v，－－verbose：处理每个文件/目录时印出名称。<br>－－help：显示此帮助信息并离开。<br>－－version：显示版本信息并离开。<br>mount<br>1.作用<br>mount命令的作用是加载文件系统，它的用权限是超级用户或/etc/fstab中允许的使用者。<br>2.格式<br>mount －a [－fv] [－t vfstype] [－n][－rw] [－F] device dir<br>3.主要参数<br>－h：显示辅助信息。<br>－v：显示信息，通常和－f用来除错。<br>－a：将/etc/fstab中定义的所有文件系统挂上。<br>－F：这个命令通常和－a一起使用，它会为每一个mount的动作产生一个行程负责执行。在系统需要挂上大量NFS文件系统时可以加快加载的速度。<br>－f：通常用于除错。它会使mount不执行实际挂上的动作，而是模拟整个挂上的过程，通常会和－v一起使用。<br>－t vfstype：显示被加载文件系统的类型。<br>－n：一般而言，mount挂上后会在/etc/mtab中写入一笔资料，在系统中没有可写入文件系统的情况下，可以用这个选项取消这个动作。<br>4.应用技巧<br>在Linux<br>和Unix系统上，所有文件都是作为一个大型树（以/为根）的一部分访问的。要访问CD-ROM上的文件，需要将CD-ROM设备挂装在文件树中的某个挂<br>装点。如果发行版安装了自动挂装包，那么这个步骤可自动进行。在Linux中，如果要使用硬盘、光驱等储存设备，就得先将它加载，当储存设备挂上了之后，<br>就可以把它当成一个目录来访问。挂上一个设备使用mount命令。在使用mount这个指令时，至少要先知道下列三种信息：要加载对象的文件系统类型、要<br>加载对象的设备名称及要将设备加载到哪个目录下。<br>（1）Linux可以识别的文件系统<br>◆ Windows 95/98常用的FAT 32文件系统：vfat ；<br>◆ Win NT/2000 的文件系统：ntfs ；<br>◆ OS/2用的文件系统：hpfs；<br>◆ Linux用的文件系统：ext2、ext3；<br>◆ CD-ROM光盘用的文件系统：iso9660。<br>虽然vfat是指FAT 32系统，但事实上它也兼容FAT 16的文件系统类型。<br>（2）确定设备的名称<br>在Linux<br>中，设备名称通常都存在/dev里。这些设备名称的命名都是有规则的，可以用“推理”的方式把设备名称找出来。例如，/dev/hda1这个<br>IDE设备，hd是Hard Disk(硬盘)的，sd是SCSIDevice，fd是Floppy Device(或是Floppy<br>Disk?)。a代表第一个设备，通常IDE接口可以接上4个IDE设备(比如4块硬盘)。所以要识别IDE硬盘的方法分别就是hda、hdb、hdc、<br>hdd。hda1中的“1”代表hda的第一个硬盘分区<br>(partition)，hda2代表hda的第二主分区，第一个逻辑分区从hda5开始，依此类推。此外，可以直接检查<br>/var/log/messages文件，在该文件中可以找到计算机开机后系统已辨认出来的设备代号。<br>（3）查找挂接点<br>在决<br>定将设备挂接之前，先要查看一下计算机是不是有个/mnt的空目录，该目录就是专门用来当作挂载点(Mount<br>Point)的目录。建议在/mnt里建几个/mnt/cdrom、/mnt/floppy、/mnt/mo等目录，当作目录的专用挂载点。举例而言，如<br>要挂载下列5个设备，其执行指令可能如下 (假设都是Linux的ext2系统，如果是WindowsXX请将ext2改成vfat)：<br>软盘 ===&gt;mount －t ext2 /dev/fd0/mnt/floppy<br>cdrom ===&gt;mount －t iso9660 /dev/hdc /mnt/cdrom<br>SCSI cdrom ===&gt;mount －t iso9660 /dev/sdb /mnt/scdrom<br>SCSI cdr ===&gt;mount －t iso9660 /dev/sdc /mnt/scdr<br>不过目前大多数较新的Linux发行版本（包括红旗 Linux、中软Linux、MandrakeLinux等）都可以自动挂装文件系统，但Red Hat Linux除外。<br>umount<br>1.作用<br>umount命令的作用是卸载一个文件系统，它的使用权限是超级用户或/etc/fstab中允许的使用者。<br>2.格式<br>unmount －a [－fFnrsvw] [－t vfstype] [－n][－rw] [－F] device dir<br>3.使用说明<br>umount<br>命令是mount命令的逆操作，它的参数和使用方法和mount命令是一样的。Linux挂装CD-ROM后，会锁定CD—ROM，这样就不能用CD-<br>ROM面板上的Eject按钮弹出它。但是，当不再需要光盘时，如果已将/cdrom作为符号链接，请使用umount/cdrom来卸装它。仅当无用户<br>正在使用光盘时，该命令才会成功。该命令包括了将带有当前工作目录当作该光盘中的目录的终端窗口。<br>chsh<br>1.作用<br>chsh命令的作用是更改使用者shell设定，它的使用权限是所有使用者。<br>2.格式<br>chsh [ －s ] [ －list] [ －－help ] [ －v ][ username ]<br>3.主要参数<br>－l：显示系统所有Shell类型。<br>－v：显示Shell版本号。<br>4.应用技巧<br>前面介绍了Linux下有多种Shell，一般缺省的是Bash，如果想更换Shell类型可以使用chsh命令。先输入账户密码，然后输入新Shell类型，如果操作正确系统会显示“Shell change”。其界面一般如下：<br>Changing fihanging shell for cao<br>Password:<br>New shell [/bin/bash]: /bin/tcsh<br>上面代码中，[ ]内是目前使用的Shell。普通用户只能修改自己的Shell，超级用户可以修改全体用户的Shell。要想查询系统提供哪些Shell，可以使用chsh-l 命令，见图1所示。<br>图1 系统可以使用的Shell类型<br>从图1中可以看到，笔者系统中可以使用的Shell有bash（缺省）、csh、sh、tcsh四种。<br>exit<br>1.作用<br>exit命令的作用是退出系统，它的使用权限是所有用户。<br>2.格式<br>exit<br>3.参数<br>exit命令没有参数，运行后退出系统进入登录界面。<br>last<br>1.作用<br>last命令的作用是显示近期用户或终端的登录情况，它的使用权限是所有用户。通过last命令查看该程序的log，管理员可以获知谁曾经或企图连接系统。<br>2.格式<br>1ast[—n][－f file][－t tty] [—h 节点][－I—IP][—1][－y][1D]<br>3.主要参数<br>－n：指定输出记录的条数。<br>－f file：指定用文件file作为查询用的log文件。<br>－t tty：只显示指定的虚拟控制台上登录情况。<br>－h 节点：只显示指定的节点上的登录情况。<br>－i IP：只显示指定的IP上登录的情况。<br>－1：用IP来显示远端地址。<br>－y：显示记录的年、月、日。<br>－ID：知道查询的用户名。<br>－x:显示系统关闭、用户登录和退出的历史。<br>动手练习<br>上面介绍了Linux安装和登录命令，下面介绍几个实例，动手练习一下刚才讲过的命令。<br>1.一次运行多个命令<br>在一个命令行中可以执行多个命令，用分号将各个命令隔开即可，例如：<br>＃last －x；halt<br>上面代码表示在显示系统关闭、用户登录和退出的历史后关闭计算机。<br>2.利用mount挂装文件系统访问Windows系统<br>许多Linux发行版本现在都可以自动加载Vfat分区来访问Windows系统，而RedHat各个版本都没有自动加载Vfat分区，因此还需要进行手工操作。<br>mount<br>可以将Windows分区作为Linux的一个“文件”挂接到Linux的一个空文件夹下，从而将Windows的分区和/mnt这个目录联系起来。因<br>此，只要访问这个文件夹就相当于访问该分区了。首先要在/mnt下建立winc文件夹，在命令提示符下输入下面命令：<br>＃mount -t vfat /dev/hda1 /mnt/winc<br>即<br>表示将Windows的C分区挂到Liunx的/mnt/winc目录下。这时，在/mnt/winc目录下就可以看到Windows中C盘的内容了。使<br>用类似的方法可以访问Windows系统的D、E盘。在Linux系统显示Windows的分区一般顺序这样的：hda1为C盘、hda5为D盘、<br>hda6为E盘……以此类推。上述方法可以查看Windows系统有一个很大的问题，就是Windows中的所有中文文件名或文件夹名全部显示为问号<br>“？”，而英文却可以正常显示。我们可以通过加入一些参数让它显示中文。还以上面的操作为例，此时输入命令：<br>＃mount -t vfat -o iocharset=cp936 /dev/hda1 /mnt/winc<br>现在它就可以正常显示中文了。<br>3.使用mount加挂闪盘上的文件系统<br>在Linux下使用闪盘非常简单。Linux对USB设备有很好的支持，当插入闪盘后，闪盘被识别为一个SCSI盘，通常输入以下命令：<br>＃ mount /dev/sda1 /usb<br>就能够加挂闪盘上的文件系统。<br>小知识<br>Linux命令与Shell<br>所<br>谓Shell，就是命令解释程序，它提供了程序设计接口，可以使用程序来编程。学习Shell对于Linux初学者理解Linux系统是非常重要的。<br>Linux系统的Shell作为操作系统的外壳，为用户提供了使用操作系统的接口。Shell是命令语言、命令解释程序及程序设计语言的统称，是用户和<br>Linux内核之间的接口程序。如果把Linux内核想象成一个球体的中心，Shell就是围绕内核的外层。当从Shell或其它程序向Linux传递命<br>令时，内核会做出相应的反应。Shell在Linux系统的作用和MSDOS下的COMMAND.COM和Windows 95/98 的<br>explorer.exe相似。Shell虽然不是系统核心的一部分，只是系统核心的一个外延，但它能够调用系统内核的大部分功能。因此，可以说<br>Shell是Unux/Linux最重要的实用程序。<br>Linux中的Shell有多种类型，其中最常用的是Bourne<br>Shell(sh)、C Shell(csh)和Korn Shell(ksh)。大多数Linux发行版本缺省的Shell是Bourne<br>Again Shell，它是Bourne Shell的扩展，简称bash，与BourneShell完全向后兼容，并且在Bourne<br>Shell的基础上增加了很多特性。bash放在/bin/bash中，可以提供如命令补全、命令编辑和命令历史表等功能。它还包含了很多C<br>Shell和Korn<br>Shell中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。Linux系统中200多个命令中有40个是bash的内部命令，主要包括<br>exit、less、lp、kill、 cd、pwd、fc、fg等。</p>
<p>Linux必学的60个命令(2)-文件处理命令<br>Linux<br>系统信息存放在文件里，文件与普通的公务文件类似。每个文件都有自己的名字、内容、存放地址及其它一些管理信息，如文件的用户、文件的大小等。文件可以是<br>一封信、一个通讯录，或者是程序的源语句、程序的数据，甚至可以包括可执行的程序和其它非正文内容。<br>Linux文件系统具有良好的结构，系统提供了很多文件处理程序。这里主要介绍常用的文件处理命令。<br>file<br>1.作用 件内容判断文件类型，使用权限是所有用户。<br>2.格式<br>file通过探测文<br>file [options] 文件名<br>3.[options]主要参数<br>-v：在标准输出后显示版本信息，并且退出。<br>-z：探测压缩过的文件类型。<br>-L：允许符合连接。<br>-f name：从文件namefile中读取要分析的文件名列表。<br>4.简单说明<br>使用file命令可以知道某个文件究竟是二进制（ELF格式）的可执行文件, 还是ShellScript文件，或者是其它的什么格式。file能识别的文件类型有目录、Shell脚本、英文文本、二进制可执行文件、C语言源文件、文本文件、DOS的可执行文件。<br>5.应用实例<br>如果我们看到一个没有后缀的文件grap，可以使用下面命令：<br>$ file grap<br>grap： English text<br>此时系统显示这是一个英文文本文件。需要说明的是，file命令不能探测包括图形、音频、视频等多媒体文件类型。<br>mkdir<br>1.作用<br>mkdir命令的作用是建立名称为dirname的子目录，与MS DOS下的md命令类似，它的使用权限是所有用户。<br>2.格式<br>mkdir [options] 目录名<br>3.[options]主要参数<br>－m, －－mode=模式：设定权限，与chmod类似。<br>－p, －－parents：需要时创建上层目录；如果目录早已存在，则不当作错误。<br>－v, －－verbose：每次创建新目录都显示信息。<br>－－version：显示版本信息后离开。<br>4.应用实例<br>在进行目录创建时可以设置目录的权限，此时使用的参数是“－m”。假设要创建的目录名是“tsk”，让所有用户都有rwx(即读、写、执行的权限)，那么可以使用以下命令：<br>$ mkdir －m 777 tsk<br>grep<br>1.作用<br>grep命令可以指定文件中搜索特定的内容，并将含有这些内容的行标准输出。grep全称是Global RegularExpression Print，表示全局正则表达式版本，它的使用权限是所有用户。<br>2.格式<br>grep [options]<br>3.主要参数<br>[options]主要参数：<br>－c：只输出匹配行的计数。<br>－I：不区分大小写（只适用于单字符）。<br>－h：查询多文件时不显示文件名。<br>－l：查询多文件时只输出包含匹配字符的文件名。<br>－n：显示匹配行及行号。<br>－s：不显示不存在或无匹配文本的错误信息。<br>－v：显示不包含匹配文本的所有行。<br>pattern正则表达式主要参数：<br>\：忽略正则表达式中特殊字符的原有含义。<br>^：匹配正则表达式的开始行。<br>$: 匹配正则表达式的结束行。<br>\：到匹配正则表达式的行结束。<br>[ ]：单个字符，如[A]即A符合要求 。<br>[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。<br>。：所有的单个字符。</p>
<ul>
<li>：有字符，长度可以为0。<br>正<br>则表达式是Linux/Unix系统中非常重要的概念。正则表达式（也称为“regex”或“regexp”）是一个可以描述一类字符串的模式<br>（Pattern）。如果一个字符串可以用某个正则表达式来描述，我们就说这个字符和该正则表达式匹配（Match）。这和DOS中用户可以使用通配符<br>“<em>”代表任意字符类似。在Linux系统上，正则表达式通常被用来查找文本的模式，以及对文本执行“搜索－替换”操作和其它功能。<br>4.应用实例<br>查<br>询DNS服务是日常工作之一，这意味着要维护覆盖不同网络的大量IP地址。有时IP地址会超过2000个。如果要查看nnn.nnn网络地址，但是却忘了<br>第二部分中的其余部分，只知到有两个句点，例如nnn nn..。要抽取其中所有nnn.nnn IP地址，使用[0－9]{3<br>}.[0－0{3}\。含义是任意数字出现3次，后跟句点，接着是任意数字出现3次，后跟句点。<br>$grep ‘[0－9 ]{3 }.[0－0{3}\’ ipfile<br>补充说明，grep家族还包括fgrep和egrep。fgrep是fixgrep，允许查找字符串而不是一个模式；egrep是扩展grep，支持基本及扩展的正则表达式，但不支持\q模式范围的应用及与之相对应的一些更加规范的模式。<br>dd<br>1.作用<br>dd命令用来复制文件，并根据参数将数据转换和格式化。<br>2.格式<br>dd [options]<br>3.[opitions]主要参数<br>bs=字节：强迫 ibs=及obs=。<br>cbs=字节：每次转换指定的。<br>conv=关键字：根据以逗号分隔的关键字表示的方式来转换文件。<br>count=块数目：只复制指定的输入数据。<br>ibs=字节：每次读取指定的。<br>if=文件：读取内容，而非标准输入的数据。<br>obs=字节：每次写入指定的。<br>of=文件：将数据写入，而不在标准输出显示。<br>seek=块数目：先略过以obs为单位的指定的输出数据。<br>skip=块数目：先略过以ibs为单位的指定的输入数据。<br>4.应用实例<br>dd命令常常用来制作Linux启动盘。先找一个可引导内核，令它的根设备指向正确的根分区，然后使用dd命令将其写入软盘：<br>$ rdev vmlinuz /dev/hda<br>$dd if＝vmlinuz of＝/dev/fd0<br>上面代码说明，使用rdev命令将可引导内核vmlinuz中的根设备指向/dev/hda，请把“hda”换成自己的根分区，接下来用dd命令将该内核写入软盘。<br>find<br>1.作用<br>find命令的作用是在目录中搜索文件，它的使用权限是所有用户。<br>2.格式<br>find [path][options][expression]<br>path指定目录路径，系统从这里开始沿着目录树向下查找文件。它是一个路径列表，相互用空格分离，如果不写path，那么默认为当前目录。<br>3.主要参数<br>[options]参数：<br>－depth：使用深度级别的查找过程方式，在某层指定目录中优先查找文件内容。<br>－maxdepth levels：表示至多查找到开始目录的第level层子目录。level是一个非负数，如果level是0的话表示仅在当前目录中查找。<br>－mindepth levels：表示至少查找到开始目录的第level层子目录。<br>－mount：不在其它文件系统（如Msdos、Vfat等）的目录和文件中查找。<br>－version：打印版本。<br>[expression]是匹配表达式，是find命令接受的表达式，find命令的所有操作都是针对表达式的。它的参数非常多，这里只介绍一些常用的参数。<br>—name：支持统配符</em>和?。<br>－atime n：搜索在过去n天读取过的文件。<br>－ctime n：搜索在过去n天修改过的文件。<br>－group grpoupname：搜索所有组为grpoupname的文件。<br>－user 用户名：搜索所有文件属主为用户名（ID或名称）的文件。<br>－size n：搜索文件大小是n个block的文件。<br>－print：输出搜索结果，并且打印。<br>4.应用技巧<br>find命令查找文件的几种方法：<br>（1）根据文件名查找<br>例如，我们想要查找一个文件名是lilo.conf的文件，可以使用如下命令：<br>find / －name lilo.conf<br>find命令后的“/”表示搜索整个硬盘。<br>（2）快速查找文件<br>根<br>据文件名查找文件会遇到一个实际问题，就是要花费相当长的一段时间，特别是大型Linux文件系统和大容量硬盘文件放在很深的子目录中时。如果我们知道了<br>这个文件存放在某个目录中，那么只要在这个目录中往下寻找就能节省很多时间。比如smb.conf文件，从它的文件后缀“.conf”可以判断这是一个配<br>置文件，那么它应该在/etc目录内，此时可以使用下面命令：<br>find /etc －name smb.conf<br>这样，使用“快速查找文件”方式可以缩短时间。<br>（3）根据部分文件名查找方法<br>有时我们知道只某个文件包含有abvd这4个字，那么要查找系统中所有包含有这4个字符的文件可以输入下面命令：<br>find / －name ‘<em>abvd</em>‘<br>输入这个命令以后，Linux系统会将在/目录中查找所有的包含有abvd这4个字符的文件（其中<em>是通配符），比如abvdrmyz等符合条件的文件都能显示出来。<br>(4) 使用混合查找方式查找文件<br>find命令可以使用混合查找的方法，例如，我们想在/etc目录中查找大于500000字节，并且在24小时内修改的某个文件，则可以使用-and (与)把两个查找参数链接起来组合成一个混合的查找方式。<br>find /etc -size +500000c -and -mtime +1<br>mv<br>1.作用<br>mv命令用来为文件或目录改名，或者将文件由一个目录移入另一个目录中，它的使用权限是所有用户。该命令如同DOS命令中的ren和move的组合。<br>2.格式<br>mv[options] 源文件或目录 目标文件或目录<br>3.[options]主要参数<br>－i：交互方式操作。如果mv操作将导致对已存在的目标文件的覆盖，此时系统询问是否重写，要求用户回答“y”或“n”，这样可以避免误覆盖文件。<br>－f：禁止交互操作。mv操作要覆盖某个已有的目标文件时不给任何指示，指定此参数后i参数将不再起作用。<br>4.应用实例<br>（1）将/usr/cbu中的所有文件移到当前目录（用“.”表示）中：<br>$ mv /usr/cbu/ </em> .<br>（2）将文件cjh.txt重命名为wjz.txt：<br>$ mv cjh.txt wjz.txt　<br>ls<br>1.作用<br>ls命令用于显示目录内容，类似DOS下的dir命令，它的使用权限是所有用户。<br>2.格式<br>ls [options][filename]<br>3.options主要参数<br>－a, －－all：不隐藏任何以“.” 字符开始的项目。<br>－A, －－almost－all：列出除了“. ”及 “.. ”以外的任何项目。<br>－－author：印出每个文件著作者。<br>－b, －－escape：以八进制溢出序列表示不可打印的字符。<br>－－block－size=大小：块以指定的字节为单位。<br>－B, －－ignore－backups：不列出任何以 ~ 字符结束的项目。<br>－f：不进行排序，－aU参数生效，－lst参数失效。<br>－F, －－classify：加上文件类型的指示符号 (<em>/=@| 其中一个)。<br>－g：like －l, but do not listowner。<br>－G, －－no－group：inhibit display ofgroup information。<br>－i, －－inode：列出每个文件的inode号。<br>－I, －－ignore=样式：不印出任何符合Shell万用字符的项目。<br>－k：即－－block－size=1K。<br>－l：使用较长格式列出信息。<br>－L, －－dereference：当显示符号链接的文件信息时，显示符号链接所指示的对象，而并非符号链接本身的信息。<br>－m：所有项目以逗号分隔，并填满整行行宽。<br>－n, －－numeric－uid－gid：类似－l，但列出UID及GID号。<br>－N, －－literal：列出未经处理的项目名称，例如不特别处理控制字符。<br>－p, －－file－type：加上文件类型的指示符号 (/=@| 其中一个)。<br>－Q, －－quote－name：将项目名称括上双引号。<br>－r, －－reverse：依相反次序排列。<br>－R, －－recursive：同时列出所有子目录层。<br>－s, －－size：以块大小为序。<br>4.应用举例<br>ls<br>命令是Linux系统使用频率最多的命令，它的参数也是Linux命令中最多的。使用ls命令时会有几种不同的颜色，其中蓝色表示是目录，绿色表示是可执<br>行文件，红色表示是压缩文件，浅蓝色表示是链接文件，加粗的黑色表示符号链接，灰色表示是其它格式文件。ls最常使用的是ls- l，见图1所示。<br>图1 使用ls-l命令<br>文<br>件类型开头是由10个字符构成的字符串。其中第一个字符表示文件类型，它可以是下述类型之一：－（普通文件）、d（目录）、l（符号链接）、b（块设备文<br>件）、c（字符设备文件）。后面的9个字符表示文件的访问权限，分为3组，每组3位。第一组表示文件属主的权限，第二组表示同组用户的权限，第三组表示其<br>他用户的权限。每一组的三个字符分别表示对文件的读（r）、写（w）和执行权限（x）。对于目录，表示进入权限。s表示当文件被执行时，把该文件的UID<br>或GID赋予执行进程的UID（用户ID）或GID（组<br>ID）。t表示设置标志位（留在内存，不被换出）。如果该文件是目录，那么在该目录中的文件只能被超级用户、目录拥有者或文件属主删除。如果它是可执行文<br>件，那么在该文件执行后，指向其正文段的指针仍留在内存。这样再次执行它时，系统就能更快地装入该文件。接着显示的是文件大小、生成时间、文件或命令名<br>称。<br>diff<br>1.作用<br>diff命令用于两个文件之间的比较，并指出两者的不同，它的使用权限是所有用户。<br>2.格式<br>diff [options] 源文件 目标文件<br>3.[options]主要参数<br>-a：将所有文件当作文本文件来处理。<br>-b：忽略空格造成的不同。<br>-B：忽略空行造成的不同。<br>-c：使用纲要输出格式。<br>-H：利用试探法加速对大文件的搜索。<br>-I：忽略大小写的变化。<br>-n –rcs：输出RCS格式。<br>cmp<br>1.作用<br>cmp（“compare”的缩写）命令用来简要指出两个文件是否存在差异，它的使用权限是所有用户。<br>2.格式<br>cmp[options] 文件名<br>3.[options]主要参数<br>-l: 将字节以十进制的方式输出，并方便将两个文件中不同的以八进制的方式输出。<br>cat<br>1.作用<br>cat（“concatenate”的缩写）命令用于连接并显示指定的一个和多个文件的有关信息，它的使用权限是所有用户。<br>2.格式<br>cat [options] 文件1 文件2……<br>3.[options]主要参数<br>－n：由第一行开始对所有输出的行数编号。<br>－b：和－n相似，只不过对于空白行不编号。<br>－s：当遇到有连续两行以上的空白行时，就代换为一行的空白行。<br>4.应用举例<br>（1）cat命令一个最简单的用处是显示文本文件的内容。例如，我们想在命令行看一下README文件的内容，可以使用命令：<br>$ cat README　<br>（2）<br>有时需要将几个文件处理成一个文件，并将这种处理的结果保存到一个单独的输出文件。cat命令在其输入上接受一个或多个文件，并将它们作为一个单独的文件<br>打印到它的输出。例如，把README和INSTALL的文件内容加上行号（空白行不加）之后，将内容附加到一个新文本文件File1 中：<br>$ cat README INSTALL File1<br>（3）cat还有一个重要的功能就是可以对行进行编号，见图2所示。这种功能对于程序文档的编制，以及法律和科学文档的编制很方便，打印在左边的行号使得参考文档的某一部分变得容易，这些在编程、科学研究、业务报告甚至是立法工作中都是非常重要的。<br>图2 使用cat命令/etc/named.conf文件进行编号<br>对行进行编号功能有-b（只能对非空白行进行编号）和-n（可以对所有行进行编号）两个参数：<br>$ cat -b /etc/named.conf<br>ln<br>1.作用<br>ln命令用来在文件之间创建链接，它的使用权限是所有用户。<br>2.格式<br>ln [options] 源文件 [链接名]<br>3.参数<br>－f：链结时先将源文件删除。<br>－d：允许系统管理者硬链结自己的目录。<br>－s：进行软链结(Symbolic Link)。<br>－b：将在链结时会被覆盖或删除的文件进行备份。<br>链接有两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（SymbolicLink）。默认情况下，ln命令产生硬链接。<br>硬<br>连接指通过索引节点来进行的连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode<br>Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户<br>就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和<br>其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件才会被真正删除。<br>与硬连接相对应，Lnux系统中还存在另一种连接，称为符号连接（SymbilcLink），也叫软连接。软链接文件有点类似于Windows的快捷方式。它实际上是特殊文件的一种。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。<br>动手练习<br>上面我们介绍了Linux文件处理命令，下面介绍几个实例，大家可以动手练习一下刚才讲过的命令。<br>1.利用符号链接快速访问关键目录<br>符<br>号链接是一个非常实用的功能。假设有一些目录或文件需要频繁使用，但由于Linux的文件和目录结构等原因，这个文件或目录在很深的子目录中。比如，<br>Apache<br>Web服务器文档位于系统的/usr/local/httpd/htdocs中，并且不想每次都要从主目录进入这样一个长的路径之中(实际上，这个路径也<br>非常不容易记忆)。<br>为了解决这个问题，可以在主目录中创建一个符号链接，这样在需要进入该目录时，只需进入这个链接即可。<br>为了能方便地进入Web服务器(/usr/local/httpd/htdocs)文档所在的目录，在主目录下可以使用以下命令：<br>$ ln -s /usr/local/httpd/htdocs gg<br>这样每次进入gg目录就可访问Web服务器的文档，以后如果不再访问Web服务器的文档时，删除gg即可，而真正的Web服务器的文档并没有删除。<br>2.使用dd命令将init.rd格式的root.ram内容导入内存<br>dd if=/dev/fd0 of=floppy.fd<br>dd if=root.ram of=/dev/ram0 #<br>3.grep命令系统调用<br>grep是Linux/Unix中使用最广泛的命令之一，许多Linux系统内部都可以调用它。<br>(1)如果要查询目录列表中的目录，方法如下：<br>$ ls -l | grep ‘∧d’<br>(2)如果在一个目录中查询不包含目录的所有文件，方法如下：<br>$ ls -l | grep ‘∧[∧d]’<br>(3)用find命令调用grep，如所有C源代码中的“Chinput”，方法如下：<br>$find /ZhXwin -name </em>.c -exec grep -q -s Chinput {} \;-print<br>Linux必学的60个命令(3)-系统管理命令<br>Linux必学的系统管理命令<br>对于Linux系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件，Linux系统管理的命令是它正常运行的核心。熟悉了Linux常用的文件处理命令以后，这一讲介绍对系统和用户进行管理的命令。<br>df<br>1.作用<br>df命令用来检查文件系统的磁盘空间占用情况，使用权限是所有用户。<br>2.格式<br>df [options]<br>3.主要参数<br>－s：对每个Names参数只给出占用的数据块总数。<br>－a：递归地显示指定目录中各文件及子目录中各文件占用的数据块数。若既不指定－s，也不指定－a，则只显示Names中的每一个目录及其中的各子目录所占的磁盘块数。<br>－k：以1024字节为单位列出磁盘空间使用情况。<br>－x：跳过在不同文件系统上的目录不予统计。<br>－l：计算所有的文件大小，对硬链接文件则计算多次。<br>－i：显示inode信息而非块使用量。<br>－h：以容易理解的格式印出文件系统大小，例如136KB、254MB、21GB。<br>－P：使用POSIX输出格式。<br>－T：显示文件系统类型。<br>4.说明<br>df命令被广泛地用来生成文件系统的使用统计数据，它能显示系统中所有的文件系统的信息，包括总容量、可用的空闲空间、目前的安装点等。<br>超<br>级权限用户使用df命令时会发现这样的情况：某个分区的容量超过了100％。这是因为Linux系统为超级用户保留了10％的空间，由其单独支配。也就是<br>说，对于超级用户而言，他所见到的硬盘容量将是110％。这样的安排对于系统管理而言是有好处的，当硬盘被使用的容量接近100％时系统管理员还可以正常<br>工作。<br>5.应用实例<br>Linux支持的文件系统非常多，包括JFS、ReiserFS、ext、ext2、ext3、ISO9660、XFS、Minx、vfat、MSDOS等。使用df-T命令查看磁盘空间时还可以得到文件系统的信息：<br>＃df －T<br>文件系统 类型 容量 已用 可用 已用% 挂载点<br>/dev/hda7 reiserfs 5.2G 1.6G 3.7G 30% /<br>/dev/hda1 vfat 2.4G 1.6G 827M 66% /windows/C<br>/dev/hda5 vfat 3.0G 1.7G 1.3G 57% /windows/D<br>/dev/hda9 vfat 3.0G 2.4G 566M 82% /windows/E<br>/dev/hda10 NTFS 3.2G 573M 2.6G 18% /windows/F<br>/dev/hda11 vfat 1.6G 1.5G 23M 99% /windows/G<br>从上面除了可以看到磁盘空间的容量、使用情况外，分区的文件系统类型、挂载点等信息也一览无遗。<br>top<br>1.作用<br>top命令用来显示执行中的程序进程，使用权限是所有用户。<br>2.格式<br>top [－] [d delay] [q] [c] [S] [s] [n]<br>3.主要参数<br>d：指定更新的间隔，以秒计算。<br>q：没有任何延迟的更新。如果使用者有超级用户，则top命令将会以最高的优先序执行。<br>c：显示进程完整的路径与名称。<br>S：累积模式，会将己完成或消失的子行程的CPU时间累积起来。<br>s：安全模式。<br>i：不显示任何闲置(Idle)或无用(Zombie)的行程。<br>n：显示更新的次数，完成后将会退出top。<br>4.说明<br>top命令是Linux系统管理的一个主要命令，通过它可以获得许多信息。这里我们结合图1来说明它给出的信息。<br>图1 top命令的显示<br>在<br>图1中，第一行表示的项目依次为当前时间、系统启动时间、当前系统登录用户数目、平均负载。第二行显示的是所有启动的进程、目前运行的、挂起<br>(Sleeping)的和无用(Zombie)的进程。第三行显示的是目前CPU的使用情况，包括系统占用的比例、用户使用比例、闲置(Idle)比例。<br>第四行显示物理内存的使用情况，包括总的可以使用的内存、已用内存、空闲内存、缓冲区占用的内存。第五行显示交换分区使用情况，包括总的交换分区、使用<br>的、空闲的和用于高速缓存的大小。第六行显示的项目最多，下面列出了详细解释。<br>PID（Process ID）：进程标示号。<br>USER：进程所有者的用户名。<br>PR：进程的优先级别。<br>NI：进程的优先级别数值。<br>VIRT：进程占用的虚拟内存值。<br>RES：进程占用的物理内存值。<br>SHR：进程使用的共享内存值。<br>S：进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值是负数。<br>%CPU：该进程占用的CPU使用率。<br>%MEM：该进程占用的物理内存和总内存的百分比。<br>TIME＋：该进程启动后占用的总的CPU时间。<br>Command：进程启动的启动命令名称，如果这一行显示不下，进程会有一个完整的命令行。<br>top命令使用过程中，还可以使用一些交互的命令来完成其它参数的功能。这些命令是通过快捷键启动的。<br>：立刻刷新。<br>P：根据CPU使用大小进行排序。<br>T：根据时间、累计时间排序。<br>q：退出top命令。<br>m：切换显示内存信息。<br>t：切换显示进程和CPU状态信息。<br>c：切换显示命令名称和完整命令行。<br>M：根据使用内存大小进行排序。<br>W：将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。<br>可以看到，top命令是一个功能十分强大的监控系统的工具，对于系统管理员而言尤其重要。但是，它的缺点是会消耗很多系统资源。<br>5.应用实例<br>使用top命令可以监视指定用户，缺省情况是监视所有用户的进程。如果想查看指定用户的情况，在终端中按“U”键，然后输入用户名，系统就会切换为指定用户的进程运行界面，见图2所示。<br>图2 使用top命令监视指定用户<br>free<br>1.作用<br>free命令用来显示内存的使用情况，使用权限是所有用户。<br>2.格式<br>free [－b|－k|－m][－o] [－s delay] [－t] [－V]<br>3.主要参数<br>－b －k －m：分别以字节（KB、MB）为单位显示内存使用情况。<br>－s delay：显示每隔多少秒数来显示一次内存使用情况。<br>－t：显示内存总和列。<br>－o：不显示缓冲区调节列。<br>4.应用实例<br>free命令是用来查看内存使用情况的主要命令。和top命令相比，它的优点是使用简单，并且只占用很少的系统资源。通过－S参数可以使用free命令不间断地监视有多少内存在使用，这样可以把它当作一个方便实时监控器。<br>＃free －b －s5<br>使用这个命令后终端会连续不断地报告内存使用情况（以字节为单位），每5秒更新一次。<br>quota<br>1.作用<br>quota命令用来显示磁盘使用情况和限制情况，使用权限超级用户。<br>2.格式<br>quota [－g][－u][－v][－p] 用户名 组名<br>3.参数<br>－g：显示用户所在组的磁盘使用限制。<br>－u：显示用户的磁盘使用限制。<br>－v：显示没有分配空间的文件系统的分配情况。<br>－p：显示简化信息。<br>4.应用实例<br>在企业应用中磁盘配额非常重要，普通用户要学会看懂自己的磁盘使用情况。要查询自己的磁盘配额可以使用下面命令（下例中用户账号是caojh)：<br>＃quota caojh<br>Disk quotas for user caojh(uid 502):<br>Filesystem blocks quota limit grace files quota limit grace<br>/dev/hda3 58 200000 400000 41 500 1000<br>以上显示ID号为502的caojh账号，文件个数设置为500～1000个，硬盘空间限制设置为200MB～400MB。一旦磁盘配额要用完时，就需要删除一些垃圾文件或向系统管理员请求追加配额。<br>at<br>1.作用<br>at命令用来在指定时刻执行指定的命令序列。<br>2.格式<br>at [－V] [－q x] [－f file] [－m]time<br>3.主要参数<br>－V：显示标准错误输出。<br>－q：许多队列输出。<br>－f：从文件中读取作业。<br>－m：执行完作业后发送电子邮件到用户。<br>time：设定作业执行的时间。time格式有严格的要求，由小时、分钟、日期和时间的偏移量组成，其中日期的格式为MM.DD.YY，MM是分钟，DD是日期，YY是指年份。偏移量的格式为时间＋偏移量，单位是minutes、hours和days。<br>4.应用实例<br>＃at －f data 15:30 +2 days<br>上面命令表示让系统在两天后的17：30执行文件data中指明的作业。<br>lp<br>1.作用<br>lp是打印文件的命令，使用权限是所有用户。<br>2.格式<br>lp [－c][－d][－m][－number][－title][-p]<br>3.主要参数<br>－c：先拷贝文件再打印。<br>－d：打印队列文件。<br>－m：打印结束后发送电子邮件到用户。<br>－number：打印份数。<br>－title：打印标题。<br>－p：设定打印的优先级别，最高为100。<br>4.应用实例<br>（1）使用lp命令打印多个文件<br>＃lp 2 3 4<br>request id is 11 (3 file(s))<br>其中2、3、4分别是文件名；“request id is 11 (3 file(s)) ”表示这是第11个打印命令，依次打印这三个文件。<br>（2）设定打印优先级别<br>＃lp lp -d LaserJet -p90 /etc/aliases<br>通过添加“-p 90”，规定了打印作业的优先级为90。它将在优先级低于90的打印作业之前打印，包括没有设置优先级的作业，缺省优先级是50<br>useradd<br>1.作用<br>useradd命令用来建立用户帐号和创建用户的起始目录，使用权限是超级用户。<br>2.格式<br>useradd [－dhome] [－s shell] [－c comment] [－m [－ktemplate]] [－finactive] [－eexpire ] [－ppasswd] [－r]name<br>3.主要参数<br>－c：加上备注文字，备注文字保存在passwd的备注栏中。　<br>－d：指定用户登入时的启始目录。<br>－D：变更预设值。<br>－e：指定账号的有效期限，缺省表示永久有效。<br>－f：指定在密码过期后多少天即关闭该账号。<br>－g：指定用户所属的群组。<br>－G：指定用户所属的附加群组。<br>－m：自动建立用户的登入目录。<br>－M：不要自动建立用户的登入目录。<br>－n：取消建立以用户名称为名的群组。<br>－r：建立系统账号。<br>－s：指定用户登入后所使用的shell。<br>－u：指定用户ID号。<br>4.说明<br>useradd可用来建立用户账号，它和adduser命令是相同的。账号建好之后，再用passwd设定账号的密码。使用useradd命令所建立的账号，实际上是保存在/etc/passwd文本文件中。<br>5.应用实例<br>建立一个新用户账户，并设置ID：<br>＃useradd caojh －u 544<br>需要说明的是，设定ID值时尽量要大于500，以免冲突。因为Linux安装后会建立一些特殊用户，一般0到499之间的值留给bin、mail这样的系统账号。<br>groupadd<br>1.作用<br>groupadd命令用于将新组加入系统。<br>2.格式<br>groupadd [－ggid] [－o]] [－r] [－f] groupname<br>3.主要参数<br>－g gid：指定组ID号。<br>－o：允许组ID号，不必惟一。<br>－r：加入组ID号，低于499系统账号。<br>－f：加入已经有的组时，发展程序退出。<br>4.应用实例<br>建立一个新组，并设置组ID加入系统：<br>＃groupadd －g 344 cjh<br>此时在/etc/passwd文件中产生一个组ID（GID）是344的项目。<br>kill<br>1.作用<br>kill命令用来中止一个进程。<br>2.格式<br>kill [ －s signal | －p ] [ －a ] pid …<br>kill －l [ signal ]<br>3.参数<br>－s：指定发送的信号。<br>－p：模拟发送信号。<br>－l：指定信号的名称列表。<br>pid：要中止进程的ID号。<br>Signal：表示信号。<br>4.说明<br>进程是Linux系统中一个非常重要的概念。Linux是一个多任务的操作系统，系统上经常同时运行着多个进程。我们不关心这些进程究竟是如何分配的，或者是内核如何管理分配时间片的，所关心的是如何去控制这些进程，让它们能够很好地为用户服务。<br>Linux<br>操作系统包括三种不同类型的进程，每种进程都有自己的特点和属性。交互进程是由一个Shell启动的进程。交互进程既可以在前台运行，也可以在后台运行。<br>批处理进程和终端没有联系，是一个进程序列。监控进程（也称系统守护进程）时Linux系统启动时启动的进程，并在后台运行。例如，httpd是著名的<br>Apache服务器的监控进程。<br>kill命令的工作原理是，向Linux系统的内核发送一个系统操作信号<br>和某个程序的进程标识号，然后系统内核就可以对进程标识号指定的进程进行操作。比如在top命令中，我们看到系统运行许多进程，有时就需要使用kill中<br>止某些进程来提高系统资源。在讲解安装和登陆命令时，曾提到系统多个虚拟控制台的作用是当一个程序出错造成系统死锁时，可以切换到其它虚拟控制台工作关闭<br>这个程序。此时使用的命令就是kill，因为kill是大多数Shell内部命令可以直接调用的。<br>5.应用实例<br>（1）强行中止（经常使用杀掉）一个进程标识号为324的进程：<br>＃kill －9 324<br>（2）解除Linux系统的死锁<br>在Linux<br>中有时会发生这样一种情况：一个程序崩溃，并且处于死锁的状态。此时一般不用重新启动计算机，只需要中止(或者说是关闭)这个有问题的程序即可。当<br>kill处于X-Window界面时，主要的程序(除了崩溃的程序之外)一般都已经正常启动了。此时打开一个终端，在那里中止有问题的程序。比如，如果<br>Mozilla浏览器程序出现了锁死的情况，可以使用kill命令来中止所有包含有Mozolla浏览器的程序。首先用top命令查处该程序的PID，然<br>后使用kill命令停止这个程序：<br>＃kill －SIGKILL XXX<br>其中，XXX是包含有Mozolla浏览器的程序的进程标识号。<br>（3）使用命令回收内存<br>我们知道内存对于系统是非常重要的，回收内存可以提高系统资源。kill命令可以及时地中止一些“越轨”的程序或很长时间没有相应的程序。例如，使用top命令发现一个无用 (Zombie) 的进程，此时可以使用下面命令：<br>＃kill －9 XXX<br>其中，XXX是无用的进程标识号。<br>然后使用下面命令：<br>＃free<br>此时会发现可用内存容量增加了。<br>（4）killall命令<br>Linux下还提供了一个killall命令，可以直接使用进程的名字而不是进程标识号，例如：<br>＃ killall -HUP inetd<br>crontab<br>1.作用<br>使用crontab命令可以修改crontab配置文件，然后该配置由cron公用程序在适当的时间执行，该命令使用权限是所有用户。<br>2.格式<br>crontab [ －u user] 文件<br>crontab [ －uuser ] { －l |－r | －e }<br>3.主要参数<br>－e：执行文字编辑器来设定时程表，内定的文字编辑器是vi。<br>－r：删除目前的时程表。<br>－l：列出目前的时程表。<br>crontab<br>文件的格式为“M H D m d<br>cmd”。其中，M代表分钟（0～59），H代表小时（0～23），D代表天（1～31），m代表月（1～12），d代表一星期内的天（0～6，0为星期<br>天）。cmd表示要运行的程序，它被送入sh执行，这个Shell只有USER、HOME、SHELL三个环境变量。<br>4.说明<br>和at命令相比，crontab命令适合完成固定周期的任务。<br>5.应用实例<br>设置一个定时、定期的系统提示：<br>[cao @www cao]#crontab －e<br>此时系统会打开一个vi编辑器。<br>如果输入以下内容：35 17 <em> </em> 5wall “Tomorrow is Saturday I will go CS”，然后存盘退出。这时在/var/spool/cron/目录下会生产一个cao的文件，内容如下：<h1 id="DO-NOT-EDIT-THIS-FILE-－edit-the-master-and-reinstall"><a href="#DO-NOT-EDIT-THIS-FILE-－edit-the-master-and-reinstall" class="headerlink" title="DO NOT EDIT THIS FILE －edit the master and reinstall."></a>DO NOT EDIT THIS FILE －edit the master and reinstall.</h1><h1 id="tmp-crontab-2707-installed-on-Thu-Jan-1-22-01-51-2004"><a href="#tmp-crontab-2707-installed-on-Thu-Jan-1-22-01-51-2004" class="headerlink" title="(/tmp/crontab.2707 installed on Thu Jan 1 22:01:51 2004)"></a>(/tmp/crontab.2707 installed on Thu Jan 1 22:01:51 2004)</h1><h1 id="Cron-version-－－-Id-crontab-c-v-2-13-1994-01-17-03-20-37-vixie-Exp"><a href="#Cron-version-－－-Id-crontab-c-v-2-13-1994-01-17-03-20-37-vixie-Exp" class="headerlink" title="(Cron version －－$Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)"></a>(Cron version －－$Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)</h1>35 17 <em> </em> 5 wall “Tomorrow is Saturday I will play CS “<br>这样每个星期五17：35系统就会弹出一个终端，提醒星期六可以打打CS了！显示结果见图3所示。<br>图3 一个定时、定期的系统提示<br>动手练习<br>1.联合使用kill和top命令观察系统性能的变化<br>首先启动一个终端运行top命令，然后再启动一个终端使用kill命令，见图4所示。<br>图4 观察kill命令对top终端的影响<br>这时利用上面介绍的kill命令来中止一些程序：<br>＃kill SIGKILL XXX<br>然后再看top命令终端的变化，包括内存容量、CPU使用率、系统负载等。注意，有些进程是不能中止的，不过学习Linux命令时可以试试，看看系统有什么反应。<br>2.使用at和halt命令定时关机<br>首先设定关机时间是17:35，输入下面代码：<br>＃at 17:35<br>warning: commands will be executed using (in order) a) $SHELL b) login shell c)/bin/sh<br>at&gt;halt `-i －p<br>at&gt;<br>job 6 at 2004－01－0117:35<br>此<br>时实际上就已经进入Linux系统的Shell，并且编写一个最简单程序：halt －i<br>－p。上面Shell中的文本结束符号表示按“Ctrl＋D”组合键关闭命令，提交任务退出Shell。“Job6 at 2004－01－01<br>17:35”表示系统接受第6个at命令，在“2004－01－0117:35”时执行命令：先把所有网络相关的装置停止，关闭系统后关闭电源。<br>3.用crontab命令实现每天定时的病毒扫描<br>前面已经介绍了一个简单的crontab命令操作，这里看一些更重要的操作。<br>（1）建立一个文件，文件名称自己设定，假设为caoproject：<br>＃crontab －e<br>（2）文件内容如下：<br>05 09 <em> </em> * antivir<br>用vi编辑后存盘退出。antivir是一个查杀Linux病毒的软件，当然需要时先安装在系统中。<br>（3）使用crontab命令添加到任务列表中：<br>＃crontab caoproject<br>这样系统内所有用户在每天的9点05分会自动进行病毒扫描。<br>4.用kill使修改的配置文件马上生效<br>Windows用户一般都知道，重要配置文件修改后往往都要重新启动计算机才能使修改生效。而Linux由于采用了模块化设计，可以自己根据需要实时设定服务。这里以网络服务inetd为例介绍一些操作技巧。<br>inetd<br>是一个监听守护进程，监听与提供互联网服务进程（如rlogin、telnet、ftp、rsh）进行连接的要求，并扩展所需的服务进程。默认情况下，<br>inetd监听的这些daemon均列于/etc<br>/inetd.conf文件中。编辑/etc/inetd.conf文件，可以改变inetd启动服务器守护进程的选项，然后驱使inetd以<br>SIGHUP（signal 1）向当前的inetd进程发送信号，使inetd重读该文件。这一过程由kill命令来实现。<br>用vi或其它编辑器修改inetd.conf后，首先使用下面命令：<br>＃ps -ef |grep inetd<br>上面代码表明查询inetd.conf的进程号(PID)，这里假设是1426，然后使用下面命令：<br>＃ kill -1426 inetd<br>这样配置文件就生效了。<br>这一讲介绍的系统管理命令都是比较重要的，特别是crontab命令和quota命令使用起来会有一定难度，需要多做一些练习。另外，使用kill命令要注意“－9“这个参数，练习时最好不要运行一些重要的程序。<br>Linux必学的60个命令(4)-网络操作命令Linux必学的60个命令：网络操作命令<br>因<br>为Linux系统是在Internet上起源和发展的，它与生俱来拥有强大的网络功能和丰富的网络应用软件，尤其是TCP/IP网络协议的实现尤为成熟。<br>Linux的网络命令比较多，其中一些命令像ping、<br>ftp、telnet、route、netstat等在其它操作系统上也能看到，但也有一些Unix/Linux系统独有的命令，如ifconfig、<br>finger、mail等。Linux网络操作命令的一个特点是，命令参数选项和功能很多，一个命令往往还可以实现其它命令的功能。<br>ifconfig<br>1.作用<br>ifconfig用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。<br>2.格式<br>ifconfig -interface [options] address<br>3.主要参数<br>-interface：指定的网络接口名，如eth0和eth1。<br>up：激活指定的网络接口卡。<br>down：关闭指定的网络接口。<br>broadcast address：设置接口的广播地址。<br>pointopoint：启用点对点方式。<br>address：设置指定接口设备的IP地址。<br>netmask address：设置接口的子网掩码。<br>4.应用说明<br>ifconfig是用来设置和配置网卡的命令行工具。为了手工配置网络，这是一个必须掌握的命令。使用该命令的好处是无须重新启动机器。要赋给eth0接口IP地址207.164.186.2，并且马上激活它，使用下面命令：<br>#fconfig eth0 210.34.6.89 netmask 255.255.255.128 broadcast 210.34.6.127<br>该<br>命令的作用是设置网卡eth0的IP地址、网络掩码和网络的本地广播地址。若运行不带任何参数的ifconfig命令，这个命令将显示机器所有激活接口的<br>信息。带有“-a”参数的命令则显示所有接口的信息，包括没有激活的接口。注意，用ifconfig命令配置的网络设备参数，机器重新启动以后将会丢失。<br>如果要暂停某个网络接口的工作，可以使用down参数：<br>#ifconfig eth0 down<br>ip<br>1.作用<br>ip是iproute2软件包里面的一个强大的网络配置工具，它能够替代一些传统的网络管理工具，例如ifconfig、route等，使用权限为超级用户。几乎所有的Linux发行版本都支持该命令。<br>2.格式<br>ip [OPTIONS] OBJECT [COMMAND [ARGUMENTS]]<br>3.主要参数<br>OPTIONS是修改ip行为或改变其输出的选项。所有的选项都是以-字符开头，分为长、短两种形式。目前，ip支持如表1所示选项。<br>OBJECT是要管理者获取信息的对象。目前ip认识的对象见表2所示。<br>表1 ip支持的选项<br>-V,-Version 打印ip的版本并退出。<br>-s,-stats,-statistics 输出更为详尽的信息。如果这个选项出现两次或多次，则输出的信息将更为详尽。<br>-f,-family 这个选项后面接协议种类，包括inet、inet6或link，强调使用的协议种类。如果没有足够的信息告诉ip使用的协议种类，ip就会使用默认值inet或any。link比较特殊，它表示不涉及任何网络协议。<br>-4 是-family inet的简写。<br>-6 是-family inet6的简写。<br>-0 是-family link的简写。<br>-o,-oneline 对每行记录都使用单行输出，回行用字符代替。如果需要使用wc、grep等工具处理ip的输出，则会用到这个选项。<br>-r,-resolve 查询域名解析系统，用获得的主机名代替主机IP地址<br>COMMAND<br>设置针对指定对象执行的操作，它和对象的类型有关。一般情况下，ip支持对象的增加(add)、删除(delete)和展示(show或list)。有些<br>对象不支持这些操作，或者有其它的一些命令。对于所有的对象，用户可以使用help命令获得帮助。这个命令会列出这个对象支持的命令和参数的语法。如果没<br>有指定对象的操作命令，ip会使用默认的命令。一般情况下，默认命令是list，如果对象不能列出，就会执行help命令。<br>ARGUMENTS<br>是命令的一些参数，它们倚赖于对象和命令。ip支持两种类型的参数：flag和parameter。flag由一个关键词组成；parameter由一个<br>关键词加一个数值组成。为了方便，每个命令都有一个可以忽略的默认参数。例如，参数dev是iplink命令的默认参数，因此ip link ls<br>eth0等于ip link ls dev eth0。我们将在后面的详细介绍每个命令的使用，命令的默认参数将使用default标出。<br>4.应用实例<br>添加IP地址192.168.2.2/24到eth0网卡上：<br>#ip addr add 192.168.1.1/24 dev eth0<br>丢弃源地址属于192.168.2.0/24网络的所有数据报：<br>#ip rule add from 192.168.2.0/24 prio 32777 reject<br>ping<br>1.作用<br>ping检测主机网络接口状态，使用权限是所有用户。<br>2.格式<br>ping [-dfnqrRv][-c][-i][-I][-l][-p][-s][-t] IP地址<br>3.主要参数<br>-d：使用Socket的SO_DEBUG功能。<br>-c：设置完成要求回应的次数。<br>-f：极限检测。<br>-i：指定收发信息的间隔秒数。<br>-I：网络界面使用指定的网络界面送出数据包。<br>-l：前置载入，设置在送出要求信息之前，先行发出的数据包。<br>-n：只输出数值。<br>-p：设置填满数据包的范本样式。<br>-q：不显示指令执行过程，开头和结尾的相关信息除外。<br>-r：忽略普通的Routing Table，直接将数据包送到远端主机上。<br>-R：记录路由过程。<br>-s：设置数据包的大小。<br>-t：设置存活数值TTL的大小。<br>-v：详细显示指令的执行过程。<br>ping<br>命令是使用最多的网络指令，通常我们使用它检测网络是否连通，它使用ICMP协议。但是有时会有这样的情况，我们可以浏览器查看一个网页，但是却无法<br>ping通，这是因为一些网站处于安全考虑安装了防火墙。另外，也可以在自己计算机上试一试，通过下面的方法使系统对ping没有反应：<h1 id="echo-1-gt-proc-sys-net-ipv4-icmp-echo-ignore-all"><a href="#echo-1-gt-proc-sys-net-ipv4-icmp-echo-ignore-all" class="headerlink" title="echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all"></a>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</h1>netstat<br>1.作用<br>检查整个Linux网络状态。<br>2.格式<br>netstat [-acCeFghilMnNoprstuvVwx][-A][–ip]<br>3.主要参数<br>-a–all：显示所有连线中的Socket。<br>-A：列出该网络类型连线中的IP相关地址和网络类型。<br>-c–continuous：持续列出网络状态。<br>-C–cache：显示路由器配置的快取信息。<br>-e–extend：显示网络其它相关信息。<br>-F–fib：显示FIB。<br>-g–groups：显示多重广播功能群组组员名单。<br>-h–help：在线帮助。<br>-i–interfaces：显示网络界面信息表单。<br>-l–listening：显示监控中的服务器的Socket。<br>-M–masquerade：显示伪装的网络连线。<br>-n–numeric：直接使用IP地址，而不通过域名服务器。<br>-N–netlink–symbolic：显示网络硬件外围设备的符号连接名称。<br>-o–timers：显示计时器。<br>-p–programs：显示正在使用Socket的程序识别码和程序名称。<br>-r–route：显示RoutingTable。<br>-s–statistice：显示网络工作信息统计表。<br>-t–tcp：显示TCP传输协议的连线状况。<br>-u–udp：显示UDP传输协议的连线状况。<br>-v–verbose：显示指令执行过程。<br>-V–version：显示版本信息。<br>-w–raw：显示RAW传输协议的连线状况。<br>-x–unix：和指定“-Aunix”参数相同。<br>–ip–inet：和指定“-Ainet”参数相同。<br>4.应用实例<br>netstat<br>主要用于Linux察看自身的网络状况，如开启的端口、在为哪些用户服务，以及服务的状态等。此外，它还显示系统路由表、网络接口状态等。可以说，它是一<br>个综合性的网络状态的察看工具。在默认情况下，netstat只显示已建立连接的端口。如果要显示处于监听状态的所有端口，使用-a参数即可：<br>#netstat -a<br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address Foreign Address State<br>tcp 0 0 <em>:32768 </em>:<em> LISTEN<br>tcp 0 0 </em>:32769 <em>:</em> LISTEN<br>tcp 0 0 <em>:nfs </em>:<em> LISTEN<br>tcp 0 0 </em>:32770 <em>:</em> LISTEN<br>tcp 0 0 <em>:868 </em>:<em> LISTEN<br>tcp 0 0 </em>:617 <em>:</em> LISTEN<br>tcp 0 0 <em>:MySQL </em>:<em> LISTEN<br>tcp 0 0 </em>:netbios-ssn <em>:</em> LISTEN<br>tcp 0 0 <em>:sunrpc </em>:<em> LISTEN<br>tcp 0 0 </em>:10000 <em>:</em> LISTEN<br>tcp 0 0 <em>:http </em>:<em> LISTEN<br>……<br>上面显示出，这台主机同时提供HTTP、FTP、NFS、MySQL等服务。<br>telnet<br>1.作用<br>telnet表示开启终端机阶段作业，并登入远端主机。telnet是一个Linux命令，同时也是一个协议（远程登陆协议）。<br>2.格式<br>telnet [-8acdEfFKLrx][-b][-e][-k][-l][-n][-S][-X][主机名称IP地址]<br>3.主要参数<br>-8：允许使用8位字符资料，包括输入与输出。<br>-a：尝试自动登入远端系统。<br>-b：使用别名指定远端主机名称。<br>-c：不读取用户专属目录里的.telnetrc文件。<br>-d：启动排错模式。<br>-e：设置脱离字符。<br>-E：滤除脱离字符。<br>-f：此参数的效果和指定“-F”参数相同。<br>-F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。<br>-k：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。<br>-K：不自动登入远端主机。<br>-l：指定要登入远端主机的用户名称。<br>-L：允许输出8位字符资料。<br>-n：指定文件记录相关信息。<br>-r：使用类似rlogin指令的用户界面。<br>-S：服务类型，设置telnet连线所需的IP TOS信息。<br>-x：假设主机有支持数据加密的功能，就使用它。<br>-X：关闭指定的认证形态。<br>4.应用说明<br>用<br>户使用telnet命令可以进行远程登录，并在远程计算机之间进行通信。用户通过网络在远程计算机上登录，就像登录到本地机上执行命令一样。为了通过<br>telnet登录到远程计算机上，必须知道远程机上的合法用户名和口令。虽然有些系统确实为远程用户提供登录功能，但出于对安全的考虑，要限制来宾的操作<br>权限，因此，这种情况下能使用的功能是很少的。<br>telnet只为普通终端提供终端仿真，而不支持X-<br>Window等图形环境。当允许远程用户登录时，系统通常把这些用户放在一个受限制的Shell中，以防系统被怀有恶意的或不小心的用户破坏。用户还可以<br>使用telnet从远程站点登录到自己的计算机上，检查电子邮件、编辑文件和运行程序，就像在本地登录一样。<br>ftp<br>1.作用<br>ftp命令进行远程文件传输。FTP是ARPANet的标准文件传输协议，该网络就是现今Internet的前身，所以ftp既是协议又是一个命令。<br>2.格式<br>ftp [-dignv][主机名称IP地址]<br>3.主要参数<br>-d：详细显示指令执行过程，便于排错分析程序执行的情形。<br>-i：关闭互动模式，不询问任何问题。<br>-g：关闭本地主机文件名称支持特殊字符的扩充特性。<br>-n：不使用自动登陆。<br>-v：显示指令执行过程。<br>4.应用说明<br>ftp<br>命令是标准的文件传输协议的用户接口，是在TCP/IP网络计算机之间传输文件简单有效的方法，它允许用户传输ASCⅡ文件和二进制文件。为了使用ftp<br>来传输文件，用户必须知道远程计算机上的合法用户名和口令。这个用户名/口令的组合用来确认ftp会话，并用来确定用户对要传输的文件进行什么样的访问。<br>另外，用户需要知道对其进行ftp会话的计算机名字的IP地址。<br>用户可以通过使用ftp客户程序，连接到另一台计算机上；可以在目录中上下移动、列出目录内容；可以把文件从远程计算机机拷贝到本地机上；还可以把文件从本地机传输到远程系统中。ftp内部命令有72个，下面列出主要几个内部命令：<br>ls：列出远程机的当前目录。<br>cd：在远程机上改变工作目录。<br>lcd：在本地机上改变工作目录。<br>close：终止当前的ftp会话。<br>hash：每次传输完数据缓冲区中的数据后就显示一个#号。<br>get（mget）：从远程机传送指定文件到本地机。<br>put（mput）：从本地机传送指定文件到远程机。<br>quit：断开与远程机的连接，并退出ftp。<br>route<br>1.作用<br>route表示手工产生、修改和查看路由表。<br>2.格式<br>#route [-add][-net|-host] targetaddress [-netmask Nm][dev]If]<br>#route [－delete][-net|-host]targetaddress [gw Gw] [-netmask Nm] [dev]If]<br>3.主要参数<br>-add：增加路由。<br>-delete：删除路由。<br>-net：路由到达的是一个网络，而不是一台主机。<br>-host：路由到达的是一台主机。<br>-netmask Nm：指定路由的子网掩码。<br>gw：指定路由的网关。<br>[dev]If：强迫路由链指定接口。<br>4.应用实例<br>route命令是用来查看和设置Linux系统的路由信息，以实现与其它网络的通信。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。<br>在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。使用下面命令可以增加一个默认路由：<br>route add 0.0.0.0 192.168.1.1<br>rlogin<br>1.作用<br>rlogin用来进行远程注册。<br>2.格式<br>rlogin [ -8EKLdx ] [ -e char ] [-k realm ] [ - l username ] host<br>3.主要参数<br>-8：此选项始终允许8位输入数据通道。该选项允许发送格式化的ANSI字符和其它的特殊代码。如果不用这个选项，除非远端的不是终止和启动字符，否则就去掉奇偶校验位。<br>-E：停止把任何字符当作转义字符。当和-8选项一起使用时，它提供一个完全的透明连接。<br>-K：关闭所有的Kerberos确认。只有与使用Kerberos 确认协议的主机连接时才使用这个选项。<br>-L：允许rlogin会话在litout模式中运行。要了解更多信息，请查阅tty联机帮助。<br>-d：打开与远程主机进行通信的TCPsockets的socket调试。要了解更多信息，请查阅setsockopt的联机帮助。<br>-e：为rlogin会话设置转义字符，默认的转义字符是“～”。<br>-k：请求rlogin获得在指定区域内远程主机的Kerberos许可，而不是获得由krb_realmofhost(3)确定的远程主机区域内的远程主机的Kerberos许可。<br>-x：为所有通过rlogin会话传送的数据打开DES加密。这会影响响应时间和CPU利用率，但是可以提高安全性。<br>4.使用说明<br>如果在网络中的不同系统上都有账号，或者可以访问别人在另一个系统上的账号，那么要访问别的系统中的账号，首先就要注册到系统中，接着通过网络远程注册到账号所在的系统中。rlogin可以远程注册到别的系统中，它的参数应是一个系统名。<br>rcp<br>1.作用<br>rcp代表远程文件拷贝，用于计算机之间文件拷贝，使用权限是所有用户。<br>2.格式<br>rcp [-px] [-k realm] file1 file2 rcp [-px] [-r] [-k realm] file<br>3.主要参数<br>-r：递归地把源目录中的所有内容拷贝到目的目录中。要使用这个选项，目的必须是一个目录。<br>-p：试图保留源文件的修改时间和模式，忽略umask。<br>-k：请求rcp获得在指定区域内的远程主机的Kerberos许可，而不是获得由krb_relmofhost(3)确定的远程主机区域内的远程主机的Kerberos许可。<br>-x：为传送的所有数据打开DES加密。<br>finger<br>1.作用<br>finger用来查询一台主机上的登录账号的信息，通常会显示用户名、主目录、停滞时间、登录时间、登录Shell等信息，使用权限为所有用户。<br>2.格式<br>finger [选项][使用者] [用户@主机]<br>3.主要参数<br>-s：显示用户注册名、实际姓名、终端名称、写状态、停滞时间、登录时间等信息。<br>-l：除了用-s选项显示的信息外，还显示用户主目录、登录Shell、邮件状态等信息，以及用户主目录下的.plan、.project和.forward文件的内容。<br>-p：除了不显示.plan文件和.project文件以外，与-l选项相同。<br>4.应用实例<br>在计算机上使用finger：<br>[root@localhost root]# Finger<br>Login Name Tty Idle Login Time Office Office Phone<br>root root tty1 2 Dec 15 11<br>root root pts/0 1 Dec 15 11<br>root root </em>pts/1 Dec 15 11<br>5.应用说明<br>如果要查询远程机上的用户信息，需要在用户名后面接“@主机名”，采用[用户名@主机名]的格式，不过要查询的网络主机需要运行finger守护进程的支持。<br>mail<br>1.作用<br>mail作用是发送电子邮件，使用权限是所有用户。此外，mail还是一个电子邮件程序。<br>2.格式<br>mail [-s subject] [-c address] [-b address]<br>mail -f [mailbox]mail [-u user]<br>3.主要参数<br>-b address：表示输出信息的匿名收信人地址清单。<br>-c address：表示输出信息的抄送（）收信人地址清单。<br>-f [mailbox]：从收件箱者指定邮箱读取邮件。<br>-s subject：指定输出信息的主体行。<br>[-u user]：端口指定优化的收件箱读取邮件。<br>nslookup<br>1.作用<br>nslookup命令的功能是查询一台机器的IP地址和其对应的域名。使用权限所有用户。它通常需要一台域名服务器来提供域名服务。如果用户已经设置好域名服务器，就可以用这个命令查看不同主机的IP地址对应的域名。<br>2.格式<br>nslookup ［IP地址/域名］<br>3.应用实例<br>（1）在本地计算机上使用nslookup命令<br>$ nslookup<br>Default Server: name.cao.com.cn<br>Address: 192.168.1.9<br>&gt;<br>在符号“&gt;”后面输入要查询的IP地址域名，并回车即可。如果要退出该命令，输入“exit”，并回车即可。<br>（2）使用nslookup命令测试named<br>输入下面命令：<br>nslookup<br>然后就进入交换式nslookup环境。如果named正常启动，则nslookup会显示当前DNS服务器的地址和域名，否则表示named没能正常启动。<br>下面简单介绍一些基本的DNS诊断。<br>◆<br>检查正向DNS解析，在nslookup提示符下输入带域名的主机名，如hp712.my.com，nslookup应能显示该主机名对应的IP地址。如<br>果只输入hp712，nslookup会根据/etc/resolv.conf的定义，自动添加my.com域名，并回答对应的IP地址。<br>◆检查反向DNS解析，在nslookup提示符下输入某个IP地址，如192.22.33.20，nslookup应能回答该IP地址所对应的主机名。<br>◆检查MX邮件地址记录在nslookup提示符下输入：<br>set q=mx<br>然后输入某个域名，输入my.com和mail.my.com，nslookup应能够回答对应的邮件服务器地址，即support.my.com和support2.my.com。<br>动手练习<br>1.危险的网络命令<br>互<br>联网的发展使安全成为一个不能忽视的问题，finger、ftp、rcp和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，嗅<br>探器可以非常容易地截获这些口令和数据。而且，这些服务程序的安全验证方式也是有弱点的，很容易受到“中间服务器”方式的攻击。这里笔者把一些不安全的命<br>令根据危险等级列出，见表3所示。<br>现在ftp、telnet可以被SSH命令代替绑定在端口22上，其连<br>接采用协商方式，使用RSA加密。身份鉴别完成之后，后面的所有流量都使用IDEA<br>进行加密。SSH（Secure　Shell）程序可以通过网络登录到远程主机，并执行命令。rcp、rlogin等远程调用命令也逐渐被VNC软件代<br>替。<br>2.在一张网卡上绑定多个IP地址<br>在Linux下，可以使用ifconfig方便地绑定多个IP地址到一张网卡。例如，eth0接口的原有IP地址为192.168.0 .254，可以执行下面命令：<br>ifconfig eth0:0 192.168.0.253 netmask 255.255.255.0<br>ifconfig eth0:1 192.168.0.252 netmask 255.255.255.0<br>……<br>3.修改网卡MAC地址<br>首先必须关闭网卡设备，命令如下：<br>/sbin/ifconfig eth0 down<br>修改MAC地址，命令如下：<br>/sbin/ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE<br>重新启用网卡：<br>/sbin/ifconfig eht0 up<br>这样网卡的MAC地址就更改完成了。每张网卡的MAC地址是惟一，但不是不能修改的，只要保证在网络中的MAC地址的惟一性就可以了。<br>4.初步部署IPv6<br>IPv4<br>技术在网络发展中起到了巨大的作用，不过随着时间的流逝它无论在网络地址的提供、服务质量、安全性等方面都越来越力不从心，IPv6呼之欲出。Linux<br>是所有操作系统中最先支持IPv6的，一般Linux基于2.4内核的Linux发行版本都可以直接使用IPv6，不过主要发行版本没有加载IPv6模<br>块，可以使用命令手工加载，需要超级用户的权限。<br>(1)加载IPv6模块<br>使用命令检测，其中inet6 addr:fe80::5054:abff:fe34:5b09/64，就是eth0网卡的IPv6地址。<h1 id="modprobe-IPv6"><a href="#modprobe-IPv6" class="headerlink" title="modprobe IPv6"></a>modprobe IPv6</h1>＃ifconfig<br>eth0 Link encap:Ethernet HWaddr 52:54:AB:34:5B:09<br>inet addr:192.168.1.2 Bcast:192.168.1.255 Mask:255.255.255.0<br>inet6 addr: fe80::5054:abff:fe34:5b09/64 Scope:Link<br>UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1<br>RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br>TX packets:21 errors:0 dropped:0 overruns:0 carrier:0<br>collisions:0 txqueuelen:100<br>RX bytes:0 (0.0 b) TX bytes:1360 (1.3 Kb)<br>Interrupt:5 Base address:0xec00<br>(2)使用ping命令检测网卡的IPv6地址是否有效<br>#ping6 -I eth0 -c 2 fe80::200:e8ff:fea0:2586<br>和IPv4不一样，使用ping6命令时必须指定一个网卡界面，否则系统不知道将数据包发送到哪个网络设备。I表示Interface、eth0是第一个网卡，－c表示回路，2表示ping6操作两次。结果见图1所示。<br>图1 IPv6网络下的ping6命令<br>(3)使用ip命令在IPv6下为eth0增加一个IP地址<br>#ip -6 addr add 3ffe:ffff:0:f101::1/64 dev eth0<br>使用ifconfig命令，查看网卡是否出现第二个IPv6地址。<br>Linux网络的主要优点是能够实现资源和信息的共享，并且用户可以远程访问信息。Linux提供了一组强有力的网络命令来为用户服务，这些工具能够帮助用户进行网络设定、检查网络状况、登录到远程计算机上、传输文件和执行远程命令等。<br>上面介绍了Linux中比较重要的网络命令，其实Linux还有许多命令需要学习。Linux网络操作命令的一个特点就是命令参数选项很多，并不要求全部记住，关键在于理解命令的主要用途和学会使用帮助信息。<br>Linux必学的60个命令(5)-网络安全命令Linux必学的60个命令：系统安全相关命令<br>虽然Linux和Windows NT/2000系统一样是一个多用户的系统，但是它们之间有不少重要的差别。对于很多习惯了Windows系统的管理员来讲，如何保证Linux操作系统安全、可靠将会面临许多新的挑战。本文将重点介绍Linux系统安全的命令。<br>passwd<br>1.作用<br>passwd命令原来修改账户的登陆密码，使用权限是所有用户。<br>2.格式<br>passwd [选项] 账户名称<br>3.主要参数<br>-l：锁定已经命名的账户名称，只有具备超级用户权限的使用者方可使用。<br>-u：解开账户锁定状态，只有具备超级用户权限的使用者方可使用。<br>-x, –maximum=DAYS：最大密码使用时间（天），只有具备超级用户权限的使用者方可使用。<br>-n, –minimum=DAYS：最小密码使用时间（天），只有具备超级用户权限的使用者方可使用。<br>-d：删除使用者的密码, 只有具备超级用户权限的使用者方可使用。<br>-S：检查指定使用者的密码认证种类, 只有具备超级用户权限的使用者方可使用。<br>4.应用实例<br>$ passwd<br>Changing password for user cao.<br>Changing password for cao<br>(current) UNIX password:<br>New UNIX password:<br>Retype new UNIX password:<br>passwd: all authentication tokens updated successfully.<br>从上面可以看到，使用passwd命令需要输入旧的密码，然后再输入两次新密码。<br>su<br>1.作用<br>su的作用是变更为其它使用者的身份，超级用户除外，需要键入该使用者的密码。<br>2.格式<br>su [选项]… [-] [USER[ARG]…]<br>3.主要参数<br>-f ， –fast：不必读启动文件（如 csh.cshrc 等），仅用于csh或tcsh两种Shell。<br>-l ， –login：加了这个参数之后，就好像是重新登陆为该使用者一样，大部分环境变量（例如HOME、SHELL和USER等）都是以该使用者（USER）为主，并且工作目录也会改变。如果没有指定USER，缺省情况是root。<br>-m， -p ，–preserve-environment：执行su时不改变环境变数。<br>-c command：变更账号为USER的使用者，并执行指令（command）后再变回原来使用者。<br>USER：欲变更的使用者账号，ARG传入新的Shell参数。<br>4.应用实例<br>变更账号为超级用户，并在执行df命令后还原使用者。 su -c df root<br>umask<br>1.作用<br>umask设置用户文件和目录的文件创建缺省屏蔽值，若将此命令放入profile文件，就可控制该用户后续所建文件的存取许可。它告诉系统在创建文件时不给谁存取许可。使用权限是所有用户。<br>2.格式<br>umask [-p] [-S] [mode]<br>3.参数<br>－S：确定当前的umask设置。<br>－p：修改umask 设置。<br>[mode]：修改数值。<br>4.说明<br>传<br>统Unix的umask值是022，这样就可以防止同属于该组的其它用户及别的组的用户修改该用户的文件。既然每个用户都拥有并属于一个自己的私有组，那<br>么这种“组保护模式”就不在需要了。严密的权限设定构成了Linux安全的基础，在权限上犯错误是致命的。需要注意的是，umask命令用来设置进程所创<br>建的文件的读写权限，最保险的值是0077，即关闭创建文件的进程以外的所有进程的读写权限，表示为-rw——-。在<br>～/.bash_profile中，加上一行命令umask 0077可以保证每次启动Shell后, 进程的umask权限都可以被正确设定。<br>5.应用实例<br>umask -S<br>u=rwx,g=rx,o=rx<br>umask -p 177<br>umask -S<br>u=rw,g=,o=<br>上述5行命令，首先显示当前状态，然后把umask值改为177，结果只有文件所有者具有读写文件的权限，其它用户不能访问该文件。这显然是一种非常安全的设置。<br>chgrp<br>1.作用<br>chgrp表示修改一个或多个文件或目录所属的组。使用权限是超级用户。<br>2.格式<br>chgrp [选项]… 组 文件…<br>或<br>chgrp [选项]… –reference=参考文件 文件…<br>将每个的所属组设定为。<br>3.参数<br>-c, –changes ：像–verbose，但只在有更改时才显示结果。<br>–dereference：会影响符号链接所指示的对象，而非符号链接本身。<br>-h, –no-dereference：会影响符号链接本身，而非符号链接所指示的目的地(当系统支持更改符号链接的所有者，此选项才有效)。<br>-f, –silent, –quiet：去除大部分的错误信息。<br>–reference=参考文件：使用的所属组，而非指定的。<br>-R, –recursive：递归处理所有的文件及子目录。<br>-v, –verbose：处理任何文件都会显示信息。<br>4.应用说明<br>该命令改变指定指定文件所属的用户组。其中group可以是用户组ID，也可以是/etc/group文件中用户组的组名。文件名是以空格分开的要改变属组的文件列表，支持通配符。如果用户不是该文件的属主或超级用户，则不能改变该文件的组。<br>5.应用实例<br>改变/opt/local /book/及其子目录下的所有文件的属组为book，命令如下：<br>$ chgrp - R book /opt/local /book<br>chmod<br>1.作用<br>chmod命令是非常重要的，用于改变文件或目录的访问权限，用户可以用它控制文件或目录的访问权限，使用权限是超级用户。<br>2.格式<br>chmod命令有两种用法。一种是包含字母和操作符表达式的字符设定法（相对权限设定）；另一种是包含数字的数字设定法（绝对权限设定）。<br>（1）字符设定法<br>chmod [who] [+ | - | =] [mode] 文件名<br>◆操作对象who可以是下述字母中的任一个或它们的组合<br>u：表示用户，即文件或目录的所有者。<br>g：表示同组用户，即与文件属主有相同组ID的所有用户。<br>o：表示其它用户。<br>a：表示所有用户，它是系统默认值。<br>◆操作符号<br>+：添加某个权限。<br>-：取消某个权限。<br>=：赋予给定权限，并取消其它所有权限（如果有的话）。<br>◆设置mode的权限可用下述字母的任意组合<br>r：可读。<br>w：可写。<br>x：可执行。<br>X：只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x属性。<br>s：文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。<br>t：保存程序的文本到交换设备上。<br>u：与文件属主拥有一样的权限。<br>g：与和文件属主同组的用户拥有一样的权限。<br>o：与其它用户拥有一样的权限。<br>文件名：以空格分开的要改变权限的文件列表，支持通配符。<br>一个命令行中可以给出多个权限方式，其间用逗号隔开。<br>（2） 数字设定法<br>数字设定法的一般形式为： chmod [mode]文件名<br>数字属性的格式应为3个0到7的八进制数，其顺序是(u)(g)(o)文件名，以空格分开的要改变权限的文件列表，支持通配符。<br>数<br>字表示的权限的含义如下：0001为所有者的执行权限；0002为所有者的写权限；0004为所有者的读权限；0010为组的执行权限；0020为组的写<br>权限；0040为组的读权限；0100为其他人的执行权限；0200为其他人的写权限；0400为其他人的读权限；1000为粘贴位置位；2000表示假<br>如这个文件是可执行文件，则为组ID为位置位，否则其中文件锁定位置位；4000表示假如这个文件是可执行文件，则为用户ID为位置位。<br>3.实例<br>如果一个系统管理员写了一个表格(tem)让所有用户填写，那么必须授权用户对这个文件有读写权限，可以使用命令：＃chmod 666 tem<br>上<br>面代码中，这个666数字是如何计算出来的呢？0002为所有者的写权限，0004为所有者的读权限，0020为组的写权限，0040为组的读权限，<br>0200为其他人的写权限，0400为其他人的读权限，这6个数字相加就是666（注以上数字都是八进制数），结果见图1所示。<br>图1 用chmod数字方法设定文件权限<br>从图1可以看出，tem文件的权限是-rw-rw-rw-，即用户对这个文件有读写权限。<br>如果用字符权限设定使用下面命令：<br>＃chmod a =wx tem<br>chown<br>1.作用<br>更改一个或多个文件或目录的属主和属组。使用权限是超级用户。<br>2.格式<br>chown [选项] 用户或组 文件<br>3.主要参数<br>–dereference：受影响的是符号链接所指示的对象，而非符号链接本身。<br>-h, –no-dereference：会影响符号链接本身，而非符号链接所指示的目的地(当系统支持更改符号链接的所有者，此选项才有效)。<br>–from=目前所有者:目前组只当每个文件的所有者和组符合选项所指定的，才会更改所有者和组。其中一个可以省略，这已省略的属性就不需要符合原有的属性。<br>-f, –silent, –quiet：去除大部分的错误信息。<br>-R, –recursive：递归处理所有的文件及子目录。<br>-v, –verbose：处理任何文件都会显示信息。<br>4.说明<br>chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或用户ID；组可以是组名或组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将文件拷贝到另一个用户的目录下以后，让用户拥有使用该文件的权限。<br>5.应用实例<br>1.把文件shiyan.c的所有者改为wan<br>$ chown wan shiyan.c<br>2.把目录/hi及其下的所有文件和子目录的属主改成wan，属组改成users。<br>$ chown - R wan.users /hi<br>chattr<br>1.作用<br>修改ext2和ext3文件系统属性(attribute)，使用权限超级用户。<br>2.格式<br>chattr [-RV] [-+=AacDdijsSu] [-v version] 文件或目录<br>3.主要参数<br>－R：递归处理所有的文件及子目录。<br>－V：详细显示修改内容，并打印输出。<br>－：失效属性。<br>＋：激活属性。<br>= ：指定属性。<br>A：Atime，告诉系统不要修改对这个文件的最后访问时间。<br>S：Sync，一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘。<br>a：Append Only，系统只允许在这个文件之后追加数据，不允许任何进程覆盖或截断这个文件。如果目录具有这个属性，系统将只允许在这个目录下建立和修改文件，而不允许删除任何文件。<br>i：Immutable，系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件。<br>D：检查压缩文件中的错误。<br>d：No dump，在进行文件系统备份时，dump程序将忽略这个文件。<br>C：Compress，系统以透明的方式压缩这个文件。从这个文件读取时，返回的是解压之后的数据；而向这个文件中写入数据时，数据首先被压缩之后才写入磁盘。<br>s：Secure Delete，让系统在删除这个文件时，使用0填充文件所在的区域。<br>u：Undelete，当一个应用程序请求删除这个文件，系统会保留其数据块以便以后能够恢复删除这个文件。<br>4.说明<br>chattr<br>命令的作用很大，其中一些功能是由Linux内核版本来支持的，如果Linux内核版本低于2.2，那么许多功能不能实现。同样－D检查压缩文件中的错误<br>的功能，需要2.5.19以上内核才能支持。另外，通过chattr命令修改属性能够提高系统的安全性，但是它并不适合所有的目录。chattr命令不能<br>保护/、/dev、/tmp、/var目录。<br>5.应用实例<br>1.恢复/root目录,即子目录的所有文件<h1 id="chattr-R-u-root"><a href="#chattr-R-u-root" class="headerlink" title="chattr -R +u/root"></a>chattr -R +u/root</h1>2.用chattr命令防止系统中某个关键文件被修改<br>在Linux下，有些配置文件(passwd ,fatab)是不允许任何人修改的，为了防止被误删除或修改，可以设定该文件的“不可修改位(immutable)”，命令如下：<h1 id="chattr-i-etc-fstab"><a href="#chattr-i-etc-fstab" class="headerlink" title="chattr +i /etc/fstab"></a>chattr +i /etc/fstab</h1>sudo<br>1.作用<br>sudo是一种以限制配置文件中的命令为基础，在有限时间内给用户使用，并且记录到日志中的命令，权限是所有用户。<br>2.格式<br>sudo [-bhHpV] [-s ] [-u ] [指令]<br>sudo [-klv]<br>3.主要参数<br>－b：在后台执行命令。<br>-h：显示帮助。<br>-H：将HOME环境变量设为新身份的HOME环境变量。<br>-k：结束密码的有效期，即下次将需要输入密码。<br>-l：列出当前用户可以使用的命令。<br>-p：改变询问密码的提示符号。<br>-s ：执行指定的Shell。<br>-u ：以指定的用户为新身份，不使用时默认为root。<br>-v：延长密码有效期5分钟。<br>4.说明<br>sudo<br>命令的配置在/etc/sudoers文件中。当用户使用sudo时，需要输入口令以验证使用者身份。随后的一段时间内可以使用定义好的命令，当使用配置<br>文件中没有的命令时，将会有报警的记录。sudo是系统管理员用来允许某些用户以root身份运行部分/全部系统命令的程序。一个明显的用途是增强了站点<br>的安全性，如果需要每天以超级用户的身份做一些日常工作，经常执行一些固定的几个只有超级用户身份才能执行的命令，那么用sudo是非常适合的。<br>ps<br>1.作用<br>ps显示瞬间进程 (process) 的动态，使用权限是所有使用者。<br>2.格式<br>ps [options] [–help]<br>3.主要参数<br>ps的参数非常多, 此出仅列出几个常用的参数。<br>-A：列出所有的进程。<br>-l：显示长列表。<br>-m：显示内存信息。<br>-w：显示加宽可以显示较多的信息。<br>-e：显示所有进程。<br>a：显示终端上的所有进程,包括其它用户的进程。<br>-au：显示较详细的信息。<br>-aux：显示所有包含其它使用者的进程。<br>4.说明<br>要<br>对进程进行监测和控制，首先要了解当前进程的情况，也就是需要查看当前进程。ps命令就是最基本、也是非常强大的进程查看命令。使用该命令可以确定有哪些<br>进程正在运行、运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等。图2给出了ps-aux命令详解。大部分信息都可以通过执行该命<br>令得到。最常用的三个参数是u、a、x。下面就结合这三个参数详细说明ps命令的作用：psaux<br>图2 ps-aux命令详解<br>图2第2行代码中，USER表示进程拥有者；PID表示进程标示符；%CPU表示占用的CPU使用率；%MEM占用的物理内存使用率；VSZ表示占用的虚拟内存大小；RSS为进程占用的物理内存值；TTY为终端的次要装置号码。<br>STAT<br>表示进程的状态，其中D为不可中断的静止（I/O动作）；R正在执行中；S静止状态；T暂停执行；Z不存在，但暂时无法消除；W没有足够的内存分页可分<br>配；高优先序的进程；N低优先序的进程；L有内存分页分配并锁在内存体内 (实时系统或<br>I/O)。START为进程开始时间。TIME为执行的时间。COMMAND是所执行的指令。<br>4.应用实例<br>在进行系统维护时，经常会出现内存使用量惊人，而又不知道是哪一个进程占用了大量进程的情况。除了可以使用top命令查看内存使用情况之外，还可以使用下面的命令：<br>ps aux | sort +5n<br>who<br>1.作用<br>who显示系统中有哪些用户登陆系统，显示的资料包含了使用者ID、使用的登陆终端、上线时间、呆滞时间、CPU占用，以及做了些什么。 使用权限为所有用户。<br>2.格式<br>who - [husfV] [user]<br>3.主要参数<br>-h：不要显示标题列。<br>-u：不要显示使用者的动作/工作。<br>-s：使用简短的格式来显示。<br>-f：不要显示使用者的上线位置。<br>-V：显示程序版本。<br>4.说明<br>该<br>命令主要用于查看当前在线上的用户情况。如果用户想和其它用户建立即时通信，比如使用talk命令，那么首先要确定的就是该用户确实在线上,不然<br>talk进程就无法建立起来。又如，系统管理员希望监视每个登录的用户此时此刻的所作所为，也要使用who命令。who命令应用起来非常简单，可以比较准<br>确地掌握用户的情况,所以使用非常广泛。<br>动手练习<br>1.使用Linux命令检测系统入侵者<br>安<br>装过Mandrake Linux和Red Hat<br>Linux的用户都会知道，Linux系统会内置三种不同级别（标准、高、更高）的防火墙，当进行了Linux服务器的安装和一些基本的设置后，服务器应<br>该说是比较安全的，但是也会有黑客通过各种方法利用系统管理员的疏忽侵入系统。如何快速查找黑客非常重要。一般来说，可以使用命令查询黑客是否入侵，见表<br>1。<br>表1 查询黑客入侵现象的命令对应表<br>举例说明，如果黑客嗅探网络，那么它必须使网卡接口处于混杂模式，使用下面命令进行查询：<br>＃ifconfig -a<br>eth0 Link encap:Ethernet HWaddr 00:00:E8:A0:25:86<br>inet addr:192.168.1.7 Bcast:192.168.1.255 Mask:255.255.255.0<br>UP BROADCAST RUNNING PROMISCUOUS MTU:1500 Metric:1<br>……<br>从<br>这个命令的输出中，可以看到上面讲到的这些概念。第一行的00:00:E8:A0:25:86是mac地址，第二行的192.168.1.7是IP地址，<br>第四行讲的是接收数据状态，这时正在被黑客嗅探。一般而言，网卡有几种接收数据帧的状态，如Broadcast、Multicast、<br>Promiscuous等。Broadcast是指接收所有类型为广播报文的数据帧；Multicast是指接收特定的组播报文；Promiscuous<br>则是通常说的混杂模式，是指对报文中的目的硬件地址不加任何检查、全部接收的工作模式。<br>2.限制su命令的滥用<br>我<br>们知道，超级用户在Linux中有最大的权利，几乎所有黑客都想得到这个目标。Linux可以增加对切换到超级用户的限制。使用PAM<br>（PluggableAuthentication<br>Modules）可以禁止除在wheel组以外的任何人su成root，修改/etc/pam.d/su文件，除去屏蔽标识#。使用<br>/usr/sbin/usermod G10 bjecadm将bjecadm这个账号加入gid为10的组，就是wheel组。命令如下：<br>/etc/pam.d/su # 使用密码验证＃<br>auth sufficient /lib/security/pam_wheel.so debug<h1 id="限制只有wheel组用户才可以切换到root＃"><a href="#限制只有wheel组用户才可以切换到root＃" class="headerlink" title="限制只有wheel组用户才可以切换到root＃"></a>限制只有wheel组用户才可以切换到root＃</h1>auth required /lib/security/pam_wheel.so use_uid<br>chmod -G10 bjecadm<br>另外，每当用户试图使用su命令进入系统用户时,命令将在/usr/adm/sulog文件中写一条信息,若该文件记录了大量试图用su进入root的无效操作信息,则表明了可能有人企图破译root口令。<br>Linux命令有着强大的功能。对于Linux系统管理员来说，往往只需要通过各种安全命令技巧，组合构成安全防线。从计算机安全的角度看，世界上没有绝对安全的计算机系统，Linux系统也不例外。<br>Linux必学的60个命令(6)-其他命令<br>Linux必学的60个命令：其它命令<br>在前面几讲中，我们把Linux命令按照在系统中的作用分成几个部分分别予以介绍。但是，还有一些命令不好划分，然而学习它们同样是比较重要的。<br>tar<br>1.作用<br>tar命令是Unix/Linux系统中备份文件的可靠方法，几乎可以工作于任何环境中，它的使用权限是所有用户。<br>2.格式<br>tar [主选项+辅选项] 文件或目录<br>3.主要参数<br>使用该命令时，主选项是必须要有的，它告诉tar要做什么事情，辅选项是辅助使用的，可以选用。<br>主选项：<br>-c 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。<br>-r 把要存档的文件追加到档案文件的未尾。例如用户已经做好备份文件，又发现还有一个目录或是一些文件忘记备份了，这时可以使用该选项，将忘记的目录或文件追加到备份文件中。<br>-t 列出档案文件的内容，查看已经备份了哪些文件。<br>-u 更新文件。就是说，用新增的文件取代原备份文件，如果在备份文件中找不到要更新的文件，则把它追加到备份文件的最后。<br>-x 从档案文件中释放文件。<br>辅助选项：<br>-b 该选项是为磁带机设定的，其后跟一数字，用来说明区块的大小，系统预设值为20（20×512bytes）。<br>-f 使用档案文件或设备，这个选项通常是必选的。<br>-k 保存已经存在的文件。例如把某个文件还原，在还原的过程中遇到相同的文件，不会进行覆盖。<br>-m 在还原文件时，把所有文件的修改时间设定为现在。<br>-M 创建多卷的档案文件，以便在几个磁盘中存放。<br>-v 详细报告tar处理的文件信息。如无此选项，tar不报告文件信息。<br>-w 每一步都要求确认。<br>-z 用gzip来压缩/解压缩文件，加上该选项后可以将档案文件进行压缩，但还原时也一定要使用该选项进行解压缩。<br>4.应用说明<br>tar 是Tape Archive（磁带归档）的缩写，最初设计用于将文件打包到磁带上。如果下载过Linux的源代码，或许已经碰到过tar文件<br>请注意，不要忘了Linux是区分大小写的。例如，tar命令应该总是以小写的形式执行。命令行开关可以是大写、小写或大小写的混合。例如，-t和-T执行不同的功能。文件或目录名称可以混合使用大小写，而且就像命令和命令行开关一样是区分大小写的。<br>5.应用实例<br>tar是一个命令行的工具，没有图形界面。使用Konsole打开一个终端窗口，接下来是一个简单的备份命令（在/temp目录中创建一个back.tar的文件，/usr目录中所有内容都包含在其中。）：<br>$tar cvf - /usr &gt; /temp/back.tar<br>另<br>外，tar命令支持前面第三讲中讲过的crontab命令，可以用crontab工具设置成基于时间的有规律地运行。例如，每晚6点把/usr目录备份到<br>hda—第一个IDE接口的主驱动器 (总是位于第一个硬盘)中，只要将下面语句添加到root的crontab中即可：<br>$00 06 <em> </em> <em> tar cvf /dev/hda1/usrfiles.tar - /usr<br>一般情况下，以下这些目录是需要备份的：<br>◆/etc 包含所有核心配置文件，其中包括网络配置、系统名称、防火墙规则、用户、组，以及其它全局系统项。<br>◆ /var 包含系统守护进程（服务）所使用的信息，包括DNS配置、DHCP租期、邮件缓冲文件、HTTP服务器文件、dB2实例配置等。<br>◆/home 包含所有默认用户的主目录，包括个人设置、已下载的文件和用户不希望失去的其它信息。<br>◆/root 根（root）用户的主目录。<br>◆/opt 是安装许多非系统文件的地方。IBM软件就安装在这里。OpenOffice、JDK和其它软件在默认情况下也安装在这里。<br>有些目录是可以不备份的：<br>◆ /proc 应该永远不要备份这个目录。它不是一个真实的文件系统，而是运行内核和环境的虚拟化视图，包括诸如/proc/kcore这样的文件，这个文件是整个运行内存的虚拟视图。备份这些文件只是在浪费资源。<br>◆/dev 包含硬件设备的文件表示。如果计划还原到一个空白的系统，就可以备份/dev。然而，如果计划还原到一个已安装的Linux 系统，那么备份/dev是没有必要的。<br>unzip<br>1.作用<br>unzip<br>命令位于/usr/bin目录中，它们和MS DOS下的pkzip、pkunzip及MS<br>Windows中的Winzip软件功能一样，将文件压缩成.zip文件，以节省硬盘空间，当需要的时候再将压缩文件用unzip命令解开。该命令使用权<br>限是所有用户。<br>2.格式<br>unzip [-cflptuvz][-agCjLMnoqsVX][-P ][.zip文件][文件][-d][-x ]<br>3.主要参数<br>-c：将解压缩的结果显示到屏幕上，并对字符做适当的转换。<br>-f：更新现有的文件。<br>-l：显示压缩文件内所包含的文件。<br>-p：与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。<br>-t：检查压缩文件是否正确。<br>-u：与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其它文件解压缩到目录中。<br>-v：执行是时显示详细的信息。<br>-z：仅显示压缩文件的备注文字。<br>-a：对文本文件进行必要的字符转换。<br>-b：不要对文本文件进行字符转换。<br>-C：压缩文件中的文件名称区分大小写。<br>-j：不处理压缩文件中原有的目录路径。<br>-L：将压缩文件中的全部文件名改为小写。<br>-M：将输出结果送到more程序处理。<br>-n：解压缩时不要覆盖原有的文件。<br>-o：不必先询问用户，unzip执行后覆盖原有文件。<br>-P：使用zip的密码选项。<br>-q：执行时不显示任何信息。<br>-s：将文件名中的空白字符转换为底线字符。<br>-V：保留VMS的文件版本信息。<br>-X：解压缩时同时回存文件原来的UID/GID。<br>[.zip文件]：指定.zip压缩文件。<br>[文件]：指定要处理.zip压缩文件中的哪些文件。<br>-d：指定文件解压缩后所要存储的目录。<br>-x：指定不要处理.zip压缩文件中的哪些文件。<br>-Z unzip：-Z等于执行zipinfo指令。在Linux中，还提供了一个叫zipinfo的工具，能够察看zip压缩文件的详细信息。unzip最新版本是5.50。<br>gunzip<br>1.作用<br>gunzip命令作用是解压文件，使用权限是所有用户。<br>2.格式<br>gunzip [-acfhlLnNqrtvV][-s ][文件…]<br>或者<br>gunzip [-acfhlLnNqrtvV][-s ][目录]<br>3.主要参数<br>-a或–ascii：使用ASCII文字模式。<br>-c或–stdout或–to-stdout：把解压后的文件输出到标准输出设备。<br>-f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在，以及该文件是否为符号连接。<br>-h或–help：在线帮助。<br>-l或–list：列出压缩文件的相关信息。<br>-L或–license：显示版本与版权信息。<br>-n或–no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理。<br>-N或–name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上。<br>-q或–quiet：不显示警告信息。<br>-r或–recursive：递归处理，将指定目录下的所有文件及子目录一并处理。<br>-S或–suffix：更改压缩字尾字符串。<br>-t或–test：测试压缩文件是否正确无误。<br>-v或–verbose：显示指令执行过程。<br>-V或–version：显示版本信息。<br>4.说明<br>gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为“.gz”。事实上，gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。gunzip最新版本是1.3.3。<br>unarj<br>1.作用<br>unarj解压缩格式为.arj格式的文件，使用权限是所有用户。<br>2.格式<br>unarj [eltx][.arj压缩文件]<br>3.主要参数<br>e：解压缩.arj文件。<br>l：显示压缩文件内所包含的文件。<br>t：检查压缩文件是否正确。<br>x：解压缩时保留原有的路径。<br>4.说明<br>带有.arj扩展名的文件是由用于MS DOS和Windows的ARJ实用程序创建的。因为ARJ是一种不能免费获得源代码的共享件程序，所以在<br>mtools<br>1.作用<br>mtools<br>实际上是一个命令集合，是DOS文件系统的工具程序，它可以模拟许多DOS命令，使用起来非常方便。使用权限是所有用户。Linux系统提供了一组称为<br>mtools的可移植工具，可以让用户轻松地从标准的DOS软盘上读、写文件和目录。它们对DOS和Linux环境之间交换文件非常有用。mtools的<br>使用非常简单，如果想把软盘里所有的文件都拷贝到硬盘上，那么就可以执行以下命令：<br>mcopy a:</em>.*<br>也就是说，只需要在相应的DOS命令之前加上一个字母“m”，就可以完成对应的功能了。一般Linux发行版本中都有这个软件，可以使用下面命令检查一下。<br>rpm -qa|grep mtools<br>如果没有安装，也没有关系，可以从网上下载(<a href="http://mtools.linux.lu/)一个最新版本来安装。目前可供下载的最新mtools版本是" target="_blank" rel="external">http://mtools.linux.lu/)一个最新版本来安装。目前可供下载的最新mtools版本是</a><br>2.包括的命令<br>mcd 目录名：改变MS DOS下的目录。<br>mcopy 源文件 目标文件：在MS DOS和Unix之间复制文件。<br>mdel 文件名：删除MS DOS下的文件。<br>mdir 目录名：显示MS DOS下的目录。<br>mformat 驱动器号：在低级格式化的软盘上创建MS DOS文件系统。<br>rnlabel 驱动器号：产生MS DOS下的卷标。<br>mmd 目录名：建立MS DOS下的目录。<br>mrd 目录名：删除MS DOS下的目录。<br>mren 源文件 目标文件：重新命名已存在的MS DOS文件。<br>mtype 文件名：显示MS DOS文件的内容。<br>请注意，这些命令和对应的MS DOS命令非常相似。在mtools命令中，“/”和“\”是可以混用的。因为文件列表的是DOS系统下的文档，对大小写并不敏感，所以“CDE”和“cde”在这里是一样的。<br>3.应用实例<br>(1)如果把软盘进行快速格式化，可以使用命令mformat：<br>mformat A：<br>mtools<br>当初发展的目的是用来处理DOS文件系统的，所以只能用在FAT文件格式的分区上。需要注意的是，如果用mount命令来挂载了FAT16/32分区，那<br>么就不能使用mtools的指令来处理这些分区上的文件。这是因为一旦FAT16/32分区挂到了Linux文件目录下，Linux就会将其视为文件系统<br>本身的一部分，这时如果要对其操作就必须使用Linux本身所附带的指令集。<br>(2)将DOS盘上的文件htca.c复制到当前目录下，并用ls命令进行验证。<br>$ mcopy a:\htca.c<br>$ ls -l htca.c<br>-rw-r- -r- - 1 xxq xxq 27136 Jan 1 01:80 htca.c<br>man<br>1.作用<br>man命令用来提供在线帮助，使用权限是所有用户。在Linux系统中存储着一部联机使用的手册，以供用户在终端上查找。使用man命令可以调阅其中的帮助信息，非常方便和实用。<br>2.格式<br>man 命令名称<br>man [-acdfhkKtwW] [-m system] [-p string] [-C config_file] [-M path] [-P pager][-S section_list] [section] name …<br>3.参数<br>-C config_file：指定设定文件man.conf，缺省值是/etc/man.conf。<br>-M path：指定了联机手册的搜寻路径, 如果没有指定则使用环境变数MANPATH的设定；如果没有使用MANPATH， 则会使用/usr/lib/man.conf内的设定；如果MANPATH是空字串，则表示使用缺省值。<br>-P pager：指定使用何种pager.man会优先使用此选项设定，然后是依环境变数MANPAGER设定，然后是环境变数PAGER；man缺省使用/usr/bin/less -is。<br>-S section_list man：所搜寻的章节列表(以冒号分隔)，此选项会覆盖环境变数MANSECT的设定。<br>-a man：缺省情况是在显示第一个找到的手册之后，就会停止搜寻，使用此选项会强迫man继续显示所有符合name的联机手册。<br>-c：即使有最新的cat page，也继续对联机手册重新作排版，本选项在屏幕的行列数改变时或已排版的联机手册损坏时特别有意义。<br>-d：不要真的显示联机手册，只显示除错讯息。<br>-D：同时显示联机手册与除错讯息。<br>-h：显示求助讯息然后结束程式 。<br>-K：对所有的联机手册搜寻所指定的字串。请注意，本功能回应速度可能很慢，如果指定section（区域）会对速度有帮助。<br>-m system：依所指定的system名称而指定另一组的联机手册。<br>man：是manual（手册）的缩写。在输入命令有困难时，可以立刻得到这个文档。例如, 如果使用ps命令时遇到困难，可以输入man ps得到帮助信息，此时会显示出ps的手册页（manpage）。<br>由于手册页man page是用less程序来看的(可以方便地使屏幕上翻和下翻), 所以在manpage里可以使用less的所有选项。<br>less中比较重要的功能键有:<br>[q] 退出；<br>[Enter] 一行行地下翻；<br>[Space] 一页页地下翻；<br>上翻一页；<br>[/] 后跟一个字符串和[Enter]来查找字符串；<br>[n] 发现上一次查找的下一个匹配。<br>4.阅读手册页<br>手册页在很少的空间里提供了很多的信息， 这里简单介绍一下大多数手册页中都有的部分内容。Linux手册页主要有九个部分：用户指令、系统调用、程序库、设备说明、文件格式、游戏、杂项、系统指令、内核，手册页快照见图1所示。<br>图1 ps命令手册页快照<br>Linux手册页布局见表1。<br>5.应用实例<br>Linux<br>命令中有一些基础的、重要的命令，例如ps、find、cat和ls等。下面来举一个综合应用的例子，由此可以看出man的地位在Linux中可谓至关重<br>要。但是，man所显示的信息却不是普通的文本，如果直接将这些文字重定向到一个文本文件，就会发现在man中高亮显示的文字就变成了两个，而且有不计其<br>数的制表符，使打印、编辑都变得非常不便。不过，使用下面这样一条语句就能得到ps命令打印。<h1 id="man-ps-col-b-lpr"><a href="#man-ps-col-b-lpr" class="headerlink" title="man ps | col -b | lpr"></a>man ps | col -b | lpr</h1>这条命令同时运用了输出重定向和管道两种技巧，作用是将ps命令的帮助信息可以直接打印出来。更多的Man文件可以查看LinuxMan<br>unencode<br>1.作用<br>unencode命令可以把一个二进制文件表编码为一个文本文件，使用权限是所有用户。<br>2.格式<br>uuencode [-hv] [源文件] 目标文件<br>3.主要参数<br>－h：列出指令使用格式(help) 。<br>－v：列出版本信息。<br>4.应用说明<br>uuencode指令可以将二进制文件转化成可使用电子邮件发送的ASCII编码形式。uuencode编码后的资料都以 begin开始，以end作为结束，且通常其中的每一行的开始均为“M”，中间部分是编码过的文件，编码后的文件比源文件要大一些。<br>uudecode<br>1.作用<br>uudecode命令用来将uuencode编码后的档案还原，uudecode只会将begin与end标记之间的编码资料还原，程序会跳过标记以外的资料。它的使用权限为所有用户。<br>2.格式<br>uuencode [-hv] [file1 …]<br>3.主要参数<br>－h：列出指令使用格式(help)。<br>－v：列出版本信息。<br>4.应用实例<br>使用下面命令一次还原几个文件：<br>uuencode file1.uud file2.uud file3.uud<br>动手练习<br>1.在Linux命令行下发送邮件<br>虽然Linux桌面应用发展很快，但是命令行（Shell）在Linux中依然有很强的生命力。如果能确认电子邮件服务器支持8bit的字节，就可以直接使用下面命令：<br>cat ＜附件文件名＞ | mail ＜邮件地址＞<br>cat（cat是concatenate的缩写）命令是将几个文件处理成一个文件，并将这种处理的结果保存到一个单独的输出文件，这里我们用它来合并邮件的文本。<br>写好邮件名称，比如叫cjkmail，然后使用下面命令：<br>$uuencode ＜附件文件名＞ ＜附件文件名＞ &gt;&gt;cjkmail<br>这样就可以用vi编辑器写cjkmail文件，并在前面写上信的正文，然后寄出。<br>对方收到信后，把信中属于cjkmail中的内容拷贝出来，存为themail.uue。如果对方是在Windows下，就可以用WinRAR或WinZip解压，这样就可以看到附件。<br>如果对方也使用Linux，可以用undecode命令还原：<br>$ uudencode -o＜附件文件名＞ themail.uue<br>2.实现tar的分卷<br>笔者想把一个378MB的文件压缩成多个63MB的文件（笔者的USB为64MB），使用下面命令：<br>$tar czvf - dir | split -d -b 63m<br>然后合并命令：<br>$cat x* &gt; dir.tgz<br>以上例子实际是由三个命令组合完成的，即用tar打包，用split分割，用cat合并。“tarczvf - dir”的意思是把dir目录打包，并输出到标准输出（argv），这样就可以直接用管道输出给split。<br>3.连续执行一个命令<br>使用watch命令，可以反复执行命令。如果和ls配合，可以达到观察某文件大小变化的效果。<br>$watch ls －l file.name<br>4.用tar命令导出一个文件<br>有一个tar格式的DVD文件GLvPro6.4_linux.tar，因为该文件非常大（4.7GB），如果全部解压比较麻烦，可以用下面命令先导出readme.txt看看。<br>tar xvf GLvPro6.4_linux.tar readme.txt<br>这样readme.txt就单独被导出了。<br>5.用tar打包一个目录时只备份其中的几个子目录<br>tar cf –exclude home/cjh home/cao<br>这样home目录下只有cjh和cao两个子目录备份。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式二]]></title>
      <url>https://fudawei.github.io/2016/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造模式是将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心。<br>在Java的应用中JavaMail使用到了该模式。<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/21783106.jpg" alt="建造者模式"></p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/* 浅复制 */</div><div class="line">public Object clone() throws CloneNotSupportedException &#123;</div><div class="line">	Prototype proto = (Prototype) super.clone();</div><div class="line">	return proto;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 深复制 */</div><div class="line">public Object deepClone() throws IOException, ClassNotFoundException &#123;</div><div class="line">	/* 写入当前对象的二进制流 */</div><div class="line">	ByteArrayOutputStream bos = new ByteArrayOutputStream();</div><div class="line">	ObjectOutputStream oos = new ObjectOutputStream(bos);</div><div class="line">	oos.writeObject(this);</div><div class="line">	/* 读出二进制流产生的新对象 */</div><div class="line">	ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());</div><div class="line">	ObjectInputStream ois = new ObjectInputStream(bis);</div><div class="line">	return ois.readObject();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/52927626-640.webp" alt="类的适配器模式"><br>核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Source &#123;</div><div class="line">	public void method1()&#123;</div><div class="line">		System.out.println(&quot;method1&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface Targetable &#123;</div><div class="line">	public void method1();</div><div class="line">	public void method2();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Adapter extends Source implements Targetable&#123;</div><div class="line">	@Override</div><div class="line">	public void method2() &#123;</div><div class="line">		System.out.println(&quot;method2&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class AdapterTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Targetable target = new Adapter();</div><div class="line">		target.method1();</div><div class="line">		target.method2();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/25514382-640.webp" alt="对象的适配器模式"><br>基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Wrapper implements Targetable &#123;</div><div class="line">	private Source source;</div><div class="line">	public Wrapper(Source source)&#123;</div><div class="line">	super();</div><div class="line">	this.source = source;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void method2() &#123;</div><div class="line">		System.out.println(&quot;this is the targetable method!&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void method1() &#123;</div><div class="line">		source.method1();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/25514382-640.webp" alt="接口的适配器模式"><br>接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public interface Sourceable &#123;</div><div class="line">	public void method1();</div><div class="line">	public void method2();</div><div class="line">	public void method3();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class Wrapper implements Sourceable &#123;</div><div class="line">	public void method1()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public void method2()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SourceSub1 extends Wrapper&#123;</div><div class="line">	@Override</div><div class="line">	public void method3() &#123;</div><div class="line">		System.out.println(&quot;SourceSub1&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SourceSub2 extends Wrapper&#123;</div><div class="line">	@Override</div><div class="line">	public void method3() &#123;</div><div class="line">		System.out.println(&quot;SourceSub3&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Sourceable source1 = new SourceSub1();</div><div class="line">		Sourceable source2 = new SourceSub2();</div><div class="line">		source1.method1();</div><div class="line">		source1.method2();</div><div class="line">		source1.method3();</div><div class="line"></div><div class="line">		source2.method1();</div><div class="line">		source2.method2();</div><div class="line">		source2.method3();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>适配器模式总结</p>
<ul>
<li>类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</li>
<li>对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</li>
<li>接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</li>
</ul>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例<br>简单的装饰模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public interface IComponent &#123;</div><div class="line">	public void operation();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteComponent implements IComponent &#123;</div><div class="line">	@Override</div><div class="line">	public void operation() &#123;</div><div class="line">		System.out.println(&quot;开车&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Decorator implements IComponent &#123;</div><div class="line">	private IComponent component;</div><div class="line"></div><div class="line">	public Decorator(IComponent component) &#123;</div><div class="line">		this.component = component;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void operation() &#123;</div><div class="line">		component.operation();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteDecorator extends Decorator &#123;</div><div class="line">	public ConcreteDecorator(IComponent component) &#123;</div><div class="line">		super(component);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void operation() &#123;</div><div class="line">		this.addOperation();</div><div class="line">		super.operation();</div><div class="line">	&#125;</div><div class="line">	private void addOperation() &#123;</div><div class="line">		System.out.print(&quot;晚上&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ConcreteComponent component = new ConcreteComponent();</div><div class="line">		ConcreteDecorator decorator = new ConcreteDecorator(component);</div><div class="line">		decorator.operation();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>复杂的装饰模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">public interface IComponent &#123;</div><div class="line">	void showCoffee();</div><div class="line">	double showPrice();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Coffee implements IComponent &#123;</div><div class="line">	private String name;</div><div class="line">	private double price;</div><div class="line">	public Coffee(String name,double price)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.price = price;</div><div class="line">	&#125;</div><div class="line">	...get...set</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void showCoffee() &#123;</div><div class="line">		System.out.println(&quot;的&quot;+this.getName()+&quot;咖啡&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public double showPrice() &#123;</div><div class="line">		return this.getPrice();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">// 装饰类</div><div class="line">public class Decorator implements IComponent &#123;</div><div class="line">	private IComponent componet;</div><div class="line"></div><div class="line">	public void setComponent(IComponent component) &#123;</div><div class="line">		this.componet = component;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void showCoffee() &#123;</div><div class="line">		componet.showCoffee();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public double showPrice() &#123;</div><div class="line">		return componet.showPrice();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Milk extends Decorator&#123;</div><div class="line">	@Override</div><div class="line">	public void showCoffee() &#123;</div><div class="line">		System.out.print(&quot;加奶&quot;);</div><div class="line">		super.showCoffee();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public double showPrice() &#123;</div><div class="line">		return 15.0+super.showPrice();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Sugar extends Decorator &#123;</div><div class="line">	@Override</div><div class="line">	public void showCoffee() &#123;</div><div class="line">		System.out.print(&quot;加糖&quot;);</div><div class="line">		super.showCoffee();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public double showPrice() &#123;</div><div class="line">		return 10+super.showPrice();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Coffee coffee = new Coffee(&quot;拿铁&quot;,55.0);</div><div class="line">		Decorator sugar = new Sugar();</div><div class="line">		Decorator milk = new Milk();</div><div class="line">		sugar.setComponent(coffee);</div><div class="line">		milk.setComponent(sugar);</div><div class="line">		milk.showCoffee();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>装饰器模式的应用场景：<br>1、需要扩展一个类的功能。<br>2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）<br>缺点：产生过多相似的对象，不易排错！</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理持有一个真实实现类的引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public interface Sourceable &#123;</div><div class="line">    public void method();</div><div class="line">&#125;</div><div class="line">public class Source implements Sourceable &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void method() &#123;</div><div class="line">        System.out.println(&quot;the original method!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class Proxy implements Sourceable &#123;</div><div class="line"></div><div class="line">    private Source source;</div><div class="line">    public Proxy()&#123;</div><div class="line">        super();</div><div class="line">        this.source = new Source();</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void method() &#123;</div><div class="line">        before();</div><div class="line">        source.method();</div><div class="line">        atfer();</div><div class="line">    &#125;</div><div class="line">    private void atfer() &#123;</div><div class="line">        System.out.println(&quot;after proxy!&quot;);</div><div class="line">    &#125;</div><div class="line">    private void before() &#123;</div><div class="line">        System.out.println(&quot;before proxy!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/70870796-640.webp" alt="外观模式"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Computer &#123;</div><div class="line">	private CPU cpu;</div><div class="line">	private Memory memory;</div><div class="line">	private Disk disk;</div><div class="line">	public Computer()&#123;</div><div class="line">		cpu = new CPU();</div><div class="line">		memory = new Memory();</div><div class="line">		disk = new Disk();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void startUp()&#123;</div><div class="line">		cpu.startUp();</div><div class="line">		memory.startUp();</div><div class="line">		disk.startUp();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void shutDown()&#123;</div><div class="line">		cpu.shutDown();</div><div class="line">		memory.shutDown();</div><div class="line">		disk.shutDown();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/95852650.jpg" alt="策略模式"></p>
<ol>
<li><p>加减法计算表达式-策略模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public interface ICalculator &#123;</div><div class="line">	public int calculate(String exp);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class AbstractCalculator &#123;</div><div class="line">	public int[] split(String exp,String delimeter)&#123;</div><div class="line">		String[] arr = exp.split(delimeter);</div><div class="line">		int[] result = new int[2];</div><div class="line">		result[0] = Integer.parseInt(arr[0]);</div><div class="line">		result[1] = Integer.parseInt(arr[1]);</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Minus extends AbstractCalculator implements ICalculator&#123;</div><div class="line">	@Override</div><div class="line">	public int calculate(String exp) &#123;</div><div class="line">		int[] arr = split(exp, &quot;-&quot;);</div><div class="line">		return arr[0]-arr[1];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Plus extends AbstractCalculator implements ICalculator&#123;</div><div class="line">	@Override</div><div class="line">	public int calculate(String exp) &#123;</div><div class="line">		int[] arr = split(exp, &quot;\\+&quot;);</div><div class="line">		return arr[0]+arr[1];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Multiply extends AbstractCalculator implements ICalculator&#123;</div><div class="line">	@Override</div><div class="line">	public int calculate(String exp) &#123;</div><div class="line">		int[] arr = split(exp, &quot;\\*&quot;);</div><div class="line">		return arr[0]*arr[1];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ICalculator cal = new Plus();</div><div class="line">		int res = cal.calculate(&quot;8+2&quot;);</div><div class="line">		System.out.println(res);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>客户打折-策略模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public interface Strategy &#123;</div><div class="line">	public double calcPrice(double goodsPrice);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class LargeCustomerStrategy implements Strategy&#123;</div><div class="line">	@Override</div><div class="line">	public double calcPrice(double goodsPrice) &#123;</div><div class="line">		System.out.println(&quot;大客户10%&quot;);</div><div class="line">		return goodsPrice*(1-0.1);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class OldCustomerStrategy implements Strategy&#123;</div><div class="line">	@Override</div><div class="line">	public double calcPrice(double goodsPrice) &#123;</div><div class="line">		System.out.println(&quot;老客户5%&quot;);</div><div class="line">		return goodsPrice*(1-0.05);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class NormalCustomerStrategy implements Strategy&#123;</div><div class="line">	@Override</div><div class="line">	public double calcPrice(double goodsPrice) &#123;</div><div class="line">		System.out.println(&quot;新客户或普通客户没有折扣&quot;);</div><div class="line">		return goodsPrice;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Price &#123;</div><div class="line">	private Strategy strategy = null;</div><div class="line"></div><div class="line">	public Price(Strategy strategy)&#123;</div><div class="line">		this.strategy = strategy;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public double quote(double goodsPrice)&#123;</div><div class="line">		return this.strategy.calcPrice(goodsPrice);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Strategy strategy = new LargeCustomerStrategy();</div><div class="line">		Price ctx = new Price(strategy);</div><div class="line">		double quote = ctx.quote(1000);</div><div class="line">		System.out.println(&quot;报价:&quot;+quote);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>保存日志到数据库/文件-策略模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public interface LogStrategy &#123;</div><div class="line">	public void log(String msg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class DbLog implements LogStrategy&#123;</div><div class="line">	@Override</div><div class="line">	public void log(String msg) &#123;</div><div class="line">		if(msg!=null &amp;&amp; msg.trim().length()&gt;5)&#123;</div><div class="line">			int a = 5/0;</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;现在把&apos;&quot;+msg+&quot;&apos;记录到数据库中&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class FileLog implements LogStrategy&#123;</div><div class="line">	@Override</div><div class="line">	public void log(String msg) &#123;</div><div class="line">		System.out.println(&quot;现在把&apos;&quot;+msg+&quot;&apos;记录到文件中&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class LogContext &#123;</div><div class="line">	public void log(String msg)&#123;</div><div class="line">		LogStrategy strategy = new DbLog();</div><div class="line">		try &#123;</div><div class="line">			strategy.log(msg);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			strategy = new FileLog();</div><div class="line">			strategy.log(msg);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		LogContext log = new LogContext();</div><div class="line">		// 正常记录到数据库中</div><div class="line">		log.log(&quot;记录日志&quot;);</div><div class="line">		// 发生异常，此时策略切换为文件记录日志</div><div class="line">		log.log(&quot;再次记录日志&quot;);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">结果：</div><div class="line">现在把&apos;记录日志&apos;记录到数据库中</div><div class="line">现在把&apos;再次记录日志&apos;记录到文件中</div></pre></td></tr></table></figure>
</li>
<li><p>给某个动作前面加上一个动作-策略模式结合模板模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public interface LogStrategy &#123;</div><div class="line">	public void log(String msg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class LogStrategyTemplate implements LogStrategy&#123;</div><div class="line">	//给各个策略前面加上时间，可以通过结合模板模式，在父类中设定好执行顺序，由子类执行</div><div class="line">	@Override</div><div class="line">	public void log(String msg) &#123;</div><div class="line">		SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">		msg = sdf.format(new Date())+&quot;内容是&quot;+msg;</div><div class="line">		doLog(msg);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	protected abstract void doLog(String msg);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class DbLog extends LogStrategyTemplate&#123;</div><div class="line">	@Override</div><div class="line">	protected void doLog(String msg) &#123;</div><div class="line">		if(msg!=null &amp;&amp; msg.trim().length()&gt;5)&#123;</div><div class="line">			int a = 5/0;</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;记录到数据库中：&quot;+msg);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class FileLog extends LogStrategyTemplate&#123;</div><div class="line">	@Override</div><div class="line">	protected void doLog(String msg) &#123;</div><div class="line">		System.out.println(&quot;现在把&quot;+msg+&quot;记录到数据库中&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class LogContext &#123;</div><div class="line">	public void log(String msg)&#123;</div><div class="line">		LogStrategy strategy = new DbLog();</div><div class="line">		try &#123;</div><div class="line">			strategy.log(msg);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			strategy = new FileLog();</div><div class="line">			strategy.log(msg);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		LogContext log = new LogContext();</div><div class="line">		log.log(&quot;记录日志&quot;);</div><div class="line">		log.log(&quot;再次记录日志&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出</div><div class="line">现在把2016-04-26 18:11:32内容是  记录日志  记录到数据库中</div><div class="line">现在把2016-04-26 18:11:32内容是  再次记录日志  记录到数据库中</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/65731774.jpg" alt="模板方式模式"><br>就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractCalculator &#123;</div><div class="line">	public final int calculate(String exp,String delimeter)&#123;</div><div class="line">		int array[] = split(exp, delimeter);</div><div class="line">		return calculate(array[0],array[1]);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public abstract int calculate(int num1,int num2);</div><div class="line"></div><div class="line">	public int[] split(String exp,String delimeter)&#123;</div><div class="line">		String[] arr = exp.split(delimeter);</div><div class="line">		int[] result = new int[2];</div><div class="line">		result[0] = Integer.parseInt(arr[0]);</div><div class="line">		result[1] = Integer.parseInt(arr[1]);</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Plus extends AbstractCalculator&#123;</div><div class="line">	@Override</div><div class="line">	public int calculate(int num1, int num2) &#123;</div><div class="line">		return num1+num2;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		AbstractCalculator cal = new Plus();</div><div class="line">		int res = cal.calculate(&quot;8+2&quot;,&quot;\\+&quot;);</div><div class="line">		System.out.println(res);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class Watcher implements Observer &#123;</div><div class="line">	public Watcher(Watched w) &#123;</div><div class="line">		w.addObserver(this);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void update(Observable o, Object arg) &#123;</div><div class="line">		System.out.println(((Watched)o).retriveData());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Watched extends Observable &#123;</div><div class="line">	private String data=&quot;&quot;;</div><div class="line"></div><div class="line">	public String retriveData()&#123;</div><div class="line">		return data;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void changeData(String data)&#123;</div><div class="line">		if(!this.data.equals(data))&#123;</div><div class="line">			this.data = data;</div><div class="line">			setChanged();</div><div class="line">			notifyObservers();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Watched watched = new Watched();</div><div class="line">		Watcher watcher = new Watcher(watched);</div><div class="line">		watched.changeData(&quot;A&quot;);</div><div class="line">		watched.changeData(&quot;B&quot;);</div><div class="line">		watched.changeData(&quot;C&quot;);</div><div class="line">		watched.changeData(&quot;D&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>又被称为游标模式。这种模式提供一种方法访问一个容器对象中的各个元素，而又不需要暴露该对象的内部细节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public interface IIterator &#123;</div><div class="line">	public Object previous();</div><div class="line">	public Object next();</div><div class="line">	public boolean hasNext();</div><div class="line">	public Object first();</div><div class="line">&#125;</div><div class="line">// 持有一个迭代器对象的引用</div><div class="line">public interface Collection &#123;</div><div class="line">	public IIterator iterator();</div><div class="line">	public Object get(int i);</div><div class="line">	public int size();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MyCollection implements Collection&#123;</div><div class="line">	public String[] string = null;</div><div class="line">	public MyCollection(String[] str)&#123;</div><div class="line">		string = str;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public IIterator iterator() &#123;</div><div class="line">		return new MyIterator(this);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Object get(int i) &#123;</div><div class="line">		return string[i];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public int size() &#123;</div><div class="line">		return string.length;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MyIterator implements IIterator&#123;</div><div class="line"></div><div class="line">	private Collection collection;</div><div class="line">	private int pos=-1;</div><div class="line"></div><div class="line">	public MyIterator(Collection collection)&#123;</div><div class="line">		this.collection = collection;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Object previous() &#123;</div><div class="line">		if(pos&gt;0)</div><div class="line">			pos--;</div><div class="line">		return collection.get(pos);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Object next() &#123;</div><div class="line">		if(pos&lt;collection.size()-1)</div><div class="line">			pos++;</div><div class="line">		return collection.get(pos);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public boolean hasNext() &#123;</div><div class="line">		if(pos&lt;collection.size()-1)</div><div class="line">			return true;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Object first() &#123;</div><div class="line">		pos=0;</div><div class="line">		return collection.get(pos);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String[] str = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;&#125;;</div><div class="line">		Collection myCollection = new MyCollection(str);</div><div class="line">		IIterator it = myCollection.iterator();</div><div class="line">		while(it.hasNext())&#123;</div><div class="line">			System.out.println(it.next());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// 责任链上各个对象执行的方法</div><div class="line">public interface Handler &#123;</div><div class="line">	public void operator();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class AbstractHandler &#123;</div><div class="line">	private Handler handler;</div><div class="line"></div><div class="line">	public Handler getHandler()&#123;</div><div class="line">		return handler;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setHandler(Handler handler)&#123;</div><div class="line">		this.handler = handler;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MyHandler extends AbstractHandler implements Handler&#123;</div><div class="line">	private String name;</div><div class="line"></div><div class="line">	public MyHandler(String name)&#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void operator() &#123;</div><div class="line">		System.out.println(name+&quot; deal!&quot;);</div><div class="line">		if(getHandler()!=null)&#123;</div><div class="line">			getHandler().operator();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 此处只能用具体类，不能用抽象类，因为后面需要设置实现了接口的对象为下一个handler</div><div class="line">		MyHandler h1 = new MyHandler(&quot;h1&quot;);</div><div class="line">		MyHandler h2 = new MyHandler(&quot;h2&quot;);</div><div class="line">		MyHandler h3 = new MyHandler(&quot;h3&quot;);</div><div class="line"></div><div class="line">		h1.setHandler(h2);</div><div class="line">		h2.setHandler(h3);</div><div class="line">		h1.operator();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>命令模式的目的就是达到命令的发出者和执行者之间解耦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public interface Command &#123;</div><div class="line">	public void execute();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class OpenCommand implements Command &#123;</div><div class="line">	private MainBoard mainBoard;</div><div class="line"></div><div class="line">	public OpenCommand(MainBoard mainBoard) &#123;</div><div class="line">		this.mainBoard = mainBoard;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void execute() &#123;</div><div class="line">		mainBoard.open();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface MainBoard &#123;</div><div class="line">	public void open();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class GigaMainBoard implements MainBoard &#123;</div><div class="line">	@Override</div><div class="line">	public void open() &#123;</div><div class="line">		System.out.println(&quot;华硕主板开机&quot;);</div><div class="line">		System.out.println(&quot;接通电源&quot;);</div><div class="line">		System.out.println(&quot;正常运转&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Box &#123;</div><div class="line">	private Command openCommand;</div><div class="line"></div><div class="line">	public void setOpenCommand(Command command) &#123;</div><div class="line">		this.openCommand = command;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void openButtonPressed() &#123;</div><div class="line">		openCommand.execute();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		MainBoard mainBoard = new GigaMainBoard();</div><div class="line">		Command openCommand = new OpenCommand(mainBoard);</div><div class="line">		Box box = new Box();</div><div class="line">		box.setOpenCommand(openCommand);</div><div class="line">		box.openButtonPressed();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public abstract class Order &#123;</div><div class="line">	public abstract void sell();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class FlavorOrder extends Order&#123;</div><div class="line">	public String flavor;</div><div class="line">	public FlavorOrder(String flavor) &#123;</div><div class="line">		this.flavor = flavor;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void sell() &#123;</div><div class="line">		System.out.println(&quot;卖出&quot;+flavor+&quot;一份&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 枚举写出的单例，利用HashMap来实现享元模式</div><div class="line">public enum FlavorFactory &#123;</div><div class="line">	instance;</div><div class="line">	private Map&lt;String,Order&gt; flavorPool = new HashMap&lt;String,Order&gt;();</div><div class="line">	public Order getOrder(String flavor)&#123;</div><div class="line">		Order order = null;</div><div class="line">		if(flavorPool.containsKey(flavor))&#123;</div><div class="line">			order = flavorPool.get(flavor);</div><div class="line">		&#125;else&#123;</div><div class="line">			order = new FlavorOrder(flavor);</div><div class="line">			flavorPool.put(flavor, order);</div><div class="line">		&#125;</div><div class="line">		return order;</div><div class="line">	&#125;</div><div class="line">	public int getTotalSize()&#123;</div><div class="line">		return flavorPool.size();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	static ArrayList&lt;Order&gt; orders = new ArrayList&lt;Order&gt;();</div><div class="line">	public static void addOrder(String flavor) &#123;</div><div class="line">		orders.add(FlavorFactory.instance.getOrder(flavor));</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		FlavorFactory factory = FlavorFactory.instance;</div><div class="line">		addOrder(&quot;one&quot;);</div><div class="line">		addOrder(&quot;two&quot;);</div><div class="line">		addOrder(&quot;three&quot;);</div><div class="line">		addOrder(&quot;three&quot;);</div><div class="line">		addOrder(&quot;three&quot;);</div><div class="line">		addOrder(&quot;one&quot;);</div><div class="line">		addOrder(&quot;two&quot;);</div><div class="line">		addOrder(&quot;three&quot;);</div><div class="line">		addOrder(&quot;two&quot;);</div><div class="line">		addOrder(&quot;two&quot;);</div><div class="line">		for (Order order : orders) &#123;</div><div class="line">			order.sell();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;一共&quot; + orders.size());</div><div class="line">		System.out.println(&quot;生成&quot; + factory.instance.getTotalSize() + &quot;个对象&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。<br>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式一]]></title>
      <url>https://fudawei.github.io/2016/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80/</url>
      <content type="html"><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>应用：使用单例模式去读取配置文件。如果在系统运行过程中有很多都需要使用配置文件的内容，也就是说很多地方都需要创建AppConfig对象的实例，这样每一个AppConfig实例对象里面都封装着配置文件的内容，系统中会同时存在多份配置文件的内容，浪费内存资源。此时应该使用单例，系统中保存一份对象。</p>
<h5 id="单例模式特点"><a href="#单例模式特点" class="headerlink" title="单例模式特点"></a>单例模式特点</h5><p>1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。<br>2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。<br>3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private static class SingletonFactory&#123;</div><div class="line">	private static Singleton instance = new Singleton();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static Singleton getInstance()&#123;</div><div class="line">	return SingletonFactory.instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class SingletonReadConfig &#123;</div><div class="line">	private static SingletonReadConfig instance = null;</div><div class="line">	private SingletonReadConfig()&#123;&#125;</div><div class="line">	public static SingletonReadConfig getInstance()&#123;</div><div class="line">		if(instance == null)&#123;</div><div class="line">			synchronized (SingletonReadConfig.class) &#123;</div><div class="line">				if(instance == null)&#123;</div><div class="line">					instance = new SingletonReadConfig();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">	public void readConfig()&#123;</div><div class="line">		Properties p = new Properties();</div><div class="line">		try &#123;</div><div class="line">			p.load(new InputStreamReader(SingletonReadConfig.class.getResourceAsStream(&quot;test.properties&quot;), &quot;utf8&quot;));</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		String newUrlkey = &quot;xxxx.db.url&quot;;</div><div class="line">		String newUserkey = &quot;xxxx.db.username&quot;;</div><div class="line">		String newPasswordkey = &quot;xxxx.db.password&quot;;</div><div class="line"></div><div class="line">		String url = p.getProperty(newUrlkey);</div><div class="line">		String user = p.getProperty(newUserkey);</div><div class="line">		String password = p.getProperty(newPasswordkey);</div><div class="line">		System.out.println(url+&quot;\t&quot;+user+&quot;\t&quot;+password+&quot;\t&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>静态内部类实现单例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class SingletonReadConfig &#123;</div><div class="line">	static  class SingletonHolder&#123;</div><div class="line">		private static SingletonReadConfig instance = new SingletonReadConfig();</div><div class="line">	&#125;</div><div class="line">	private SingletonReadConfig()&#123;&#125;</div><div class="line"></div><div class="line">	public static SingletonReadConfig getInstance()&#123;</div><div class="line">		return SingletonHolder.instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当getInstance第一次被调用时，第一次读取 SingletonHolder.instance,导致SingletonHolder类得到初始化，这个类在初始化的时候，会初始化它的静态域，从而创建SingletonReadConfig的实例，静态域只会在虚拟机装在类的时候初始化一次，并由虚拟机来保证它的线程安全性。</p>
<p>枚举类实现单例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public enum SingletonReadConfig &#123;</div><div class="line">	instance;</div><div class="line">	public void readConfig()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>单例模式优点：<ol>
<li>在内存中只有一个实例，减少了内存消耗，特别是一个对象如果要频繁的被创建、销毁时，单例优势明显</li>
<li>当一个兑现共产生需要较多资源，读取配置、产生其他依赖对象时</li>
<li>避免对资源的多重占用，如一个写文件动作，由于只有一个实例存在内存，避免了对同一个资源文件的同时写操作</li>
<li>可以在系统设置全局的访问点，优化共享资源的访问，比如可以设计一个单例类，负责所有数据表的映射处理。</li>
</ol>
</li>
<li>单例模式缺点：<ol>
<li>扩展困难，若要扩展，只能修改源码，与单一职责冲突</li>
</ol>
</li>
<li>使用场景<ol>
<li>要求生成唯一序列号的环境</li>
<li>在整个项目中需要有访问一个共享访问点或共享数据，例如web页面上的计数器，可以不用每次刷新都记录到数据库中，使用单例保持计数器的值</li>
<li>创建一个对象需要消耗的资源过多，如要访问I/O，访问数据库等资源</li>
<li>需要定义大量的静态常量和静态方法。当然，也可以直接声明为static方式。</li>
</ol>
</li>
<li>单例适用场景<br>控制资源的使用，通过线程同步来控制资源的并发访问<br>控制实例的产生，以达到节约资源的目的<br>控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li>
</ul>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>指挥者类中可以注入一个抽象建造者类型的对象，核心在与提供一个建造方法，该方法调用了builder对象构造部件的方法，最后返回一个产品对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">// 要生产的产品</div><div class="line">public class Car &#123;</div><div class="line">	private String head;</div><div class="line">	private String body;</div><div class="line">	private String tail;</div><div class="line">&#125;</div><div class="line">// 抽象的建造者</div><div class="line">public abstract class CarBuilder &#123;</div><div class="line">	public abstract void makeHead();</div><div class="line">	public abstract void makeBody();</div><div class="line">	public abstract void makeTail();</div><div class="line">	public abstract Car getCar();</div><div class="line">&#125;</div><div class="line">// 具体建造者</div><div class="line">public class JeepBuilder extends CarBuilder &#123;</div><div class="line">	Car car = new Car();</div><div class="line">	@Override</div><div class="line">	public void makeHead() &#123;</div><div class="line">		car.setHead(&quot;head&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void makeBody() &#123;</div><div class="line">		car.setBody(&quot;body&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void makeTail() &#123;</div><div class="line">		car.setTail(&quot;tail&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public Car getCar() &#123;</div><div class="line">		return car;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 指挥类</div><div class="line">public class CarDirector &#123;</div><div class="line">	public void makeCar(CarBuilder builder)&#123;</div><div class="line">		builder.makeHead();</div><div class="line">		builder.makeBody();</div><div class="line">		builder.makeTail();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 测试</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">		CarDirector director = new CarDirector();</div><div class="line">		CarBuilder jeepBuilder = new JeepBuilder();</div><div class="line">		director.makeCar(jeepBuilder);</div><div class="line">		Car car = jeepBuilder.getCar();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>建造者模式与工厂模式的区别：工厂模式只关心你要的是什么，不关心这个东西的具体细节是什么。而建造者关心的是这个东西的具体细节的创建。<br>note:若要返回调用链式的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public RaceBuilder setSkin(String skinColor)&#123;</div><div class="line">	this.skinColor = skinColor;</div><div class="line">	return this; // 返回一个可以继续操作的该类对象</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>建造者模式的优点</p>
<ol>
<li>封装性，客户端不必知道产品内部组成的细节，不需要关心模型内部是如何实现的</li>
<li>建造者独立，容易扩展</li>
<li>便于控制细节和风险，建造者独立，因此可以对建造过程进行细化，而不对其他的模块产生任何影响</li>
</ol>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式能够将一个原型对象传给那个要发动创建的兑对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。<br>能够实现拷贝的java类必须实现一个标志接口 Cloneable，表示java类支持被复制。<br>java中的clone方法满足下列关系：</p>
<ol>
<li>对于任何对象，都有x.clone()!=x</li>
<li>对于任何对象，都有x.clone.getClass()==x.getClass(),即拷贝对象与原型对象的类型一样</li>
<li>如果对x的equals方法定义恰当，x.clone.equals(x)应该成立。</li>
</ol>
<p>为了获取一份对象的拷贝，可以直接利用Object类的clone方法</p>
<ol>
<li>在派生类中覆盖基类的clone()方法，并声明为public</li>
<li>在派生类的clone()方法中，调用super.clone()</li>
<li>派生类需要实现Cloneable接口<ul>
<li>深拷贝与浅拷贝<br>浅拷贝是指背靠背对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。<br>深拷贝是指拷贝对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量，那些引用其他对象的变量将指向被拷贝的新对象，而不再是原有的那些被引用的对象。深拷贝把重复的对象所引用的对象都拷贝了一遍。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Thing implements Cloneable&#123;</div><div class="line">	private ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">	public Thing clone()&#123;</div><div class="line">		Thing thing = null;</div><div class="line">		try &#123;</div><div class="line">			thing = (Thing) super.clone();</div><div class="line">			// 加上这一句为深拷贝，复制链表</div><div class="line">			thing.list = (ArrayList&lt;String&gt;) this.list.clone();</div><div class="line">		&#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		return thing;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>Object类的clone方法的原理是从内存中（具体的说是堆内存）以二进制流的方式进行拷贝，重新分配一个内存块，所以构造函数没有被执行<br>深拷贝的实现： 可以通过序列化等方式来实现深拷贝。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而源对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制器引用的成员对象，因此通过序列化将对象写到流中，再从流里将其读出来，可以实现深拷贝。<br>注意：能够实现序列化的对象必须实现Serializable接口，否则无法进行序列化操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public YueLog deepClone() throws IOException, ClassNotFoundException&#123;</div><div class="line">		ByteArrayOutputStream bao = new ByteArrayOutputStream();</div><div class="line">		ObjectOutputStream oos = new ObjectOutputStream(bao);</div><div class="line">		oos.writeObject(this);</div><div class="line">		ByteArrayInputStream bis = new ByteArrayInputStream(bao.toByteArray());</div><div class="line">		ObjectInputStream ois = new ObjectInputStream(bis);</div><div class="line">		return (YueLog) ois.readObject();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>原型模式的优点</p>
<ol>
<li>性能优良，原型模式是内存二进制流的拷贝，要比直接new一个对象性能好得多，特别是要在一个循环体内产生大量的对象时，原型模式性能更好</li>
<li>避免构造函数约束。直接在内存中拷贝，构造函数不会被执行。<ul>
<li>使用场景</li>
</ul>
</li>
<li>资源优化场景，类初始化需要消耗非常多的资源，包括数据、硬件资源等。</li>
<li>性能和安全要求的场景<br>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</li>
<li>一个对象多个修改者的场景<br>各个调用者可能都需要修改其值时考虑使用原型模式拷贝多个对象供调用者使用。</li>
</ol>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器的角色用于u扩展源角色，实现目标角色</p>
<ul>
<li><p>类的适配器模式，采用继承实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Adaptee &#123;</div><div class="line">	public int get220V()&#123;</div><div class="line">		return 220;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface Target &#123;</div><div class="line">	int get110V();</div><div class="line">	int get220V();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Adapter extends Adaptee implements Target&#123;</div><div class="line">	@Override</div><div class="line">	public int get110V() &#123;</div><div class="line">		return 110;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Client().test();</div><div class="line">	&#125;</div><div class="line">	public void test()&#123;</div><div class="line">		Target target = new Adapter();</div><div class="line">		int v1 = target.get110V();</div><div class="line">		int v2 = target.get220V();</div><div class="line">		System.out.println(&quot;v1=&quot;+v1+&quot;,v2=&quot;+v2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对象适配器，采用对象组合方式<br>把“源”作为一个对象聚合到适配器类中,把“源”作为一个构造参数传入适配器，执行接口所要求的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Adapter implements Job&#123;</div><div class="line">	Person person;</div><div class="line">	public Adapter(Person person)&#123;</div><div class="line">		this.person = person;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void speekJapanese() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		person.speekJapanese();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void speekEnglish() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		person.speekEnglish();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void speekFrench() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		System.out.println(&quot;person French&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>默认适配器模式<br>当我们想实现一个接口，但又不想实现所有接口方法，而只想去实现一部分方法时，就使用默认的适配器模式。它的方式是在接口和具体实现类中添加一个抽象类，而用抽象类去实现目标接口的所有方法，而具体的类只需要覆盖其需要完成的方法即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public interface Job&#123;</div><div class="line">	public abstract void speekJapanese();</div><div class="line">	public abstract void speekEnglish();</div><div class="line">	public abstract void speekFrench();</div><div class="line">	public abstract void speekChinese();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class JobDefault implements Job&#123;</div><div class="line">	public void speekChinese()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public void speekEnglish()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public void speekFrench()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public void speekJapanese()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class JobImpl extends JobDefault&#123;</div><div class="line">	public void speekChinese()&#123;</div><div class="line">		System.out.println(&quot;I can speek Chinese&quot;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>各个设计模式之间的关系总览<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-29/69394885.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大数据相关]]></title>
      <url>https://fudawei.github.io/2016/04/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h3 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h3><p>对于时间问题，可以采用巧妙的算法搭配合适的数据结构（如布隆  ，使同一个元素只出现在单独的一台电脑中，然后按照1)求解</p>
<h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map/Reduce"></a>Map/Reduce</h3><p>MapReduce借鉴了函数式程序设计语言的思想，通过Map函数将数据映射到不同的区块，分配给计算机集群处理，以达到分布式计算的效果，再通过Reduce函数的程序将结果汇总，从而输出需要的结果。软件实现是指定一个Map函数，把键值对映射成新的键值对，形成一系列中间结果构成的键值对，然后把他们传给Reduce函数，把具有相同中间形式的键值对合并在一起。Map函数和Reduce函数具有一定的关联性。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>实际上是一个很长的二进制向量和一系列随机映射函数。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率<br>就是使用多个 Hash，如果它们有一个说元素不在集合中，那肯定就不在。如果它们都说在，虽然也有一定可能性它们在说谎，不过直觉上判断这种事情的概率是比较低的。<br>优点：相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数。另外, Hash 函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。<br><strong> Bloom Filter 用例 </strong><br>Google 著名的分布式数据库 Bigtable 使用了布隆过滤器来查找不存在的行或列，以减少磁盘查找的IO次数<br>Squid 网页代理缓存服务器在 cache digests 中使用了也布隆过滤器<br>Venti 文档存储系统也采用布隆过滤器来检测先前存储的数据<br>SPIN 模型检测器也使用布隆过滤器在大规模验证问题时跟踪可达状态空间<br>Google Chrome浏览器使用了布隆过滤器加速安全浏览服<br><strong> 布隆过滤器的典型使用 </strong><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-19/56196771.jpg" alt="布隆过滤器"></p>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>Trie树的核心思想是以空间换时间，利用字符串的公共前缀来降低查询时间的开销，以达到提高效率的目的。</p>
<ol>
<li>根节点不包含字符，除根节点以外每一个节点都只包含一个字符</li>
<li>从根节点到某一节点的路径上经过的字符连接起来，即为该节点对应的字符串<br>3.每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>InnoDB存储引擎的B树索引使用的存储结构就是B+树。B+树在B树的基础上做了改造，在每一个叶节点上除了存放索引键的相关信息外，还存储了指向与该叶节点相邻的后一个叶节点的指针，可以加快检索多个相邻叶节点的效率。</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>正向索引是文档指向了它包含的那些单词；反向索引则是单词指向了包含它的文档。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[排序算法的稳定性]]></title>
      <url>https://fudawei.github.io/2016/04/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>稳定排序和不稳定排序</p>
<blockquote>
<p>这几天笔试了好几次了，连续碰到一个关于常见排序算法稳定性判别的问题，往往还是多选，对于我以及和我一样拿不准的同学可不是一个能轻易下结论的题目，当然如果你笔试之前已经记住了数据结构书上哪些是稳定的，哪些不是稳定的，做起来应该可以轻松搞定。本文是针对老是记不住这个或者想真正明白到底为什么是稳定或者不稳定的人准备的。<br>首先，排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。<br>其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，对基于比较的排序算法而言，元素交换的次数可能会少一些（个人感觉，没有证实）。</p>
</blockquote>
<p>回到主题，现在分析一下常见的排序算法的稳定性，每个都给出简单的理由。</p>
<p>(1)冒泡排序</p>
<p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p>
<p>(2)选择排序</p>
<p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<p>(3)插入排序<br>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<p>(4)快速排序<br>快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j，交换a[i]和a[j],重复上面的过程，直到i &gt; j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p>
<p>(5)归并排序<br>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p>
<p>(6)基数排序<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。</p>
<p>(7)希尔排序(shell)<br>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
<p>(8)堆排序<br>我们知道堆的结构是节点i的孩子为2 <em> i和2 </em> i + 1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， … 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p>
<p>综上，得出结论: 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法<br>PS: 快[快速排序]些[希尔排序]选[选择排序]一堆[堆排序]不稳定排序</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[六大原则]]></title>
      <url>https://fudawei.github.io/2016/04/16/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>高内聚，低耦合。每一个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个。将不同的职责分别进行封装，不要将其组合在一个勒种，要使这个类只有一个可能会以前它变化的原因。</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>在里氏替换原则中，所有引用基类的地方必须能够透明的使用其子类对象，也就是说只要父类出现的地方，子类就能出现，而且替换为子类不会产生任何错误或异常。但是反过来，子类出现的地方，替换为父类就可能出现问题了。<br>四层含义：</p>
<ol>
<li>子类必须完全实现父类的方法</li>
<li>子类可以有自己的特性</li>
<li>覆盖或者实现父类的方法时输入参数可以被放大</li>
<li>覆写或者实现父类的方法时输出结果可以被缩小<h3 id="依赖注入原则"><a href="#依赖注入原则" class="headerlink" title="依赖注入原则"></a>依赖注入原则</h3>要依赖于抽象，不要依赖于具体的实现（依赖反转原则）<br>三点说明：</li>
<li>高层模块不应该依赖底层模块，两者都应该依赖于抽象（抽象类或接口）</li>
<li>抽象（抽象类或接口）不应该依赖于细节（具体实现类）</li>
<li>细节（具体实现类）应该依赖抽象<br>依赖注入原则用如下三种方式来实现：</li>
<li>通过构造函数传递依赖对象</li>
<li>通过setter方法传递依赖对象</li>
<li>接口声明实现依赖对象<h3 id="接口分离原则"><a href="#接口分离原则" class="headerlink" title="接口分离原则"></a>接口分离原则</h3>不应该强迫客户端程序依赖他们不需要使用的方法，一个接口不需要提供太多的方法，应该只提供一种对外的功能</li>
<li>接口尽量小，保证一个接口只服务于一个子模块或业务逻辑</li>
<li>接口高内聚：接口高内聚是对内高度依赖，对外尽可能隔离。<h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3>降低各个对象之间的耦合，提高系统的可维护性，在模块之间，应该只通过接口来通信，不用理会模块的内部工作原理，降低耦合度，促进复用。<h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4>一个对象对扩展开放，对修改关闭。<br>一旦写出了可以运行的代码，就不应该去改变它，而是要保证它能一直运行下去，如何保证这一点？ 这就需要借助抽象和多态，把科恩给你变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现层则是可以改变和扩展的。<br>eg:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public interface IFindGirl &#123;</div><div class="line">	public int getAge();</div><div class="line">	public String getName();</div><div class="line">	public String getFace();</div><div class="line">	public String getFigure();</div><div class="line">&#125;</div><div class="line">public class FindGirl implements IFindGirl&#123;</div><div class="line"></div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	private String face;</div><div class="line">	private String figure;</div><div class="line">	public FindGirl(String name,int age,String face,String figure)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">		this.face = face;</div><div class="line">		this.figure = figure;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String getFace() &#123;</div><div class="line">		return face;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String getFigure() &#123;</div><div class="line">		return figure;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong> 现在想要增加一个country的属性 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">接口继承接口</div><div class="line">public interface IForeignGirl extends IFindGirl&#123;</div><div class="line">	public String getCountry();</div><div class="line">&#125;</div><div class="line">public class ForeignGirl implements IForeignGirl &#123;</div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	private String face;</div><div class="line">	private String figure;</div><div class="line">	private String country;</div><div class="line">	public ForeignGirl(String name,int age,String face,String figure,String country)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">		this.face = face;</div><div class="line">		this.figure = figure;</div><div class="line">		this.country = country;</div><div class="line">	&#125;</div><div class="line">	get...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>抽象类可以有构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class AMan &#123;</div><div class="line">	protected IPrettyGirl prettyGirl;</div><div class="line">	public AMan(IPrettyGirl prettyGirl)&#123;</div><div class="line">		this.prettyGirl = prettyGirl;</div><div class="line">	&#125;</div><div class="line">	public abstract void findGirl();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JDK并发工具类]]></title>
      <url>https://fudawei.github.io/2016/04/12/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h3 id="Fork-Join-框架测试"><a href="#Fork-Join-框架测试" class="headerlink" title="Fork/Join 框架测试"></a>Fork/Join 框架测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.ExecutionException;</div><div class="line">import java.util.concurrent.ForkJoinPool;</div><div class="line">import java.util.concurrent.ForkJoinTask;</div><div class="line">import java.util.concurrent.RecursiveTask;</div><div class="line">/**</div><div class="line"> * Fork/Join框架测试</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class ForkTest extends RecursiveTask&lt;Integer&gt;&#123;</div><div class="line">	public static int THRESHOLD = 2;</div><div class="line">	public int start;</div><div class="line">	public int end;</div><div class="line">	public ForkTest(int start,int end)&#123;</div><div class="line">		this.start = start;</div><div class="line">		this.end = end;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	protected Integer compute() &#123;</div><div class="line">		int sum = 0;</div><div class="line">		if(end-start &lt;= THRESHOLD)&#123;</div><div class="line">			for(int i=start;i&lt;=end;i++)&#123;</div><div class="line">				sum +=i;</div><div class="line">			&#125;</div><div class="line">		&#125;else&#123;</div><div class="line">			int middle = (start+end)/2;</div><div class="line">			ForkTest leftTask = new ForkTest(start, middle);</div><div class="line">			ForkTest rightTask = new ForkTest(middle+1,end);</div><div class="line">			leftTask.fork();</div><div class="line">			rightTask.fork();</div><div class="line">			int leftResult = leftTask.join();</div><div class="line">			int rightResult = rightTask.join();</div><div class="line">			sum = leftResult + rightResult;</div><div class="line">		&#125;</div><div class="line">		return sum;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		ForkJoinPool forkJoinPool = new ForkJoinPool();</div><div class="line">		ForkTest task = new ForkTest(1, 100);</div><div class="line">		ForkJoinTask&lt;Integer&gt; result = forkJoinPool.submit(task);</div><div class="line">		try &#123;</div><div class="line">			System.out.println(result.get());</div><div class="line">		&#125; catch (InterruptedException | ExecutionException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CountDownLatch-使用"><a href="#CountDownLatch-使用" class="headerlink" title="CountDownLatch 使用"></a>CountDownLatch 使用</h3><h4 id="不使用-CountDownLatch实现"><a href="#不使用-CountDownLatch实现" class="headerlink" title="不使用 CountDownLatch实现"></a>不使用 CountDownLatch实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class CDTest &#123;</div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		Thread t1 = new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				System.out.println(&quot;parse 1 finished!&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		Thread t2 = new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				System.out.println(&quot;parse 2 finished!&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">		// join用于让当前线程等待join线程执行结束</div><div class="line">		t1.join();</div><div class="line">		t2.join();</div><div class="line">		System.out.println(&quot;all parse finished!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-CountDownLatch实现"><a href="#使用-CountDownLatch实现" class="headerlink" title="使用 CountDownLatch实现"></a>使用 CountDownLatch实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class CountDownTest &#123;</div><div class="line">	static CountDownLatch c = new CountDownLatch(2);</div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		Thread t1 = new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				System.out.println(&quot;parse 1 finished!&quot;);</div><div class="line">				c.countDown();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		Thread t2 = new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				System.out.println(&quot;parse 2 finished!&quot;);</div><div class="line">				c.countDown();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">		// await方法会阻塞当前线程，直到N变为0.</div><div class="line">		// countDown可以用在任何地方，可以是N个线程，也可以是1个线程里的N个执行步骤。</div><div class="line">		c.await();  // 也可以指定等待时间  --- await(long time,TimeUnit unit)</div><div class="line">		System.out.println(&quot;finished!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CyclicBarrier-使用"><a href="#CyclicBarrier-使用" class="headerlink" title="CyclicBarrier 使用"></a>CyclicBarrier 使用</h3><h4 id="CyclicBarrierTest1"><a href="#CyclicBarrierTest1" class="headerlink" title="CyclicBarrierTest1"></a>CyclicBarrierTest1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class CYclicBarrierTest_1 &#123;</div><div class="line">	/*</div><div class="line">	 *  屏障拦截的线程数量，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行</div><div class="line">	 *</div><div class="line">	 */</div><div class="line">	static CyclicBarrier c = new CyclicBarrier(2);</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125; catch (BrokenBarrierException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(1);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">			c.await();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">		&#125;</div><div class="line">		System.out.println(2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="CyclicBarrierTest2"><a href="#CyclicBarrierTest2" class="headerlink" title="CyclicBarrierTest2"></a>CyclicBarrierTest2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.BrokenBarrierException;</div><div class="line">import java.util.concurrent.CyclicBarrier;</div><div class="line">/**</div><div class="line"> * CyclicBarrier还提供了一个更高级的构造函数CyclicBarrier(int parties,Runnable barrier-Action)</div><div class="line"> * 用于在线程到达屏障时，优先执行barrierAction,，方便处理更复杂的业务场景</div><div class="line"> * eg: 先输出3，再输出1,2，或者2,1。</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class CyclicBarrierTest_2 &#123;</div><div class="line">	static CyclicBarrier c = new CyclicBarrier(2,new A());</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125; catch (BrokenBarrierException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(1);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">			c.await();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">		&#125;</div><div class="line">		System.out.println(2);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class A implements Runnable&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println(3);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="CyclicBarrierTest3"><a href="#CyclicBarrierTest3" class="headerlink" title="CyclicBarrierTest3"></a>CyclicBarrierTest3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest_3 &#123;</div><div class="line">	static CyclicBarrier c =new CyclicBarrier(2);</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		Thread t = new Thread(new Runnable() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		t.start();</div><div class="line">		t.interrupt();</div><div class="line">		try &#123;</div><div class="line">			c.await();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			// 此时发生BrokenBarrierException 异常执行该代码</div><div class="line">			System.out.println(&quot;Exception&quot;+c.isBroken());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="CyclicBarrier的应用场景"><a href="#CyclicBarrier的应用场景" class="headerlink" title="CyclicBarrier的应用场景"></a>CyclicBarrier的应用场景</h4><p>例如用一个Excel保存了用户所有银行流水，每一个sheet保存一个账号近一年的银行流水，现在需要统计用户的日均银行流水。先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">import java.util.Map.Entry;</div><div class="line">import java.util.concurrent.ConcurrentHashMap;</div><div class="line">import java.util.concurrent.CyclicBarrier;</div><div class="line">import java.util.concurrent.Executor;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line">/**</div><div class="line"> * 使用线程池创建4个线程，分别计算每个sheet里面的数据，每个sheet计算结果是1，</div><div class="line"> * 再由BankWaterService汇总4个sheet计算出的结果</div><div class="line"> */</div><div class="line">public class BankWaterService implements Runnable &#123;</div><div class="line">	private CyclicBarrier c = new CyclicBarrier(4, this);</div><div class="line">	private Executor executor = Executors.newFixedThreadPool(4);</div><div class="line">	private ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;String, Integer&gt;();</div><div class="line">	private void count()&#123;</div><div class="line">		for(int i=0;i&lt;4;i++)&#123;</div><div class="line">			executor.execute(new Runnable() &#123;</div><div class="line">				@Override</div><div class="line">				public void run() &#123;</div><div class="line">					sheetBankWaterCount.put(Thread.currentThread().getName(), 1);</div><div class="line">					try &#123;</div><div class="line">						c.await();</div><div class="line">					&#125; catch (Exception e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		int result = 0;</div><div class="line">		for(Entry&lt;String,Integer&gt; sheet:sheetBankWaterCount.entrySet())&#123;</div><div class="line">			result += sheet.getValue();</div><div class="line">		&#125;</div><div class="line">		sheetBankWaterCount.put(&quot;result&quot;, result);</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		BankWaterService bankWaterService = new BankWaterService();</div><div class="line">		bankWaterService.count();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h4><ul>
<li>CountDownLatch 的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset方法重置，所以CyclicBarrier可以处理更为复杂的业务场景，例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</li>
<li>CyclicBarrier 还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest_3 &#123;</div><div class="line">	static CyclicBarrier c =new CyclicBarrier(2);</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		Thread t = new Thread(new Runnable() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		t.start();</div><div class="line">		t.interrupt();</div><div class="line">		try &#123;</div><div class="line">			c.await();</div><div class="line">			System.out.println(c.isBroken());</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			System.out.println(&quot;Exception&quot;+c.isBroken());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Semaphore-用法"><a href="#Semaphore-用法" class="headerlink" title="Semaphore 用法"></a>Semaphore 用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class SemaphoreTest &#123;</div><div class="line">	private static final int THREAD_COUNT = 30;</div><div class="line">	static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</div><div class="line">	private static Semaphore s = new Semaphore(10);</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		for(int i=0;i&lt;THREAD_COUNT;i++)&#123;</div><div class="line">			threadPool.execute(new Runnable() &#123;</div><div class="line">				@Override</div><div class="line">				public void run() &#123;</div><div class="line">					try &#123;</div><div class="line">						s.acquire();</div><div class="line">						Thread.sleep(1000);</div><div class="line">						System.out.println(Thread.currentThread().getName()+&quot; Save Data&quot;);</div><div class="line">						s.release();</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">		threadPool.shutdown();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Semaphore 还有一些其他方法：</p>
<ul>
<li>public int availablePermits() 返回此信号量中当前可用的许可数</li>
<li>public final int getQueueLength()  返回正在等待获取许可证的线程数</li>
<li>public final boolean hasQueuedThreads() 是否有线程正在等待获取许可证</li>
<li>protected Collection<thread> getQueuedThreads()  返回所有等待获取许可证的线程集合，是个protected方法</thread></li>
</ul>
<h3 id="线程间交换数据的Exchanger"><a href="#线程间交换数据的Exchanger" class="headerlink" title="线程间交换数据的Exchanger"></a>线程间交换数据的Exchanger</h3><p>一个用于线程间协作的工具类。它提供一个同步点，在这个同步点，两个线程更可以交换彼此的数据。这两个线程通过exchanger方法交换数据。如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法。当两个线程都到达同步点时，这两个线程就可以交换数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class ExchangerTest &#123;</div><div class="line">	static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;();</div><div class="line">	static ExecutorService threadPool = Executors.newFixedThreadPool(2);</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		threadPool.execute(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				try &#123;</div><div class="line">					String A = &quot;银行流水A&quot;;</div><div class="line">					String newA = exgr.exchange(A);</div><div class="line">					System.out.println(&quot;newA &quot;+newA);</div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		threadPool.execute(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				try &#123;</div><div class="line">					String B = &quot;银行流水B&quot;;</div><div class="line">					String newB = exgr.exchange(B);</div><div class="line">					System.out.println(&quot;newB &quot;+newB);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">输出:</div><div class="line">newB 银行流水A</div><div class="line">newA 银行流水B</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法-数组]]></title>
      <url>https://fudawei.github.io/2016/04/11/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h3 id="奇数全部放在偶数前面"><a href="#奇数全部放在偶数前面" class="headerlink" title="奇数全部放在偶数前面"></a>奇数全部放在偶数前面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 把数组中的奇数全部放到偶数之前</div><div class="line"> * 注意：面试官期待我们提供的不仅仅是解决一个问题的办法，而是解决一系列问题的通用办法</div><div class="line"> */</div><div class="line">public class OrderArray &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] arr = &#123;1,2,3,4,5,6,7,8,9&#125;;</div><div class="line">		orderModify(arr);</div><div class="line">		ArrayUtils.printArray(arr);</div><div class="line">	&#125;</div><div class="line">	private static void orderModify(int[] arr) &#123;</div><div class="line">		int i=0,j=arr.length-1;</div><div class="line">		while(i&lt;j)&#123;</div><div class="line">			while(i&lt;j &amp;&amp; !isEven(arr[i]))</div><div class="line">				i++;</div><div class="line">			while(i&lt;j &amp;&amp; isEven(arr[j]))</div><div class="line">				j--;</div><div class="line">			if(i &lt; j)&#123;</div><div class="line">				int temp = arr[i];</div><div class="line">				arr[i] = arr[j];</div><div class="line">				arr[j] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private static boolean isEven(int n)&#123;</div><div class="line">		return (n&amp;1)==0 ? true:false;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="行列均递增的二维数组查找指定值"><a href="#行列均递增的二维数组查找指定值" class="headerlink" title="行列均递增的二维数组查找指定值"></a>行列均递增的二维数组查找指定值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 行列都是递增的二维数组，根据给定的数判断是否在在二维数组中</div><div class="line"> * eg:</div><div class="line"> * 1 2 8  9</div><div class="line"> * 2 4 9  12</div><div class="line"> * 4 7 10 13</div><div class="line"> * 6 8 11 15</div><div class="line"> */</div><div class="line">public class FindMatrix &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[][] arr = &#123;</div><div class="line">			&#123;1,2,8,9&#125;,&#123;2,4,9,12&#125;,&#123;4,7,10,13&#125;,&#123;6,8,11,15&#125;</div><div class="line">		&#125;;</div><div class="line">		boolean flag = Find(arr,4,4,4);</div><div class="line">		System.out.println(flag);</div><div class="line">	&#125;</div><div class="line">	private static boolean Find(int[][] arr, int rows, int columns,int num) &#123;</div><div class="line">		boolean found = false;</div><div class="line">		int row=0,col=columns-1;</div><div class="line">		while(row&lt;rows &amp;&amp; col &gt; 0)&#123;</div><div class="line">			if(arr[row][col] == num)&#123;</div><div class="line">				found = true;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			else if(arr[row][col] &gt; num)</div><div class="line">				col--;</div><div class="line">			else</div><div class="line">				row++;</div><div class="line">		&#125;</div><div class="line">		return found;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="未排序正数数组中累加和为给定值的最长子数组长度"><a href="#未排序正数数组中累加和为给定值的最长子数组长度" class="headerlink" title="未排序正数数组中累加和为给定值的最长子数组长度"></a>未排序正数数组中累加和为给定值的最长子数组长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * eg : arr=[1,2,1,1,1]  k=3</div><div class="line"> * 返回最长子数组为[1,1,1]</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class LongestArr &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[] arr = &#123;1,2,1,1,1,1&#125;;</div><div class="line">		int k= 3;</div><div class="line">		int len = getLongestArr(arr,k);</div><div class="line">		System.out.println(len);</div><div class="line">	&#125;</div><div class="line">	private static int getLongestArr(int[] arr,int k) &#123;</div><div class="line">		int left = 0,right = 0,len = 0;</div><div class="line">		int sum=arr[0];</div><div class="line">		while(right &lt; arr.length)&#123;</div><div class="line">			if(sum==k)&#123;</div><div class="line">				System.out.println(&quot;right=&quot;+right+&quot; left=&quot;+left);</div><div class="line">				len = Math.max(len,right-left+1);</div><div class="line">				sum-=arr[left++];</div><div class="line">			&#125;else if(sum &lt; k)&#123;</div><div class="line">				right++;</div><div class="line">				if(right == arr.length)</div><div class="line">					break;</div><div class="line">				sum+=arr[right];</div><div class="line">			&#125;else&#123;</div><div class="line">				sum-=arr[left++];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return len;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最少需要排序的数组元素个数"><a href="#最少需要排序的数组元素个数" class="headerlink" title="最少需要排序的数组元素个数"></a>最少需要排序的数组元素个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 最少需要修改的数组元素个数</div><div class="line"> * eg: &#123;1,5,3,-1,4,2,6,7&#125; 需要修改6个</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class ZuiDuanZiShuZuLength &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[] arr =&#123;1,5,3,-1,4,2,6,7&#125;;</div><div class="line">		int result = getShorestLength(arr);</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int getShorestLength(int[] arr) &#123;</div><div class="line">		// maxIndex 从左往右找到最右侧小于左边最大值的位置</div><div class="line">		int maxIndex = -1;</div><div class="line">		//  minIndex 从右往左找到最左侧大于右边最小值的位置</div><div class="line">		int minIndex = arr.length-1;</div><div class="line">		int max = arr[0];</div><div class="line">		int min=arr[arr.length-1];</div><div class="line">		for(int i=1;i&lt;arr.length;i++)&#123;</div><div class="line">			if(arr[i] &lt; max)&#123;</div><div class="line">				maxIndex = i;</div><div class="line">			&#125;else&#123;</div><div class="line">				max = Math.max(max,arr[i]);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if(maxIndex==-1)</div><div class="line">			return 0;</div><div class="line">		for(int j=arr.length-2;j&gt;=0;j--)&#123;</div><div class="line">			if(arr[j] &gt; min)&#123;</div><div class="line">				minIndex = j;</div><div class="line">			&#125;else&#123;</div><div class="line">				min = Math.min(min, arr[j]);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if(minIndex==-1)</div><div class="line">			return 0;</div><div class="line">		return maxIndex-minIndex+1;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数组中最小的K个数"><a href="#数组中最小的K个数" class="headerlink" title="数组中最小的K个数"></a>数组中最小的K个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 最小的K个数</div><div class="line"> * 思路：建立个数为K的数组，构造大顶堆，然后维护这K个元素的大顶堆，</div><div class="line"> * 若数组后续值比大顶堆的第一个值小，则替换并重新调整大顶堆</div><div class="line"> */</div><div class="line">public class ZuiXiaoKShu &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] arr = &#123;7,8,0,2,2,-1,9,6,4,5,1,-2&#125;;</div><div class="line">		int k=4;</div><div class="line">		heapSort(arr);</div><div class="line">		int[] arrCopy = Arrays.copyOfRange(arr, 0, k);</div><div class="line">		heapSort(arrCopy);</div><div class="line">		for(int i=k;i&lt;arr.length;i++)&#123;</div><div class="line">			if(arr[i] &lt; arrCopy[0])&#123;</div><div class="line">				arrCopy[0] =arr[i];</div><div class="line">				heapSort(arrCopy);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ArrayUtils.printArray(arrCopy);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void heapSort(int[] arr) &#123;</div><div class="line">		if (arr == null || arr.length &lt;= 1) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">		buildMaxHeap(arr);</div><div class="line">		for(int i=arr.length-1;i&gt;=0;i--)&#123;</div><div class="line">			ArrayUtils.swap(arr, 0, i);</div><div class="line">			maxHeap(arr, i, 0);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void buildMaxHeap(int[] arr) &#123;</div><div class="line">		if (arr == null || arr.length &lt;= 1) &#123;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		int half = (arr.length-1)/2;</div><div class="line">		for(int i=half;i&gt;=0;i--)&#123;</div><div class="line">			maxHeap(arr,arr.length,i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void maxHeap(int[] arr, int length, int index) &#123;</div><div class="line">		 int left = 2*index+1;</div><div class="line">		 int right = 2*index+2;</div><div class="line">		 int largestIndex = index;</div><div class="line">		if(left &lt; length &amp;&amp; arr[left] &lt; arr[largestIndex])</div><div class="line">			largestIndex = left;</div><div class="line">		if(right &lt; length &amp;&amp; arr[right] &lt; arr[largestIndex])</div><div class="line">			largestIndex = right;</div><div class="line">		if(largestIndex!=index)&#123;</div><div class="line">			ArrayUtils.swap(arr, index, largestIndex);</div><div class="line">			maxHeap(arr, length, largestIndex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="求给定数字包含1的个数"><a href="#求给定数字包含1的个数" class="headerlink" title="求给定数字包含1的个数"></a>求给定数字包含1的个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 求给定数字包含1的个数</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class TestOne &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(CountOne(56));</div><div class="line">	&#125;</div><div class="line">	private static int CountOne(int n) &#123;</div><div class="line">		int count = 0;</div><div class="line">		while(n!=0)&#123;</div><div class="line">			//相当于抹去最右边的1</div><div class="line">			n &amp;= (n-1);</div><div class="line">			count++;</div><div class="line">		&#125;</div><div class="line">		return count;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="一个数出现了奇数次"><a href="#一个数出现了奇数次" class="headerlink" title="一个数出现了奇数次"></a>一个数出现了奇数次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 给定一个整型数组arr，其中只有一个数出现了奇数次，其他的数都出现了偶数次，求此数</div><div class="line"> * @author flyyc</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class TestOld &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 数组中出现一次的一个数</div><div class="line">		getFromEvenArray();</div><div class="line">	&#125;</div><div class="line">	private static void getFromEvenArray() &#123;</div><div class="line">		int[] array = &#123;3,3,6,2,4,6,4&#125;;</div><div class="line">		int e0=0;</div><div class="line">		for(int cur : array)&#123;</div><div class="line">			e0 ^= cur;</div><div class="line">		&#125;</div><div class="line">		System.out.println(e0);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="两个数出现了奇数次"><a href="#两个数出现了奇数次" class="headerlink" title="两个数出现了奇数次"></a>两个数出现了奇数次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 出现奇数次的数</div><div class="line"> * 给定一个整型数组arr，其中只有两个数出现了奇数次，其他的数都出现了偶数次，求此数</div><div class="line"> */</div><div class="line">public class TestOneTwo &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		//数组中只出现一次的两个数</div><div class="line">		getFromEvenArray2();</div><div class="line">	&#125;</div><div class="line">	private static void getFromEvenArray2() &#123;</div><div class="line">		char[] result;</div><div class="line">		int[] array = &#123;3,3,6,2,4,6,4,12&#125;;</div><div class="line">		int e0=0,e2=0;</div><div class="line">		for(int cur : array)&#123;</div><div class="line">			e0 ^= cur;</div><div class="line">		&#125;</div><div class="line">		// 求出最低位为1的位置</div><div class="line">		int pri = e0 &amp; (~e0+1);</div><div class="line">		for(int cur : array)&#123;</div><div class="line">			// 若第K位为1，则进行异或，这样可以确定异或结果中不受另一个出现一次的数的影响</div><div class="line">			if((cur &amp; pri)!=0)&#123;</div><div class="line">				e2 ^= cur;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(e2+&quot; &quot; + (e2 ^ e0));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="其他数出现K次"><a href="#其他数出现K次" class="headerlink" title="其他数出现K次"></a>其他数出现K次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 给定一个整型数组arr和一个大于1的整数k。已知arr中只有1个数出现了1次，其他的数都出现了k次，请返回只出现了1次的数。</div><div class="line"> * 时间复杂度为O(N),额外空间复杂度为O(1).</div><div class="line"> * 仿照无进位相加思想。即忽略进位的相加。</div><div class="line"> * eg: 两个7进制的a和b，在i位上无进位相加的结果就是(a[i]+b[i])%7。出现K次使用K进制相加为0,则最后数组中结果即为所求 。</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class KInOne &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] e0 = new int[32];</div><div class="line">		int[] arr = &#123;3,3,7,7,7,3,4,4,4,5,5,5,9,6,6,6&#125;;</div><div class="line">		int k = 3;</div><div class="line">		for(int i =0;i&lt;arr.length;i++)&#123;</div><div class="line">			// 对数组中每一个数进行无进位相加</div><div class="line">			setExclusive(e0,arr[i],k);</div><div class="line">		&#125;</div><div class="line">		int res = getNumFromKSysNum(e0,k);</div><div class="line">		System.out.println(res);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public  static void setExclusive(int[] e0, int n, int k) &#123;</div><div class="line">		int[] cur = getKNum(n,k);</div><div class="line">		for(int i=0 ; i&lt;cur.length;i++)&#123;</div><div class="line">			e0[i] = (e0[i] + cur[i])%k;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static int[] getKNum(int n, int k) &#123;</div><div class="line">		int[] res = new int[32];</div><div class="line">		int index = 0;</div><div class="line">		// 把n转化为K进制，此处转化结果与后面从数组中读取顺序要一致。</div><div class="line">		// 注意：此处是按从0开始保存余数。</div><div class="line">		while(n!=0)&#123;</div><div class="line">			res[index++] = n%k;</div><div class="line">			n = n/k;</div><div class="line">		&#125;</div><div class="line">		return res;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public  static int getNumFromKSysNum(int[] arr, int k) &#123;</div><div class="line">		int result = 0;</div><div class="line">		for(int i = 0;i &lt; arr.length;i++)&#123;</div><div class="line">			// 从结果数组中还原K进制数为十进制。因为上面保存的时候是从前往后保存，所以此处读取顺序一致</div><div class="line">			result+=arr[i]*Math.pow(k, i);</div><div class="line">		&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="奇偶数下标"><a href="#奇偶数下标" class="headerlink" title="奇偶数下标"></a>奇偶数下标</h3><p>调整次序使得所有偶数在偶数下标或者奇数在奇数下标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private static void adjust(int[] arr) &#123;</div><div class="line">		int evenIndex = 0;</div><div class="line">		int oddIndex = 1;</div><div class="line">		int high=arr.length-1;</div><div class="line">		while(evenIndex &lt; arr.length &amp;&amp; oddIndex &lt; arr.length)&#123;</div><div class="line">			if((arr[high]&amp;1)==0)&#123;</div><div class="line">				arr[evenIndex] = arr[high];</div><div class="line">				evenIndex+=2;</div><div class="line">			&#125;else&#123;</div><div class="line">				arr[oddIndex] = arr[high];</div><div class="line">				oddIndex++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 非递归二分搜索</div><div class="line">	private static int binarySearch(int[] arr,int key) &#123;</div><div class="line">		int left = 0;</div><div class="line">		int right = arr.length-1;</div><div class="line">		while(left &lt;= right)&#123;</div><div class="line">			int middle = (left+right)&gt;&gt;1;</div><div class="line">			if(arr[middle]==key)</div><div class="line">				return middle;</div><div class="line">			else if(arr[middle] &gt; key)</div><div class="line">				right=middle-1;</div><div class="line">			else</div><div class="line">				left=middle+1;</div><div class="line">		&#125;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	// 递归二分搜索</div><div class="line">	private static int recBinarySearch(int[] arr,int low,int high,int key)&#123;</div><div class="line">		if(low &lt;= high)&#123;</div><div class="line">			int middle = (low+high)/2;</div><div class="line">			if(key==arr[middle])&#123;</div><div class="line">				return middle;</div><div class="line">			&#125;else if(key&lt;arr[middle])&#123;</div><div class="line">				return recBinarySearch(arr, low, middle-1, key);</div><div class="line">			&#125;else&#123;</div><div class="line">				return recBinarySearch(arr, middle+1, high, key);</div><div class="line">			&#125;</div><div class="line">		&#125;else</div><div class="line">			return -1;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="从左上角沿着边缘线走到右下角"><a href="#从左上角沿着边缘线走到右下角" class="headerlink" title="从左上角沿着边缘线走到右下角"></a>从左上角沿着边缘线走到右下角</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class QiPan &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(numOfMethod(1,1));</div><div class="line">	&#125;</div><div class="line">	//从图中可以看出，要达到右下角的位置，必须先到达右下角的上边或者左边，可以归结为n-1行m列和n行m-1列的模型解决</div><div class="line">	private static int numOfMethod(int i, int j) &#123;</div><div class="line">		if(i&lt;=0 || j&lt;=0)</div><div class="line">			return 0;</div><div class="line">		else if(i==1)</div><div class="line">			return j+1;</div><div class="line">		else if(j==1)</div><div class="line">			return i+1;</div><div class="line">		else</div><div class="line">			return numOfMethod(i-1, j)+numOfMethod(i, j-1);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="苹果放法"><a href="#苹果放法" class="headerlink" title="苹果放法"></a>苹果放法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * M个相同的苹果放到N个相同的盘子里，允许为空，共有多少种不同的放法。</div><div class="line"> */</div><div class="line">public class PlaceApple &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int result = fun(7,3);</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int fun(int n, int m) &#123;</div><div class="line">		if(n&lt;0) return 0;</div><div class="line">		if(n==0||m==1) return 1;</div><div class="line">		return fun(n,m-1)+fun(n-m,m);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/** 模型： 最长递增子序列</div><div class="line"> * 1.计算最少出列多少位同学，使得剩下的同学排成合唱队形。</div><div class="line"> * 2.走梅花桩，从前到后，往高的桩子走，走的步数最多。</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class IncrementOrderTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] arr = &#123;186,186,150,200,160,130,197,200&#125;;</div><div class="line">		int[] dp = getDp(arr);</div><div class="line">		int max = 0;</div><div class="line">		for(int i=0;i&lt;dp.length;i++)&#123;</div><div class="line">			if(dp[i] &gt; max)</div><div class="line">				max = dp[i];</div><div class="line">		&#125;</div><div class="line">		System.out.println(max);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int[] getDp(int[] arr) &#123;</div><div class="line">		int[] dp = new int[arr.length];</div><div class="line">		for(int i=0;i&lt;arr.length;i++)&#123;</div><div class="line">			dp[i] = 1;</div><div class="line">			for(int j=0;j&lt;i;j++)&#123;</div><div class="line">				if(arr[j] &lt; arr[i])</div><div class="line">					dp[i] = Math.max(dp[i],dp[j]+1);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="未排序-最长子数组长度"><a href="#未排序-最长子数组长度" class="headerlink" title="未排序 最长子数组长度"></a>未排序 最长子数组长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 未排序正数数组中累加和为给定值的最长子数组长度</div><div class="line"> * eg : arr=[1,2,1,1,1]  k=3</div><div class="line"> * 返回最长子数组为[1,1,1]</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class LongestArr &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[] arr = &#123;1,2,1,1,1,1&#125;;</div><div class="line">		int k= 3;</div><div class="line">		int len = getLongestArr(arr,k);</div><div class="line">		System.out.println(len);</div><div class="line">	&#125;</div><div class="line">	private static int getLongestArr(int[] arr,int k) &#123;</div><div class="line">		int left = 0,right = 0,len = 0;</div><div class="line">		int sum=arr[0];</div><div class="line">		while(right &lt; arr.length)&#123;</div><div class="line">			if(sum==k)&#123;</div><div class="line">				System.out.println(&quot;right=&quot;+right+&quot; left=&quot;+left);</div><div class="line">				len = Math.max(len,right-left+1);</div><div class="line">				sum-=arr[left++];</div><div class="line">			&#125;else if(sum &lt; k)&#123;</div><div class="line">				right++;</div><div class="line">				if(right == arr.length)</div><div class="line">					break;</div><div class="line">				sum+=arr[right];</div><div class="line">			&#125;else&#123;</div><div class="line">				sum-=arr[left++];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return len;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法-树]]></title>
      <url>https://fudawei.github.io/2016/04/10/%E7%AE%97%E6%B3%95-%E6%A0%91/</url>
      <content type="html"><![CDATA[<h3 id="创建二叉排序树"><a href="#创建二叉排序树" class="headerlink" title="创建二叉排序树"></a>创建二叉排序树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private static void createBinaryTree(TreeNode head ,int value) &#123;</div><div class="line">		if(head==null)</div><div class="line">			return;</div><div class="line">		TreeNode currentNode = head;</div><div class="line">		while(true)&#123;</div><div class="line">			if(value &lt; currentNode.value)&#123;</div><div class="line">				if(currentNode.left == null)&#123;</div><div class="line">					currentNode.left = new TreeNode(value);</div><div class="line">					return;</div><div class="line">				&#125;else</div><div class="line">					currentNode = currentNode.left;</div><div class="line">			&#125;else&#123;</div><div class="line">				if(currentNode.right == null)&#123;</div><div class="line">					currentNode.right = new TreeNode(value);</div><div class="line">					return;</div><div class="line">				&#125;else</div><div class="line">					currentNode = currentNode.right;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">private static String sequenceTree(TreeNode&lt;Integer&gt; head) &#123;</div><div class="line">	if(head==null)</div><div class="line">		return &quot;#!&quot;;</div><div class="line">	String res = String.valueOf(head.item)+&quot;!&quot;;</div><div class="line">	res += sequenceTree(head.left);</div><div class="line">	res += sequenceTree(head.right);</div><div class="line">	return res;</div><div class="line">&#125;</div><div class="line">// 使用前序遍历来反序列化</div><div class="line">//  seq=&quot;10!3!2!#!#!4!#!7!5!#!#!9!8!#!#!#!11!#!12!#!20!#!23!#!#!&quot;</div><div class="line">private static TreeNode&lt;Integer&gt; reconByString(String seq) &#123;</div><div class="line">	String[] value = seq.split(&quot;!&quot;);</div><div class="line">	Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</div><div class="line">	for(int i=0;i!=value.length;i++)</div><div class="line">		queue.offer(value[i]);</div><div class="line">	return reconPreOrder(queue);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static TreeNode&lt;Integer&gt; reconPreOrder(Queue&lt;String&gt; queue) &#123;</div><div class="line">	String value =queue.poll();</div><div class="line">	if(value.equals(&quot;#&quot;))</div><div class="line">		return null;</div><div class="line">	TreeNode head = new TreeNode(Integer.valueOf(value));</div><div class="line">	head.left = reconPreOrder(queue);</div><div class="line">	head.right = reconPreOrder(queue);</div><div class="line">	return head;</div><div class="line">&#125;</div><div class="line">// 使用层次遍历来反序列化</div><div class="line">private static String sequenceTreeByLevel(TreeNode head)&#123;</div><div class="line">	if(head==null)</div><div class="line">		return &quot;#!&quot;;</div><div class="line">	String res = head.value+&quot;!&quot;;</div><div class="line">	Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();</div><div class="line">	queue.offer(head);</div><div class="line">	while(!queue.isEmpty())&#123;</div><div class="line">		head = queue.poll();</div><div class="line">		if(head.left!=null)&#123;</div><div class="line">			res+=head.left.value+&quot;!&quot;;</div><div class="line">			queue.offer(head.left);</div><div class="line">		&#125;else&#123;</div><div class="line">			res+=&quot;#!&quot;;</div><div class="line">		&#125;</div><div class="line">		if(head.right!=null)&#123;</div><div class="line">			res+=head.right.value+&quot;!&quot;;</div><div class="line">			queue.offer(head.right);</div><div class="line">		&#125;else&#123;</div><div class="line">			res+=&quot;#!&quot;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法-链表]]></title>
      <url>https://fudawei.github.io/2016/04/10/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h3 id="单链表整体逆置-相邻元素逆置"><a href="#单链表整体逆置-相邻元素逆置" class="headerlink" title="单链表整体逆置/相邻元素逆置"></a>单链表整体逆置/相邻元素逆置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 单链表整体逆置 &amp;&amp;  单链表相邻元素逆置</div><div class="line"> */</div><div class="line">public class LinkList &#123;</div><div class="line">	static class Node&#123;</div><div class="line">		public int data;</div><div class="line">		public Node next;</div><div class="line">		public Node(int data)&#123;</div><div class="line">			this.data = data;</div><div class="line">		&#125;</div><div class="line">		public Node()&#123;&#125;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//带头结点的链表</div><div class="line">		Node head = new Node();</div><div class="line">		head.next = null;</div><div class="line">		Node p = head;</div><div class="line">		for(int i = 1;i&lt;10;i++)&#123;</div><div class="line">			Node temp = new Node(i);</div><div class="line">			temp.next = null;</div><div class="line">			p.next = temp;</div><div class="line">			p = p.next;</div><div class="line">		&#125;</div><div class="line">		//单链表整体逆置</div><div class="line">		reverseLinkedList(head);</div><div class="line">		printLinkedList(head);</div><div class="line"></div><div class="line">		//单链表相邻元素逆置</div><div class="line">		neighbourReverse(head);</div><div class="line">		printLinkedList(head);</div><div class="line">	&#125;</div><div class="line">	//反转相邻元素，交换相邻元素的值，然后令next指向后两个节点，若有一个不存在则结束</div><div class="line">	private static void neighbourReverse(Node head) &#123;</div><div class="line">		int temp;</div><div class="line">		Node p=head.next;</div><div class="line">		Node q=p.next;</div><div class="line">		while(p!=null &amp;&amp; q!=null)&#123;</div><div class="line">			temp = p.data;</div><div class="line">			p.data = q.data;</div><div class="line">			q.data = temp;</div><div class="line">			p = q.next;</div><div class="line">			q = p.next;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//反转单链表</div><div class="line">	private static Node reverseLinkedList(Node head) &#123;</div><div class="line">		Node p,q,r;</div><div class="line">		p = head.next;</div><div class="line">		q = p.next;</div><div class="line">		p.next = null;</div><div class="line">		while(q!=null)&#123;</div><div class="line">			 r=q.next;</div><div class="line">			 q.next=head.next;</div><div class="line">			 head.next=q;</div><div class="line">			 q=r;</div><div class="line">		&#125;</div><div class="line">		return head;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//	反转链表(没有头结点)</div><div class="line">	// 将结点保存至pNext，然后将当前结点的next重新设置为prev，将prev指向当前结点，再将指针后移一个结点</div><div class="line">	private static Node reverseLink(Node head) &#123;</div><div class="line">		Node prev = null;</div><div class="line">		Node newHead = null;</div><div class="line">		Node p = head;</div><div class="line">		while(p!=null)&#123;</div><div class="line">			Node pNext = p.next;</div><div class="line">			if(pNext==null)</div><div class="line">				newHead = p;</div><div class="line">			p.next = prev;</div><div class="line">			prev = p;</div><div class="line">			p = pNext;</div><div class="line">		&#125;</div><div class="line">		return newHead;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 递归反转链表(没有头结点)</div><div class="line">	private static Node reverseRecursively(Node head)&#123;</div><div class="line">		if(head == null || head.next == null)</div><div class="line">			return head;</div><div class="line">		else&#123;</div><div class="line">			Node newHead = reverseRecursively(head.next);</div><div class="line">			head.next.next = head;</div><div class="line">			head.next = null;</div><div class="line">			return newHead;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	//顺序打印输出(带头结点的链表输出)</div><div class="line">	private static void printLinkedList(Node p) &#123;</div><div class="line">		p = p.next;</div><div class="line">		while(p!=null)&#123;</div><div class="line">			System.out.println(p.data);</div><div class="line">			p = p.next;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	// 逆序打印结点(不带头结点)</div><div class="line">	private static void printReverse(Node head) &#123;</div><div class="line">		Node p = head;</div><div class="line">		if(p!=null)&#123;</div><div class="line">			if(p.next!=null)</div><div class="line">				printReverse(p.next);</div><div class="line">		&#125;</div><div class="line">		System.out.print(p.value+&quot; &quot;);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法-动态规划]]></title>
      <url>https://fudawei.github.io/2016/04/10/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 给定两个字符串str1和str2,返回这两个字符串的最长公共子序列</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class ZuiChangGongGongZiXuLie &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String str1=&quot;1B12A2C33D4B56&quot;;</div><div class="line">		String str2=&quot;B12D33BA45B6A&quot;;</div><div class="line">		int[][] dp = getDp(str1,str2);</div><div class="line">		ArrayUtils.printArray(dp);</div><div class="line">		printResult(str1,str2,dp);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void printResult(String str1,String str2,int[][] dp) &#123;</div><div class="line">		int rows = dp.length-1;</div><div class="line">		int cols = dp[0].length-1;</div><div class="line">		char[] chs1 = str1.toCharArray();</div><div class="line">		char[] chs2 = str2.toCharArray();</div><div class="line"></div><div class="line">		char[] res = new char[dp[rows][cols]];</div><div class="line">		int index = res.length-1;</div><div class="line">		while(index &gt;= 0)&#123;</div><div class="line">			if(rows &gt; 0 &amp;&amp; dp[rows][cols] == dp[rows-1][cols])</div><div class="line">				rows--;</div><div class="line">			else if(cols &gt; 0 &amp;&amp; dp[rows][cols] == dp[rows][cols-1])</div><div class="line">				cols--;</div><div class="line">			else&#123;</div><div class="line">				res[index--] =  chs1[rows];</div><div class="line">				rows--;</div><div class="line">				cols--;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ArrayUtils.printArray(res);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int[][] getDp(String str1, String str2) &#123;</div><div class="line">		char[] chs1 = str1.toCharArray();</div><div class="line">		char[] chs2 = str2.toCharArray();</div><div class="line">		int[][] dp = new int[chs1.length][chs2.length];</div><div class="line">		dp[0][0] = chs1[0]==chs2[0]?1:0;</div><div class="line">		for(int i = 1;i &lt; chs2.length;i++)&#123;</div><div class="line">			// 若有一处为1，则该行或该列都为1</div><div class="line">			dp[0][i] = Math.max(dp[0][i-1],chs1[0]==chs2[i]?1:0);</div><div class="line">		&#125;</div><div class="line">		for(int j = 1;j &lt; chs1.length;j++)&#123;</div><div class="line">			dp[j][0] = Math.max(dp[j-1][0],chs1[j]==chs2[0]?1:0);</div><div class="line">		&#125;</div><div class="line">		for(int i=1;i&lt;chs1.length;i++)&#123;</div><div class="line">			for(int j=1;j&lt;chs2.length;j++)&#123;</div><div class="line">				dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);</div><div class="line">				if(chs1[i] == chs2[j])</div><div class="line">					// 相等则为上一次末尾相等的字符对应的值加1</div><div class="line">					dp[i][j] = Math.max(dp[i][j],dp[i-1][j-1]+1);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 最长公共子串</div><div class="line"> * 与最长公共子序列不同的地方在于，必须连续</div><div class="line"> *</div><div class="line"> * eg:  String str1 = &quot;1AB2345CD&quot;;</div><div class="line">		String str2 = &quot;123345EF&quot;;</div><div class="line">	返回  &#123;3,4,5&#125;</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class ZuiChangGongGongZiChuan &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String str1 = &quot;1AB2345CD&quot;;</div><div class="line">		String str2 = &quot;123345EF&quot;;</div><div class="line">		int  index = 0;</div><div class="line">		int max = 0;</div><div class="line">		char[] chs1 = str1.toCharArray();</div><div class="line">		char[] chs2 = str2.toCharArray();</div><div class="line">		int[][] dp = getDp(chs1,chs2);</div><div class="line">		ArrayUtils.printArray(dp);</div><div class="line">		for(int i = 0;i &lt; chs2.length;i++)&#123;</div><div class="line">			for(int j = 0;j &lt; chs1.length;j++)&#123;</div><div class="line">				if(dp[i][j] &gt; max)&#123;</div><div class="line">					// 找到最大公共子串的末尾位置</div><div class="line">					index = i;</div><div class="line">					// 找到最大公共子串的长度</div><div class="line">					max = dp[i][j];</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		char result[]  = new char[max];</div><div class="line">		while(max &gt; 0)</div><div class="line">			// 最大公共子串的长度不为1，则赋值给result</div><div class="line">			result[--max] = chs1[index--];</div><div class="line">		ArrayUtils.printArray(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	private static int[][] getDp(char[] chs1, char[] chs2) &#123;</div><div class="line">		int lenA = chs1.length;</div><div class="line">		int lenB = chs2.length;</div><div class="line">		int[][] dp = new int[lenB][lenA];</div><div class="line">		for(int i = 0;i &lt; chs2.length;i++)&#123;</div><div class="line">			if(chs2[i] == chs1[0])</div><div class="line">				dp[i][0] = 1;</div><div class="line">		&#125;</div><div class="line">		for(int i = 0;i &lt; chs1.length;i++)&#123;</div><div class="line">			if(chs2[0] == chs1[i])</div><div class="line">				dp[0][i] = 1;</div><div class="line">		&#125;</div><div class="line">		for(int i = 1;i &lt; chs1.length;i++)&#123;</div><div class="line">			for(int j = 1;j &lt; chs2.length;j++)&#123;</div><div class="line">				if(chs1[i] == chs2[j])</div><div class="line">					// 因为所求为连续字符串，所以下一个dp[i][j]为上一个dp[i-1][j-1]的值加1</div><div class="line">					dp[i][j] = dp[i-1][j-1] + 1;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 数组中最长连续序列</div><div class="line"> * eg: arr=[100,4,1,3,2] 返回 [1,2,3,4]</div><div class="line"> */</div><div class="line">import java.util.HashMap;</div><div class="line"></div><div class="line">public class ArrZuiChangLianXuXuLie &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[] arr=&#123;100,4,200,1,3,2,6,5&#125;;</div><div class="line">		int maxLen = getLongestLen(arr);</div><div class="line">		System.out.println(maxLen);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int getLongestLen(int[] arr) &#123;</div><div class="line">		HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();</div><div class="line">		// 全局max，保存最长连续序列最大值</div><div class="line">		int max = 1;</div><div class="line">		for(int i = 0;i &lt; arr.length;i++)&#123;</div><div class="line">			if(!map.containsKey(arr[i]))&#123;</div><div class="line">				map.put(arr[i], 1);</div><div class="line">				if(map.containsKey(arr[i]-1))&#123;</div><div class="line">					max = Math.max(max,mergeArr(map,arr[i]-1,arr[i]));</div><div class="line">				&#125;</div><div class="line">				if(map.containsKey(arr[i]+1))&#123;</div><div class="line">					max = Math.max(max,mergeArr(map,arr[i],arr[i]+1));</div><div class="line"></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return max;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int mergeArr(HashMap&lt;Integer, Integer&gt; map, int low, int high) &#123;</div><div class="line">		// 对于一串连续的序列，会把首字符和长度、尾字符和长度存到map里面，方便合并的时候使用首尾</div><div class="line">		// 得到较小的数的首字符位置</div><div class="line">		int left = low-map.get(low)+1;</div><div class="line">		// 得到较大的数的尾字符位置</div><div class="line">		int right= high+map.get(high)-1;</div><div class="line">		int len = right - left + 1;</div><div class="line">		// 把首字符和长度存入map</div><div class="line">		map.put(left, len);</div><div class="line">		// 把尾字符和长度存入map</div><div class="line">		map.put(right, len);</div><div class="line">		return len;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 最长递增子序列</div><div class="line"> * eg: arr=&#123;2,1,5,3,6,4,8,9,7&#125; 返回的最长的递增子序列为[1,3,4,8,9]。</div><div class="line"> */</div><div class="line">public class IncrementSubOrder &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[] arr = &#123;2,1,5,3,6,4,8,9,7&#125;;</div><div class="line">		int[] result = getIncrementArr(arr);</div><div class="line">		int index = 0;</div><div class="line">		int len = 0;</div><div class="line">		// 打印dp路径 dp[i]表示以arr[i]结尾的情况下，arr[0...j]中的最大递增子序列长度。</div><div class="line">		ArrayUtils.printArray(result);</div><div class="line">		for(int i = 0;i &lt; result.length;i++)&#123;</div><div class="line">			if(result[index] &lt; result[i])&#123;</div><div class="line">				// index定位最大值，即最大递增子序列的末尾数</div><div class="line">				index = i;</div><div class="line">				len = result[i];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		int[] newArr = new int[len];</div><div class="line">		newArr[--len] = arr[index];</div><div class="line">		for(int i = index;i &gt;= 0;i--)&#123;</div><div class="line">			// 若某个数小于index所指的数且dp长度相差为1，则可以包含这个数</div><div class="line">			if(arr[index] &gt; arr[i] &amp;&amp; result[i] == result[index]-1)&#123;</div><div class="line">				newArr[--len] = arr[i];</div><div class="line">				index = i;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ArrayUtils.printArray(newArr);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int[] getIncrementArr(int[] arr) &#123;</div><div class="line">		int len = arr.length;</div><div class="line">		int[] dp = new int[len];</div><div class="line">		for(int i = 0;i &lt; arr.length;i++)&#123;</div><div class="line">			// 默认都为1 (包含自身)</div><div class="line">			dp[i] = 1;</div><div class="line">			for(int j = 0;j &lt; i;j++)&#123;</div><div class="line">				if(arr[i] &gt; arr[j])</div><div class="line">					dp[i] = Math.max(dp[i], dp[j]+1);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二维数组中最小路径和"><a href="#二维数组中最小路径和" class="headerlink" title="二维数组中最小路径和"></a>二维数组中最小路径和</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 给定一个矩阵m，从左上角开始每次只能向右或向下走，最后到达右下角的位置，路径上</div><div class="line"> * 所有数字累加起来就是路径和，返回最小的路径和</div><div class="line"> * 1 3 5 9</div><div class="line"> * 8 1 3 4</div><div class="line"> * 5 0 6 1</div><div class="line"> * 8 8 4 0</div><div class="line"> */</div><div class="line"></div><div class="line">public class ShortDistance &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[][] arr = &#123;</div><div class="line">				&#123;1,3,5,9&#125;,&#123;8,1,3,4&#125;,&#123;5,0,6,1&#125;,&#123;8,8,4,0&#125;</div><div class="line">		&#125;;</div><div class="line">		int[][] dp = getDp(arr);</div><div class="line">		System.out.println(dp[dp.length-1][dp[0].length-1]);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int[][] getDp(int[][] arr) &#123;</div><div class="line">		int rows = arr.length;</div><div class="line">		int cols = arr[0].length;</div><div class="line">		int[][] dp = new int[rows][cols];</div><div class="line">		dp[0][0] = arr[0][0];</div><div class="line">		// dp的行</div><div class="line">		for(int i=1;i&lt;cols;i++)</div><div class="line">			dp[0][i] = dp[0][i-1]+arr[0][i];</div><div class="line">		// dp的列</div><div class="line">		for(int i=1;i&lt;rows;i++)</div><div class="line">			dp[i][0] = dp[i-1][0]+arr[i][0];</div><div class="line">		// 更新dp其他行列值</div><div class="line">		for(int i=1;i&lt;rows;i++)&#123;</div><div class="line">			for(int j=1;j&lt;cols;j++)&#123;</div><div class="line">				// dp[i][j] 根据左边或者上边的值确定之后加上当前arr的值</div><div class="line">				dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1])+arr[i][j];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a>交错字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 动态规划</div><div class="line"> * 给定三个字符串：str1,str2,aim。若aim包含str1和str2且相对属顺序一致则true</div><div class="line"> * dp[i][j]代表aim[i+j-1]能否被str1[0..i-1]和str2[0..j-1]交错组成</div><div class="line"> * dp[i-1][j] 代表aim[0..i+j-2]能否被str1[0..i-2]和str2[0..j-1]组成，此时，如果str[i-1]等于aim[i+j-1] 说明</div><div class="line"> * str[i-1]又可以作为交错组成aim[0..i+j-1]的最后一个字符，令dp[i][j]=true.</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class StringCross &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">//		String str1 = &quot;ABE1EF12&quot;;</div><div class="line">//		String str2 = &quot;CDG&quot;;</div><div class="line">//		String aim = &quot;ABE1ECF1D2G&quot;;</div><div class="line">		String str1 = &quot;AB&quot;;</div><div class="line">		String str2 = &quot;12&quot;;</div><div class="line">		String aim = &quot;A12B&quot;;</div><div class="line">		char[] chs1 = str1.toCharArray();</div><div class="line">		char[] chs2 = str2.toCharArray();</div><div class="line">		char[] chsaim = aim.toCharArray();</div><div class="line">		boolean flag = getDp(chs1,chs2,chsaim);</div><div class="line">		System.out.println(flag);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static boolean getDp(char[] chs1, char[] chs2, char[] chsaim) &#123;</div><div class="line">		if(chsaim.length != chs1.length+ chs2.length)</div><div class="line">			return false;</div><div class="line">		boolean[][] dp = new boolean[chs1.length+1][chs2.length+1];</div><div class="line">		dp[0][0] = true;</div><div class="line">		for(int i = 1;i &lt;= chs1.length;i++)&#123;</div><div class="line">			if(chs1[i-1] == chsaim[i-1])</div><div class="line">				dp[i][0] = true;</div><div class="line">		&#125;</div><div class="line">		for(int i = 1;i &lt;= chs2.length;i++)&#123;</div><div class="line">			if(chs2[i-1] == chsaim[i-1])</div><div class="line">				dp[0][i] = true;</div><div class="line">		&#125;</div><div class="line">		for(int i = 1;i &lt;= chs1.length;i++)&#123;</div><div class="line">			for(int j = 1;j &lt;= chs2.length;j++)&#123;</div><div class="line">				if((dp[i-1][j] &amp;&amp; chs1[i-1] == chsaim[i+j-1])</div><div class="line">						|| (dp[i][j-1] &amp;&amp; chs2[j-1] == chsaim[i+j-1]))</div><div class="line">					dp[i][j] = true;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		// 打印dp</div><div class="line">		ArrayUtils.printArray(dp);</div><div class="line">		return isCross(dp);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static boolean isCross(boolean[][] dp) &#123;</div><div class="line"></div><div class="line">		return dp[dp.length-1][dp[0].length-1];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最大乘积数组"><a href="#最大乘积数组" class="headerlink" title="最大乘积数组"></a>最大乘积数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> * 利用动态规划求解。考虑到负数的情况，用maxEnd来表示以arr[i]结尾的最大连续子数组的乘积值</div><div class="line"> * 用minEnd表示以arr[i]结尾的最小连续子数组的乘积值</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class LargestMultiArr &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		double[] arr = &#123;1,0,-2,0.5,-8,7,2&#125;;</div><div class="line">		double result = getLargestArr(arr);</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line">	private static double getLargestArr(double[] arr) &#123;</div><div class="line">		double maxEnd = arr[0];</div><div class="line">		double minEnd = arr[0];</div><div class="line">		double maxResult = arr[0];</div><div class="line">		for(int i=1;i&lt;arr.length;i++)&#123;</div><div class="line">			// maxEnd和minEnd分别保存arr[i]之前的最大值和最小值</div><div class="line">			double end1=maxEnd*arr[i],end2=minEnd*arr[i];</div><div class="line">			// 状态转移方程</div><div class="line">			maxEnd = Math.max(Math.max(end1,end2),arr[i]);</div><div class="line">			minEnd = Math.min(Math.min(end1, end2),arr[i]);</div><div class="line">			maxResult=Math.max(maxResult,maxEnd);</div><div class="line">		&#125;</div><div class="line">		return maxResult;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">最优子问题和无后效性保证。一个状态下的最优值取决于到达这个状态的全部子状态的最优值，且状态之间的最优值不互相影响</div><div class="line">动态规划实质上是一种递推。假设当前状态是S，所有能达到S的状态是S&apos;&apos;，用f(state)表示在状态state下的最优值，payoff表示代价，则有</div><div class="line">f(S)=min&#123;f(S&apos;&apos;)+payoff(S&apos;&apos;-&gt;S)&#125;</div></pre></td></tr></table></figure>
<h3 id="最长回文字符串"><a href="#最长回文字符串" class="headerlink" title="最长回文字符串"></a>最长回文字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class LongestString &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String str=&quot;aabaabac&quot;;</div><div class="line">		System.out.println(LongestString(str));</div><div class="line">	&#125;</div><div class="line">	private static int LongestString(String str) &#123;</div><div class="line">		int max=0,c=0;</div><div class="line">		if(str==null)</div><div class="line">			return 0;</div><div class="line">		char[] ch = str.toCharArray();</div><div class="line">		for(int i=0;i&lt;ch.length-1;i++)&#123;</div><div class="line">			// 最中间位置可能为单个字符回文</div><div class="line">			String str1 = getLongestString(ch,i,i);</div><div class="line">			// 最中间位置可能为两个字符回文</div><div class="line">			String str2 = getLongestString(ch,i,i+1);</div><div class="line">			c = str1.length() &gt; str2.length()?str1.length() : str2.length();</div><div class="line">			max = max &gt; c?max:c;</div><div class="line">		&#125;</div><div class="line">		return max;</div><div class="line">	&#125;</div><div class="line">	private static String getLongestString(char[] ch, int i, int j) &#123;</div><div class="line">		int l = i;</div><div class="line">		int r  = j;</div><div class="line">		while(l&gt;=0 &amp;&amp; r&lt;=ch.length-1 &amp;&amp; ch[l]==ch[r])&#123;</div><div class="line">			l--;</div><div class="line">			r++;</div><div class="line">		&#125;</div><div class="line">		return String.valueOf(ch).substring(l+1, r);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最大连续子数组和"><a href="#最大连续子数组和" class="headerlink" title="最大连续子数组和"></a>最大连续子数组和</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 方法一</div><div class="line">	private static int getMaxSum(int[] arr) &#123;</div><div class="line">		int currSum=0;</div><div class="line">		int maxSum=Integer.MIN_VALUE;</div><div class="line">		for(int j=0;j&lt;arr.length;j++)&#123;</div><div class="line">			if(currSum&gt;=0)</div><div class="line">				currSum += arr[j];</div><div class="line">			// 小于0则记录当前值，然后从下一个开始重新计算最大值</div><div class="line">			else</div><div class="line">				currSum = arr[j];</div><div class="line">			if(currSum &gt; maxSum)</div><div class="line">				maxSum = currSum;</div><div class="line">		&#125;</div><div class="line">		return maxSum;</div><div class="line">	&#125;</div><div class="line">	// 方法二</div><div class="line">	private static int getMaxSum2(int[] arr)&#123;</div><div class="line">		int cur = 0;</div><div class="line">		int max =Integer.MIN_VALUE;</div><div class="line">		for (int i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">			cur += arr[i];</div><div class="line">			max = Math.max(max,cur);</div><div class="line">			cur = cur &lt; 0?0:cur;</div><div class="line">		&#125;</div><div class="line">		return max;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串的全排列"><a href="#字符串的全排列" class="headerlink" title="字符串的全排列"></a>字符串的全排列</h3><p>设一组数p = {r1, r2, r3, … ,rn}, 全排列为perm(p)，pn = p - {rn}。因此perm(p) = r1perm(p1), r2perm(p2), r3perm(p3), … , rnperm(pn)。当n = 1时perm(p} = r1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class QuanPaiLie &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] arr=&#123;1,2,3,4&#125;;</div><div class="line">		calcAllPermutation(arr,0,3);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void calcAllPermutation(int[] arr, int from, int to) &#123;</div><div class="line">		if(to&lt;=1)</div><div class="line">			return;</div><div class="line">		if(from==to)&#123;</div><div class="line">			for(int i=0;i&lt;=to;i++)&#123;</div><div class="line">				System.out.print(arr[i]);</div><div class="line">			&#125;</div><div class="line">			System.out.println();</div><div class="line">		&#125;else&#123;</div><div class="line">			for(int j=from;j&lt;=to;j++)&#123;</div><div class="line">				ArrayUtils.swap(arr, j, from);</div><div class="line">				calcAllPermutation(arr, from+1, to);</div><div class="line">				ArrayUtils.swap(arr, from,j);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关键的就是arrange方法的else里面的内容，我的理解是（以求str[] = {“a”,”b”,”c”}的排列为例子）：用i从str[st]做一遍循环：<br>每一次循环中，都要将str[i]与str[i]互相调换位置：第一次开始，”a”与自己换，这时候，递归调用arrange[str,st + 1, len]<br>这是在求取str[str…len - 1]的排列即”b”,”c”的排列；<br>第二次，”a”与”b”互相调换，递归调用arrange[str,str + 1, len]就是在求取{“a”,”c”}的排列。<br>第三次，”a”与”c”互相调换，递归调用arrange[str, str + 1,len]就是在求取”{“b”,”a}的排列。<br>下面再以”b”,”c”的排列求取为例：<br>首先还是做循环，第一次，”b”与自己调换，这时候，调用arrange[str,st + 1,len]就是求c的排列。呵呵，这时候终于到了函数递归调用的出口了<br>: st = len - 1。输出”b”  “c”;第二次，类似的，输出”c”,”b”;至此，”b” “c”的排列求取完毕。加上前面的a,就输出”a””b””c”  “a””c””b”。<br>类似的，就可以输出所有的排列了。</p>
<h3 id="第一次只出现一次的字符"><a href="#第一次只出现一次的字符" class="headerlink" title="第一次只出现一次的字符"></a>第一次只出现一次的字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class TheFirstOnceNum &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(firstNotRepeatingChar(&quot;google&quot;)); // l</div><div class="line">        System.out.println(firstNotRepeatingChar(&quot;aabccdbd&quot;)); // &apos;\0&apos;</div><div class="line">        System.out.println(firstNotRepeatingChar(&quot;abcdefg&quot;)); // a</div><div class="line">        System.out.println(firstNotRepeatingChar(&quot;gfedcba&quot;)); // g</div><div class="line">        System.out.println(firstNotRepeatingChar(&quot;zgfedcba&quot;)); // g</div><div class="line">	&#125;</div><div class="line">	private static char firstNotRepeatingChar(String str) &#123;</div><div class="line">		HashMap&lt;Character, Integer&gt; hm = new HashMap&lt;Character,Integer&gt;();</div><div class="line">		for(int i=0;i&lt;str.length();i++)&#123;</div><div class="line">			char c = str.charAt(i);</div><div class="line">			if(hm.containsKey(c))&#123;</div><div class="line">				// 若已存在，则排除，把value设置为负数，在最后判断的时候根据value排除</div><div class="line">				hm.put(c, -2);</div><div class="line">			&#125;else&#123;</div><div class="line">				hm.put(c, i);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		int idx = Integer.MAX_VALUE;</div><div class="line">		char result = &apos; &apos;;</div><div class="line">		for(Map.Entry&lt;Character, Integer&gt; entry : hm.entrySet())&#123;</div><div class="line">			if(entry.getValue() &gt;= 0 &amp;&amp; entry.getValue() &lt; idx)&#123;</div><div class="line">				// idx保存字符串中位置的索引，选择最小的就是最早出现的。</div><div class="line">				idx = entry.getValue();</div><div class="line">				// idx对应的字符</div><div class="line">				result = entry.getKey();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="寻找和为定值的多个数"><a href="#寻找和为定值的多个数" class="headerlink" title="寻找和为定值的多个数"></a>寻找和为定值的多个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class SumGivenNumber &#123;</div><div class="line">	static Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;();</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		sumOfNumber(10, 8);</div><div class="line">	&#125;</div><div class="line">	public static void sumOfNumber(int sum, int n) &#123;</div><div class="line">		if (n &lt;= 0 || sum &lt;= 0)</div><div class="line">			return;</div><div class="line">		if (sum == n) &#123;</div><div class="line">			System.out.print(n+&quot; &quot;);</div><div class="line">			Enumeration&lt;Integer&gt; elements = st.elements();</div><div class="line">			while (elements.hasMoreElements()) &#123;</div><div class="line">				System.out.print(elements.nextElement()+&quot; &quot;);</div><div class="line">			&#125;</div><div class="line">			System.out.println();</div><div class="line">		&#125;</div><div class="line">		st.push(n);</div><div class="line">		sumOfNumber(sum - n, n - 1);</div><div class="line">		st.pop();</div><div class="line">		sumOfNumber(sum, n - 1);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法-字符串相关]]></title>
      <url>https://fudawei.github.io/2016/04/10/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h3 id="句子逆序输出"><a href="#句子逆序输出" class="headerlink" title="句子逆序输出"></a>句子逆序输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">/** 句子逆序</div><div class="line"> * 将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”</div><div class="line"> * 所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符</div><div class="line"> */</div><div class="line">import java.util.Scanner;</div><div class="line"></div><div class="line"></div><div class="line">public class StringReverse &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		Scanner sc = new Scanner(System.in);</div><div class="line">		while(sc.hasNext())&#123;</div><div class="line">			String str = sc.nextLine();</div><div class="line">			String result = reverse(str);</div><div class="line">			System.out.println(result);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public static  String reverse(String sentence)&#123;</div><div class="line">		char[] arr = sentence.toCharArray();</div><div class="line">		rev(arr,0,arr.length-1);</div><div class="line">		int start=0,end=0;</div><div class="line">		while(arr[start]==&apos; &apos;) start++;</div><div class="line">		while(arr[end]!=&apos;\0&apos; &amp;&amp; end &lt; arr.length-1)&#123;</div><div class="line">			while(end &lt; arr.length-1 &amp;&amp; arr[end]!=&apos; &apos;)</div><div class="line">				end++;</div><div class="line">			if(end==arr.length-1)&#123;</div><div class="line">				rev(arr,start,end);</div><div class="line">			&#125;else</div><div class="line">				rev(arr,start,end-1);</div><div class="line">			if(arr[end]==&apos; &apos; &amp;&amp; arr[end]!=&apos;\0&apos;)&#123;</div><div class="line">				end++;</div><div class="line">				start=end;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return new String(arr);</div><div class="line">	&#125;</div><div class="line">	public static void rev(char arr[],int start,int end)&#123;</div><div class="line">		char temp;</div><div class="line">		while(start&lt;end)&#123;</div><div class="line">			temp = arr[start];</div><div class="line">			arr[start] = arr[end];</div><div class="line">			arr[end] = temp;</div><div class="line">			start++;</div><div class="line">			end--;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="替换空格为指定字符串"><a href="#替换空格为指定字符串" class="headerlink" title="替换空格为指定字符串"></a>替换空格为指定字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 替换字符串</div><div class="line"> * 将字符串中的每个空格替换成&apos;%20&apos;</div><div class="line"> * eg &quot;we are happy&quot; 替换为&quot;we%20are%20happy.&quot;</div><div class="line"> * 需求：将特殊符号转换为服务器可以识别的字符，转换的规则是在&apos;%&apos;后面跟上ASCII码的两位十六进制的表示</div><div class="line"> */</div><div class="line">public class ReplaceBlank &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		String str = &quot;We Are Happy.&quot;;</div><div class="line">		String st = replaceChar(str);</div><div class="line">		System.out.println(st);</div><div class="line">	&#125;</div><div class="line">	public static String replaceChar(String str)&#123;</div><div class="line">		char[] ch = str.toCharArray();</div><div class="line">		int i=0;</div><div class="line">		int numBlack=0;</div><div class="line">		int numOrigin=ch.length;</div><div class="line">		while(i&lt;ch.length)&#123;</div><div class="line">			if(ch[i]==&apos; &apos;)</div><div class="line">				++numBlack;</div><div class="line">			++i;</div><div class="line">		&#125;</div><div class="line">		int newLength = numOrigin+numBlack*2;</div><div class="line">		char[] chs = new char[newLength];</div><div class="line">		int newOrigin = numOrigin-1;</div><div class="line">		newLength--;</div><div class="line">		while(newOrigin&gt;=0)&#123;</div><div class="line">			if(ch[newOrigin]==&apos; &apos;)&#123;</div><div class="line">				chs[newLength--]=&apos;0&apos;;</div><div class="line">				chs[newLength--]=&apos;2&apos;;</div><div class="line">				chs[newLength--]=&apos;%&apos;;</div><div class="line">			&#125;else&#123;</div><div class="line">				chs[newLength--]=ch[newOrigin];</div><div class="line">			&#125;</div><div class="line">			newOrigin--;</div><div class="line">		&#125;</div><div class="line">		return new String(chs);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程笔记]]></title>
      <url>https://fudawei.github.io/2016/03/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class ThreadLocalTest &#123;</div><div class="line">	private static ThreadLocal&lt;Integer&gt; seqNum = new ThreadLocal&lt;Integer&gt;()&#123;</div><div class="line">		protected Integer initialValue() &#123;</div><div class="line">			return 0;</div><div class="line">		&#125;;</div><div class="line">	&#125;;</div><div class="line">	// 便于后面删除该对象</div><div class="line">	public ThreadLocal&lt;Integer&gt; getThreadLocal()&#123;</div><div class="line">		return seqNum;</div><div class="line">	&#125;</div><div class="line">	public int getNextNum()&#123;</div><div class="line">		seqNum.set(seqNum.get()+1);</div><div class="line">		return seqNum.get();</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		ThreadLocalTest sn = new ThreadLocalTest();</div><div class="line">		TestClient t1 = new TestClient(sn);</div><div class="line">		TestClient t2 = new TestClient(sn);</div><div class="line">		TestClient t3 = new TestClient(sn);</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">		t3.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	private static class TestClient extends Thread&#123;</div><div class="line">		private ThreadLocalTest sn;</div><div class="line">		public TestClient(ThreadLocalTest sn)&#123;</div><div class="line">			this.sn = sn;</div><div class="line">		&#125;</div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			for(int i=0;i&lt;3;i++)&#123;</div><div class="line">				System.out.println(&quot;thread &quot;+Thread.currentThread().getName()+&quot; -&gt; &quot;+sn.getNextNum());</div><div class="line">			&#125;</div><div class="line">			//  每个线程用完的时候要记得删除，减少内存占用</div><div class="line">			// 使用ThreadLocal ，一般都是声明在静态变量中，如果不断的创建ThreadLocal而且没有调用其remove方法</div><div class="line">			//将会导致内存泄漏，特别是在高并发的web容器中</div><div class="line">			sn.getThreadLocal().remove();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="线程异常捕获"><a href="#线程异常捕获" class="headerlink" title="线程异常捕获"></a>线程异常捕获</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import java.lang.Thread.UncaughtExceptionHandler;</div><div class="line"></div><div class="line">public class ThreadMain &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ThreadB task = new ThreadB();</div><div class="line">		Thread thread = new Thread(task);</div><div class="line">		// 线程出现异常，通过设置 setUncaughtExceptionHandler 注册一个UncaughtExceptionHandler的对象实例来处理</div><div class="line">		thread.setUncaughtExceptionHandler(new ExceptionHandleThreadB());</div><div class="line">		thread.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ThreadB implements Runnable &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		// 一个会出现异常的线程</div><div class="line">		int number = Integer.parseInt(&quot;TTT&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//  实现  UncaughtExceptionHandler 接口 处理出现异常的实例</div><div class="line">class ExceptionHandleThreadB implements UncaughtExceptionHandler &#123;</div><div class="line">	@Override</div><div class="line">	public void uncaughtException(Thread t, Throwable e) &#123;</div><div class="line">		System.out.println(&quot;An Exception Has Been captured&quot;);</div><div class="line">		System.out.printf(&quot;Thread %s\n&quot;, t.getId());</div><div class="line">		System.out.printf(&quot;Exception : %s: %s\n&quot;, e.getClass().getName(),</div><div class="line">				e.getMessage());</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[堆排序]]></title>
      <url>https://fudawei.github.io/2016/03/11/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote>
<ul>
<li>堆是一种重要的数据结构，为一棵完全二叉树, 底层如果用数组存储数据的话，假设某个元素为序号为i(Java数组从0开始,i为0到n-1), 如果它有左子树，那么左子树的位置是2i+1，如果有右子树，右子树的位置是2i+2，如果有父节点，父节点的位置是(n-1)/2取整。分为最大堆和最小堆，最大堆的任意子树根节点不小于任意子结点，最小堆的根节点不大于任意子结点。所谓堆排序就是利用堆这种数据结构来对数组排序，我们使用的是最大堆。处理的思想和冒泡排序，选择排序非常的类似，一层层封顶，只是最大元素的选取使用了最大堆。最大堆的最大元素一定在第0位置，构建好堆之后，交换0位置元素与顶即可。堆排序为原位排序(空间小), 且最坏运行时间是O(n2)，是渐进最优的比较排序算法。</li>
</ul>
</blockquote>
<h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ArrayUtils &#123;</div><div class="line">	public static void printArray(int[] array)&#123;</div><div class="line">		System.out.print(&quot;&#123; &quot;);</div><div class="line">		for(int i=0;i&lt;array.length;i++)&#123;</div><div class="line">			System.out.print(array[i]);</div><div class="line">			if(i&lt;array.length-1)&#123;</div><div class="line">				System.out.print(&quot;,&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot; &#125; &quot;);</div><div class="line">	&#125;</div><div class="line">	public static void swap(int[] array,int index1,int index2)&#123;</div><div class="line">		int temp = array[index1];</div><div class="line">		array[index1] = array[index2];</div><div class="line">		array[index2] = temp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="堆排序核心算法"><a href="#堆排序核心算法" class="headerlink" title="堆排序核心算法"></a>堆排序核心算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">package com.Arr;</div><div class="line"></div><div class="line">import org.junit.experimental.max.MaxHistory;</div><div class="line"></div><div class="line">public class HeapSort &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] arr = &#123;7,8,0,2,9,6,4,5,1&#125;;</div><div class="line">		heapSort(arr);</div><div class="line">		ArrayUtils.printArray(arr);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void heapSort(int[] arr) &#123;</div><div class="line">		if (arr == null || arr.length &lt;= 1) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">		buildMaxHeap(arr);</div><div class="line">		for(int i=arr.length-1;i&gt;=0;i--)&#123;</div><div class="line">			ArrayUtils.swap(arr, 0, i);</div><div class="line">			maxHeap(arr, i, 0);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void buildMaxHeap(int[] arr) &#123;</div><div class="line">		if (arr == null || arr.length &lt;= 1) &#123;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		int half = (arr.length-1)/2;</div><div class="line">		for(int i=half;i&gt;=0;i--)&#123;</div><div class="line">			maxHeap(arr,arr.length,i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void maxHeap(int[] arr, int length, int index) &#123;</div><div class="line">		 int left = 2*index+1;</div><div class="line">		 int right = 2*index+2;</div><div class="line">		 int largestIndex = index;</div><div class="line">		if(left &lt; length &amp;&amp; arr[left] &gt; arr[largestIndex])</div><div class="line">			largestIndex = left;</div><div class="line">		if(right &lt; length &amp;&amp; arr[right] &gt; arr[largestIndex])</div><div class="line">			largestIndex = right;</div><div class="line">		if(largestIndex!=index)&#123;</div><div class="line">			ArrayUtils.swap(arr, index, largestIndex);</div><div class="line">			maxHeap(arr, length, largestIndex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class MergeSort &#123;</div><div class="line">	public static int[] sort(int[] nums, int low, int high) &#123;</div><div class="line">		int mid = (low + high) / 2;</div><div class="line">		if (low &lt; high) &#123;</div><div class="line">			// 左边</div><div class="line">			sort(nums, low, mid);</div><div class="line">			// 右边</div><div class="line">			sort(nums, mid + 1, high);</div><div class="line">			// 左右归并</div><div class="line">			merge(nums, low, mid, high);</div><div class="line">		&#125;</div><div class="line">		return nums;</div><div class="line">	&#125;</div><div class="line">	public static void merge(int[] nums, int low, int mid, int high) &#123;</div><div class="line">		int[] temp = new int[high - low + 1];</div><div class="line">		int i = low;// 左指针</div><div class="line">		int j = mid + 1;// 右指针</div><div class="line">		int k = 0;</div><div class="line">		// 把较小的数先移到新数组中</div><div class="line">		while (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</div><div class="line">			if (nums[i] &lt; nums[j]) &#123;</div><div class="line">				temp[k++] = nums[i++];</div><div class="line">			&#125; else &#123;</div><div class="line">				temp[k++] = nums[j++];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		// 把左边剩余的数移入数组</div><div class="line">		while (i &lt;= mid) &#123;</div><div class="line">			temp[k++] = nums[i++];</div><div class="line">		&#125;</div><div class="line">		// 把右边边剩余的数移入数组</div><div class="line">		while (j &lt;= high) &#123;</div><div class="line">			temp[k++] = nums[j++];</div><div class="line">		&#125;</div><div class="line">		// 把新数组中的数覆盖nums数组</div><div class="line">		for (int k2 = 0; k2 &lt; temp.length; k2++) &#123;</div><div class="line">			nums[k2 + low] = temp[k2];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	// 归并排序的实现</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[] nums = &#123; 2, 7, 8, 3, 1, 6, 9, 0, 5, 4 &#125;;</div><div class="line">		MergeSort.sort(nums, 0, nums.length - 1);</div><div class="line">		System.out.println(Arrays.toString(nums));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class SortQuick &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] arr = &#123; 3, 5, 6, 9, -1, 4, 8, 2, 7 &#125;;</div><div class="line">		quickSort(arr, 0, arr.length - 1);</div><div class="line">		ArrayUtils.printArray(arr);</div><div class="line">	&#125;</div><div class="line">	private static void quickSort(int[] arr, int i, int j) &#123;</div><div class="line">		if (i &lt; j) &#123;</div><div class="line">			int pivot = qSort(arr, i, j);</div><div class="line">			quickSort(arr, i, pivot - 1);</div><div class="line">			quickSort(arr, pivot + 1, j);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private static int qSort(int[] arr, int i, int j) &#123;</div><div class="line">		int n = arr[i];</div><div class="line">		while (i &lt; j) &#123;</div><div class="line">			while (i &lt; j &amp;&amp; arr[j] &gt;= n)</div><div class="line">				j--;</div><div class="line">			arr[i] = arr[j];</div><div class="line">			while (i &lt; j &amp;&amp; arr[i] &lt;= n)</div><div class="line">				i++;</div><div class="line">			arr[j] = arr[i];</div><div class="line">		&#125;</div><div class="line">		arr[i] = n;</div><div class="line">		return i;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="位排序"><a href="#位排序" class="headerlink" title="位排序"></a>位排序</h3><p>把数组元素作为键，boolean元素作为值映射到数组上，然后顺序遍历数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private static void bitSort(int[] arr) &#123;</div><div class="line">		boolean[] bitMap = new boolean[256];</div><div class="line">		for(int i=0;i&lt;bitMap.length;i++)</div><div class="line">			bitMap[i] = false;</div><div class="line">		for(int i=0;i&lt;arr.length;i++)&#123;</div><div class="line">			if(arr[i]!=0)</div><div class="line">				bitMap[arr[i]]=true;</div><div class="line">		&#125;</div><div class="line">		for(int i=0;i&lt;bitMap.length;i++)</div><div class="line">			if(bitMap[i]==true)</div><div class="line">				System.out.print(i);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字符串算法]]></title>
      <url>https://fudawei.github.io/2016/03/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h3><h4 id="字符串变形词"><a href="#字符串变形词" class="headerlink" title="字符串变形词"></a>字符串变形词</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 判断两个字符串是否互为变形词</div><div class="line"> * 如果str1和str2中出现的字符种类一样且每种字符出现的次数也一样,则互为变形词</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class SqureString &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(isDeformation(&quot;aannvv123a&quot;,&quot;aannvv123&quot;));</div><div class="line">	&#125;</div><div class="line">	public static boolean isDeformation(String str1,String str2)&#123;</div><div class="line">		char[] chas1 = str1.toCharArray();</div><div class="line">		char[] chas2 = str2.toCharArray();</div><div class="line">		// map[a]=b 代表字符编码为a的字符出现了b次</div><div class="line">		int[] map = new int[256];</div><div class="line">		for(int i=0;i&lt;chas1.length;i++)&#123;</div><div class="line">			map[chas1[i]]++;</div><div class="line">		&#125;</div><div class="line">		// 扫描str2的字符数组，若曾出现在str1的字符数组中则减1</div><div class="line">		for(int i=0;i&lt;chas2.length;i++)&#123;</div><div class="line">			map[chas1[i]]--;</div><div class="line">		&#125;</div><div class="line">		// 扫描结果数组，若出现不为0的位置则判断两个字符串不同</div><div class="line">		for(int i = 0;i&lt;map.length;i++)&#123;</div><div class="line">			if(map[i]!=0)</div><div class="line">				return false;</div><div class="line">		&#125;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="判断各字符是否只出现一次"><a href="#判断各字符是否只出现一次" class="headerlink" title="判断各字符是否只出现一次"></a>判断各字符是否只出现一次</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 判断各字符是否只出现一次</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class UniqueChar &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		System.out.println(isUnique(&quot;abcdaef&quot;));</div><div class="line">	&#125;</div><div class="line">	public static boolean isUnique(String str)&#123;</div><div class="line">		char[] chars = str.toCharArray();</div><div class="line">		if(chars == null)</div><div class="line">			return true;</div><div class="line">		boolean[] map = new boolean[256];</div><div class="line">		for(int i=0;i&lt;chars.length;i++)&#123;</div><div class="line">			if(map[chars[i]])</div><div class="line">				return false;</div><div class="line">			map[chars[i]]=true;</div><div class="line">		&#125;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="移除K个连续0字符"><a href="#移除K个连续0字符" class="headerlink" title="移除K个连续0字符"></a>移除K个连续0字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 移除K个连续0字符</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class RemoveKZero &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String result = removeKZero(&quot;A00B000C00D00&quot;, 2);</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line">	public static String removeKZero(String str,int k)&#123;</div><div class="line">		char[] chas = str.toCharArray();</div><div class="line">		int count=0,start=-1;</div><div class="line">		for(int i=0;i!=chas.length;i++)&#123;</div><div class="line">			if(chas[i]==&apos;0&apos;)&#123;</div><div class="line">				count++;</div><div class="line">				// 如果start为-1 则更新值，指向当前为0的位置；如果不为-1 则维持，由count记录0的个数</div><div class="line">				start = start==-1?i:start;</div><div class="line">			&#125;else&#123;</div><div class="line">				if(count==k)&#123;</div><div class="line">					while(count--!=0)</div><div class="line">						chas[start++]=0;</div><div class="line">				&#125;</div><div class="line">				count=0;</div><div class="line">				start=-1;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		// 检查一下count是否为K，如果为K,则去掉最后一组连续值</div><div class="line">		if(count==k)&#123;</div><div class="line">			while(count--!=0)</div><div class="line">				chas[start++]=0;</div><div class="line">		&#125;</div><div class="line">		return String.valueOf(chas);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 给定一个字符串和一个整数，把前k个字符整体移到右半区，右半区整体移到左半区</div><div class="line"> * eg: &quot;ABCDE&quot; ,size=3 调整为 &quot;DEABC&quot;</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class ReverseString &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		char[] ss =&quot;abacde&quot;.toCharArray();</div><div class="line">		rotate(ss, 3);</div><div class="line">		System.out.println(String.valueOf(ss));</div><div class="line">	&#125;</div><div class="line">	public static void rotate(char[] chas,int size)&#123;</div><div class="line">		if(chas == null || size &lt;=0 || size &gt;=chas.length)</div><div class="line">			return;</div><div class="line">		reverse(chas,0,size-1);</div><div class="line">		reverse(chas,size,chas.length-1);</div><div class="line">		reverse(chas,0,chas.length-1);</div><div class="line">	&#125;</div><div class="line">	public static void reverse(char[] chas,int start,int end)&#123;</div><div class="line">		char tmp=0;</div><div class="line">		while(start &lt; end)&#123;</div><div class="line">			tmp = chas[start];</div><div class="line">			chas[start] = chas[end];</div><div class="line">			chas[end] = tmp;</div><div class="line">			start ++;</div><div class="line">			end --;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="反转单词"><a href="#反转单词" class="headerlink" title="反转单词"></a>反转单词</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class RotateWord &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// char[] chas = &quot;dog loves pig&quot;.toCharArray();</div><div class="line">		char[] chas = &quot;one two three&quot;.toCharArray();</div><div class="line">		rotateWord(chas);</div><div class="line">		System.out.println(String.valueOf(chas));</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public static void rotateWord(char[] chas)&#123;</div><div class="line">	    // 先整体逆置，然后各个单词逆置</div><div class="line">		reverse(chas, 0, chas.length-1);</div><div class="line">		int start=-1,count=0;</div><div class="line">		for(int i=0;i&lt;chas.length;i++)&#123;</div><div class="line">		// start指向要移除的字符的开头，count记录反转的字符个数</div><div class="line">			if(chas[i]!=&apos; &apos;)&#123;</div><div class="line">				start=start==-1?i:start;</div><div class="line">				count++;</div><div class="line">			&#125;else&#123;</div><div class="line">				reverse(chas, start, start+count-1);</div><div class="line">				count=0;</div><div class="line">				start=-1;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		reverse(chas, start, start+count-1);</div><div class="line">	&#125;</div><div class="line">	// 反转字符串</div><div class="line">	public static void reverse(char[] chas,int start,int end)&#123;</div><div class="line">		char tmp=0;</div><div class="line">		while(start &lt; end)&#123;</div><div class="line">			tmp = chas[start];</div><div class="line">			chas[start] = chas[end];</div><div class="line">			chas[end] = tmp;</div><div class="line">			start ++;</div><div class="line">			end --;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[矩阵的加速乘法(斐波那契、台阶、农场母牛问题)]]></title>
      <url>https://fudawei.github.io/2016/03/07/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8A%A0%E9%80%9F%E4%B9%98%E6%B3%95-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E3%80%81%E5%8F%B0%E9%98%B6%E3%80%81%E5%86%9C%E5%9C%BA%E6%AF%8D%E7%89%9B%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="矩阵相乘的加速算法"><a href="#矩阵相乘的加速算法" class="headerlink" title="矩阵相乘的加速算法"></a>矩阵相乘的加速算法</h3><h4 id="实现复杂度为O-logN-的算法"><a href="#实现复杂度为O-logN-的算法" class="headerlink" title="实现复杂度为O(logN)的算法"></a>实现复杂度为O(logN)的算法</h4><blockquote>
<ul>
<li>给定整数N，返回斐波那契数列的第N项</li>
<li>一次可以跨2个或1个台阶，返回有多少种走法</li>
<li>农场成熟的母牛每年只会生一头小母牛，假设不死。第一年农场有一只成熟的母牛，从第二年开始，母牛生小母牛，每只小母牛3年之后成熟生小母牛，求N年之后牛的数量</li>
</ul>
</blockquote>
<h4 id="矩阵相乘算法"><a href="#矩阵相乘算法" class="headerlink" title="矩阵相乘算法"></a>矩阵相乘算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * F(n)=F(n-1)+F(n-2) 是一个二阶递推数列，一定可以用矩阵乘法的形式表示，且状态矩阵是2*2的矩阵</div><div class="line"> * 求出状态矩阵 [1,1][1,0] 而求矩阵N次方的问题是一个能够在O(logN)时间内解决的问题</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class MatrixAlgorithm &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[][] res = &#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;;</div><div class="line">		int p=3;</div><div class="line">		int[][] result = matrix(res,p);</div><div class="line">		for (int i = 0; i &lt; result.length; i++) &#123;</div><div class="line">			for (int j = 0; j &lt; result[0].length; j++) &#123;</div><div class="line">				System.out.print(result[i][j]+&quot; &quot;);</div><div class="line">			&#125;</div><div class="line">			System.out.println();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static int[][] matrix(int[][] res, int p) &#123;</div><div class="line">		int[][] result = new int[res.length][res[0].length];</div><div class="line">		for(int i=0;i&lt;res.length;i++)&#123;</div><div class="line">			result[i][i] = 1;</div><div class="line">		&#125;</div><div class="line">		int[][] tmp = res;</div><div class="line">		for(;p!=0;p&gt;&gt;=1)&#123;</div><div class="line">			if ((p &amp; 1) !=0) &#123;</div><div class="line">				res = getMatrix(res, tmp);</div><div class="line">			&#125;</div><div class="line">			tmp = getMatrix(tmp, tmp);</div><div class="line">		&#125;</div><div class="line">		return res;</div><div class="line">	&#125;</div><div class="line">	public static int[][] getMatrix(int[][] m1, int[][] m2) &#123;</div><div class="line">		int[][] result = new int[m1.length][m2[0].length];</div><div class="line">		for (int i = 0; i &lt; result.length; i++) &#123;</div><div class="line">			for(int j = 0;j &lt; result[0].length;j++)</div><div class="line">				result[i][j] = 0;</div><div class="line">		&#125;</div><div class="line">		for(int i = 0;i&lt;m1.length;i++)&#123;</div><div class="line">			for(int j = 0;j&lt;m2[0].length;j++)&#123;</div><div class="line">				for(int k=0;k&lt;m2.length;k++)&#123;</div><div class="line">					result[i][j] += m1[i][k] * m2[k][j];</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="斐波那契数列的O-logN）实现"><a href="#斐波那契数列的O-logN）实现" class="headerlink" title="斐波那契数列的O(logN）实现"></a>斐波那契数列的O(logN）实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class PeiBoNaQi &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(f3(5));</div><div class="line">	&#125;</div><div class="line">	public static int f3(int n)&#123;</div><div class="line">		if(n &lt; 1)</div><div class="line">			return 0;</div><div class="line">		if(n == 1 || n == 2)</div><div class="line">			return 1;</div><div class="line">		int[][] base = &#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;;</div><div class="line">		int[][] res = MatrixAlgorithm.matrix(base, n-3);</div><div class="line">		return res[0][0]+res[0][1];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="台阶问题的O-logN）实现"><a href="#台阶问题的O-logN）实现" class="headerlink" title="台阶问题的O(logN）实现"></a>台阶问题的O(logN）实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 根据上文所得，(s(n),s(n-1)) = ((s(2),s(1))*&#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;[n-2]</div><div class="line"> * 即    (2,1)*&#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;[n-2]</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class TaiJie &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(f3(5));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static int f3(int n) &#123;</div><div class="line">		if(n &lt; 1)</div><div class="line">			return 0;</div><div class="line">		if(n == 1 || n==2)</div><div class="line">			return n;</div><div class="line">		int[][] base = &#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;;</div><div class="line">		int[][] res = MatrixAlgorithm.matrix(base, n-3);</div><div class="line">		return 2*res[0][0]+res[0][1];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="母牛问题的O-logN）实现"><a href="#母牛问题的O-logN）实现" class="headerlink" title="母牛问题的O(logN）实现"></a>母牛问题的O(logN）实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 基数为(3,2,1)</div><div class="line">*/</div><div class="line">    public int c3(int n)&#123;</div><div class="line">		if(n&lt;1)</div><div class="line">			return 0;</div><div class="line">		if(n ==1 || n==2 || n==3)</div><div class="line">			return n;</div><div class="line">		int[][] base = &#123;&#123;1,1,0&#125;,&#123;0,0,1&#125;,&#123;1,0,0&#125;;</div><div class="line">		int[][] res = MatrixAlgorithm.matrix(base, n-4);</div><div class="line">		return 3*res[0][0] +2*res[1][0]+res[0][0];</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Map接口及子类总结]]></title>
      <url>https://fudawei.github.io/2016/03/05/Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%AD%90%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>转自 <a href="http://blog..hsuxu/article/details/7454172" target="_blank" rel="external">Hsuxu的专栏</a></p>
<h3 id="子接口"><a href="#子接口" class="headerlink" title="子接口"></a>子接口</h3><p>Bindings、ConcurrentMap、ConcurrentNavigableMap、MessageContext、LogicMessageContext、NavigableMap、SOAPMessageMap、SortedMap</p>
<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><p>AbstractMap, Attributes,AuthProvider, ConcurrentHashMap, EnumMap,ConcurrentSkipListMap,HashMap, Hashtable, IdentityHashMap,<br>LinkedHashMap, PrinterStateReasons,Properties,Provider, RenderingHints, SimpleBindings, TabularDataSupport,TreeMap,UIDefaults,<br>WeakHashMap</p>
<h3 id="方法定义说明"><a href="#方法定义说明" class="headerlink" title="方法定义说明"></a>方法定义说明</h3><p>put(K, V) ： 将给定的“键-值”对放入到给定的Map当中<br>putAll(Map&lt;? extends K, ? extends V) : 将指定的Map中的“键-值”对放入到给定的Map当中<br>remove(Object key) : 从该集合中移除指定的对象，并返回对应的value<br>clear() : 清空Map中的所有对象<br>int size() : 返回此Map中“键-值”对的个数<br>boolean isEmpty() : 判断此Map中“键-值”对的个数是否为0<br>boolean containsKey(Object key) : 测试此Map中是否有该key<br>boolean containsValue(Object value) : 测试此Map中是否包含该value<br>V get(Object key) : 通过指定的key查询Map中对应的value<br>Collection<object value=""> values() : 取得Map中所有的value<br>Set<object key=""> keySet() : 取得当前Map中key的集合<br>Set<entry<k, v="">&gt; entrySet() : 取得当前Map中entry的集合</entry<k,></object></object></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap 实现了Map、CloneMap、Serializable三个接口，并且继承自AbstractMap类。<br>HashMap 基于hash数组实现，若key的hash值相同则使用链表方式进行保存。Entry是一个结点，它持有下一个元素的引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static int indexFor(int h,int length)&#123;</div><div class="line">	return h &amp; (length-1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法是根据hashCode及当前table的长度得到该元素应该存放的位置，或者在table中的索引。<br>在HashMap中当数据量很多时，并且已经达到了负载限度时，会重新做一次哈希，也就是说会再散列。调用的方法为resize()<br>resize（再哈希）的工作量是不是很大啊。再哈希是重新建一个指定容量的数组，然后将每个元素重新计算它要放的位置<br>Q： 如何提高Hash表的性能 ？<br>比较重要的是HashMap的遍历方法,KeySet,EntrySet。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1.HashMap采用数组方式存储key，value构成的Entry对象，无容量限制。<br>2.HashMap基于key hash寻找Entry对象存放到数组的位置，对于Hash冲突采用链表的方式来解决。<br>3.HashMap在插入元素时可能要扩大数组的容量，扩大容量时对所有的数据要重新计算哈希和存放到新数组中。当元素个数size大于threshold扩容<br>threshold = (int)(newCapacity* loadFactor);<br>4.HashMap保证数组的大小为2的指数大小。<br>5.HashMap非线程安全。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap继承自HashMap并且实现了Map接口。和HashMap一样，LinkedHashMap允许key和value均为null。<br>如果你想在多线程中使用，那么需要使用Collections.synchronizedMap方法进行外部同步。<br>LinkedHashMap与HashMap的不同之处在于，LinkedHashMap维护着运行于所有条目的双向链接列表，此链接列表可以是插入顺序或者访问顺序。<br>重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上<br>又构成了双向链接列表<br>LinkedHashMap重写了init()方法，在调用父类的构造方法完成构造后，进一步实现了对其元素Entry的初始化操作（双向链表）<br>LinkedHashMap适合做LRU缓存。</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>如果要控制TreeMap中元素的存储顺序，应使用带Comparator参数的构造器。<br>put(K,V)<br>先判断root是否为null，如果为null，则创建一个新的Entry对象，并赋值给root属性。否则，首先判断是否传入了Compatator实现，如果是，则基于<br>红黑树的方式遍历，直到为树节点null，使用传入的comparator比较Key的大小，如果找到相等的key则更新其值，若没有找到相同的key，则创建一个<br>新的Entry对象，并将其parent设置为上面所寻找到的元素，并根据和parent key比较的情况设置parent的left和right属性。最后对红黑树进行调整。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap 是线程安全的HashMap实现。支持获取，查找时完全并发和更新时可调整并发的哈希表。获取操作（包括 get）通常不会受阻塞。<br>并发场景中(多个线程的情况下) ConcurrentHashMap 比HashMap优秀很多。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一张图看懂Java多线程]]></title>
      <url>https://fudawei.github.io/2016/03/05/%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%87%82Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="一张图看懂Java多线程"><a href="#一张图看懂Java多线程" class="headerlink" title="一张图看懂Java多线程"></a>一张图看懂Java多线程</h1><hr>
<p>转自 <a href="http://blog..hsuxu/article/details/7454172" target="_blank" rel="external">Hsuxu的专栏</a><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="java多线程"></p>
<blockquote>
<ul>
<li><p>Thread t = new Thread()，初始化一个线程，实际上就是一个普通对象，此时他的状态为New</p>
</li>
<li><p>t.start(); 线程处于就绪状态（可运行状态），也就是随时等待着运行， 不要小看这个start，这个start决定了他是否是一个真正的线程实例，因为start为其准备了线程环境，你若只是普通调用run方法，那么这就是 一个普通的方法。处在这个时候的线程，都会去竞争CPU资源，所以谁被竞争到了CPU资源，也就是被调度Scheduler，那么他就可以从可运行状态到 真正运行状态。</p>
</li>
<li><p>当线程获取到了CPU资源时，线程就从可运行状态到真正运行状态，也就是Running，不用怀疑，他现在正在运行。</p>
</li>
<li><p>如果这个线程正在等待客户输入学习，也就是IO异常，等各种阻塞事件，也有可能是自己调用了sleep或者join方法等阻塞事件，线程就会从运行状态转为阻塞状态，这个状态是不会发生任何事情的！</p>
</li>
<li><p>一旦阻塞事件被清除，比如用户已经输入完成，IO流已经关闭，sleep也已经超时，join()结束等，线程从阻塞状态变为就绪状态，又一次回到了可运行状态，随时与别的线程竞争资源，等待运行！</p>
</li>
<li><p>处于运行状态的线程可能会在运行当中遇到了同步方法或同步块，也就是synchronized标记的方法或块，这个时候该线程获到了对象的锁， 其他线程就无法进入该同步方法，那么这些无法执行的线程怎么办呢？他们就都阻塞在这里，等待锁的释放，从新去竞争锁资源，因为只有拥有锁的线程才有资格继 续往下运行，那么这里这些线程就阻塞在锁池（Lock Pool）。</p>
</li>
<li><p>一旦被阻塞在锁池的线程竞争到了锁（之前的线程运行完了或之前的线程在内部跑出来异常，或者调用了wait等，都会释放线程的锁），那么这个线 程就会从阻塞状态转为就绪状态，不要以为这个线程会立刻执行，这是不可能的，你要想到线程执行都是要获取到CPU资源的，如果没有操作系统的调度，他们都 没有资格运行！</p>
</li>
<li><p>处于运行状态的线程可能会在运行当中进入了同步方法或同步块，这个时候他拥有了对象的锁，至高无上，可是由于当前环境可能导致他没必要继续执 行，所以他会自己让出锁资源让别的线程也有机会继续执行，所以这个线程可能在synchronized内部调用所对象的wait方法，一旦调用，当前线程 让出锁资源，同时自己进入等待池（wait pool）中，直到被别的线程唤醒！如果没有被唤醒就一直会处在等待池当中，受到线程的阻塞，所以这个时候他们一心想要的是被唤醒，因为只有唤醒才有可能 继续运行！</p>
</li>
<li><p>一旦被阻塞在等待池的线程被唤醒（可能是某个synchronized的线程调用了notify或notifyAll，也可能是外部调用 interrupt导致内部抛出异常，也会获取到锁），那么这个线程就会从等待池转为锁池当中，继续阻塞，所以不要以为线程被唤醒就会继续运行，这是不可 能的，他们同样需要竞争锁资源。</p>
</li>
<li><p>线程运行过程中抛出异常，或者线程实在运行完了，那么线程就结束了，也就是消亡期。运行完了是不可以继续start的，必须从新new 一个线程才能start。那么将是有一个生命周期。</p>
</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最长公共子序列]]></title>
      <url>https://fudawei.github.io/2016/03/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 最长公共子序列问题</div><div class="line"> * 给定两个字符串str1和str2,返回两个字符串的最长公共子序列</div><div class="line"> * dp[i][j] 的值可能来自于三种情况</div><div class="line"> * 1.dp[i-1][j]</div><div class="line"> * 2.dp[i][j-1]</div><div class="line"> * 3.dp[i-1][j-1]+1</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class LongestCommonSequence &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		String str1=&quot;A23Ddfd4B56&quot;;</div><div class="line">		String str2=&quot;B1D2eCA45B6A&quot;;</div><div class="line">		System.out.println(lcse(str1,str2));</div><div class="line">	&#125;</div><div class="line">	public static int[][] getdp(char[] str1,char[] str2)&#123;</div><div class="line">		int[][] dp = new int[str1.length][str2.length];</div><div class="line">		dp[0][0] = str1[0]==str2[0]?1:0;</div><div class="line">		//dp第一列中，如果str1[i]==str2[0],令dp[i][0]=1,一旦dp[i][0]被设置为1，之后的dp[i+1...M-1][0]也都为1</div><div class="line">		for(int i=1;i&lt;str1.length;i++)&#123;</div><div class="line">			dp[i][0] = Math.max(dp[i-1][0], str1[i]==str2[0]?1:0);</div><div class="line">		&#125;</div><div class="line">		//dp第一行中，如果str1[0]==str2[j],令dp[0][j]=1,一旦dp[0][j]被设置为1，之后的dp[0][j+1...M-1]也都为1</div><div class="line">		for(int j=1;j&lt;str2.length;j++)&#123;</div><div class="line">			dp[0][j]=Math.max(dp[0][j-1], str1[0] == str2[j]?1:0);</div><div class="line">		&#125;</div><div class="line">		//dp[i][j]是 dp[i-1][j]、dp[i][j-1]、dp[i-1][j-1]+1中最大的值</div><div class="line">		for(int i=1;i&lt;str1.length;i++)&#123;</div><div class="line">			for(int j=1;j&lt;str2.length;j++)&#123;</div><div class="line">				dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);</div><div class="line">				if(str1[i] == str2[j])&#123;</div><div class="line">					dp[i][j] = Math.max(dp[i][j], dp[i-1][j-1]+1);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static String lcse(String str1,String str2)&#123;</div><div class="line">		char[] chs1 = str1.toCharArray();</div><div class="line">		char[] chs2 = str2.toCharArray();</div><div class="line">		int[][] dp = getdp(chs1, chs2);</div><div class="line">		int m = chs1.length-1;</div><div class="line">		int n = chs2.length-1;</div><div class="line">		char[] res = new char[dp[m][n]];</div><div class="line">		int index = res.length-1;</div><div class="line">		while(index &gt;=0)&#123;</div><div class="line">			//从右下角开始向左、向上、向左上方移动</div><div class="line">			if(n&gt;0 &amp;&amp; dp[m][n] == dp[m][n-1])</div><div class="line">				//说明之前在计算dp[i][j]的时候，dp[i-1][j-1]+1这个不是必须选择的，向上方移动</div><div class="line">				n--;</div><div class="line">			else if(m&gt;0 &amp;&amp; dp[m][n] == dp[m-1][n])</div><div class="line">				//说明之前在计算dp[i][j]的时候，dp[i-1][j-1]+1这个不是必须选择的，向左方移动</div><div class="line">				m--;</div><div class="line">			else&#123;</div><div class="line">				//说明之前在计算dp[i][j]的时候，dp[i-1][j-1]是必须选择的，向左上方移动</div><div class="line">				res[index--] = chs1[m];</div><div class="line">				m--;</div><div class="line">				n--;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return String.valueOf(res);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[动态规划(最长公共子串)]]></title>
      <url>https://fudawei.github.io/2016/03/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 最长公共子串</div><div class="line"> * dp[i][j] 的值只可能有两种情况</div><div class="line"> * 1.如果str1[i]!=str2[j],说明在必须把str1[i]和str2[j]当做公共子串最后一个字符是不可能的，令dp[i][j]=0</div><div class="line"> * 2.如果str1[i]==str2[j] 说明str1[i]和str2[j]可以作为公共子串的最后一个字符，所以令 dp[i][j] = dp[i-1][j-1]+1</div><div class="line"> */</div><div class="line">public class CommonString &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String str1=&quot;ABCE12F&quot;;</div><div class="line">		String str2=&quot;EAEEF&quot;;</div><div class="line">		char[] chs1 = str1.toCharArray();</div><div class="line">		char[] chs2 = str2.toCharArray();</div><div class="line">		int[][] dp = getDp(chs1,chs2);</div><div class="line">		int max=0;</div><div class="line">		for(int i = 0;i&lt;dp.length;i++)&#123;</div><div class="line">			for(int j = 0;j&lt;dp[i].length;j++)&#123;</div><div class="line">				if(max&lt;dp[i][j])</div><div class="line">					max = dp[i][j];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(max);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int[][] getDp(char[] chs1, char[] chs2) &#123;</div><div class="line">		int[][] dp = new int[chs1.length][chs2.length];</div><div class="line">		for(int i=0;i&lt;chs1.length;i++)&#123;</div><div class="line">			if(chs1[i]==chs2[0])</div><div class="line">				dp[i][0]=1;</div><div class="line">		&#125;</div><div class="line">		for(int j=0;j&lt;chs2.length;j++)&#123;</div><div class="line">			if(chs1[0] == chs2[j])</div><div class="line">				dp[0][j]=1;</div><div class="line">		&#125;</div><div class="line">		for(int i=1;i&lt;chs1.length;i++)&#123;</div><div class="line">			for(int j=1;j&lt;chs2.length;j++)&#123;</div><div class="line">				if(chs1[i] == chs2[j])</div><div class="line">					dp[i][j] = dp[i-1][j-1]+1;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础算法]]></title>
      <url>https://fudawei.github.io/2016/03/04/%E7%AE%97%E6%B3%95%E4%B8%80/</url>
      <content type="html"><![CDATA[<h3 id="裴波那契"><a href="#裴波那契" class="headerlink" title="裴波那契"></a>裴波那契</h3><p>36596<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 裴波那契</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class PeiBoNaQi &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		System.out.println(func(9));</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	private static int func(int i) &#123;</div><div class="line">		if(i==1 || i==2)</div><div class="line">			return 1;</div><div class="line">		else</div><div class="line">			return func(i-1)+func(i-2);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 裴波那契的非递归方法</div><div class="line">	private static int fibo(int n) &#123;</div><div class="line">		int[] dp = &#123;1,1,0&#125;;</div><div class="line">		for(int i=2;i&lt;n;i++)&#123;</div><div class="line">			dp[2] = dp[0]+dp[1];</div><div class="line">			dp[0] = dp[1];</div><div class="line">			dp[1] = dp[2];</div><div class="line">		&#125;</div><div class="line">		return dp[2];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="求解素数"><a href="#求解素数" class="headerlink" title="求解素数"></a>求解素数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Prime &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int count = 0;</div><div class="line">		for (int i = 101; i &lt; 200; i++) &#123;</div><div class="line">			if (isPrime(i)) &#123;</div><div class="line">				count++;</div><div class="line">				System.out.println(i);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(count);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	private static boolean isPrime(int i) &#123;</div><div class="line">		for (int j = 2; j &lt;= Math.sqrt(i); j++) &#123;</div><div class="line">			if (i % j == 0)</div><div class="line">				return false;</div><div class="line">		&#125;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="哥德巴赫猜想"><a href="#哥德巴赫猜想" class="headerlink" title="哥德巴赫猜想"></a>哥德巴赫猜想</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 哥德巴赫猜想</div><div class="line"> * 一个偶数总能表示为两个素数之和</div><div class="line"> */</div><div class="line">public class GeDeBaHeCaiXiang &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Scanner sc = new Scanner(System.in);</div><div class="line">		int n,i;</div><div class="line">		do &#123;</div><div class="line">			System.out.println(&quot;please input:\n&quot;);</div><div class="line">			n = sc.nextInt();</div><div class="line">		&#125; while (n&lt;2 || n%2!=0);</div><div class="line">		for(i=0;i&lt;n/2;i++)&#123;</div><div class="line">			int j = n-i;</div><div class="line">			if(isPrime(i) &amp;&amp; isPrime(j) &amp;&amp; i &lt;= j)&#123;</div><div class="line">				System.out.println(&quot;number is &quot;+i+&quot; and &quot;+j);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static boolean isPrime(int j) &#123;</div><div class="line">		boolean flag = true;</div><div class="line">		for(int i=2;i&lt;=Math.sqrt(j);i++)&#123;</div><div class="line">			if(j%i==0)&#123;</div><div class="line">				flag = false;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return flag;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class YangHuiSanJiao &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[][] arr = new int[15][15];</div><div class="line">		for(int i = 0;i&lt;15;i++)</div><div class="line">			for(int j = 0;j&lt;15;j++)&#123;</div><div class="line">				if(j==0||i-1==j)</div><div class="line">					arr[i][j]=1;</div><div class="line">			&#125;</div><div class="line">		for(int i = 2;i&lt;15;i++)</div><div class="line">			for(int j = 1;j&lt;i;j++)&#123;</div><div class="line">				arr[i][j]=arr[i-1][j-1]+arr[i-1][j];</div><div class="line">			&#125;</div><div class="line">		for(int i = 0;i&lt;15;i++)&#123;</div><div class="line">			for(int j = 0;j&lt;i;j++)&#123;</div><div class="line">				System.out.print(arr[i][j]+&quot; &quot;);</div><div class="line">			&#125;</div><div class="line">			System.out.println();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h3><p>/**</p>
<ul>
<li>最大公约数、最小公倍数</li>
<li>在循环中，只要除数不等于0，用较大数除以较小的数，将小的一个数作为下一轮循环的大数，取得的余数作为下一轮循环的较小的数，</li>
<li>如此循环直到较小的数的值为0，返回较大的数，此数即为最大公约数，最小公倍数为两数之积除以最大公约数<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class GCD &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Scanner sc = new Scanner(System.in);</div><div class="line">		int m = sc.nextInt();</div><div class="line">		int n = sc.nextInt();</div><div class="line">		int k = gcd(m, n);</div><div class="line">		System.out.println(&quot;公约数是 &quot;+k+&quot; 公倍数是 &quot;+m*n/k);</div><div class="line">	&#125;</div><div class="line">	private static int gcd(int m, int n) &#123;</div><div class="line">		int k = 0;</div><div class="line">		if(m &lt; n)&#123;</div><div class="line">			m = m ^ n;</div><div class="line">			n = n ^ m;</div><div class="line">			m = m ^ n;</div><div class="line">		&#125;</div><div class="line">		while(n!=0)&#123;</div><div class="line">			if(m==n)</div><div class="line">				return m;</div><div class="line">			else &#123;</div><div class="line">				k = m;</div><div class="line">				m = n;</div><div class="line">				n = k%n;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return m;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 分解质因数</div><div class="line"> * 	(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。</div><div class="line">	(2)如果n &lt;&gt; k，但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数你n,重复执行第一步。</div><div class="line">	(3)如果n不能被k整除，则用k+1作为k的值,重复执行第一步。</div><div class="line"> */</div><div class="line">public class FenJieZhiYinShu &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		Scanner sc = new Scanner(System.in);</div><div class="line">		int n = sc.nextInt();</div><div class="line">		int k = 2;</div><div class="line">		while (k &lt;= n) &#123;</div><div class="line">			if (k == n)&#123;</div><div class="line">				System.out.println(k);</div><div class="line">				break;</div><div class="line">			&#125;else if (n % k == 0) &#123;</div><div class="line">				System.out.print(k + &quot;*&quot;);</div><div class="line">				n /= k;</div><div class="line">			&#125;else</div><div class="line">				k++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1的个数"><a href="#1的个数" class="headerlink" title="1的个数"></a>1的个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">while(sc.hasNext())&#123;</div><div class="line">			int num = sc.nextInt();</div><div class="line">			while(num!=0)&#123;</div><div class="line">				num = num &amp; (num-1);</div><div class="line">				count++;</div><div class="line">			&#125;</div><div class="line">			System.out.println(count);</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h3 id="整数的N次方"><a href="#整数的N次方" class="headerlink" title="整数的N次方"></a>整数的N次方</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static double powerWithUnsignedExponent(double base, int exponent) &#123;</div><div class="line">		if(exponent==0)</div><div class="line">			return 1;</div><div class="line">		if(exponent==1)</div><div class="line">			return base;</div><div class="line">		double result = powerWithUnsignedExponent(base, exponent&gt;&gt;1);</div><div class="line">		result *= result;</div><div class="line">		if((exponent &amp; 0x1)==1)</div><div class="line">			result *= base;</div><div class="line">		return result;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="从1打印到N组成的数字"><a href="#从1打印到N组成的数字" class="headerlink" title="从1打印到N组成的数字"></a>从1打印到N组成的数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Print1ToMxt &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		 Print1ToMax(5);</div><div class="line">	&#125;</div><div class="line">	public static void Print1ToMax(int n)&#123;</div><div class="line">		if(n &lt;= 0)</div><div class="line">			return ;</div><div class="line">		int[] arr = new int[n];</div><div class="line">		for(int i=0;i&lt;10;i++)&#123;</div><div class="line">			arr[0]=i;</div><div class="line">			printRecursively(arr,n,0);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private static void printRecursively(int[] arr, int length, int index) &#123;</div><div class="line">		if(index == length-1)&#123;</div><div class="line">			print(arr);</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		for(int i=0;i&lt;10;i++)&#123;</div><div class="line">			arr[index+1]=i;</div><div class="line">			printRecursively(arr, length, index+1);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private static void print(int[] arr) &#123;</div><div class="line">		for(int i=0;i&lt;arr.length;i++)&#123;</div><div class="line">			System.out.print(arr[i]);</div><div class="line">		&#125;</div><div class="line">		System.out.println();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[约瑟夫两种解法(数组和链表)]]></title>
      <url>https://fudawei.github.io/2016/03/04/%E7%BA%A6%E7%91%9F%E5%A4%AB%E4%B8%A4%E7%A7%8D%E8%A7%A3%E6%B3%95-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，</div><div class="line"> * 问最后留下的是原来第几号的那位</div><div class="line"> */</div><div class="line">public class YueSeFu &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Scanner s = new Scanner(System.in);</div><div class="line">		System.out.println(&quot;please input :\n&quot;);</div><div class="line">		int n = s.nextInt();</div><div class="line">		boolean[] arr = new boolean[n];</div><div class="line">		for(int i=0; i&lt;arr.length; i++) &#123;</div><div class="line">			arr[i] = true;</div><div class="line">		&#125;</div><div class="line">		int leftCount = n;</div><div class="line">		int countNum = 0;</div><div class="line">		int index = 0;</div><div class="line">		while(leftCount &gt; 1) &#123;</div><div class="line">			if(arr[index] == true) &#123;</div><div class="line">				countNum ++;</div><div class="line">				if(countNum == 3) &#123;</div><div class="line">					countNum =0;</div><div class="line">					arr[index] = false;</div><div class="line">					leftCount --;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			index ++;</div><div class="line">			if(index == n) &#123;</div><div class="line">				index = 0;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		for(int i=0; i&lt;n; i++) &#123;</div><div class="line">			if(arr[i] == true) &#123;</div><div class="line">				System.out.println(&quot;原排在第&quot;+(i+1)+&quot;位的人留下了。&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class JoseRing &#123;</div><div class="line">	static class Node &#123;</div><div class="line">		public int data;</div><div class="line">		public Node next;</div><div class="line">		public Node(int data) &#123;</div><div class="line">			this.data = data;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Node first = new Node(1);</div><div class="line">		Scanner scanner = new Scanner(System.in);</div><div class="line">		int n = scanner.nextInt();</div><div class="line">		int m = scanner.nextInt();</div><div class="line">		//first.next = first;</div><div class="line">		Node p = first;</div><div class="line">		for (int i = 2; i &lt;= n; i++) &#123;</div><div class="line">			Node temp = new Node(i);</div><div class="line">			//temp.next = p;</div><div class="line">			p.next = temp;</div><div class="line">			p = p.next;</div><div class="line">		&#125;</div><div class="line">		p.next = first;</div><div class="line">		while(p != p.next)</div><div class="line">        &#123;</div><div class="line">            //下面for循环后，p是第m个结点的前一个结点</div><div class="line">            for(int i=1; i&lt;m; i++)</div><div class="line">                p = p.next;</div><div class="line">            //删除第m个结点</div><div class="line">            System.out.print(p.next.data+&quot; &quot;);</div><div class="line">            p.next = p.next.next;</div><div class="line">        &#125;</div><div class="line">        System.out.print(&quot;\n幸运者是:&quot;+p.data);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程学习笔记]]></title>
      <url>https://fudawei.github.io/2016/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="查询CPU核数和线程数"><a href="#查询CPU核数和线程数" class="headerlink" title="查询CPU核数和线程数"></a>查询CPU核数和线程数</h3><p>grep ‘processor’ /proc/cpuinfo | sort -u | wc -l<br>grep ‘core id’ /proc/cpuinfo | sort -u | wc -l</p>
<h3 id="线程组和线程池的区别"><a href="#线程组和线程池的区别" class="headerlink" title="线程组和线程池的区别"></a>线程组和线程池的区别</h3><p>线程组是为了方便线程的管理，线程池是为了管理线程的生命周期，复用线程，减少创建、销毁线程的开销。<br>守护线程，可以简单理解为后台运行线程，进程结束，守护线程自然而然就会结束。JVM的垃圾回收，内存管理等都是守护线程。<br>调用线程对象的setDaemon(true)则可以将其设置为守护线程<br>注意：JRE 判断程序是否执行结束的标准是所有的前台执行线程执行完毕了，而不管后台线程的状态。<br>当使用Threadlocal维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本。<br>JMM(Java Memory Model) 内存管理模型<br>隐式锁的应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public synchronized void methodA();   // 同步方法</div><div class="line">public void methodA(); synchronized(this);  // 同步代码块</div></pre></td></tr></table></figure></p>
<h3 id="Lock-与-synchronized-区别："><a href="#Lock-与-synchronized-区别：" class="headerlink" title="Lock 与 synchronized 区别："></a>Lock 与 synchronized 区别：</h3><p>Lock 使用起来比较灵活，但是必须有释放锁的动作配合<br>Lock 必须手动释放和开启锁，而 synchronized 不需要手动释放和开启锁<br>Lock  只适用于代码块锁，而 synchronized 对象之间是互斥关系</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ConcurrentHashMap&lt;String, Integer&gt; map = new ConcurrentHashMap&lt;String,Integer&gt;();</div><div class="line">for (Map.Entry&lt;String,Integer&gt; entry : map.entrySet()) &#123;</div><div class="line">			System.out.println(entry.getKey() + &quot; = &quot; +entry.getValue());</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Java 线程池实现了一个Java高并发的、java多线程的、可管理的统一调度器Executors是个线程的工厂类，提供了一些静态方法，生成线程池常用方法三种：</li>
</ul>
<ol>
<li>newSingleThreadExecutor  创建一个单线程的线程池</li>
<li>newFieedThreadPool 创建固定大小的线程池</li>
<li>newCachedThreadPool 创建一个可缓存的线程池</li>
</ol>
<ul>
<li>线程安全的集合类 ：<br>Set : CopyOnWriteArraySet<br>List : CopyOnWriteArrayList   Vector(synchronized方法修饰)<br>Map : Hashtable(synchronized方法修饰)   ConcurrentMap -&gt; ConcurrentHashMap</li>
</ul>
</blockquote>
<h3 id="Runnable和Thread的区别"><a href="#Runnable和Thread的区别" class="headerlink" title="Runnable和Thread的区别"></a>Runnable和Thread的区别</h3><p>只要是多线程肯定永远以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类有如下好处<br>1.避免单继承的局限，一个类可以实现多个接口<br>2.适合资源的共享</p>
<p>synchronized 可以在任意对象及方法上加锁<br>虽然println() 在内部是同步的，但i–的操作是在进入println()之前发生的，所以有发生非线程安全问题的概率。<br>MyThread.java 类的构造函数是被main线程调用的，而run方法是被名为Thread-0 的线程调用的，run方法是自动调用的方法。</p>
<p>java中有3种方法可以终止正在运行的线程：<br>1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止<br>2.使用stop方法强行终止线程，不推荐，使用它们可能产生不可预料的结果<br>3.使用interrupt方法中断线程</p>
<p>调用interrupte() 方法仅仅是在当前线程中打了一个停止的标记。</p>
<h3 id="interrupted-amp-amp-isInterrupted？"><a href="#interrupted-amp-amp-isInterrupted？" class="headerlink" title="interrupted &amp;&amp; isInterrupted？"></a>interrupted &amp;&amp; isInterrupted？</h3><p>1.this.interrupted() 测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false功能<br>2.this.isInterrupted()  测试线程Thread对象是否已经是中断状态，但不清楚状态标识。</p>
<p>当进程中不存在非守护线程了，则守护线程自动销毁。典型的守护线程就是垃圾回收线程。<br>只有当最后一个非守护线程结束时，守护线程才随着JVM一同结束工作。<br>调用synchronized方法一定是排队运行的; 另外，只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本没有同步的必要。</p>
<p>当A线程调用anyObject对象调用synchronized方法修饰的X方法时，A线程就获得了X方法所在<strong>对象的锁</strong>，所以其他线程必须等A线程执行完毕才可以调用X方法，但B线程可以调用其他的非synchronized同步方法。<br>而B线程如果调用了synchronized修饰的<strong>非X方法</strong>时，必须等到A线程将X方法执行完，也就是释放对象锁之后才可以调用。</p>
<p>synchronized锁重入（自己可以再次获取自己的内部锁）<br>当一个线程得到一个对象锁后，再次请求此对象锁时可以再次得到该对象的锁。<br>这也证明在一个synchronized方法/块的内部调用本类的其他synchronized方法时，是永远可以得到锁的。</p>
<p>当存在父子类继承关系时，子类是完全可以通过“可重入锁”调用父类的同步方法的。<br>出现异常的锁被自动释放了。<br>同步不能继承。所以还得在子类的方法中添加synchronized关键字<br>同步synchronized是锁定当前对象的。</p>
<p>锁非this对象具有一定的优点：如果在一个类中有很多个 synchronized 方法，这时虽然能实现同步，但会受到阻塞，影响运行效率；但如果使用同步代码块<br>锁非this对象，则 synchronized(非this)代码块中的程序与同步方法是异步的，不与其他锁this同步方法争抢this锁，可以大大提高运行效率。</p>
<p>synchronized 关键字加到static静态方法上是给Class上锁(加锁之后若其他线程只需要对象锁也不能获取到必须等待)，而 synchronized加到非static<br>静态方法上是给对象上锁。</p>
<p>若字符串作为锁，涉及到常量池，导致两个线程持有相同的锁，其中一个线程不能运行<br>volatile 的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值<br>volatile 关键字增加了实例变量在多个线程之间的可见性。但缺点是不支持原子性。</p>
<h3 id="synchronized和volatile区别"><a href="#synchronized和volatile区别" class="headerlink" title="synchronized和volatile区别"></a>synchronized和volatile区别</h3><p>1.volatile属于线程同步逇轻量级实现，性能好。只能修饰变量，synchroinzed可以修饰方法及代码块。<br>2.多线程访问volatile不会阻塞，而synchronized会发生阻塞<br>3.volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存数据同步</p>
<p>线程安全包含原子性和可见性两个方面，java的同步机制都是围绕这两个方面来确保线程安全的。<br>除了在i++操作时使用synchronized关键字实现同步，还可以使用 AtomicInteger 原子类进行实现（java.util.concurrent.atomic.AtomicInteger）。</p>
<p>方法 boolean hasQueuedThread(Thread thread) 查询指定的线程是否正在等待获取此锁定<br>方法 boolean hasQueuedThreads()  查询是否有线程正在等待获取此锁定<br>方法 boolean hasWaiters(Condition condition)  查询是否有线程正在等待与此锁定有关的condition条件<br>eg： service.lock.hasQuedThread(threadA)    lock.hasWaiters(newCondition)   lock.getWaitQueueLength(newCondition)</p>
<h3 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h3><p>t1想中断t2的话只需要在线程t1中将线程t2对象的中断标志设置为true,然后线程2可以选择在合适的时候处理该中断请求，甚至可以不理会该请求。</p>
<h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void set(T value) &#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        // 获得一个和当前线程相关的ThreadLocalMap</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        if (map != null)</div><div class="line">        	// ThreadLocalMap 是ThreadLocal类的一个静态内部类，实现了键值对的获取</div><div class="line">        	// 键是this对象指向的ThreadLocal对象</div><div class="line">            map.set(this, value);</div><div class="line">        else</div><div class="line">            createMap(t, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public T get() &#123;</div><div class="line">Thread t = Thread.currentThread();</div><div class="line">ThreadLocalMap map = getMap(t);</div><div class="line">if (map != null) &#123;</div><div class="line">    ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">    if (e != null)</div><div class="line">        return (T)e.value;</div><div class="line">&#125;</div><div class="line">return setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进一步的，我们可以创建不同的ThreadLocal实例来实现多个变量在不同线程间的访问隔离，因为不同的ThreadLocal对象作为不同键，当然也可以在线程的ThreadLocalMap对象中设置不同的值了。</p>
<blockquote>
<p>ThreadLocal在处理线程的局部变量的时候比synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性<br>注意： 使用ThreadLocal，一般都是声明在静态变量中，如果不断的创建ThreadLocal而且没有调用其remove方法，将会导致内存泄漏，特别实在高并发的web容器中。</p>
</blockquote>
<h3 id="线程的异常处理"><a href="#线程的异常处理" class="headerlink" title="线程的异常处理"></a>线程的异常处理</h3><p>thread.setUncaughtExceptionHandler 语句来实现逻辑的注册<br>UncaughtExceptionHandler是一个接口，异常处理对象需要实现这个接口才能处理异常<br>对于checked exception 推荐try/catch 块来处理；对于unchecked exception,注册一个实现UncaughtExceptionHandler接口对象该实例来处理。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList 中的set,add,remove等方法，都使用了ReentrantLock的lock来加锁，unlock来解锁。当增加元素的时候用Arrays.copyOf()拷贝副本，在副本上增加元素，然后改变原引用指向副本。读操作不需要加锁，而写操作类实现中对其进行了加锁。因此CopyOnWriteArrayList是一个线程安全的List接口的实现，可以提供高并发读取。<br>CopyOnWrite 机制也是一种读写分离的思想<br><strong>CopyOnWrite缺点：1）内存占用问题，回收。   2）数据一致性问题，只能保证最终一致性，不能保证实时一致性</strong></p>
<h3 id="线程阀"><a href="#线程阀" class="headerlink" title="线程阀"></a>线程阀</h3><h4 id="阻塞队列-BlockingQueue"><a href="#阻塞队列-BlockingQueue" class="headerlink" title="阻塞队列 BlockingQueue"></a>阻塞队列 BlockingQueue</h4><p>支持两个附加操作的队列，在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，存储元素的线程会等待队列可用。<br>包括 DelayQueue/ArrayBlockingQueue/LinkedBlockingQueue/LinkedBlockingQueue/SynchronousQueue/PriorityBlockingQueue/LinkedBlockingDeque<br>ArrayBlockingQueue 是一个由数组支持的有界的阻塞队列。<br>LinkedBlockingQueue是基于链表的阻塞队列，对于生产者和消费者分别采用了独立的锁来控制数据同步。若构造对象的时候没有指定初始化大小，默认一个类似无限大小的容量。<br>PriorityBlockingQueue 是一个支持优先级排序的无界阻塞队列，它并不会阻塞数据生产者只会在没有可消费的数据时，阻塞数据的消费者</p>
<p>SynchronousQueue 同步队列是一个不存储元素的阻塞队列，每一个put操作必须等待一个take操作，否则不能继续添加元素。<br>CountDownLatch同步计数器：在完成一组正在其他线程中执行的操作之前，允许一个或多个线程一直等待，用给定的计数初始化CountDownLatch，由于调用了countDown方法，所以在当前计数器到达零之前，await方法会一直受阻塞，之后，会释放所有等待的线程，await的所有后续调用都立即返回。<br>使用场景： 同时当线程都完成后触发事件事件。比如：开5个多线程去下载，当5个线程都执行完了才算下载成功。</p>
<blockquote>
<p>ReentrantLock、CountDownLatch、Semaphore、FutureTask、ThreadPoolExecutor都会发现有个叫Sync的静态内部类，继承自AbstractQueuedSynchronizer。AbstractQueuedSynchronizer是java.util.concurrent的核心组件之一，它为并发包中的其他synchronizers提供了一组公共的基础设施。<br>Semaphore 是一个计数信号量，信号量维护了一个许可集合，在许可可用前会阻塞每一个acquire，然后再获取该许可，每个release添加一个许可，从而可能释放一个正在阻塞的获取者。</p>
</blockquote>
<p>线程池任务拒绝策略： 直接丢弃任务 不用线程池线程运行  丢弃队列中最旧任务 抛出异常<br>线程池一定要在合理的单例模式下才有效。<br>在某些情况情况下，可以简单的抛弃请求，依靠更高级别的协议稍后重试请求，也可以指出服务器暂时很忙的响应来拒绝请求。</p>
<h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(int i=0;i&lt;arr.length-1;i++)&#123;</div><div class="line">			for(int j=0;j&lt;arr.length-i-1;j++)&#123;</div><div class="line">				if(compareArr(arr[j],arr[j+1]) &gt; 0)&#123;</div><div class="line">					swap(arr,j,j+1);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h3 id="线程监控工具"><a href="#线程监控工具" class="headerlink" title="线程监控工具"></a>线程监控工具</h3><p>VisualVM 是JDK的一个集成的分析工具，监控应用程序的性能和内存占用情况、监控线程进行线程转储(Thread Dump)或堆转储(Heap Dump)<br>在线程一栏中，四种状态，其中监视(Monitor)表示线程想执行一端synchronized中的代码，但是发现其他线程正在执行，被block等待<br>有时候需要生产线程Dump进行那个时刻的线程分析，点击线程Dump即可生产Dump文件。可以在java VisualVM工具里面安装JTA插件，分析线程dump文件。正常阶段的dump文件与非正常的dump文件比较更容易分析问题。<br>使用JConsole进行应用程序性能监控<br>jmc(Oracle Java Mission Console)提供监控和分析</p>
<h3 id="linux线程分析监控"><a href="#linux线程分析监控" class="headerlink" title="linux线程分析监控"></a>linux线程分析监控</h3><p>获取进程ID之后(top -p 8442 -H) 用jstack打印出给定的java进程ID或core file或远程调试服务的java堆栈信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstack 8442 &gt; ./8442_dump.txt</div></pre></td></tr></table></figure></p>
<h3 id="Eclipse-里面调试并发程序"><a href="#Eclipse-里面调试并发程序" class="headerlink" title="Eclipse 里面调试并发程序"></a>Eclipse 里面调试并发程序</h3><p>默认情况下，Eclipse调试的时候debugger找到断点，只是把有断点的线程停止，其他线程都在继续他们的运行。<br>Window-&gt;preference 把 Default suspend policy for new breakpoints 改为 Suspend VM ,这样遇到断点就会暂停所有线程的运行</p>
<blockquote>
<p>利用Badboy或者Jmeter进行服务器抗压能力的测试</p>
</blockquote>
<h3 id="内存溢出三种情况"><a href="#内存溢出三种情况" class="headerlink" title="内存溢出三种情况"></a>内存溢出三种情况</h3><ol>
<li>堆溢出。解决：手动设置JVM Heap 的大小</li>
<li>永久代溢出。 设置永久代大小</li>
<li>栈溢出。优化程序，或者通过-Xss来设置每个线程的栈大小</li>
</ol>
<h3 id="ReentrantReadWriteLock-读写锁有两个锁，一个是读操作相关的锁，也成为共享锁-另一个是写操作相关的锁，也叫排它锁。多个Thread可以同时进行读取"><a href="#ReentrantReadWriteLock-读写锁有两个锁，一个是读操作相关的锁，也成为共享锁-另一个是写操作相关的锁，也叫排它锁。多个Thread可以同时进行读取" class="headerlink" title="ReentrantReadWriteLock 读写锁有两个锁，一个是读操作相关的锁，也成为共享锁;另一个是写操作相关的锁，也叫排它锁。多个Thread可以同时进行读取"></a>ReentrantReadWriteLock 读写锁有两个锁，一个是读操作相关的锁，也成为共享锁;另一个是写操作相关的锁，也叫排它锁。多个Thread可以同时进行读取</h3><p>操作，但是同一时刻只允许一个Thread进行写入操作。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池处理流程"><a href="#线程池处理流程" class="headerlink" title="线程池处理流程"></a>线程池处理流程</h4><ol>
<li>如果当前运行的线程少于corePoolSize,则创建新线程来执行任务（执行这一步骤需要获取全局锁）</li>
<li>如果运行的线程等于或多于corePoolSize,则将任务加入BlockingQueue</li>
<li>如果无法将任务加入BlockingQueue(队列已满)，则创建新的线程来处理任务u（需要获取全局锁你）</li>
<li>如果创建新线程将使得当前运行的线程超出maximumPoolSize,任务将被拒绝。<blockquote>
<p>在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤</p>
<h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4></blockquote>
</li>
<li>ArrayBlockingQueue 是一个基于数组结构的有界阻塞队列，此队列按FIFO原则对元素进行排序</li>
<li>LinkedBlockingQueue 一个基于链表结构的阻塞队列FIFO排序元素，静态工厂方法Executors.newFixedThreadPool()使用这个队列</li>
<li>SynchronousQueue 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，静态工厂方法 Executors.newCachedThreadPool使用了这个队列</li>
<li>PriorityBlockingQueue 一个具有优先级的无限阻塞队列<h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4></li>
<li>AbortPolicy 直接抛出异常</li>
<li>CallerRunsPolicy 只用调用者所在线程来运行任务</li>
<li>DiscardOldestPolicy 丢弃队列最近的一个任务，并执行当前任务</li>
<li><p>DiscardPolicy 不处理，丢弃</p>
<h4 id="execute-amp-amp-submit-区别"><a href="#execute-amp-amp-submit-区别" class="headerlink" title="execute &amp;&amp; submit 区别"></a>execute &amp;&amp; submit 区别</h4><p>execute() 方法用于提交不需要返回值的任务</p>
<ul>
<li><p>submit()方法用于提交需要返回值的任务 ，返回一个future对象，通过future的get()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">threadPool.execute(new Runnable()&#123;</div><div class="line">   public void run()&#123; ... &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>方法来获取返回值，get方法会阻塞当前线程一段时间后立即返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Future&lt;Object&gt; future = executor.submit(harrReturnValuetask);</div><div class="line">Object s = future.get();</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="shutdown-amp-amp-shutdownNow-区别"><a href="#shutdown-amp-amp-shutdownNow-区别" class="headerlink" title="shutdown &amp;&amp; shutdownNow 区别"></a>shutdown &amp;&amp; shutdownNow 区别</h3><ul>
<li>shutdownNow 首先将线程池的状态设置为STOF，然后尝试停止所有的正在执行或暂停执行的线程，并返回等待执行任务的列表</li>
<li>shutdown 只是将线程池的状态设置为SHUTDOWN状态，然后中断所有没有正在执行的线程</li>
</ul>
<blockquote>
<p>编译器优化重排序和处理器冲排序会导致多线程出现内存可见性问题<br>两个操作之间具有happens-before关系，并不意味这前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作对后一个操作可见。</p>
</blockquote>
<h3 id="Thread-join的使用"><a href="#Thread-join的使用" class="headerlink" title="Thread.join的使用"></a>Thread.join的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        Thread previous = Thread.currentThread();</div><div class="line">        for(int i=0;i&lt;10;i++)&#123;</div><div class="line">            Thread t = new Thread(new TestA(previous),String.valueOf(i));</div><div class="line">            t.start();</div><div class="line">            previous = t;</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName()+&quot; terminated!&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="游标的使用"><a href="#游标的使用" class="headerlink" title="游标的使用"></a>游标的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Declare cursor CURSOR for</div><div class="line">select stuID from student</div><div class="line">open cursor</div><div class="line">fetch next from cursor</div><div class="line">while @@fetch_status =0</div><div class="line">begin</div><div class="line">if (@ID=15)</div><div class="line">	delete from student where id=@ID</div><div class="line">	fetch next from cursor into @ID</div><div class="line">end</div><div class="line">close cursor</div><div class="line">deallocate cursor</div></pre></td></tr></table></figure>
<h3 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h3><p>TCP是传输控制协议，提供的面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。<br>TCP提供超时重发、丢弃重复数据、校验数据、流量控制等功能，保证数据能从一端传到另一端。<br>UDP是用户数据报协议，无连接的面向数据包的传输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据包发送出去，但是并不保证他们能到达目的地。由于UDP在传输数据前不需要建立链接，且没有超时重发机制，所以传输速度快。</p>
<h3 id="编写Socket套接字"><a href="#编写Socket套接字" class="headerlink" title="编写Socket套接字"></a>编写Socket套接字</h3><p>调用socket()创建一个套接字，调用bind()绑定IP地址和端口，然后启动一个死循环，循环中调用accept接受链接。对于每个接受的连接，可以启动多线程<br>方式进行处理，在线程中调用send(),recv()发送和接受数据。客户端只需要调用socket()创建套接字，连接服务器，就可以发送和接受数据了。</p>
<h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><p>SQL注入攻击 就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串中，欺骗服务器执行恶意的SQL命令。在某些表单中，用户输入的内容<br>直接用来构造动态SQL命令，或作为存储过程的输入参数。<br>防范SQL注入攻击：替换单引号，连字符   检查用户输入的合法性    将用户登录名称密码等数据加密保存   存储过程执行所有的查询</p>
<h3 id="数据库四范式"><a href="#数据库四范式" class="headerlink" title="数据库四范式"></a>数据库四范式</h3><p>1NF  所有属性值域中每一个值都是不可再分解的值<br>2NF  如果关系模式R为第一范式，并且R中每一个非主属性完全函数依赖于R的某个候选键<br>3NF  如果关系模式R是第二范式，且每个非主属性都不传递依赖于R的候选键<br>BCNF 如果关系模式R是第一范式，且每个属性都不传递依赖于R的候选键，那么成R为BCNF的模式</p>
<p>死锁的4个必要条件是： 互斥 请求与保持  不剥夺条件  循环等待条件</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语法]]></title>
      <url>https://fudawei.github.io/2016/01/17/Markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">* hello world           *代表项目编号</div><div class="line">``` System.out.println()</div><div class="line">```                      代码风格</div><div class="line">[on GitHub](https://github.com/jbt/markdown-editor)  超链接</div><div class="line">[StackEdit][6]   [6]: https://github.com/benweet/stackedit    超链接</div><div class="line">- **hello world**   **xxx** 加粗 等同于 ctrl+B,斜体 ctrl+I</div><div class="line"> - 加粗    `Ctrl + B`</div><div class="line"> - 斜体    `Ctrl + I`</div><div class="line"> - 引用    `Ctrl + Q`</div><div class="line"> - 插入链接    `Ctrl + L`</div><div class="line"> - 插入代码    `Ctrl + K`</div><div class="line"> - 插入图片    `Ctrl + G`</div><div class="line"> - 提升标题    `Ctrl + H`</div><div class="line"> - 有序列表    `Ctrl + O`</div><div class="line"> - 无序列表    `Ctrl + U`</div><div class="line"> - 横线    `Ctrl + R`</div><div class="line"> - 撤销    `Ctrl + Z`</div><div class="line"> - 重做    `Ctrl + Y`</div><div class="line"></div><div class="line">表格</div><div class="line">项目  |  价格  | 总结</div><div class="line">------|--------| -------</div><div class="line">使用冒号对齐</div><div class="line">| :-------- | --------:| :--: |</div><div class="line">项目1</div><div class="line">	定义A     : 定义A</div><div class="line">hello world [^footnote]  生成脚注</div><div class="line">[TOC]  生成目录</div><div class="line">公式 $$E=mc^2$$</div><div class="line"></div><div class="line">```flow                 --流程图</div><div class="line">st=&gt;start: Start</div><div class="line">op=&gt;operation: Your Operation</div><div class="line">cond=&gt;condition: Yes or No?</div><div class="line">e=&gt;end</div><div class="line"></div><div class="line">st-&gt;op-&gt;cond</div><div class="line">cond(yes)-&gt;e</div><div class="line">cond(no)-&gt;op</div></pre></td></tr></table></figure>
<p><del>helloworld</del> 删除线</p>
<p>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DesignPattern]]></title>
      <url>https://fudawei.github.io/2016/01/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="设计模式学习笔记"><a href="#设计模式学习笔记" class="headerlink" title="设计模式学习笔记"></a>设计模式学习笔记</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class SchoolGirl &#123;</div><div class="line">	private String name;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>接口（代理类和真实类实现同一个接口，代理持有一个真实类对象的引用，具体实现由真实类完成）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface GiveGift &#123;</div><div class="line">	void GiveDolls();</div><div class="line">	void GiveFlowers();</div><div class="line">	void GiveChocolate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>真实类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Pursuit implements GiveGift&#123;</div><div class="line">	SchoolGirl mm;</div><div class="line">	public Pursuit(SchoolGirl mm) &#123;</div><div class="line">		this.mm = mm;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void GiveDolls() &#123;</div><div class="line">		System.out.println(&quot;give dolls&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void GiveFlowers() &#123;</div><div class="line">		System.out.println(&quot;give flowers&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void GiveChocolate() &#123;</div><div class="line">		System.out.println(&quot;give cholocate&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Proxy implements GiveGift &#123;</div><div class="line">	Pursuit gg;</div><div class="line">	public Proxy(SchoolGirl mm) &#123;</div><div class="line">		this.gg = new Pursuit(mm);   //代理类就是持有一个真实类的引用</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void GiveDolls() &#123;</div><div class="line">		gg.GiveDolls();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void GiveFlowers() &#123;</div><div class="line">		gg.GiveFlowers();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void GiveChocolate() &#123;</div><div class="line">		gg.GiveChocolate();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SchoolGirl jiaojiao = new SchoolGirl();</div><div class="line">		jiaojiao.setName(&quot;jiaojiao&quot;);</div><div class="line">		Proxy daili = new Proxy(jiaojiao);</div><div class="line">		daili.GiveChocolate();</div><div class="line">		daili.GiveFlowers();</div><div class="line">		daili.GiveDolls();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">public class Operation &#123;</div><div class="line">	public double numberA=0;</div><div class="line">	public double numberB=0;</div><div class="line"></div><div class="line">	public double getNumberA() &#123;</div><div class="line">		return numberA;</div><div class="line">	&#125;</div><div class="line">	public void setNumberA(double numberA) &#123;</div><div class="line">		this.numberA = numberA;</div><div class="line">	&#125;</div><div class="line">	public double getNumberB() &#123;</div><div class="line">		return numberB;</div><div class="line">	&#125;</div><div class="line">	public void setNumberB(double numberB) &#123;</div><div class="line">		this.numberB = numberB;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public double GetResult()&#123;</div><div class="line">		double result=0;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class OperationAdd extends Operation&#123;</div><div class="line">	@Override</div><div class="line">	public double GetResult() &#123;</div><div class="line">		return numberA+numberB;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class OperationMinus extends Operation&#123;</div><div class="line">	 @Override</div><div class="line">	public double GetResult() &#123;</div><div class="line">		 return numberA - numberB;</div><div class="line">	 &#125;</div><div class="line">&#125;</div><div class="line">public class OperationFactory &#123;</div><div class="line">	public static Operation createOperation(String operateString)&#123;</div><div class="line">		Operation operate = null;</div><div class="line">		switch(operateString)&#123;</div><div class="line">		case &quot;+&quot;:</div><div class="line">			operate = new OperationAdd();</div><div class="line">			break;</div><div class="line">		case &quot;l&quot;:</div><div class="line">			operate = new OperationMinus();</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		return operate;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">测试代码</div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Operation operate = null;</div><div class="line">		operate = OperationFactory.createOperation(&quot;+&quot;);</div><div class="line">		operate.setNumberA(33);</div><div class="line">		operate.setNumberB(44);</div><div class="line">		System.out.println(operate.GetResult());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">public abstract class CashSuper &#123;</div><div class="line">	public abstract double acceptCash(double money);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CashNormal extends CashSuper&#123;</div><div class="line">	@Override</div><div class="line">	public double acceptCash(double money) &#123;</div><div class="line">		return money;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CashRebate extends CashSuper&#123;</div><div class="line">	public double moneyRebate=0.8;</div><div class="line">	public  CashRebate(String money) &#123;</div><div class="line">		this.moneyRebate = Double.parseDouble(money);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public double acceptCash(double money) &#123;</div><div class="line"></div><div class="line">		return money*moneyRebate;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CashReturn extends CashSuper &#123;</div><div class="line">	public double moneyCondition=0;</div><div class="line">	public double moneyReturn = 0;</div><div class="line">	public CashReturn(String moneyCondition, String moneyReturn) &#123;</div><div class="line">		this.moneyCondition = Double.parseDouble(moneyCondition);</div><div class="line">		this.moneyReturn = Double.parseDouble(moneyReturn);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public double acceptCash(double money) &#123;</div><div class="line">		if(money &gt; moneyCondition)</div><div class="line">			return money-Math.floor(money/moneyCondition)*moneyReturn;</div><div class="line">		else</div><div class="line">			return money;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CashContext &#123;</div><div class="line">	CashSuper cs = null;</div><div class="line">	public CashContext(String type) &#123;</div><div class="line">		switch(type)&#123;</div><div class="line">		case &quot;normal&quot;:</div><div class="line">			cs = new CashNormal();</div><div class="line">			break;</div><div class="line">		case &quot;cashRebate&quot;:</div><div class="line">			cs = new CashRebate(&quot;0.8&quot;);</div><div class="line">			break;</div><div class="line">		case &quot;caseReturn&quot;:</div><div class="line">			cs = new CashReturn(&quot;300&quot;, &quot;100&quot;);</div><div class="line">			break;</div><div class="line">		 &#125;</div><div class="line">	&#125;</div><div class="line">	public double GetResult(double money)&#123;</div><div class="line">		return cs.acceptCash(money);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">测试代码</div><div class="line">	public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		/*CashSuper cash;</div><div class="line">		cash = CashFactory.create(&quot;normal&quot;);</div><div class="line">		System.out.println(cash.acceptCash(300));</div><div class="line">		cash = CashFactory.create(&quot;cashRebate&quot;);</div><div class="line">		System.out.println(cash.acceptCash(300));</div><div class="line">		cash = CashFactory.create(&quot;cashReturn&quot;);</div><div class="line">		System.out.println(cash.acceptCash(310));*/   此段代码用来跟简单工厂模式区别，最好的设计就是对依赖的类保持最少的了解</div><div class="line">		CashContext csuper = new CashContext(&quot;normal&quot;);</div><div class="line">		System.out.println(csuper.GetResult(300));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>简单工厂和策略模式的区别<br>工厂模式是创建型模式，策略模式是行为性模式；一个关注对象创建，一个关注行为的封装；<br>在下面的情况下应当考虑使用策略模式：</p>
<ol>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li>
<li>一个系统需要动态地在几种算法中选择一种。那么这些算法可以包装到一个个的具体算法类里面，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体<br>算法类均有统一的接口，由于多态性原则，客户端可以选择使用任何一个具体算法类，并只持有一个数据类型是抽象算法类的对象。</li>
<li>一个系统的算法使用的数据不可以让客户端知道。策略模式可以避免让客户端涉及到不必要接触到的复杂的和只与算法有关的数据。</li>
</ol>
</blockquote>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public abstract class Component &#123;</div><div class="line">	public abstract void Operation();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteComponent extends Component&#123;</div><div class="line">	@Override</div><div class="line">	public void Operation() &#123;</div><div class="line">		System.out.println(&quot;具体对象的操作&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteDecoratorA extends Decorator&#123;</div><div class="line">	private String addedState;</div><div class="line">	@Override</div><div class="line">	public void Operation() &#123;</div><div class="line">		super.Operation();</div><div class="line">		addedState = &quot;New State&quot;;</div><div class="line">		System.out.println(&quot;具体装饰对象A的操作&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteDecortorB extends Decorator&#123;</div><div class="line">	@Override</div><div class="line">	public void Operation() &#123;</div><div class="line">		super.Operation();</div><div class="line">		AddedBehavior();</div><div class="line">		System.out.println(&quot;具体装饰B对象的操作&quot;);</div><div class="line">	&#125;</div><div class="line">	private void AddedBehavior() &#123;</div><div class="line">		System.out.println(&quot;hello world！&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Decorator extends Component&#123;</div><div class="line">	protected Component component;</div><div class="line"></div><div class="line">	public Component getComponent() &#123;</div><div class="line">		return component;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setComponent(Component component) &#123;</div><div class="line">		this.component = component;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Operation() &#123;</div><div class="line">		if(component!=null)&#123;</div><div class="line">			component.Operation();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Component c = new ConcreteComponent();</div><div class="line">		Decorator d1 = new ConcreteDecoratorA();</div><div class="line">		Decorator d2 = new ConcreteDecortorB();</div><div class="line">		d1.setComponent(c);</div><div class="line">		d2.setComponent(d1);</div><div class="line">		d2.Operation();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">定义 抽象Manager类，经理，总监，总经理都继承 Manager</div><div class="line">public abstract class Manager &#123;</div><div class="line">	protected String name;</div><div class="line">	protected Manager superior;</div><div class="line">	public Manager(String name)&#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public void setSuperior(Manager superior)&#123;</div><div class="line">		this.superior = superior;</div><div class="line">	&#125;</div><div class="line">	abstract public void RequestApplication(Request request);</div><div class="line">&#125;</div><div class="line">//经理</div><div class="line">public class CommonManager extends Manager &#123;</div><div class="line">	public CommonManager(String name)&#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void RequestApplication(Request request) &#123;</div><div class="line">		if(request.requestType==&quot;jiaxin&quot; &amp;&amp; request.number&lt;100)&#123;</div><div class="line">			System.out.println(name + &quot; agree&quot;);</div><div class="line">		&#125;else&#123;</div><div class="line">			if(superior!=null)&#123;</div><div class="line">				superior.RequestApplication(request);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//总监</div><div class="line">public class Zongjian extends Manager&#123;</div><div class="line">	public Zongjian(String name) &#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void RequestApplication(Request request) &#123;</div><div class="line">		 if(request.requestType==&quot;jiaxin&quot; &amp;&amp; request.number&lt;500)&#123;</div><div class="line">			 System.out.println(name + &quot; agreen&quot;);</div><div class="line">		 &#125;else&#123;</div><div class="line">			 superior.RequestApplication(request);</div><div class="line">		 &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//总经理</div><div class="line">public class GeneralManager extends Manager&#123;</div><div class="line">	public GeneralManager(String name) &#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void RequestApplication(Request request) &#123;</div><div class="line">		 if(request.requestType==&quot;jiaxin&quot; &amp;&amp; request.number &lt; 2000)&#123;</div><div class="line">			 System.out.println(name + &quot; agree&quot;);</div><div class="line">		 &#125;else&#123;</div><div class="line">			 System.out.println(name + &quot; not agree&quot;);</div><div class="line">		 &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//Test代码</div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		CommonManager commonManager = new CommonManager(&quot;CommonManager&quot;);</div><div class="line">		Zongjian zongjian = new Zongjian(&quot;Zongjian&quot;);</div><div class="line">		GeneralManager generalManager = new GeneralManager(&quot;GeneralManager&quot;);</div><div class="line">		commonManager.setSuperior(zongjian);</div><div class="line">		zongjian.setSuperior(generalManager);</div><div class="line">		Request request = new Request();</div><div class="line">		request.setRequestType(&quot;jiaxin&quot;);</div><div class="line">		request.setNumber(500);</div><div class="line">		commonManager.RequestApplication(request);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出</div><div class="line">GeneralManager agree</div></pre></td></tr></table></figure>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">public abstract class Unitednations &#123;</div><div class="line">	public abstract void Declare(String message,Country college);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class Country &#123;</div><div class="line">	protected Unitednations mediator;</div><div class="line">	public Country(Unitednations mediator) &#123;</div><div class="line">		this.mediator = mediator;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class USA extends Country&#123;</div><div class="line">	public USA(Unitednations mediator) &#123;</div><div class="line">		super(mediator);</div><div class="line">	&#125;</div><div class="line">	public void Declare(String message)&#123;</div><div class="line">		mediator.Declare(message, this);</div><div class="line">	&#125;</div><div class="line">	public void GetMessage(String message)&#123;</div><div class="line">		System.out.println(&quot;USA gains message &quot;+message);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Iraq extends Country &#123;</div><div class="line">	public Iraq(Unitednations mediator) &#123;</div><div class="line">		super(mediator);</div><div class="line">	&#125;</div><div class="line">	public void Declare(String message)&#123;</div><div class="line">		mediator.Declare(message, this);</div><div class="line">	&#125;</div><div class="line">	public void GetMessage(String message)&#123;</div><div class="line">		System.out.println(&quot;Iraq gains message &quot;+message );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class UnitedNationSecurityCouncil extends Unitednations &#123;</div><div class="line">	private USA colleague1;</div><div class="line">	private Iraq colleague2;</div><div class="line">	public void setUSA(USA colleague)&#123;</div><div class="line">		this.colleague1 = colleague;</div><div class="line">	&#125;</div><div class="line">	public void setIraq(Iraq colleague)&#123;</div><div class="line">		this.colleague2 = colleague;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Declare(String message, Country college) &#123;</div><div class="line">		if(college == colleague1)&#123;</div><div class="line">			colleague2.GetMessage(message);</div><div class="line">		&#125;else&#123;</div><div class="line">			colleague1.GetMessage(message);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//测试代码</div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		UnitedNationSecurityCouncil UNSC = new UnitedNationSecurityCouncil();</div><div class="line">		USA c1 = new USA(UNSC);</div><div class="line">		Iraq c2 = new Iraq(UNSC);</div><div class="line">		UNSC.setUSA(c1);</div><div class="line">		UNSC.setIraq(c2);</div><div class="line">		c1.Declare(&quot;do not &quot;);</div><div class="line">		c2.Declare(&quot;do&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">输出</div><div class="line">Iraq gains message do not</div><div class="line">USA gains message do</div></pre></td></tr></table></figure>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">1. class Singleton&#123;</div><div class="line">	private static Singleton instance;</div><div class="line">	private static byte[] lock = new byte[1];</div><div class="line">	private Singleton&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public static Singleton getInstance()&#123;</div><div class="line">		if(instance == null)&#123;</div><div class="line">			synchronized(lock)&#123;</div><div class="line">				if(instance==null)&#123;</div><div class="line">					instance = new Singleton();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">2. class Singleton&#123;</div><div class="line">	private static Singleton instance;</div><div class="line">	private static ReentrantLock lock = new ReentrantLock();</div><div class="line">	private Singleton()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public static Singleton getInstance()&#123;</div><div class="line">		if(instance == null)&#123;</div><div class="line">			lock.lock;</div><div class="line">			if(instance == null)&#123;</div><div class="line">				instance = new Singleton();</div><div class="line">			&#125;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">public abstract class Player &#123;</div><div class="line">	protected String name;</div><div class="line">	public Player(String name)&#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public abstract void Attack();</div><div class="line">	public abstract void Defense();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Forwards extends Player&#123;</div><div class="line">	public Forwards(String name) &#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Attack() &#123;</div><div class="line"></div><div class="line">		System.out.println(name + &quot; Attack&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Defense() &#123;</div><div class="line">		System.out.println(name + &quot; Defense&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Center extends Player &#123;</div><div class="line">	public Center(String name) &#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Attack() &#123;</div><div class="line">		System.out.println(name + &quot; Attack&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Defense() &#123;</div><div class="line">		System.out.println(name + &quot; Attack&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Guards extends Player&#123;</div><div class="line">	public Guards(String name) &#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Attack() &#123;</div><div class="line">		System.out.println(name + &quot; Attack&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Defense() &#123;</div><div class="line">		System.out.println(name + &quot; Attack&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ForeighCenter &#123;</div><div class="line">	public String name;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public void attack()&#123;</div><div class="line">		System.out.println(name + &quot; attack&quot;);</div><div class="line">	&#125;</div><div class="line">	public void defense()&#123;</div><div class="line">		System.out.println(name + &quot; defense&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Translator extends Player &#123;</div><div class="line">	private ForeighCenter foreigh = new ForeighCenter();</div><div class="line">	public Translator(String name) &#123;</div><div class="line">		super(name);</div><div class="line">		foreigh.name = name;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Attack() &#123;</div><div class="line">		foreigh.attack();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Defense() &#123;</div><div class="line">		foreigh.defense();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Player b = new Forwards(&quot;巴蒂尔&quot;);</div><div class="line">		b.Attack();</div><div class="line">		Player m = new Center(&quot;麦克格雷迪&quot;);</div><div class="line">		m.Attack();</div><div class="line">		Player ym = new Translator(&quot;姚明&quot;);</div><div class="line">		ym.Attack();</div><div class="line">		ym.Defense();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">输出</div><div class="line">巴蒂尔 Attack</div><div class="line">麦克格雷迪 Attack</div><div class="line">姚明 attack</div><div class="line">姚明 defense</div></pre></td></tr></table></figure>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public abstract class Subject &#123;</div><div class="line">	private List&lt;ObserverObj&gt; observers = new ArrayList&lt;ObserverObj&gt;();</div><div class="line">	public void Attach(ObserverObj observer)&#123;</div><div class="line">		observers.add(observer);</div><div class="line">	&#125;</div><div class="line">	public void Detach(ObserverObj observer)&#123;</div><div class="line">		observers.remove(observer);</div><div class="line">	&#125;</div><div class="line">	public void Nofity()&#123;</div><div class="line">		for (ObserverObj o : observers) &#123;</div><div class="line">			o.Update();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class ObserverObj &#123;</div><div class="line">	public abstract void Update();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteSubject extends Subject&#123;</div><div class="line">	private String subjectState;</div><div class="line">	public String getSubjectState() &#123;</div><div class="line">		return subjectState;</div><div class="line">	&#125;</div><div class="line">	public void setSubjectState(String subjectState) &#123;</div><div class="line">		this.subjectState = subjectState;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteObserver extends ObserverObj &#123;</div><div class="line">	private String name;</div><div class="line">	private String observerState;</div><div class="line">	private ConcreteSubject subject;</div><div class="line">	public ConcreteObserver(String name, ConcreteSubject subject) &#123;</div><div class="line">		this.name = name;</div><div class="line">		this.subject = subject;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Update() &#123;</div><div class="line">		observerState = subject.getSubjectState();</div><div class="line">		System.out.println(name+&quot; state is &quot; + observerState);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ConcreteSubject s = new ConcreteSubject();</div><div class="line">		s.Attach(new ConcreteObserver(&quot;X&quot;, s));</div><div class="line">		s.Attach(new ConcreteObserver(&quot;Y&quot;, s));</div><div class="line">		s.Attach(new ConcreteObserver(&quot;Z&quot;, s));</div><div class="line">		s.setSubjectState(&quot;ABC&quot;);</div><div class="line">		s.Nofity();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h3><table>
<thead>
<tr>
<th>排序方法</th>
<th>平均情况</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlog(n))</td>
<td>O(n^1.3)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog(n))</td>
<td>O(nlog(n))</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog(n))</td>
<td>O(nlog(n))</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog(n))</td>
<td>O(nlog(n))</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
</tbody>
</table>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>可维护 克服用法 可扩展 灵活型号<br>通过封装、继承、多态把程序的耦合性降低<br>类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类<br>单一职责原则(SRP)：就一个类而言，应该仅有一个引起它变化的原因<br>依赖倒置原则： 针对接口编程，不要针对实现编程<br>A.高层模块不应该依赖低层模块，两个都应该依赖抽象<br>B.抽象不应该依赖细节，细节应该依赖抽象<br>装饰模式： 动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。<br>代理模式： 为其他对象提供一种代理以控制对这个对象的访问。<br>代理类就是持有一个真实类的引用，调用实际类的方法。 代理类和实际类通过实现相同接口达到统一。<br>远程代理：也就是为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实。</p>
<p>简单工厂模式 VS 工厂方法模式 IFactory factory = new UndergraduateFactory();  LeiFeng student = factory.CreateLeiFeng();<br>外观模式(Facade): 为子系统的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>适配器模式(Adapter)将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>就是说，需要的东西就在眼前，却不能使用，而短时间又无法改造它，只能想办法适配。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[飞鸟集]]></title>
      <url>https://fudawei.github.io/2015/12/22/%E9%A3%9E%E9%B8%9F%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>001﻿</p>
<p>夏天的飞鸟落在我的窗前﻿</p>
<p>歌唱之后便匆匆离去﻿﻿</p>
<p>深秋的落叶寂静不语﻿</p>
<p>叹息之后便落在了那里﻿﻿</p>
<p>002﻿﻿</p>
<p>流浪在世界的人﻿</p>
<p>请将你们的足记留在我的文字里﻿﻿</p>
<p>003﻿﻿</p>
<p>面对爱人﻿</p>
<p>世界无比真诚﻿﻿</p>
<p>然后它变小了﻿</p>
<p>如诗歌﻿</p>
<p>如深吻﻿﻿</p>
<p>004﻿﻿</p>
<p>大地流下的泪﻿</p>
<p>让她的笑容一直美丽﻿﻿</p>
<p>005﻿﻿</p>
<p>荒漠向绿草求爱﻿</p>
<p>而激情澎湃﻿</p>
<p>可它笑着摇头﻿</p>
<p>飞走离开﻿﻿</p>
<p>006﻿﻿</p>
<p>失去太阳流下流泪﻿</p>
<p>也会错过满天繁星﻿﻿</p>
<p>007﻿﻿</p>
<p>跳舞的流水﻿</p>
<p>你路过的泥沙渴望着﻿</p>
<p>你的歌声，你的舞姿﻿</p>
<p>而你愿意去接受他们﻿</p>
<p>不能远行的牵绊吗？﻿﻿</p>
<p>008﻿﻿</p>
<p>她满脸渴望着﻿</p>
<p>如深夜的雨﻿</p>
<p>惊扰着我的梦﻿﻿</p>
<p>009﻿﻿</p>
<p>曾经梦里我们形同陌路﻿</p>
<p>醒来发现彼此爱的深沉﻿﻿</p>
<p>010﻿﻿</p>
<p>忧郁沉寂在心﻿</p>
<p>正如﻿</p>
<p>黄昏在寂静的树林﻿﻿</p>
<p>011﻿﻿</p>
<p>无形的手指﻿</p>
<p>如同自在的微风﻿</p>
<p>随着潺潺的乐声﻿</p>
<p>在我的心上调皮﻿﻿</p>
<p>012﻿﻿</p>
<p>—大海，你要说什么？﻿</p>
<p>—还是那个问题。﻿﻿</p>
<p>—天空，你的回答呢？﻿</p>
<p>—还是保持沉默。﻿﻿</p>
<p>013﻿﻿</p>
<p>听听我的心﻿</p>
<p>听听世界的低语﻿</p>
<p>听他把深爱诉说给你﻿﻿</p>
<p>014﻿﻿</p>
<p>创造如夜的黑暗﻿</p>
<p>—伟大神秘﻿﻿</p>
<p>而虚渺的认知﻿</p>
<p>如尘雾中的黎明﻿﻿</p>
<p>015﻿﻿</p>
<p>不要让你的爱太过高耸﻿</p>
<p>如无法触及的悬崖峭壁</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[皆大欢喜的加薪]]></title>
      <url>https://fudawei.github.io/2015/10/23/%E7%9A%86%E5%A4%A7%E6%AC%A2%E5%96%9C%E7%9A%84%E5%8A%A0%E8%96%AA/</url>
      <content type="html"><![CDATA[<p> 我的朋友A君是个典型的.NET开发人员，技术不错，人品也不错，在一家小公司（姑且称为甲公司）做项目开发，是技术骨干。3个月前，他找到我说想跳槽，让我帮忙介绍工作。我说为什么想跳了？</p>
<a id="more"></a>
<h2 id="为什么想离职？"><a href="#为什么想离职？" class="headerlink" title="为什么想离职？"></a>为什么想离职？</h2><p>他简单说了一下他在甲公司当时的状况：A君在甲公司做了两年多，这两年多完成了一个大项目，作为开发的核心主力，开发压力很大，特别是项目上线前的几个月是非常辛苦，几乎每晚都要加班到12点以后，周末最多只有一天休息。在最困难的时候，老板给大家大气，“大家再坚持坚持，项目上线赚钱了，就给大家涨工资，公司是绝对不会亏待大家的”，在老板豪情壮语的加薪鼓励下，大家要紧牙关拼上了。终于，半年前，项目上线了，运行也慢慢稳定了，公司赚钱也多了起来。</p>
<p>是的，公司赚钱了，利润很可观，这是大家都知道的事情。但是，一两个月过去了，加薪的事情完全没影，老板就像从来没提过一样。于是，A君向人事经理说出了希望加薪的请求，最后，得到的回复（在小公司，这当然是老板的意思）:</p>
<ol>
<li>A君目前的工资与外面相比，基本是持平的。</li>
<li>A君目前的工作很悠闲，工作量不饱和。</li>
</ol>
<p>关于1实际上是个难题，两个人的工资要怎么比较，几乎都是老板一个非常主观的想法。而关于2，却是事实：由于新的项目还在调研中，所以，A君的工作暂时就轻松了不少，主要就是维护线上的系统，加加小功能，修修小bug，比较清闲。</p>
<h2 id="老板很有骨气"><a href="#老板很有骨气" class="headerlink" title="老板很有骨气"></a>老板很有骨气</h2><p>A君听到回复后，很是生气，在和同事们一起吃饭时，就忍不住埋怨起公司来，后来，这话传到了老板的耳朵里，老板很有骨气：越是抱怨，越不给你涨工资，看你怎么样。<br>终于，A决定离职，老板一如既往的有骨气：离职就离职，离开你公司就得关门了？<br>所以，就回到了开头的一幕，3个月前，A要我帮忙介绍工作。我刚好想到之前另外一个乙公司的技术经理联系我说，他下面有个B君想离职，希望我推荐个人，事成之后有推荐费拿的。理所当然的，我把A推荐了到了乙公司，A接手了B君的工作（在接手的过程中，A和B还成为了好朋友），乙公司对A的表现非常满意，最后，A的工资相比在甲公司涨幅达到50%。</p>
<h2 id="对调一下吧"><a href="#对调一下吧" class="headerlink" title="对调一下吧"></a>对调一下吧</h2><p>事情还没完，A君从甲公司离职后，甲公司的线上系统的维护就成为一个大问题了，老板命令人事经理赶快找人来顶上，苦逼的人事经理在QQ里群发了招聘的信息，这个信息也发给了A君，于是，A君把正在找工作的B君推荐过去了。B君在甲公司工作一个月后就转正，老板也很满意，相比之前在乙公司工资上涨了30%，和现在A的工资差不多。</p>
<p> —— 后来，A告诉我，B之所以要离职，原因跟A是差不多的。</p>
<h2 id="皆大欢喜"><a href="#皆大欢喜" class="headerlink" title="皆大欢喜"></a>皆大欢喜</h2><p>这真是一个皆大欢喜的局面！</p>
<ol>
<li>A到乙公司接手了原来B的工作，工资涨了50%。</li>
<li>B到甲公司接手了原来A的工作，工资涨了30%。</li>
<li>更重要的是，甲、乙公司的老板都爽了，对新进来的员工的表现都非常满意。</li>
<li>而我，拿到了乙公司的推荐费。</li>
<li>A和B成为了好朋友，除了经常探讨技术外，还经常一起讨论这搞笑的离职加薪过程，交流心得。</li>
</ol>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>尊重原创，本文转载自：<a href="http://www.cnblogs.com/justnow/p/4903436.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://www.cnblogs.com/justnow/p/4903436.html?utm_source=tuicool&amp;utm_medium=referral</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis主从复制]]></title>
      <url>https://fudawei.github.io/2015/10/18/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：  </p>
<ol>
<li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li>
<li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内容容量为256G，也不能将所有内容用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过<strong>20G</strong>。</li>
</ol>
<p>本文先讨论第一点的解决方案：<strong>Redis主从复制</strong>，第二点可以使用Redis集群解决，下一篇文章将介绍Redis集群。<br><a id="more"></a></p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>考虑如下一种场景：</p>
<blockquote>
<p>电子商务网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p>
</blockquote>
<p>对于这种场景，我们可以使如下这种架构：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis主从复制/主从复制架构.png" alt="Redis主从复制结构图"></p>
<p>如图中所示，我们将一台Redis服务器作主库(Matser)，其他三台作为从库(Slave)，主库只负责写数据，每次有数据更新都将更新的数据同步到它所有的从库，而从库只负责读数据。这样一来，就有了两个好处：</p>
<ol>
<li>读写分离，不仅可以提高服务器的负载能力，并且可以根据读请求的规模自由增加或者减少从库的数量，棒极了；</li>
<li>数据被复制成了了好几份，就算有一台机器出现故障，也可以使用其他机器的数据快速恢复。</li>
</ol>
<p>需要注意的是：在Redis主从模式中，一台主库可以拥有多个从库，但是一个从库只能隶属于一个主库。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在Redis中，要实现主从复制架构非常简单，只需要在从数据库的配置文件中加上如下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slaveof 主数据库地址  主数据库端口</div></pre></td></tr></table></figure>
<p>主数据库不需要任何配置。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>下面将演示怎么实现一个简单的复制系统。我们在一台机器上起两个Redis实例，监听不同的端口，其中一个作为主库，另外一个作为从库。首先不加任何参数来启动一个Redis实例作为主数据库：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis主从复制/启动主库.png" alt=""><br>可以看到，主库监听的是6379端口。</p>
<p>然后加上slaveof参数启动另一个Redis实例作为从库，并且监听6380端口：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis主从复制/启动从库.png" alt=""><br>从控制台输出中可以看到，从库已经连接到主库：126.0.0.1:6379了，看样子主从复制系统配置成功。我们可以分别在主库和从库中使用如下命令看一看当前实例在复制系统中的相关信息：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis主从复制/Redis角色.png" alt=""></p>
<p>接下来验证一把。</p>
<p>首先在主库中设置一个键值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[qifuguang@Mac~]$ /opt/soft/redis-3.0.4/src/redis-cli -p 6379</div><div class="line">127.0.0.1:6379&gt; set test-sync 飞鸟</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure>
<p>现在到从库中检查该值是否已经自动同步到了从库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[qifuguang@Mac~]$ /opt/soft/redis-3.0.4/src/redis-cli -p 6380</div><div class="line">127.0.0.1:6380&gt; get test-sync</div><div class="line">&quot;飞鸟&quot;</div><div class="line">127.0.0.1:6380&gt;</div></pre></td></tr></table></figure>
<p>可以看到，数据确实从主库同步到了从库.</p>
<p>在默认情况下，从库是只读的，如果在从库中写数据将会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[qifuguang@Mac~]$ /opt/soft/redis-3.0.4/src/redis-cli -p 6380</div><div class="line">127.0.0.1:6380&gt; set x y</div><div class="line">(error) READONLY You can&apos;t write against a read only slave.</div><div class="line">127.0.0.1:6380&gt;</div></pre></td></tr></table></figure>
<p>但是可以在从库的配置文件中加上如下的配置项允许从库写数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slave-read-only no</div></pre></td></tr></table></figure>
<p>但是，因为从库中修改的数据不会被同步到任何其他数据库，并且一旦主库修改了数据，从库的数据就会因为自动同步被覆盖，所以一般情况下，不建议将从库设置为可写。</p>
<p>相同的道理，配置多台从库也使用相同的方法，都在从库的配置文件中加上slaveof参数即可。</p>
<p>此外，我们可以在客户端使用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SLAVEOF 新主库地址  新主库端口</div></pre></td></tr></table></figure>
<p>来修改当前数据库的主库，如果当前数据库已经是其他库的从库， 则当前数据库会停止和原来的数据库的同步而和新的数据库同步。</p>
<p>最后，从数据库还可以通过运行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SLAVEOF NO ONE</div></pre></td></tr></table></figure>
<p>来停止接受来自其他数据库的同步而升级成为主库。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>上面说了配置主从复制系统的方法，并且举例例子详细说明，本节将介绍Redis主从复制的实现原理。</p>
<p>当一个从数据库启动时，会向主数据库发送SYNC命令，主数据库收到命令后会开始在后台保存快照（即RDB持久化过程），并将保存快照期间接收到的命令缓存起来。当快照完成后，Redis会将快照文件和缓存的命令发给从数据库，从数据库收到数据后，会载入快照文件并执行缓存的命令。以上过程称为<strong>复制初始化</strong>。复制初始化之结束后，主数据库每收到写命令时就会将命令同步给从数据库，从而保证主从数据库数据一致，这一过程称为<strong>复制同步阶段</strong>。</p>
<p>有两点需要注意：</p>
<ol>
<li>当主从数据库之间的连接断开后，Redis2.8之前的版本会重新进行复制初始化过程，这样就使得主从数据库断开连接后数据恢复的过程的效率很低下。Redis2.8版本的一个重要改进就是断线支持有条件的增量数据传输，当从数据库再次连接到主数据库时，主数据库只需要将断线期间执行的命令发给从数据库即可，大大提高了Redis主从复制的实用性。</li>
<li>复制同步阶段贯穿整个主从同步过程的始终，直到主从关系终止为止。在复制过程中，即使关闭了RDB方式的持久化(删除所有save参数)，依旧会执行快照操作。</li>
</ol>
<h1 id="乐观复制"><a href="#乐观复制" class="headerlink" title="乐观复制"></a>乐观复制</h1><p>Redis采用了复制的策略。容忍在一定时间内主从数据库的内容是不同的，但是两者的数据最终会保持一致。具体来说，Redis主从数据库之间的复制数据的过程本身是异步的，这意味着，主数据库执行完客户端的写请求后会立即将命令在主数据库的执行结果返回给客户端，而不会等待从数据库收到该命令后再返回给客户端。这一特性保证了复制后主从数据库的性能不会受到影响，但另一方面也会产生一个主从数据库数据不一致的时间窗口，当主数据库执行一条写命令之后，主数据库的数据已经发生变动，然而在主数据库将该命令传送给从数据库之前，如果两个数据库之间的连接断开了，此时二者间的数据就不一致了。从这个角度看，主数据库无法得知命令最终同步给了几个从数据库，不过Redis提供了两个配置选项来限制只有至少同步给指定数量的数据库时，主数据库才是可写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">min-slaves-to-write 3</div><div class="line">min-slave2-max-lag 10</div></pre></td></tr></table></figure>
<p>第一个参数表示只有当3个或3个以上的从数据库连接到主库时，主数据库才是可写的，否则返回错误。<br>第二个参数表示允许从数据库失去连接的最长时间，该选项默认是关闭的，在分布式系统中，打开并合理配置该选项可以降低主从架构因为网络分区导致的数据不一致问题。</p>
<h1 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h1><p>从数据库不仅可以接收主数据库的数据，同时也可以作为主数据库存在，形成类似图的结构，如下图：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis主从复制/图结构.png" alt=""><br>A中的数据会同步到B,C中，C中的数据会同步到D,E中。</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文为作者原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/10/18/Redis主从复制">http://fudawei.github.io/2015/10/18/Redis主从复制</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Docker学习三]Docker入门]]></title>
      <url>https://fudawei.github.io/2015/10/17/%5BDocker%E5%AD%A6%E4%B9%A0%E4%B8%89%5DDocker%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>前面的文章讲解了怎么安装Docker，本文将迈出使用Docker的第一步，学习第一个Docker容器。<br><a id="more"></a></p>
<h2 id="确保Docker已经就绪"><a href="#确保Docker已经就绪" class="headerlink" title="确保Docker已经就绪"></a>确保Docker已经就绪</h2><p>使用如下命令可以查看docker程序是否存在，功能是否正常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sudo docker info</div><div class="line">Containers: 5</div><div class="line">Images: 72</div><div class="line">Storage Driver: aufs</div><div class="line"> Root Dir: /var/lib/docker/aufs</div><div class="line"> Backing Filesystem: extfs</div><div class="line"> Dirs: 82</div><div class="line"> Dirperm1 Supported: false</div><div class="line">Execution Driver: native-0.2</div><div class="line">Kernel Version: 3.13.0-53-generic</div><div class="line">Operating System: Ubuntu 14.04.2 LTS</div><div class="line">CPUs: 8</div><div class="line">Total Memory: 15.56 GiB</div><div class="line">Name: qifuguang-OptiPlex-9010</div><div class="line">ID: SNVW:WBCG:76BZ:2L63:AFQR:ZMDS:KI4Z:XIQZ:ENHV:O7PI:QMDP:6DQ3</div><div class="line">Username: quinn2012</div><div class="line">Registry: [https://index.docker.io/v1/]</div><div class="line">WARNING: No swap limit support</div></pre></td></tr></table></figure></p>
<p>上述的info命令返回docker中所有的容器和镜像的数量，docker使用的执行驱动和存储驱动，以及docker的基本配置。</p>
<h2 id="运行第一个容器"><a href="#运行第一个容器" class="headerlink" title="运行第一个容器"></a>运行第一个容器</h2><p>现在，我们尝试启动第一个容器。我们可以使用docker run命令创建容器，docker run命令提供了容器的创建和启动功能，在本文中我们使用该命里那个创建新容器：</p>
<p><img src="http://img.blog.csdn.net/20150627111304649" alt="这里写图片描述"></p>
<p>首先，我们告诉docker执行docker run命令，并指定-i和-t两个命令行参数。-i标识保证容器的STDIN是开启的，尽管我们并没有附着在容器中。持久的标准输入是交互式shell的“半边天”，而-t则是另外“半边天”，它告诉docker要为创建的容器分配一个伪tty终端。这样，创建的容器才能提供一个交互式的shell。如果要在命令行创建一个我们能与之进行交互的容器，这两个命令参数最基本的参数。</p>
<p>接下来，告诉docker基于什么镜像来创建容器，上面示例使用的是ubuntu镜像。ubuntu镜像是一个常备镜像，也可以称为“基础镜像”，它由Docker公司提供，保存在Docker Hub Registry上。本例中我们基于ubuntu镜像创建、启动了一个容器，并没有做任何修改。</p>
<p>这个命令背后的执行流程是怎样的呢？首先Docker会检查本地是否有ubuntu镜像，如果没有该镜像的话，Docker连接官方维护的Docker Hub Registry，查看Docker Hub中是否有该镜像，Docker一旦找到该镜像，就会下载该镜像并保存到本地宿主机中。随后Docker在文件系统内部用这个镜像创建 一个新容器。该容器拥有自己的网络，IP地址，以及一个用来和宿主机进行通信的桥接网络接口。最后，告诉Docker要在新容器中执行什么命令，在本例中执行/bin/bash命令启动一个Bash shell。</p>
<p>##使用第一个容器<br>我们已经以root用户登录到 了新的容器中，容器ID为faa127f03be9，看起来很不和谐，非常难以记忆，后续会告诉大家怎么为容器命名。</p>
<h3 id="查看-etc-hosts文件"><a href="#查看-etc-hosts文件" class="headerlink" title="查看/etc/hosts文件"></a>查看/etc/hosts文件</h3><p>看看hosts文件的配置情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root@faa127f03be9:/# cat /etc/hosts</div><div class="line">172.17.0.45 faa127f03be9</div><div class="line">127.0.0.1   localhost</div><div class="line">::1 localhost ip6-localhost ip6-loopback</div><div class="line">fe00::0 ip6-localnet</div><div class="line">ff00::0 ip6-mcastprefix</div><div class="line">ff02::1 ip6-allnodes</div><div class="line">ff02::2 ip6-allrouters</div><div class="line">root@faa127f03be9:/#</div></pre></td></tr></table></figure></p>
<p>可以看到，Docker已经使用容器ID在/etc/hosts文件中为容器添加了一条主机配置项。</p>
<h3 id="查看网络配置情况"><a href="#查看网络配置情况" class="headerlink" title="查看网络配置情况"></a>查看网络配置情况</h3><p>我们可以看看容器的网络配置情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">root@faa127f03be9:/# ip a</div><div class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default</div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">    inet 127.0.0.1/8 scope host lo</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">    inet6 ::1/128 scope host</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">100: eth0: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</div><div class="line">    link/ether 02:42:ac:11:00:2d brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 172.17.0.45/16 scope global eth0</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">    inet6 fe80::42:acff:fe11:2d/64 scope link</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">root@faa127f03be9:/#</div></pre></td></tr></table></figure></p>
<p>可以看到，这里有lo回环接口，还有IP为172.17.0.45的白哦准的eth0网络接口，和普通的宿主机完全一样。</p>
<h3 id="查看容器中运行的进程"><a href="#查看容器中运行的进程" class="headerlink" title="查看容器中运行的进程"></a>查看容器中运行的进程</h3><p>通过如下的命令可以查看容器中运行的进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@faa127f03be9:/# ps -aux</div><div class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</div><div class="line">root         1  0.0  0.0  18164  2020 ?        Ss   03:11   0:00 /bin/bash</div><div class="line">root        17  0.0  0.0  15564  1152 ?        R+   03:17   0:00 ps -aux</div><div class="line">root@faa127f03be9:/#</div></pre></td></tr></table></figure></p>
<h3 id="在容器中安装软件"><a href="#在容器中安装软件" class="headerlink" title="在容器中安装软件"></a>在容器中安装软件</h3><p>刚刚启动的容器中是没有vim软件包的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@faa127f03be9:/# vim /etc/hosts</div><div class="line">bash: vim: command not found</div><div class="line">root@faa127f03be9:/#</div></pre></td></tr></table></figure></p>
<p>现在我们在容器中安装vim软件包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">root@faa127f03be9:/# sudo apt-get install vim</div><div class="line">Reading package lists... Done</div><div class="line">Building dependency tree</div><div class="line">Reading state information... Done</div><div class="line">The following extra packages will be installed:</div><div class="line">  libgpm2 libpython2.7 libpython2.7-minimal libpython2.7-stdlib vim-runtime</div><div class="line">Suggested packages:</div><div class="line">  gpm ctags vim-doc vim-scripts</div><div class="line">The following NEW packages will be installed:</div><div class="line">  libgpm2 libpython2.7 libpython2.7-minimal libpython2.7-stdlib vim</div><div class="line">  vim-runtime</div><div class="line">0 upgraded, 6 newly installed, 0 to remove and 0 not upgraded.</div><div class="line">Need to get 9083 kB of archives.</div><div class="line">After this operation, 42.9 MB of additional disk space will be used.</div><div class="line">Do you want to continue? [Y/n] Y</div><div class="line">Get:1 http://archive.ubuntu.com/ubuntu/ trusty/main libgpm2 amd64 1.20.4-6.1 [16.5 kB]</div><div class="line">Get:2 http://archive.ubuntu.com/ubuntu/ trusty/main libpython2.7-minimal amd64 2.7.6-8 [307 kB]</div><div class="line">Get:3 http://archive.ubuntu.com/ubuntu/ trusty/main libpython2.7-stdlib amd64 2.7.6-8 [1872 kB]</div><div class="line">Get:4 http://archive.ubuntu.com/ubuntu/ trusty/main libpython2.7 amd64 2.7.6-8 [1044 kB]</div><div class="line">Get:5 http://archive.ubuntu.com/ubuntu/ trusty/main vim-runtime all 2:7.4.052-1ubuntu3 [4888 kB]</div><div class="line">......</div><div class="line">Processing triggers for libc-bin (2.19-0ubuntu6.6) ...</div><div class="line">root@faa127f03be9:/#</div></pre></td></tr></table></figure></p>
<p>vim软件包就已经安装好了，怎么样？是不是和普通宿主机安装软件包一样简单！</p>
<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><p>使用如下命令可以退出容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@faa127f03be9:/# exit</div><div class="line">exit</div><div class="line">[qifuguang@winwill~]$</div></pre></td></tr></table></figure></p>
<p>现在，容器已经退出了，我们可以使用如下命令看看当前有哪些容器正在运行：</p>
<p><img src="http://img.blog.csdn.net/20150627112734913" alt="这里写图片描述"></p>
<p>可以看到，当前没有处于运行状态的容器，但是如果使用如下命令，便会显示所有容器，包含没有处于运行状态的：</p>
<p><img src="http://img.blog.csdn.net/20150627112852973" alt="这里写图片描述"></p>
<p>也可以使用如下的命令列出最后一次运行的容器，包含正在运行和没有运行的：</p>
<p><img src="http://img.blog.csdn.net/20150627113045970" alt="这里写图片描述"></p>
<h2 id="为容器命名"><a href="#为容器命名" class="headerlink" title="为容器命名"></a>为容器命名</h2><p>上面的例子运行的容器的ID默认是一串没有规律的字符串，可读性非常差，还好，我们可以在创建启动容器的时候给它指定一个名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sudo docker run -t -i --name ubuntu ubuntu /bin/bash</div><div class="line">root@fdbcdbed6749:/#</div><div class="line">root@fdbcdbed6749:/#</div><div class="line">root@fdbcdbed6749:/#</div><div class="line">root@fdbcdbed6749:/#</div></pre></td></tr></table></figure></p>
<p>上面的命令通过参数项–name为创建的容器命名为ubuntu，我们看看生效没有：<br><img src="http://img.blog.csdn.net/20150627113908706" alt="这里写图片描述"><br>从图中可以看到，命名已经生效。</p>
<p>顺便说一下，容器的命名规则：只能包含大小写字母，数字，下划线，圆点，横线，如果用正则表达式表示这些符号就是[a-zA-Z0-9_.]。</p>
<h2 id="重启已经停止的容器"><a href="#重启已经停止的容器" class="headerlink" title="重启已经停止的容器"></a>重启已经停止的容器</h2><p>我们可以使用start命令启动已经停止的容器：<br><img src="http://img.blog.csdn.net/20150627114405311" alt="这里写图片描述"><br>也可以使用docker restart命令重新启动一个正在运行的容器。</p>
<h2 id="附着在容器上"><a href="#附着在容器上" class="headerlink" title="附着在容器上"></a>附着在容器上</h2><p>Docker容器重新启动的时候，会沿用创建容器时（docker run时）指定的参数来运行，因此指定了-t -i参数的容器重新启动之后会运行一个交互式的会话shell，我们可以使用docker attach命令重新附着到该容器的会话上：<br><img src="http://img.blog.csdn.net/20150627114728424" alt="这里写图片描述"></p>
<h2 id="创建守护式进程"><a href="#创建守护式进程" class="headerlink" title="创建守护式进程"></a>创建守护式进程</h2><p>除了运行交互式的容器，我们还可以创建长期运行的容器，守护式进程没有交互式会话，非常适合于运用程序和服务，大多数时候我们都需要使用交互式方式运行容器。下面我们启动一个守护式容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sudo docker run -d --name deamon_ubuntu ubuntu /bin/bash -c &quot;while true; do echo hello word; sleep 1; done&quot;</div><div class="line">48fcd5b118fd86ebee6fefb376cda3235384ddd3c41fa502ef0b59c9e1f2f1d3</div><div class="line">[qifuguang@winwill~]$</div></pre></td></tr></table></figure></p>
<p>可以看到，这个容器运行之后并没有像交互式容器一样将主机的控制台附着在新的shell会话上，而是仅仅返回一个容器ID。使用docker ps可以看到刚刚创建的交互式的容器正在运行：</p>
<p><img src="http://img.blog.csdn.net/20150627120122298" alt="这里写图片描述"></p>
<h2 id="查看容日日志"><a href="#查看容日日志" class="headerlink" title="查看容日日志"></a>查看容日日志</h2><p>对于守护式的容器，我们不能知道他到底在干些什么，但是我们可以通过查看docker容器的日志了解：<br><img src="http://img.blog.csdn.net/20150627120306595" alt="这里写图片描述"><br>可以看到，刚才创建的守护式容器正在后台不停地打印“hello world”。</p>
<p>也可以使用docker logs -f来监控docker容器的日志，就像ubuntu系统下使用tail -f 一样：</p>
<h2 id="查看容器内的进程"><a href="#查看容器内的进程" class="headerlink" title="查看容器内的进程"></a>查看容器内的进程</h2><p>除了容器的日志，我们还可以查看容器内部的进程：<br><img src="http://img.blog.csdn.net/20150627120548711" alt="这里写图片描述"><br>通过这个命令，我们可以看到容器内部的所有进程，运行进程的用户以及进程ID。</p>
<h2 id="在容器内部运行进程"><a href="#在容器内部运行进程" class="headerlink" title="在容器内部运行进程"></a>在容器内部运行进程</h2><p>Docker 1.3之后，可以通过docker exec命令在容器内部额外启动新进程。可以在容器内部运行的进程有两种形式：后台任务和交互式任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sudo docker exec -d deamon_ubuntu touch /etc/new_file</div><div class="line">[qifuguang@winwill~]$</div><div class="line">[qifuguang@winwill~]$</div><div class="line">[qifuguang@winwill~]$</div></pre></td></tr></table></figure></p>
<p>这里的-d标志表明需要运行一个后台任务，-d后面紧跟的是要在哪个容器内部执行命令，接下来是需要执行的命令。</p>
<p>我们也可以在deamon_ubuntu容器中启动一个打开shell的交互式任务，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sudo docker exec -i -t deamon_ubuntu /bin/bash</div><div class="line">root@48fcd5b118fd:/#</div><div class="line">root@48fcd5b118fd:/#</div><div class="line">root@48fcd5b118fd:/#</div><div class="line">root@48fcd5b118fd:/#</div><div class="line">root@48fcd5b118fd:/#</div></pre></td></tr></table></figure></p>
<p>这里的-i和-t参数和运行容器时的含义是一样的。</p>
<h2 id="停止守护式容器"><a href="#停止守护式容器" class="headerlink" title="停止守护式容器"></a>停止守护式容器</h2><p>要停止守护式容器，可以使用stop命令：<br><img src="http://img.blog.csdn.net/20150627121343870" alt="这里写图片描述"></p>
<h2 id="自动重启容器"><a href="#自动重启容器" class="headerlink" title="自动重启容器"></a>自动重启容器</h2><p>如果由于某种错误导致容器停止运行，我们可以通过–restart表示，让Docker自动重启容器。–restart会检查容器的推出代码，并以此来决定是否要重启容器，默认行为是docker不会重启容器。</p>
<h2 id="深入容器"><a href="#深入容器" class="headerlink" title="深入容器"></a>深入容器</h2><p>可以使用哪个docker inspect查看容器的详细信息：</p>
<p><img src="http://img.blog.csdn.net/20150627121639396" alt="这里写图片描述"></p>
<p>由于信息量太大，还可以使用-f或者–format标识来选定查看结果：</p>
<p><img src="http://img.blog.csdn.net/20150627121827553" alt="这里写图片描述"></p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用docker rm命令删除容器：</p>
<p><img src="http://img.blog.csdn.net/20150627121932771" alt="这里写图片描述"></p>
<p>docker基本的操作大概就这么多。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis持久化]]></title>
      <url>https://fudawei.github.io/2015/10/13/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Redis的强大性能很大程度上都是因为所有数据都是存储在内存中的，然而当Redis重启后，所有存储在内存中的数据将会丢失，在很多情况下是无法容忍这样的事情的。所以，我们需要将内存中的数据持久化！典型的需要持久化数据的场景如下：</p>
<ul>
<li>将Redis作为数据库使用；</li>
<li>将Redis作为缓存服务器使用，但是缓存miss后会对性能造成很大影响，所有缓存同时失效时会造成服务雪崩，无法响应。</li>
</ul>
<a id="more"></a>
<p>本文介绍Redis所支持的两种数据持久化方式。</p>
<h1 id="Redis数据持久化"><a href="#Redis数据持久化" class="headerlink" title="Redis数据持久化"></a>Redis数据持久化</h1><p>Redis支持两种数据持久化方式：RDB方式和AOF方式。前者会根据配置的规则定时将内存中的数据持久化到硬盘上，后者则是在每次执行写命令之后将命令记录下来。两种持久化方式可以单独使用，但是通常会将两者结合使用。</p>
<h2 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h2><p>RDB方式的持久化是通过快照的方式完成的。当符合某种规则时，会将内存中的数据全量生成一份副本存储到硬盘上，这个过程称作”快照”，Redis会在以下几种情况下对数据进行快照：</p>
<ul>
<li>根据配置规则进行自动快照；</li>
<li>用户执行SAVE, BGSAVE命令；</li>
<li>执行FLUSHALL命令；</li>
<li>执行复制（replication）时。</li>
</ul>
<h3 id="执行快照的场景"><a href="#执行快照的场景" class="headerlink" title="执行快照的场景"></a>执行快照的场景</h3><h4 id="根据配置自动快照"><a href="#根据配置自动快照" class="headerlink" title="根据配置自动快照"></a>根据配置自动快照</h4><p>Redis允许用户自定义快照条件，当满足条件时自动执行快照，快照规则的配置方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">save 900 1</div><div class="line">save 300 10</div><div class="line">save 60 10000</div></pre></td></tr></table></figure>
<p>每个快照条件独占一行，他们之间是或（||）关系，只要满足任何一个就进行快照。上面配置save后的第一个参数T是时间，单位是秒，第二个参数M是更改的键的个数，含义是：当时间T内被更改的键的个数大于M时，自动进行快照。比如<code>save 900 1</code>的含义是15分钟内(900s)被更改的键的个数大于1时，自动进行快照操作。</p>
<h4 id="执行SAVE或BGSAVE命令"><a href="#执行SAVE或BGSAVE命令" class="headerlink" title="执行SAVE或BGSAVE命令"></a>执行SAVE或BGSAVE命令</h4><p>除了让Redis自动进行快照外，当我们需要重启，迁移，备份Redis时，我们也可以手动执行SAVE或BGSAVE命令主动进行快照操作。</p>
<ul>
<li><strong>SAVE命令：</strong>当执行SAVE命令时，Redis同步进行快照操作，期间会阻塞所有来自客户端的请求，所以放数据库数据较多时，应该避免使用该命令；</li>
<li><strong>BGSAVE命令：</strong> 从命令名字就能看出来，这个命令与SAVE命令的区别就在于该命令的快照操作是在后台异步进行的，进行快照操作的同时还能处理来自客户端的请求。执行BGSAVE命令后Redis会马上返回OK表示开始进行快照操作，如果想知道快照操作是否已经完成，可以使用LASTSAVE命令返回最近一次成功执行快照的时间，返回结果是一个Unix时间戳。</li>
</ul>
<h4 id="执行FLUSHALL命令"><a href="#执行FLUSHALL命令" class="headerlink" title="执行FLUSHALL命令"></a>执行FLUSHALL命令</h4><p>当执行FLUSHALL命令时，Redis会清除数据库中的所有数据。需要注意的是：<strong>不论清空数据库的过程是否触发 了自动快照的条件，只要自动快照条件不为空，Redis就会执行一次快照操作，当没有定义自动快照条件时，执行FLUSHALL命令不会进行快照操作。</strong></p>
<h4 id="执行复制"><a href="#执行复制" class="headerlink" title="执行复制"></a>执行复制</h4><p>当设置了主从模式时，Redis会在复制初始化是进行自动快照。</p>
<h3 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h3><p>Redis默认会将快照文件存储在Redis当前进程的工作目录的dump.rdb文件中，可以通过配置文件中的dir和dbfilename两个参数分别指定快照文件的存储路径和文件名，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dbfilename dump.rdb</div><div class="line">dir /opt/soft/redis-3.0.4/cache</div></pre></td></tr></table></figure>
<p>快照执行的过程如下：</p>
<ol>
<li>Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；</li>
<li>父进程继续处理来自客户端的请求，子进程开始将内存中的数据写入硬盘中的临时文件；</li>
<li>当子进程写完所有的数据后，用该临时文件替换旧的RDB文件，至此，一次快照操作完成。</li>
</ol>
<p>需要注意的是：  </p>
<blockquote>
<p><strong>在执行fork是时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻，父进程和子进程共享同一块内存数据，当父进程需要修改其中的某片数据（如执行写命令）时，操作系统会将该片数据复制一份以保证子进程不受影响，所以RDB文件存储的是执行fork操作那一刻的内存数据。所以RDB方式理论上是会存在丢数据的情况的(fork之后修改的的那些没有写进RDB文件)。</strong></p>
</blockquote>
<p>通过上述的介绍可以知道，快照进行时时不会修改RDB文件的，只有完成的时候才会用临时文件替换老的RDB文件，所以就保证任何时候RDB文件的都是完整的。这使得我们可以通过定时备份RDB文件来实现Redis数据的备份。RDB文件是经过压缩处理的二进制文件，所以占用的空间会小于内存中数据的大小，更有利于传输。</p>
<p>Redis启动时会自动读取RDB快照文件，将数据从硬盘载入到内存，根据数量的不同，这个过程持续的时间也不尽相同，通常来讲，一个记录1000万个字符串类型键，大小为1GB的快照文件载入到内存需要20-30秒的时间。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面演示RDB方式持久化，首先使用配置有如下快照规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">save 900 1</div><div class="line">save 300 10</div><div class="line">save 60 10000</div><div class="line">dbfilename dump.rdb</div><div class="line">dir /opt/soft/redis-3.0.4/cache</div></pre></td></tr></table></figure>
<p>的配置文件<code>/opt/soft/redis-3.0.4/conf/redis.conf</code>启动Redis服务：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis持久化/start-redis.png" alt="">  </p>
<p>然后通过客户端设置一个键值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[qifuguang@Mac~]$ /opt/soft/redis-3.0.4/src/redis-cli -p 6379</div><div class="line">127.0.0.1:6379&gt; set test-rdb HelloWorld</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; get test-rdb</div><div class="line">&quot;HelloWorld&quot;</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure>
<p>现在强行kill Redis服务：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis持久化/stop-redis.png" alt=""><br>现在到<code>/opt/soft/redis-3.0.4/cache</code>目录看，目录下出现了Redis的快照文件dump.rdb：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[qifuguang@Mac/opt/soft/redis-3.0.4/cache]$ ls</div><div class="line">dump.rdb</div></pre></td></tr></table></figure>
<p>现在重新启动Redis：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Redis持久化/start-redis.png" alt="">  </p>
<p>然后再用客户端连接，检查之前设置的key是否还存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[qifuguang@Mac~]$ /opt/soft/redis-3.0.4/src/redis-cli -p 6379</div><div class="line">127.0.0.1:6379&gt; get test-rdb</div><div class="line">&quot;HelloWorld&quot;</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure>
<p>可以发现，之前设置的key在Redis重启之后又通过快照文件dump.rdb恢复了。</p>
<h2 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h2><p>在使用Redis存储非临时数据时，一般都需要打开AOF持久化来降低进程终止导致的数据丢失，AOF可以将Redis执行的每一条写命令追加到硬盘文件中，这已过程显然会降低Redis的性能，但是大部分情况下这个影响是可以接受的，另外，使用较快的硬盘能提高AOF的性能。</p>
<h3 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h3><p>默认情况下，Redis没有开启AOF（append only file）持久化功能，可以通过在配置文件中作如下配置启用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appendonly yes</div></pre></td></tr></table></figure>
<p>开启之后，Redis每执行一条写命令就会将该命令写入硬盘中的AOF文件。AOF文件保存路径和RDB文件路径是一致的，都是通过dir参数配置，默认文件名是：appendonly.aof，可以通过配置appendonlyfilename参数修改，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appendonlyfilename appendonly.aof</div></pre></td></tr></table></figure>
<h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>AOF纯文本的形式记录了Redis执行的写命令，例如在开启AOF持久化的情况下执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[qifuguang@Mac/opt/soft/redis-3.0.4]$ ./src/redis-cli</div><div class="line">127.0.0.1:6379&gt;</div><div class="line">127.0.0.1:6379&gt;</div><div class="line">127.0.0.1:6379&gt;</div><div class="line">127.0.0.1:6379&gt; set aof1 value1</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; set aof2 value2</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure>
<p>然后查看<code>/opt/soft/redis-3.0.4/cache/appendonly.aof</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[qifuguang@Mac/opt/soft/redis-3.0.4/cache]$ cat appendonly.aof</div><div class="line">*2</div><div class="line">$6</div><div class="line">SELECT</div><div class="line">$1</div><div class="line">0</div><div class="line">*3</div><div class="line">$3</div><div class="line">set</div><div class="line">$4</div><div class="line">aof1</div><div class="line">$6</div><div class="line">value1</div><div class="line">*3</div><div class="line">$3</div><div class="line">set</div><div class="line">$4</div><div class="line">aof2</div><div class="line">$6</div><div class="line">value2</div></pre></td></tr></table></figure>
<p>文件中的内容正是Redis刚才执行的命令的内容，内容的格式就先不展开叙述了。</p>
<h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><p>假设Redis执行了如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[qifuguang@Mac/opt/soft/redis-3.0.4]$ ./src/redis-cli</div><div class="line">127.0.0.1:6379&gt;</div><div class="line">127.0.0.1:6379&gt;</div><div class="line">127.0.0.1:6379&gt;</div><div class="line">127.0.0.1:6379&gt; set k v1</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; set k v2</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; set k v3</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure>
<p>如果这所有的命令都写到AOF文件的话，将是一个比较蠢行为，因为前面两个命令会被第三个命令覆盖，所以AOF文件完全不需要保存前面两个文件，事实上Redis确实就是这么做的。删除AOF文件中无用的命令的过程成为”AOF重写”，AOF重写可以在配置文件中做相应的配置，当满足配置的条件时，自动进行AOF重写操作。配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto-aof-rewrite-percentage 100</div><div class="line">auto-aof-rewrite-min-size 64mb</div></pre></td></tr></table></figure>
<p>第一行的意思是，目前的AOF文件的大小超过上一次重写时的AOF文件的百分之多少时再次进行重写，如果之前没有重写过，则以启动时AOF文件大小为依据。<br>第二行的意思是，当AOF文件的大小大于64MB时才进行重写，因为如果AOF文件本来就很小时，有几个无效的命令也是无伤大雅的事情。<br>这两个配置项通常一起使用。</p>
<p>我们还可以手动执行BDREWRITEAOF命令主动让Redis重写AOF文件，执行重写命令之后查看现在的AOF文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[qifuguang@Mac/opt/soft/redis-3.0.4]$ cat cache/appendonly.aof</div><div class="line">*2</div><div class="line">$6</div><div class="line">SELECT</div><div class="line">$1</div><div class="line">0</div><div class="line">*3</div><div class="line">$3</div><div class="line">SET</div><div class="line">$4</div><div class="line">aof2</div><div class="line">$6</div><div class="line">value2</div><div class="line">*3</div><div class="line">$3</div><div class="line">SET</div><div class="line">$1</div><div class="line">k</div><div class="line">$2</div><div class="line">v3</div><div class="line">*3</div><div class="line">$3</div><div class="line">SET</div><div class="line">$4</div><div class="line">aof1</div><div class="line">$6</div><div class="line">value1</div></pre></td></tr></table></figure>
<p>可以看到，文件中并没有再记录<code>set k v1</code>这样的无效命令。</p>
<h3 id="同步硬盘数据"><a href="#同步硬盘数据" class="headerlink" title="同步硬盘数据"></a>同步硬盘数据</h3><p>虽然每次执行更改数据库的内容时，AOF都会记录执行的命令，但是由于操作系统本身的硬盘缓存的缘故，AOF文件的内容并没有真正地写入硬盘，在默认情况下，操作系统会每隔30s将硬盘缓存中的数据同步到硬盘，但是为了防止系统异常退出而导致丢数据的情况发生，我们还可以在Redis的配置文件中配置这个同步的频率：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># appendfsync always</div><div class="line">appendfsync everysec</div><div class="line"># appendfsync no</div></pre></td></tr></table></figure>
<p>第一行表示每次AOF写入一个命令都会执行同步操作，这是最安全也是最慢的方式；<br>第二行表示每秒钟进行一次同步操作，一般来说使用这种方式已经足够；<br>第三行表示不主动进行同步操作，这是最不安全的方式。</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文为作者原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/10/13/Redis持久化">http://fudawei.github.io/2015/10/13/Redis持久化</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ZooKeeper使用场景]]></title>
      <url>https://fudawei.github.io/2015/10/10/ZooKeeper%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ZooKeeper是一个高可用的分布式数据管理与系统协调框架。基于对Paxos算法的实现，使该框架保证了分布式环境中数据的强一致性，也正是基于这样的特性，使得ZooKeeper解决很多分布式问题。网上对ZK的应用场景也有不少介绍，本文将结合作者身边的项目例子，系统地对ZK的应用场景进行一个分门归类的介绍。</p>
<p>值得注意的是，ZK并非天生就是为这些应用场景设计的，都是后来众多开发者根据其框架的特性，利用其提供的一系列API接口（或者称为原语集），摸索出来的典型使用方法。因此，也非常欢迎读者分享你在ZK使用上的奇技淫巧。<br><a id="more"></a></p>
<h1 id="ZooKeeper应用场景"><a href="#ZooKeeper应用场景" class="headerlink" title="ZooKeeper应用场景"></a>ZooKeeper应用场景</h1><h2 id="数据发布与订阅（配置中心）"><a href="#数据发布与订阅（配置中心）" class="headerlink" title="数据发布与订阅（配置中心）"></a>数据发布与订阅（配置中心）</h2><p>发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。<br>应用中用到的一些配置信息放到ZK上进行集中管理。这类场景通常是这样：应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个Watcher，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。<br>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在ZK的一些指定节点，供各个客户端订阅使用。分布式日志收集系统。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用来分配收集任务单元，因此需要在ZK上创建一个以应用名作为path的节点P，并将这个应用的所有机器ip，以子节点的形式注册到节点P上，这样一来就能够实现机器变动的时候，能够实时通知到收集器调整任务分配。<br>系统中有些信息需要动态获取，并且还会存在人工手动去修改这个信息的发问。通常是暴露出接口，例如JMX接口，来获取一些运行时的信息。引入ZK之后，就不用自己实现一套方案了，只要将这些信息存放到指定的ZK节点上即可。<br><strong>注意：在上面提到的应用场景中，有个默认前提是：数据量很小，但是数据更新可能会比较快的场景。</strong></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>这里说的负载均衡是指软负载均衡。在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，其中比较典型的是消息中间件中的生产者，消费者负载均衡。<br>消息中间件中发布者和订阅者的负载均衡，linkedin开源的KafkaMQ和阿里开源的 metaq都是通过zookeeper来做到生产者、消费者的负载均衡。这里以metaq为例讲下： </p>
<h3 id="生产者负载均衡"><a href="#生产者负载均衡" class="headerlink" title="生产者负载均衡"></a>生产者负载均衡</h3><p>metaq发送消息的时候，生产者在发送消息的时候必须选择一台broker上的一个分区来发送消息，因此metaq在运行过程中，会把所有broker和对应的分区信息全部注册到ZK指定节点上，默认的策略是一个依次轮询的过程，生产者在通过ZK获取分区列表之后，会按照brokerId和partition的顺序排列组织成一个有序的分区列表，发送的时候按照从头到尾循环往复的方式选择一个分区来发送消息。</p>
<h3 id="消费负载均衡："><a href="#消费负载均衡：" class="headerlink" title="消费负载均衡："></a>消费负载均衡：</h3><p>在消费过程中，一个消费者会消费一个或多个分区中的消息，但是一个分区只会由一个消费者来消费。MetaQ的消费策略是：</p>
<ul>
<li>每个分区针对同一个group只挂载一个消费者。</li>
<li>如果同一个group的消费者数目大于分区数目，则多出来的消费者将不参与消费。</li>
<li>如果同一个group的消费者数目小于分区数目，则有部分消费者需要额外承担消费任务。</li>
<li>在某个消费者故障或者重启等情况下，其他消费者会感知到这一变化（通过 zookeeper watch消费者列表），然后重新进行负载均衡，保证所有的分区都有消费者进行消费。</li>
</ul>
<h2 id="命名服务-Naming-Service"><a href="#命名服务-Naming-Service" class="headerlink" title="命名服务(Naming Service)"></a>命名服务(Naming Service)</h2><p>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。<br>阿里巴巴集团开源的分布式服务框架Dubbo中使用ZooKeeper来作为其命名服务，维护全局的服务地址列表， 点击这里查看Dubbo开源项目。在Dubbo实现中：</p>
<blockquote>
<p>服务提供者在启动的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。<br>服务消费者启动的时候，订阅/dubbo/${serviceName}/providers目录下的提供者URL地址， 并向/dubbo/${serviceName} /consumers目录下写入自己的URL地址。<br>注意，所有向ZK上注册的地址都是临时节点，这样就能够保证服务提供者和消费者能够自动感应资源的变化。<br>另外，Dubbo还有针对服务粒度的监控，方法是订阅/dubbo/${serviceName}目录下所有提供者和消费者的信息。</p>
</blockquote>
<h2 id="分布式通知-协调"><a href="#分布式通知-协调" class="headerlink" title="分布式通知/协调"></a>分布式通知/协调</h2><p>ZooKeeper中特有watcher注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理。使用方法通常是不同系统都对ZK上同一个znode进行注册，监听znode的变化（包括znode本身内容及子节点的），其中一个系统update了znode，那么另一个系统能够收到通知，并作出相应处理<br>另一种心跳检测机制：检测系统和被检测系统之间并不直接关联起来，而是通过zk上某个节点关联，大大减少系统耦合。<br>另一种系统调度模式：某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了ZK上某些节点的状态，而ZK就把这些变化通知给他们注册Watcher的客户端，即推送系统，于是，作出相应的推送任务。<br>另一种工作汇报模式：一些类似于任务分发系统，子任务启动后，到zk来注册一个临时节点，并且定时将自己的进度进行汇报（将进度写回这个临时节点），这样任务管理者就能够实时知道任务进度。<br>总之，使用zookeeper来进行分布式通知和协调能够大大降低系统之间的耦合</p>
<h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><p>集群机器监控通常用于那种对集群中机器状态，机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。这样的场景中，往往有一个监控系统，实时检测集群机器是否存活。过去的做法通常是：监控系统通过某种手段（比如ping）定时检测每个机器，或者每个机器自己定时向监控系统汇报“我还活着”。 这种做法可行，但是存在两个比较明显的问题：</p>
<ul>
<li>集群中机器有变动的时候，牵连修改的东西比较多。</li>
<li>有一定的延时。</li>
</ul>
<p>利用ZooKeeper的两个特性，就可以实时另一种集群机器存活性监控系统：</p>
<blockquote>
<p>客户端在节点x上注册一个Watcher，那么如果x的子节点变化了，会通知该客户端。<br>创建EPHEMERAL类型的节点，一旦客户端和服务器的会话结束或过期，那么该节点就会消失。<br>例如，监控系统在 /clusterServers 节点上注册一个Watcher，以后每动态加机器，那么就往 /clusterServers 下创建一个 EPHEMERAL类型的节点：/clusterServers/{hostname}. 这样，监控系统就能够实时知道机器的增减情况，至于后续处理就是监控系统的业务了。</p>
</blockquote>
<h2 id="Master选举"><a href="#Master选举" class="headerlink" title="Master选举"></a>Master选举</h2><p>Master选举是zookeeper中最为经典的应用场景了。在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络I/O处理），往往只需要让整个集群中的某一台机器进行执行，其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能，于是这个master选举便是这种场景下的碰到的主要问题。</p>
<p>利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 /currentMaster 节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选取了。</p>
<p>另外，这种场景演化一下，就是动态Master选举。这就要用到?EPHEMERAL_SEQUENTIAL类型节点的特性了。</p>
<p>上文中提到，所有客户端创建请求，最终只有一个能够创建成功。在这里稍微变化下，就是允许所有请求都能够创建成功，但是得有个创建顺序，于是所有的请求最终在ZK上创建结果的一种可能情况是这样： /currentMaster/{sessionId}-1 ,?/currentMaster/{sessionId}-2 ,?/currentMaster/{sessionId}-3 ….. 每次选取序列号最小的那个机器作为Master，如果这个机器挂了，由于他创建的节点会马上小时，那么之后最小的那个机器就是Master了。</p>
<p>在搜索系统中，如果集群中每个机器都生成一份全量索引，不仅耗时，而且不能保证彼此之间索引数据一致。因此让集群中的Master来进行全量索引的生成，然后同步到集群中其它机器。另外，Master选举的容灾措施是，可以随时进行手动指定master，就是说应用在zk在无法获取master信息时，可以通过比如http方式，向一个地方获取master。<br>在Hbase中，也是使用ZooKeeper来实现动态HMaster的选举。在Hbase实现中，会在ZK上存储一些ROOT表的地址和HMaster的地址，HRegionServer也会把自己以临时节点（Ephemeral）的方式注册到Zookeeper中，使得HMaster可以随时感知到各个HRegionServer的存活状态，同时，一旦HMaster出现问题，会重新选举出一个HMaster来运行，从而避免了HMaster的单点问题。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强一致性。锁服务可以分为两类，一个是 保持独占，另一个是 控制时序。<br>所谓保持独占，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。<br>控制时序，就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 /distribute_lock 已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指定）。Zk的父节点（/distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p>
<h2 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h2><p>队列方面，简单地讲有两种，一种是常规的先进先出队列，另一种是要等到队列成员聚齐之后的才统一按序执行。对于第一种先进先出队列，和分布式锁服务中的控制时序场景基本原理一致，这里不再赘述。<br>第二种队列其实是在FIFO队列的基础上作了一个增强。通常可以在 /queue 这个znode下预先建立一个/queue/num 节点，并且赋值为n（或者直接给/queue赋值n），表示队列大小，之后每次有队列成员加入后，就判断下是否已经到达队列大小，决定是否可以开始执行了。这种用法的典型场景是，分布式环境中，一个大任务Task A，需要在很多子任务完成（或条件就绪）情况下才能进行。这个时候，凡是其中一个子任务完成（就绪），那么就去 /taskList 下建立自己的临时时序节点（CreateMode.EPHEMERAL_SEQUENTIAL），当 /taskList 发现自己下面的子节点满足指定个数，就可以进行下一步按序进行处理了。</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文非原创，原文链接：<a href="http://itindex.net/detail/53886-zookeeper" target="_blank" rel="external">http://itindex.net/detail/53886-zookeeper</a>，尊重原创，转载请注明出处。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Docker学习二]Ubuntu系统安装Docker]]></title>
      <url>https://fudawei.github.io/2015/10/03/%5BDocker%E5%AD%A6%E4%B9%A0%E4%BA%8C%5DUbuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Docker/</url>
      <content type="html"><![CDATA[<p>本文仅仅介绍在ubuntu系统主机上安装Docker的方法，OSX,windows等系统请读者参阅：</p>
<p><a href="http://blog.csdn.net/zistxym/article/details/42918339" target="_blank" rel="external">window安装点击这里</a><br><a href="http://www.oschina.net/translate/installing-docker-on-mac-os-x" target="_blank" rel="external">OSX安装点击这里</a><br><a id="more"></a></p>
<h2 id="在Ubuntu系统中安装Docker"><a href="#在Ubuntu系统中安装Docker" class="headerlink" title="在Ubuntu系统中安装Docker"></a>在Ubuntu系统中安装Docker</h2><p>目前，官方支持在西面的Ubuntu系统中安装Docker：</p>
<p>Ubuntu  14.04   64位<br>Ubuntu  13.04   64位<br>Ubuntu  13.10   64位<br>Ubuntu  12.04   64位<br>但是，并不是说在上述清单之外的Ubuntu（活着Debian）版本就不能安装Docker。只要有适当的内核和Docker所必须的支持，其他版本的Ubuntu也是可以安装Docker的，只不过这些版本没有得到官方支持，遇到bug无法得到官方的修复。</p>
<p>在Ubuntu系统下安装Docker需要如下步骤：</p>
<h3 id="检查前提条件"><a href="#检查前提条件" class="headerlink" title="检查前提条件"></a>检查前提条件</h3><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>使用如下命令检查系统内核版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ uname -a</div><div class="line">Linux qifuguang-OptiPlex-9010 3.13.0-53-generic #89-Ubuntu SMP Wed May 20 10:34:39 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux</div></pre></td></tr></table></figure></p>
<p>可以看到我的机器的内核版本是3.13.0-53，安装Docker需要Linux机器内核版本在3.8以上，所以符合要求。</p>
<h4 id="检查Device-Mapper"><a href="#检查Device-Mapper" class="headerlink" title="检查Device Mapper"></a>检查Device Mapper</h4><p>我们将使用Device Mapper作为存储驱动，自2.6.9版本的linux内核已经开始集成了Device Mapper，并且提供了一个将快设备映射到高级虚拟设备的方法。Device Mapper支持“自动精简配置”的概念，可以在一中文件系统中存储多台虚拟设备。因此使用Device Mapper作为Docker的存储驱动再合适不过了。</p>
<p>可以通过如下的命令确认机器是否安装了Device Mapper：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ ls -l /sys/class/misc/device-mapper</div><div class="line">lrwxrwxrwx 1 root root 0  6月 26 20:26 /sys/class/misc/device-mapper -&gt; ../../devices/virtual/misc/device-mapper</div></pre></td></tr></table></figure></p>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>如果上述的条件都符合，就可以安装Docker了。首先要添加Docker的APT仓库，代码如下:</p>
<p>[qifuguang@winwill~]$ sudo sh -c “echo deb <a href="https://get.docker.io/ubuntu" target="_blank" rel="external">https://get.docker.io/ubuntu</a> docker main &gt; /etc/apt/sources.list.d/docker.list”</p>
<p>接下来，要添加Docker仓库的GPG密钥，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ curl -s https://get.docker.io/gpg | sudo apt-key add -</div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>之后，我们更新一下APT源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sudo apt-get update</div><div class="line">忽略 http://security.ubuntu.com trusty-security InRelease</div><div class="line">忽略 http://ppa.launchpad.net trusty InRelease</div><div class="line">获取：1 http://security.ubuntu.com trusty-security Release.gpg [933 B]</div><div class="line">忽略 http://extras.ubuntu.com trusty InRelease</div><div class="line">获取：2 http://security.ubuntu.com trusty-security Release [63.5 kB]</div><div class="line">忽略 http://ppa.launchpad.net trusty InRelease</div><div class="line">命中 http://extras.ubuntu.com trusty Release.gpg</div><div class="line">获取：3 http://ppa.launchpad.net trusty Release.gpg [316 B]</div><div class="line">命中 http://extras.ubuntu.com trusty Release</div><div class="line">获取：4 https://get.docker.io docker InRelease</div><div class="line">命中 http://ppa.launchpad.net trusty Release.gpg</div><div class="line">命中 http://extras.ubuntu.com trusty/main Sources</div><div class="line">命中 http://extras.ubuntu.com trusty/main amd64 Packages</div><div class="line">获取：5 http://ppa.launchpad.net trusty Release [15.1 kB]</div><div class="line">获取：6 http://security.ubuntu.com trusty-security/main amd64 Packages [304 kB]</div><div class="line">忽略 https://get.docker.io docker InRelease</div><div class="line">命中 http://extras.ubuntu.com trusty/main i386 Packages</div><div class="line">25% [正在连接 cn.archive.ubuntu.com] [正在等待报头] [6 Packages 17.0</div><div class="line">......</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>现在，就可以安装Docker软件包了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sudo apt-get install lxc-docker</div><div class="line">正在读取软件包列表... 完成</div><div class="line">正在分析软件包的依赖关系树</div><div class="line">正在读取状态信息... 完成</div><div class="line">将会安装下列额外的软件包：</div><div class="line">  lxc-docker-1.7.0</div><div class="line">  下列软件包将被【卸载】：</div><div class="line">    lxc-docker-1.6.2</div><div class="line">    下列【新】软件包将被安装：</div><div class="line">      lxc-docker-1.7.0</div><div class="line">      下列软件包将被升级：</div><div class="line">        lxc-docker</div><div class="line">        升级了 1 个软件包，新安装了 1 个软件包，要卸载 1 个软件包，有 0 个软件包未被升级。</div><div class="line">        需要下载 4,964 kB 的软件包。</div><div class="line">        解压缩后会消耗掉 820 kB 的额外空间。</div><div class="line">        您希望继续执行吗？ [Y/n]Y</div></pre></td></tr></table></figure></p>
<h2 id="检查Docker是否安装成功"><a href="#检查Docker是否安装成功" class="headerlink" title="检查Docker是否安装成功"></a>检查Docker是否安装成功</h2><pre><code>安装完成之后，可以使用docker info命令确认docker是否已经正确安装并运行了：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sudo docker info</div><div class="line">Containers: 5</div><div class="line">Images: 72</div><div class="line">Storage Driver: aufs</div><div class="line"> Root Dir: /var/lib/docker/aufs</div><div class="line">  Backing Filesystem: extfs</div><div class="line">   Dirs: 82</div><div class="line">    Dirperm1 Supported: false</div><div class="line">    Execution Driver: native-0.2</div><div class="line">    Kernel Version: 3.13.0-53-generic</div><div class="line">    Operating System: Ubuntu 14.04.2 LTS</div><div class="line">    CPUs: 8</div><div class="line">    Total Memory: 15.56 GiB</div><div class="line">    Name: qifuguang-OptiPlex-9010</div><div class="line">    ID: SNVW:WBCG:76BZ:2L63:AFQR:ZMDS:KI4Z:XIQZ:ENHV:O7PI:QMDP:6DQ3</div><div class="line">    Username: quinn2012</div><div class="line">    Registry: [https://index.docker.io/v1/]</div><div class="line">    WARNING: No swap limit support</div></pre></td></tr></table></figure>
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Docker学习一]Docker简介]]></title>
      <url>https://fudawei.github.io/2015/10/01/%5BDocker%E5%AD%A6%E4%B9%A0%E4%B8%80%5DDocker%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><p>Docker是一个能够把开发的应用程序很方便地部署到容器的开源引擎。由Docker公司团队编写，基于Apache 2.0开源授权协议发行。Docker的主要目的如下：<br><a id="more"></a></p>
<h3 id="提供一个简单的，轻量的建模方式"><a href="#提供一个简单的，轻量的建模方式" class="headerlink" title="提供一个简单的，轻量的建模方式"></a>提供一个简单的，轻量的建模方式</h3><p>Docker上手快，只需要几分钟就可以将自己的程序Docker化。Docker依赖写时复制技术，使修改应用程序非常迅速，达到“随心所至，代码即改”的境界。Docker启动速度非常快，大多数的Docker容器只需不到1秒钟的时间即可启动。由于除去了管理程序的开销，Docker容器拥有很高的性能，一台宿主机可以同时运行很多容器，要比虚拟机技术牛逼得多。</p>
<h3 id="职责的逻辑分离"><a href="#职责的逻辑分离" class="headerlink" title="职责的逻辑分离"></a>职责的逻辑分离</h3><p>使用Docker，开发人员只需要关系容器中运行的应用程序，而运维人员只需要关心如何管理容器，分离职责。</p>
<h3 id="快速、高效的开发生命周期"><a href="#快速、高效的开发生命周期" class="headerlink" title="快速、高效的开发生命周期"></a>快速、高效的开发生命周期</h3><p>Docker的目标之一就是缩短代码从开发，测试到部署，上线运行的周期，让应用程序具备可移植性，易于构建，易于协作。</p>
<h3 id="鼓励使用面向服务的架构"><a href="#鼓励使用面向服务的架构" class="headerlink" title="鼓励使用面向服务的架构"></a>鼓励使用面向服务的架构</h3><p>Docker鼓励面向服务的架构和微服务架构，推荐单个容器只运行一个进程或程序。这样就形成了一个分布式的应用程序模型，在这种情况下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序变得非常简单，同时也提高了程序的内省性。</p>
<h2 id="Docker组件"><a href="#Docker组件" class="headerlink" title="Docker组件"></a>Docker组件</h2><p>Docker包含如下组件：</p>
<p>Docker客户端和服务器<br>Docker镜像（image）<br>Docker容器<br>Registry<br>至于这些名词具体表示什么意思，后面会有文章做详细的介绍。</p>
<h2 id="Docker能做什么"><a href="#Docker能做什么" class="headerlink" title="Docker能做什么"></a>Docker能做什么</h2><p>我们可以使用Docker做如下一些事情：</p>
<p>加速本地开发和构建流程，使其更加高效，更加轻量化。<br>能够让独立服务或者应用程序在不同的环境红，得到相同的运行结果。<br>用Docker创建隔离的环境来进行测试。<br>Docker可以让开发者很简单地在本机构建一个复杂的环境进行测试。<br>构建一个多用户的平台即服务（PaaS）基础设施。<br>为开发，测试提供一个轻量级的独立沙盒测试环境。<br>提供软件即服务(SaaS)应用程序，如Memcached即服务。<br>高性能，超大规模的宿主机部署。</p>
<h2 id="Docker的核心技术"><a href="#Docker的核心技术" class="headerlink" title="Docker的核心技术"></a>Docker的核心技术</h2><ul>
<li><strong>文件系统隔离</strong>：每个容器都拥有自己的root文件系统。</li>
<li><strong>进程隔离</strong>：每个容器都运行在自己的进程环境中。</li>
<li><strong>网络隔离</strong>：容器的虚拟网络接口和IP都是分开的。</li>
<li><strong>资源隔离和分组</strong>：使用cgroups将CPU和内存资源独立分配给每个 Docker容器。</li>
<li><strong>写时复制</strong>：文件系统都是写时复制的，速度快，占用磁盘空间更少。</li>
<li><strong>日志收集</strong>：容器产生的stdin，stdout，stderr日志都会被收集并记录日志。</li>
<li><strong>交互式shell</strong>：用户可以创建一个伪tty终端，将其连接到stdin，为容器提供一个交互式的shell。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis过期机制介绍]]></title>
      <url>https://fudawei.github.io/2015/09/30/Redis%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在实际开发过程中经常会遇到一些有时效性数据，比如限时优惠活动，缓存或者验证码之类的。过了一段时间就需要删除这些数据。在关系型数据库中一般都要增加一个字段记录数据的到期时间，然后周期性地检查过期数据然后删除。Redis本身就对键过期提供了很好的支持。</p>
<a id="more"></a>
<h1 id="Redis过期机制"><a href="#Redis过期机制" class="headerlink" title="Redis过期机制"></a>Redis过期机制</h1><p>在Redis中可以使用<strong>EXPIRE</strong>命令设置一个键的存活时间(ttl: time to live)，过了这段时间，该键就会自动被删除，EXPIRE命令的使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EXPIRE key ttl(单位秒)</div></pre></td></tr></table></figure>
<p>命令返回1表示设置ttl成功，返回0表示键不存在或者设置失败。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; set session 100</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; EXPIRE session 5</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; get session</div><div class="line">&quot;100&quot;</div><div class="line">127.0.0.1:6379&gt; get session</div><div class="line">&quot;100&quot;</div><div class="line">127.0.0.1:6379&gt; get session</div><div class="line">(nil)</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure>
<p>上例可见，先设置session的值为100，然后设置他的ttl为5s，之后连续几次使用get命令获取session，5s之后将获取不到session，因为ttl时间已到，session被删除。</p>
<p>如果想知道一个键还有多长时间被删除，则可以使用<strong>TTL</strong>命令查看，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TTL key</div></pre></td></tr></table></figure>
<p>返回值是键的剩余时间，单位秒。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; set session 100</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; EXPIRE session 10</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; TTL session</div><div class="line">(integer) 7</div><div class="line">127.0.0.1:6379&gt; TTL session</div><div class="line">(integer) 5</div><div class="line">127.0.0.1:6379&gt; TTL session</div><div class="line">(integer) 2</div><div class="line">127.0.0.1:6379&gt; TTL session</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; TTL session</div><div class="line">(integer) -2</div><div class="line">127.0.0.1:6379&gt; TTL session</div><div class="line">(integer) -2</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure>
<p>可见，TTL的返回值会随着时间的流逝慢慢减少，10s之后键会被删除，键不存在时TTL会返回-2，<strong>当没有为键设置过期时间时，使用TTL获取键的剩余时间将会返回-1</strong>，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; set url http://fudawei.github.io</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; ttl url</div><div class="line">(integer) -1</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure>
<p>如果想取消某个键的过期时间，可以使用<strong>PERSIST</strong>命令，用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PERSIST key</div></pre></td></tr></table></figure>
<p>清除成功返回1，失败返回0.</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; set title 飞鸟</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; EXPIRE title 100</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; ttl title</div><div class="line">(integer) 97</div><div class="line">127.0.0.1:6379&gt; PERSIST title</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; ttl title</div><div class="line">(integer) -1</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure>
<p>除了PERSIST命令会清除键的过期时间之外，SET,GETSET命令也能清除键的过期时间，但是只对键进行操作的命令（比如INCR,LPUSH等等）不会清除键的过期时间。</p>
<p><strong>EXPIRE命令的单位是秒，如果想要更精确的过期时间，则可以使用PEXPIRE命令，该命令的单位是毫秒，相应地可以使用PTTL看剩余时间。</strong></p>
<p><strong>如果<a href="http://fudawei.github.io/2015/09/30/Redis%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D/">WATCH</a>命令监控了一个具有过期时间的键，如果监控期间这个键过期被自动删除，WATCH并不认为该键被改变</strong></p>
<h1 id="Redis过期机制的用途"><a href="#Redis过期机制的用途" class="headerlink" title="Redis过期机制的用途"></a>Redis过期机制的用途</h1><p>有了过期机制就能实现很多跟时间相关的功能了，比如访问频率限制，作为缓存等等，具体细节就不展开了，有疑问的可以留言。</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/09/30/Redis过期机制介绍/">http://fudawei.github.io/2015/09/30/Redis过期机制介绍/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis事务介绍]]></title>
      <url>https://fudawei.github.io/2015/09/30/Redis%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>相信学过Mysql等其他数据库的同学对事务这个词都不陌生，事务表示的是一组动作，这组动作要么全部执行，要么全部不执行。为什么会有这样的需求呢？看看下面的场景：</p>
<blockquote>
<ul>
<li>微博是一个弱关系型社交网络，用户之间有关注和被关注两种关系，比如两个用户A和B，如果A关注B，则B的粉丝中就应该有A。关注这个动作需要两个步骤完成：在A的关注者中添加B；在B的粉丝中添加A。 这两个动作要么都执行成功，要么都不执行。否则就可能会出现A关注了B，但是B的粉丝中没有A的不可容忍的情况。</li>
<li>转账汇款，假设现在有两个账户A和B，现在需要将A中的一万块大洋转到B的账户中，这个动作也需要两个步骤完成：从A的账户中划走一万块；在B的账户中增加一万块。这两个动作要么全部执行成功，要么全部不执行，否则自会有人问候你的！！！</li>
</ul>
</blockquote>
<a id="more"></a>
<p>Redis作为一种高效的分布式数据库，同样支持事务。</p>
<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>Redis中的事务(transaction)是一组命令的集合。事务同命令一样都是Redis最小的执行单位，一个事务中的命令要么都执行，要么都不执行。Redis事务的实现需要用到<strong> MULTI </strong>和<strong> EXEC </strong>两个命令，事务开始的时候先向Redis服务器发送<strong> MULTI </strong>命令，然后依次发送需要在本次事务中处理的命令，最后再发送<strong> EXEC </strong>命令表示事务命令结束。</p>
<p>举个例子，使用redis-cli连接redis，然后在命令行工具中输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; MULTI</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; set url http://fudawei.github.io</div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; set title 飞鸟</div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; set desc java</div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; EXEC</div><div class="line">1) OK</div><div class="line">2) OK</div><div class="line">3) OK</div><div class="line">127.0.0.1:6379&gt;</div><div class="line">127.0.0.1:6379&gt; get url</div><div class="line">&quot;http://fudawei.github.io&quot;</div><div class="line">127.0.0.1:6379&gt; get title</div><div class="line">&quot;飞鸟&quot;</div><div class="line">127.0.0.1:6379&gt; get desc</div><div class="line">&quot;java&quot;</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure>
<p>从输出中可以看到，当输入MULTI命令后，服务器返回OK表示事务开始成功，然后依次输入需要在本次事务中执行的所有命令，每次输入一个命令服务器并不会马上执行，而是返回”QUEUED”，这表示命令已经被服务器接受并且暂时保存起来，最后输入EXEC命令后，本次事务中的所有命令才会被依次执行，可以看到最后服务器一次性返回了三个OK，这里返回的结果与发送的命令是按顺序一一对应的，这说明这次事务中的命令全都执行成功了。</p>
<p>再举个例子，在命令行工具中输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; MULTI</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; set a a</div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; sett b b</div><div class="line">(error) ERR unknown command &apos;sett&apos;</div><div class="line">127.0.0.1:6379&gt; set c c</div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; EXEC</div><div class="line">(error) EXECABORT Transaction discarded because of previous errors.</div><div class="line">127.0.0.1:6379&gt; get a</div><div class="line">(nil)</div><div class="line">127.0.0.1:6379&gt; get b</div><div class="line">(nil)</div><div class="line">127.0.0.1:6379&gt; get c</div><div class="line">(nil)</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure>
<p>和前面的例子一样，先输入MULTI最后输入EXEC表示中间的命令属于一个事务，不同的是中间输入的命令有一个错误(set写成了sett)，这样因为有一个错误的命令导致事务中的其他命令都不执行了(通过后续的get命令可以验证)，可见事务中的所有命令式同呼吸共命运的。</p>
<p>如果客户端在发送EXEC命令之前断线了，则服务器会清空事务队列，事务中的所有命令都不会被执行。而一旦客户端发送了EXEC命令之后，事务中的所有命令都会被执行，即使此后客户端断线也没关系，因为服务器已经保存了事务中的所有命令。</p>
<p>除了保证事务中的所有命令要么全执行要么全不执行外，Redis的事务还能保证一个事务中的命令依次执行而不会被其他命令插入。试想一个客户端A需要执行几条命令，同时客户端B发送了几条命令，如果不使用事务，则客户端B的命令有可能会插入到客户端A的几条命令中，如果想避免这种情况发生，也可以使用事务。</p>
<h1 id="Redis事务错误处理"><a href="#Redis事务错误处理" class="headerlink" title="Redis事务错误处理"></a>Redis事务错误处理</h1><p>如果一个事务中的某个命令执行出错，Redis会怎样处理呢？要回答这个问题，首先要搞清楚是什么原因导致命令执行出错：</p>
<ol>
<li><p><strong>语法错误</strong> 就像上面的例子一样，语法错误表示命令不存在或者参数错误<br>这种情况需要区分Redis的版本，Redis 2.6.5之前的版本会忽略错误的命令，执行其他正确的命令，2.6.5之后的版本会忽略这个事务中的所有命令，都不执行，就比如上面的例子(使用的Redis版本是2.8的)</p>
</li>
<li><p><strong>运行错误</strong> 运行错误表示命令在执行过程中出现错误，比如用GET命令获取一个散列表类型的键值。<br>这种错误在命令执行之前Redis是无法发现的，所以在事务里这样的命令会被Redis接受并执行。如果食物里有一条命令执行错误，其他命令依旧会执行（包括出错之后的命令）。比如下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; MULTI</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; set key 1</div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; SADD key 2</div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; set key 3</div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; EXEC</div><div class="line">1) OK</div><div class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</div><div class="line">3) OK</div><div class="line">127.0.0.1:6379&gt; get key</div><div class="line">&quot;3&quot;</div></pre></td></tr></table></figure>
<p><strong>Redis中的事务并没有关系型数据库中的事务回滚(rollback)功能，因此使用者必须自己收拾剩下的烂摊子。</strong>不过由于Redis不支持事务回滚功能，这也使得Redis的事务简洁快速。</p>
</li>
</ol>
<p>回顾上面两种类型的错误，语法错误完全可以在开发的时候发现并作出处理，另外如果能很好地规划Redis数据的键的使用，也是不会出现命令和键不匹配的问题的。</p>
<h1 id="WATCH命令"><a href="#WATCH命令" class="headerlink" title="WATCH命令"></a>WATCH命令</h1><p>从上面的例子我们可以看到，事务中的命令要全部执行完之后才能获取每个命令的结果，但是如果一个事务中的命令B依赖于他上一个命令A的结果的话该怎么办呢？就比如说实现类似Java中的i++的功能，先要获取当前值，才能在当前值的基础上做加一操作。这种场合仅仅使用上面介绍的MULTI和EXEC是不能实现的，因为MULTI和EXEC中的命令是一起执行的，并不能将其中一条命令的执行结果作为另一条命令的执行参数，所以这个时候就需要引进Redis事务家族中的另一成员：<strong>WATCH命令</strong></p>
<p>换个角度思考上面说到的实现i++的方法，可以这样实现：</p>
<blockquote>
<ol>
<li>监控i的值，保证i的值不被修改</li>
<li>获取i的原值</li>
<li>如果过程中i的值没有被修改，则将当前的i值+1，否则不执行</li>
</ol>
</blockquote>
<p>这样就能够避免竞态条件，保证i++能够正确执行。</p>
<p>WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，EXEC命令执行完之后被监控的键会自动被UNWATCH）</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; set mykey 1</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; WATCH mykey</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; set mykey 2</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; MULTI</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; set mykey 3</div><div class="line">QUEUED</div><div class="line">127.0.0.1:6379&gt; EXEC</div><div class="line">(nil)</div><div class="line">127.0.0.1:6379&gt; get mykey</div><div class="line">&quot;2&quot;</div><div class="line">127.0.0.1:6379&gt;</div></pre></td></tr></table></figure>
<p>上面的例子中，首先设置mykey的键值为1，然后使用WATCH命令监控mykey，随后更改mykey的值为2，然后进入事务，事务中设置mykey的值为3，然后执行EXEC运行事务中的命令，最后使用get命令查看mykey的值，发现mykey的值还是2，也就是说事务中的命令根本没有执行（因为WATCH监控mykey的过程中，mykey被修改了，所以随后的事务便会被取消）。</p>
<p>有了WATCH命令，我们就可以自己实现i++功能了，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def incr($key):</div><div class="line">    WATCH $key</div><div class="line">    $value = GET $key</div><div class="line">    if not $value</div><div class="line">        $value = 0</div><div class="line">    $value = $value + 1</div><div class="line">    </div><div class="line">    MULTI</div><div class="line">    SET $key $value</div><div class="line">        result = EXEC</div><div class="line">    return result[0]</div></pre></td></tr></table></figure>
<p>因为EXEC返回的是多行字符串，使用result[0]表示返回值的第一个字符串。</p>
<p><strong>注意：由于WATCH命令的作用只是当被监控的键被修改后取消之后的事务，并不能保证其他客户端不修改监控的值，所以当EXEC命令执行失败之后需要手动重新执行整个事务。</strong></p>
<p>执行EXEC命令之后会取消监控使用WATCH命令监控的键，如果不想执行事务中的命令，也可以使用UNWATCH命令来取消监控。</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文为原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/09/30/Redis事务介绍/">http://fudawei.github.io/2015/09/30/Redis事务介绍/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis五种数据类型介绍]]></title>
      <url>https://fudawei.github.io/2015/09/29/Redis%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Redis的键值可以使用物种数据类型：<strong>字符串，散列表，列表，集合，有序集合</strong>。本文详细介绍这五种数据类型的使用方法。本文命令介绍部分只是列举了基本的命令，至于具体的使用示例，可以参考Redis官方文档：<a href="http://redis.readthedocs.org/en/latest/" target="_blank" rel="external">Redis命令大全</a><br><a id="more"></a></p>
<h1 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h1><p>字符串是Redis中最基本的数据类型，它能够存储任何类型的字符串，包含二进制数据。可以用于存储邮箱，JSON化的对象，甚至是一张图片，一个字符串允许存储的最大容量为<strong>512MB</strong>。字符串是其他四种类型的基础，与其他几种类型的区别从本质上来说只是组织字符串的方式不同而已。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><ol>
<li><strong>SET</strong> 赋值，用法： <code>SET key value</code></li>
<li><strong>GET</strong> 取值，用法： <code>GET key</code></li>
<li><strong>INCR</strong> 递增数字，仅仅对数字类型的键有用，相当于Java的i++运算，用法： <code>INCR key</code></li>
<li><strong>INCRBY</strong> 增加指定的数字，仅仅对数字类型的键有用，相当于Java的i+=3，用法：<code>INCRBY key increment</code>，意思是key自增increment，increment可以为负数，表示减少。</li>
<li><strong>DECR</strong> 递减数字，仅仅对数字类型的键有用，相当于Java的i–，用法：<code>DECR key</code></li>
<li><strong>DECRBY</strong> 减少指定的数字，仅仅对数字类型的键有用，相当于Java的i-=3，用法：<code>DECRBY key decrement</code>，意思是key自减decrement，decrement可以为正数，表示增加。</li>
<li><strong>INCRBYFLOAT</strong> 增加指定浮点数，仅仅对数字类型的键有用，用法：<code>INCRBYFLOAT key increment</code></li>
<li><strong>APPEND</strong> 向尾部追加值，相当于Java中的”hello”.append(“ world”)，用法：<code>APPEND key value</code></li>
<li><strong>STRLEN</strong> 获取字符串长度，用法：<code>STRLEN key</code></li>
<li><strong>MSET</strong> 同时设置多个key的值，用法：<code>MSET key1 value1 [key2 value2 ...]</code></li>
<li><strong>MGET</strong> 同时获取多个key的值，用法：<code>MGET key1 [key2 ...]</code></li>
</ol>
<h3 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h3><ol>
<li><strong>GETBIT</strong> 获取一个键值的二进制位的指定位置的值(0/1)，用法：<code>GETBIT key offset</code></li>
<li><strong>SETBIT</strong> 设置一个键值的二进制位的指定位置的值(0/1)，用法：<code>SETBIT key offset value</code></li>
<li><strong>BITCOUNT</strong> 获取一个键值的一个范围内的二进制表示的1的个数，用法：<code>BITCOUNT key [start end]</code></li>
<li><strong>BITOP</strong> 该命令可以对多个字符串类型键进行位运算，并将结果存储到指定的键中，BITOP支持的运算包含：<strong>OR,AND,XOR,NOT</strong>，用法：<code>BITOP OP desKey key1 key2</code></li>
<li><strong>BITPOS</strong> 获取指定键的第一个位值为0或者1的位置，用法：<code>BITPOS key 0/1 [start， end]</code></li>
</ol>
<h1 id="散列类型"><a href="#散列类型" class="headerlink" title="散列类型"></a>散列类型</h1><p>散列类型相当于Java中的HashMap，他的值是一个字典，保存很多key，value对，每对key，value的值个键都是字符串类型，换句话说，散列类型不能嵌套其他数据类型。一个散列类型键最多可以包含2的32次方-1个字段。</p>
<h2 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令"></a>基本命令</h2><ol>
<li><strong>HSET</strong> 赋值，用法：<code>HSET key field value</code></li>
<li><strong>HMSET</strong> 一次赋值多个字段，用法：<code>HMSET key field1 value1 [field2 values]</code></li>
<li><strong>HGET</strong> 取值，用法：<code>HSET key field</code></li>
<li><strong>HMGET</strong> 一次取多个字段的值，用法：<code>HMSET key field1 [field2]</code></li>
<li><strong>HGETALL</strong> 一次取所有字段的值，用法：<code>HGETALL key</code></li>
<li><strong>HEXISTS</strong> 判断字段是否存在，用法：<code>HEXISTS key field</code></li>
<li><strong>HSETNX</strong> 当字段不存在时赋值，用法：<code>HSETNX key field value</code></li>
<li><strong>HINCRBY</strong> 增加数字，仅对数字类型的值有用，用法：<code>HINCRBY key field increment</code></li>
<li><strong>HDEL</strong> 删除字段，用法：<code>HDEL key field</code></li>
<li><strong>HKEYS</strong> 获取所有字段名，用法：<code>HKEYS key</code></li>
<li><strong>HVALS</strong> 获取所有字段值，用法：<code>HVALS key</code></li>
<li><strong>HLEN</strong> 获取字段数量，用法：<code>HLEN key</code></li>
</ol>
<h1 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h1><p>列表类型(list)用于存储一个有序的字符串列表，常用的操作是向队列两端添加元素或者获得列表的某一片段。列表内部使用的是双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度是O(1),获取越接近列表两端的元素的速度越快。但是缺点是使用列表通过索引访问元素的效率太低（需要从端点开始遍历元素）。所以列表的使用场景一般如：朋友圈新鲜事，只关心最新的一些内容。借助列表类型，Redis还可以作为消息队列使用。</p>
<h2 id="基本命令-2"><a href="#基本命令-2" class="headerlink" title="基本命令"></a>基本命令</h2><ol>
<li><strong>LPUSH</strong> 向列表左端添加元素，用法：<code>LPUSH key value</code></li>
<li><strong>RPUSH</strong> 向列表右端添加元素，用法：<code>RPUSH key value</code></li>
<li><strong>LPOP</strong> 从列表左端弹出元素，用法：<code>LPOP key</code></li>
<li><strong>RPOP</strong> 从列表右端弹出元素，用法：<code>RPOP key</code></li>
<li><strong>LLEN</strong> 获取列表中元素个数，用法：<code>LLEN key</code></li>
<li><strong>LRANGE</strong> 获取列表中某一片段的元素，用法：<code>LRANGE key start stop</code>，index从0开始，-1表示最后一个元素</li>
<li><strong>LREM</strong> 删除列表中指定的值，用法：<code>LREM key count value</code>，删除列表中前count个值为value的元素，当count&gt;0时从左边开始数，count&lt;0时从右边开始数，count=0时会删除所有值为value的元素</li>
<li><strong>LINDEX</strong> 获取指定索引的元素值，用法：<code>LINDEX key index</code></li>
<li><strong>LSET</strong> 设置指定索引的元素值，用法：<code>LSET key index value</code></li>
<li><strong>LTRIM</strong> 只保留列表指定片段，用法：<code>LTRIM key start stop</code>，包含start和stop</li>
<li><strong>LINSERT</strong> 像列表中插入元素，用法：<code>LINSERT key BEFORE|AFTER privot value</code>，从左边开始寻找值为privot的第一个元素，然后根据第二个参数是BEFORE还是AFTER决定在该元素的前面还是后面插入value</li>
<li><strong>RPOPLPUSH</strong> 将元素从一个列表转义到另一个列表，用法：<code>RPOPLPUSH source destination</code></li>
</ol>
<h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p>集合在概念在高中课本就学过，集合中每个元素都是不同的，集合中的元素个数最多为2的32次方-1个，集合中的元素师没有顺序的。</p>
<h2 id="基本命令-3"><a href="#基本命令-3" class="headerlink" title="基本命令"></a>基本命令</h2><ol>
<li><strong>SADD</strong> 添加元素，用法：<code>SADD key value1 [value2 value3 ...]</code></li>
<li><strong>SREM</strong> 删除元素，用法：<code>SREM key value2 [value2 value3 ...]</code></li>
<li><strong>SMEMBERS</strong> 获得集合中所有元素，用法：<code>SMEMBERS key</code></li>
<li><strong>SISMEMBER</strong> 判断元素是否在集合中，用法：<code>SISMEMBER key value</code></li>
<li><strong>SDIFF</strong> 对集合做差集运算，用法：<code>SDIFF key1 key2 [key3 ...]</code>，先计算key1和key2的差集，然后再用结果与key3做差集</li>
<li><strong>SINTER</strong> 对集合做交集运算，用法：<code>SINTER key1 key2 [key3 ...]</code></li>
<li><strong>SUNION</strong> 对集合做并集运算，用法：<code>SUNION key1 key2 [key3 ...]</code></li>
<li><strong>SCARD</strong> 获得集合中元素的个数，用法：<code>SCARD key</code></li>
<li><strong>SDIFFSTORE</strong> 对集合做差集并将结果存储，用法：<code>SDIFFSTORE destination key1 key2 [key3 ...]</code></li>
<li><strong>SINTERSTORE</strong> 对集合做交集运算并将结果存储，用法：<code>SINTERSTORE destination key1 key2 [key3 ...]</code></li>
<li><strong>SUNIONSTORE</strong> 对集合做并集运算并将结果存储，用法：<code>SUNIONSTORE destination key1 key2 [key3 ...]</code></li>
<li><strong>SRANDMEMBER</strong> 随机获取集合中的元素，用法：<code>SRANDMEMBER key [count]</code>，当count&gt;0时，会随机中集合中获取count个不重复的元素，当count&lt;0时，随机中集合中获取|count|和可能重复的元素。</li>
<li><strong>SPOP</strong> 从集合中随机弹出一个元素，用法：<code>SPOP key</code></li>
</ol>
<h1 id="有序集合类型"><a href="#有序集合类型" class="headerlink" title="有序集合类型"></a>有序集合类型</h1><p>有序集合类型与集合类型的区别就是他是有序的。有序集合是在集合的基础上为每一个元素关联一个分数，这就让有序集合不仅支持插入，删除，判断元素是否存在等操作外，还支持获取分数最高/最低的前N个元素。有序集合中的每个元素是不同的，但是分数却可以相同。有序集合使用散列表和跳跃表实现，即使读取位于中间部分的数据也很快，时间复杂度为O(log(N))，有序集合比列表更费内存。</p>
<h2 id="基本命令-4"><a href="#基本命令-4" class="headerlink" title="基本命令"></a>基本命令</h2><ol>
<li><strong>ZADD</strong> 添加元素，用法：<code>ZADD key score1 value1 [score2 value2 score3 value3 ...]</code></li>
<li><strong>ZSCORE</strong> 获取元素的分数，用法：<code>ZSCORE key value</code></li>
<li><strong>ZRANGE</strong> 获取排名在某个范围的元素，用法：<code>ZRANGE key start stop [WITHSCORE]</code>，按照元素从小到大的顺序排序，从0开始编号，包含start和stop对应的元素，WITHSCORE选项表示是否返回元素分数</li>
<li><strong>ZREVRANGE</strong> 获取排名在某个范围的元素，用法：<code>ZREVRANGE key start stop [WITHSCORE]</code>，和上一个命令用法一样，只是这个倒序排序的。</li>
<li><strong>ZRANGEBYSCORE</strong> 获取指定分数范围内的元素，用法：<code>ZRANGEBYSCORE key min max</code>，包含min和max，<code>(min</code>表示不包含min，<code>(max</code>表示不包含max，<code>+inf</code>表示无穷大</li>
<li><strong>ZINCRBY</strong> 增加某个元素的分数，用法：<code>ZINCRBY key increment value</code></li>
<li><strong>ZCARD</strong> 获取集合中元素的个数，用法：<code>ZCARD key</code></li>
<li><strong>ZCOUNT</strong> 获取指定分数范围内的元素个数，用法：<code>ZCOUNT key min max</code>，min和max的用法和5中的一样</li>
<li><strong>ZREM</strong> 删除一个或多个元素，用法：<code>ZREM key value1 [value2 ...]</code></li>
<li><strong>ZREMRANGEBYRANK</strong> 按照排名范围删除元素，用法：<code>ZREMRANGEBYRANK key start stop</code></li>
<li><strong>ZREMRANGEBYSCORE</strong> 按照分数范围删除元素，用法：<code>ZREMRANGEBYSCORE key min max</code>，min和max的用法和4中的一样</li>
<li><strong>ZRANK</strong> 获取正序排序的元素的排名，用法：<code>ZRANK key value</code></li>
<li><strong>ZREVRANK</strong> 获取逆序排序的元素的排名，用法：<code>ZREVRANK key value</code></li>
<li><strong>ZINTERSTORE</strong> 计算有序集合的交集并存储结果，用法：<code>ZINTERSTORE destination numbers key1 key2 [key3 key4 ...] WEIGHTS weight1 weight2 [weight3 weight4 ...] AGGREGATE SUM | MIN | MAX</code>，numbers表示参加运算的集合个数，weight表示权重，aggregate表示结果取值</li>
<li><strong>ZUNIONSTORE</strong> 计算有序几个的并集并存储结果，用法和14一样，不再赘述。</li>
</ol>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文为原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/09/29/Redis五种数据类型介绍/">http://fudawei.github.io/2015/09/29/Redis五种数据类型介绍/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis 3.0新特性]]></title>
      <url>https://fudawei.github.io/2015/09/28/Redis-3-0%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h1 id="Redis-3-0改进"><a href="#Redis-3-0改进" class="headerlink" title="Redis 3.0改进"></a>Redis 3.0改进</h1><p>Redis 3.0.0 正式版终于到来了，与 RC6 版本比较，该版本改进包括：</p>
<ul>
<li>修复了无磁盘的复制问题 (Oran Agra)</li>
<li>在角色变化后对 BLPOP 复制进行测试 (Salvatore Sanfilippo)</li>
<li>prepareClientToWrite() 错误处理方法的改进 (Salvatore Sanfilippo)</li>
<li>移除 dict.c 中不再使用的函数(Salvatore Sanfilippo)<a id="more"></a>
</li>
</ul>
<h1 id="Redis-3-0新特性"><a href="#Redis-3-0新特性" class="headerlink" title="Redis 3.0新特性"></a>Redis 3.0新特性</h1><p>Redis 3.0 版本与 2.8 版本比较，主要新特性包括如下几个方面：</p>
<ul>
<li>Redis Cluster —— 一个分布式的 Redis 实现</li>
<li>全新的 “embedded string” 对象编码结果，更少的缓存丢失，在特定的工作负载下速度的大幅提升</li>
<li>AOF child -&gt; parent 最终数据传输最小化延迟，通过在 AOF 重写过程中的  “last write” </li>
<li>大幅提升 LRU 近似算法用于键的擦除</li>
<li>WAIT 命令堵塞等待写操作传输到指定数量的从节点</li>
<li>MIGRATE 连接缓存，大幅提升键移植的速度</li>
<li>MIGARTE 新的参数 COPY 和 REPLACE</li>
<li>CLIENT PAUSE 命令：在指定时间内停止处理客户端请求</li>
<li>BITCOUNT 性能提升</li>
<li>CONFIG SET 接受不同单位的内存值，例如 “CONFIG SET maxmemory 1gb”.</li>
<li>Redis 日志格式小调整用于反应实例的角色 (master/slave) </li>
<li>INCR 性能提升</li>
</ul>
<p>下载地址：<a href="http://download.redis.io/releases/redis-3.0.0.tar.gz" target="_blank" rel="external">http://download.redis.io/releases/redis-3.0.0.tar.gz</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.oschina.net/news/61115/redis-3-0-final" target="_blank" rel="external">http://www.oschina.net/news/61115/redis-3-0-final</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Shell特殊字符简介]]></title>
      <url>https://fudawei.github.io/2015/09/23/Shell%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>linux shell中有很多特殊的字符，本文简单介绍常用的特殊字符的含义：<br><a id="more"></a></p>
<ul>
<li><strong>$0</strong> 表示当前运行的脚本的名字</li>
<li><strong>$#</strong> 表示当前运行的脚本的参数个数</li>
<li><strong>$*</strong> 表示当前运行的脚本的参数列表，如果有三个参数：a b c，则$*为 “a b c”</li>
<li><strong>$@</strong> 表示当前运行的脚本的参数列表，如果有三个参数：a b c，则$@为 “a” “b” “c”，可以理解为参数数组</li>
<li><strong>$$</strong> 当前运行的脚本的PID</li>
<li><strong>$n</strong> n为一个整数(1 &lt;= n &lt;= 脚本参数个数)，表示当前脚本接收到的第n个参数</li>
<li><strong>$?</strong> 表示目前为止执行的最后一条命令的返回值，返回0表示成功，返回1表示失败</li>
<li><strong>$-</strong> 表示当前shell的设置选项</li>
</ul>
<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><p>如下是一个简单的脚本test.sh，用于演示上面提到的各种特殊字符的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">echo &quot;脚本名字:&quot;$0</div><div class="line">echo &quot;脚本参数:&quot;$*</div><div class="line">echo &quot;脚本参数:&quot;$@</div><div class="line">echo &quot;脚本参数个数:&quot;$#</div><div class="line">echo &quot;脚本第一个参数:&quot;$1</div><div class="line">echo &quot;脚本第二个参数:&quot;$2</div><div class="line">echo &quot;本脚本运行PID:&quot;$$</div><div class="line">echo &quot;当前shell选项:&quot;$-</div><div class="line">echo &quot;test text&quot; | grep &quot;test&quot; 1&gt;/dev/null</div><div class="line">echo &quot;上一条命令执行结果:&quot;$?</div></pre></td></tr></table></figure>
<p>使用如下命令运行上面的脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[qifuguang@Mac~/shell]$ ./test.sh a b c</div></pre></td></tr></table></figure>
<p>输出如下：</p>
<blockquote>
<p>脚本名字:./test.sh<br>脚本参数:a b c<br>脚本参数:a b c<br>脚本参数个数:3<br>脚本第一个参数:a<br>脚本第二个参数:b<br>本脚本运行PID:37073<br>当前shell选项:hB<br>上一条命令执行结果:0  </p>
</blockquote>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文原创，转载请注明出处，本文链接<a href="http://fudawei.github.io/2015/09/23/Shell特殊字符简介">http://fudawei.github.io/2015/09/23/Shell特殊字符简介</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[类初始化]]></title>
      <url>https://fudawei.github.io/2015/09/22/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h3><p>类初始化是类加载过程的最后一个阶段，到初始化阶段，才真正开始执行类中的Java程序代码。<strong>虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：</strong></p>
<ul>
<li><p>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时</p>
</li>
<li><p>使用Java.lang.refect包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化</p>
</li>
<li><p>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化</p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类</p>
<p>虚拟机规定只有这四种情况才会触发类的初始化，称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发其初始化，称为被动引用</p>
</li>
</ul>
<a id="more"></a>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><h4 id="子类引用父类"><a href="#子类引用父类" class="headerlink" title="子类引用父类"></a>子类引用父类</h4><ul>
<li>通过子类引用父类中的静态字段，这时对子类的引用为被动引用，因此不会初始化子类，只会初始化父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">33</span>;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"父类被初始化"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125; </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"子类被初始化"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        System.out.println(Child.m);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行后输出的结果如下：</p>
<blockquote>
<p>父类被初始化<br>  33</p>
</blockquote>
<ul>
<li>对于静态字段，只有直接定义这个字段的类才会被初始化，因此，通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化</li>
</ul>
<h4 id="类的常量池"><a href="#类的常量池" class="headerlink" title="类的常量池"></a>类的常量池</h4><ul>
<li>常量在编译阶段会存入调用它的类的常量池中，本质上没有直接引用到定义该常量的类，因此不会触发定义常量的类的初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"我是常量"</span>;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"初始化Const类"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        System.out.println(Const.NAME);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 执行后输出的结果如下：</p>
<blockquote>
<p>我是常量</p>
</blockquote>
<ul>
<li>虽然程序中引用了const类的常量NAME，但是在编译阶段将此常量的值“我是常量”存储到了调用它的类FinalTest的常量池中，对常量Const.NAME的引用实际上转化为了FinalTest类对自身常量池的引用。也就是说，实际上FinalTest的Class文件之中并没有Const类的符号引用入口，这两个类在编译成Class文件后就不存在任何联系了</li>
</ul>
<h4 id="数组引用类"><a href="#数组引用类" class="headerlink" title="数组引用类"></a>数组引用类</h4><ul>
<li>通过数组定义来引用类，不会触发类的初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"初始化Const类"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        Const[] con = <span class="keyword">new</span> Const[<span class="number">5</span>];  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p> 执行后不输出任何信息，说明Const类并没有被初始化</p>
</blockquote>
<ul>
<li>但这段代码里触发了另一个名为“LLConst”的类的初始化，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发，很明显，这是一个对数组引用类型的初初始化，而该数组中的元素仅仅包含一个对Const类的引用，并没有对其进行初始化。如果我们加入对con数组中各个Const类元素的实例化代码，便会触发Const类的初始化，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"初始化Const类"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        Const[] con = <span class="keyword">new</span> Const[<span class="number">5</span>];  </div><div class="line">        <span class="keyword">for</span>(Const a:con)  </div><div class="line">            a = <span class="keyword">new</span> Const();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这样便会得到如下输出结果：</p>
<blockquote>
<p>初始化Const类</p>
</blockquote>
<ul>
<li>根据四条规则的第一条，这里的new触发了Const类</li>
</ul>
<h3 id="接口和类初始化的不同"><a href="#接口和类初始化的不同" class="headerlink" title="接口和类初始化的不同"></a>接口和类初始化的不同</h3><ul>
<li><p>接口也有初始化过程，上面的代码中我们都是用静态语句块来输出初始化信息的，而在接口中不能使用“static{}”语句块，但编译器仍然会为接口生成<clinit>类构造器，用于初始化接口中定义的成员变量（实际上是static final修饰的全局常量）</clinit></p>
</li>
<li><p>二者在初始化时最主要的区别是：当一个类在初始化时，要求其父类全部已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化该父接口。这点也与类初始化的情况很不同，回过头来看第2个例子就知道，调用类中的static final常量时并不会 触发该类的初始化，但是调用接口中的static final常量时便会触发该接口的初始化</p>
</li>
</ul>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul>
<li><a href="http://blog.csdn.net/ns_code/article/details/17845821" target="_blank" rel="external">传送门</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sed命令详解]]></title>
      <url>https://fudawei.github.io/2015/09/21/Sed%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。</p>
<a id="more"></a>
<h1 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h1><p>sed命令的使用规则是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed [option] &apos;command&apos; input_file</div></pre></td></tr></table></figure>
<p>其中option是可选的，常用的option有如下几种：</p>
<ul>
<li><strong>-n</strong> 使用安静(silent)模式（想不通为什么不是-s）。在一般sed的用法中，所有来自stdin的内容一般都会被列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来；</li>
<li><strong>-e</strong> 直接在指令列模式上进行 sed 的动作编辑；</li>
<li><strong>-f</strong> 直接将 sed 的动作写在一个文件内， <code>-f filename</code> 则可以执行filename内的sed命令；</li>
<li><strong>-r</strong> 让sed命令支持扩展的正则表达式(默认是基础正则表达式)；</li>
<li><p><strong>-i</strong> 直接修改读取的文件内容，而不是由屏幕输出。</p>
<p>常用的命令有以下几种：</p>
</li>
<li><p><strong>a \：</strong> append即追加字符串， a \的后面跟上字符串s(多行字符串可以用\n分隔)，则会在当前选择的行的后面都加上字符串s；</p>
</li>
<li><strong>c \：</strong> 取代/替换字符串，c \后面跟上字符串s(多行字符串可以用\n分隔)，则会将当前选中的行替换成字符串s；</li>
<li><strong>d：</strong> delete即删除，该命令会将当前选中的行删除；</li>
<li><strong>i \：</strong> insert即插入字符串，i \后面跟上字符串s(多行字符串可以用\n分隔)，则会在当前选中的行的前面都插入字符串s；</li>
<li><strong>p：</strong> print即打印，该命令会打印当前选择的行到屏幕上；</li>
<li><strong>s：</strong> 替换，通常s命令的用法是这样的：<code>1，2s/old/new/g</code>，将old字符串替换成new字符串</li>
</ul>
<h1 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h1><p>假设有一个本地文件test.txt，文件内容如下：</p>
<blockquote>
<p>[qifuguang@winwill~]$ cat test.txt<br>this is first line<br>this is second line<br>this is third line<br>this is fourth line<br>this fifth line<br>happy everyday<br>end  </p>
</blockquote>
<p>本节将使用该文件详细演示每一个命令的用法。</p>
<h2 id="a命令"><a href="#a命令" class="headerlink" title="a命令"></a>a命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed &apos;1a \add one&apos; test.txt</div><div class="line">this is first line</div><div class="line">add one</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例命令部分中的1表示第一行，同样的第二行写成2，第一行到第三行写成<code>1,3</code>，用<code>$</code>表示最后一行，比如<code>2,$</code>表示第二行到最后一行中间所有的行(包含第二行和最后一行)。<br>本例的作用是在第一行之后增加字符串”add one”，从输出可以看到具体效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed &apos;1,$a \add one&apos; test.txt</div><div class="line">this is first line</div><div class="line">add one</div><div class="line">this is second line</div><div class="line">add one</div><div class="line">this is third line</div><div class="line">add one</div><div class="line">this is fourth line</div><div class="line">add one</div><div class="line">this is fifth line</div><div class="line">add one</div><div class="line">happy everyday</div><div class="line">add one</div><div class="line">end</div><div class="line">add one</div></pre></td></tr></table></figure>
<p>本例表示在第一行和最后一行所有的行后面都加上”add one”字符串，从输出可以看到效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed &apos;/first/a \add one&apos; test.txt</div><div class="line">this is first line</div><div class="line">add one</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例表示在包含”first”字符串的行的后面加上字符串”add one”，从输出可以看到第一行包含first，所以第一行之后增加了”add one”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed &apos;/^ha.*day$/a \add one&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">happy everyday</div><div class="line">add one</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例使用正则表达式匹配行，<code>^ha.*day$</code>表示以ha开头，以day结尾的行，则可以匹配到文件的”happy everyday”这样，所以在该行后面增加了”add one”字符串。</p>
<h2 id="i命令"><a href="#i命令" class="headerlink" title="i命令"></a>i命令</h2><p>i命令使用方法和a命令一样的，只不过是在匹配的行的前面插入字符串，所以直接将上面a命令的示例的a替换成i即可，在此就不啰嗦了。</p>
<h2 id="c命令"><a href="#c命令" class="headerlink" title="c命令"></a>c命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed &apos;$c \add one&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is     fifth line</div><div class="line">happy everyday</div><div class="line">add one</div></pre></td></tr></table></figure>
<p>本例表示将最后一行替换成字符串”add one”，从输出可以看到效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed &apos;4,$c \add one&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">add one</div></pre></td></tr></table></figure>
<p>本例将第四行到最后一行的内容替换成字符串”add one”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed &apos;/^ha.*day$/c \replace line&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">replace line</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例将以ha开头，以day结尾的行替换成”replace line”。</p>
<h2 id="d命令"><a href="#d命令" class="headerlink" title="d命令"></a>d命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed &apos;/^ha.*day$/d&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例删除以ha开头，以day结尾的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed &apos;4,$d&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div></pre></td></tr></table></figure>
<p>本例删除第四行到最后一行中的内容。</p>
<h2 id="p命令"><a href="#p命令" class="headerlink" title="p命令"></a>p命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed -n &apos;4,$p&apos; test.txt</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例在屏幕上打印第四行到最后一行的内容，p命令一般和-n选项一起使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed -n &apos;/^ha.*day$/p&apos; test.txt</div><div class="line">happy everyday</div></pre></td></tr></table></figure>
<p>本例打印以ha开始，以day结尾的行。</p>
<h2 id="s命令"><a href="#s命令" class="headerlink" title="s命令"></a>s命令</h2><p>实际运用中s命令式最常使用到的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed &apos;s/line/text/g&apos; test.txt</div><div class="line">this is first text</div><div class="line">this is second text</div><div class="line">this is third text</div><div class="line">this is fourth text</div><div class="line">this is fifth text</div><div class="line">happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例将文件中的所有line替换成text，最后的g是global的意思，也就是全局替换，如果不加g，则只会替换本行的第一个line。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed &apos;/^ha.*day$/s/happy/very happy/g&apos; test.txt</div><div class="line">this is first line</div><div class="line">this is second line</div><div class="line">this is third line</div><div class="line">this is fourth line</div><div class="line">this is fifth line</div><div class="line">very happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>本例首先匹配以ha开始，以day结尾的行，本例中匹配到的行是”happy everyday”这样，然后再将该行中的happy替换成very happy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed &apos;s/\(.*\)line$/\1/g&apos; test.txt</div><div class="line">this is first</div><div class="line">this is second</div><div class="line">this is third</div><div class="line">this is fourth</div><div class="line">this is fifth</div><div class="line">happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>这个例子有点复杂，先分解一下。首先s命令的模式是<code>s/old/new/g</code>这样的，所以本例的old部分即<code>\(.*\)line$</code>,sed命令中使用<code>\(\)</code>包裹的内容表示正则表达式的第n部分，序号从1开始计算，本例中只有一个<code>\(\)</code>所以<code>\(.*\)</code>表示正则表达式的第一部分，这部分匹配任意字符串，所以<code>\(.*\)line$</code>匹配的就是以line结尾的任何行。然后将匹配到的行替换成正则表达式的第一部分（本例中相当于删除line部分），使用<code>\1</code>表示匹配到的第一部分，同样<code>\2</code>表示第二部分，<code>\3</code>表示第三部分，可以依次这样引用。比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ sed &apos;s/\(.*\)is\(.*\)line/\1\2/g&apos; test.txt</div><div class="line">this  first</div><div class="line">this  second</div><div class="line">this  third</div><div class="line">this  fourth</div><div class="line">this  fifth</div><div class="line">happy everyday</div><div class="line">end</div></pre></td></tr></table></figure>
<p>正则表达式中<code>is</code>两边的部分可以用<code>\1</code>和<code>\2</code>表示，该例子的作用其实就是删除中间部分的is。</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文为作者原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/09/21/sed命令详解/">http://fudawei.github.io/2015/09/21/sed命令详解/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sybase学习小记]]></title>
      <url>https://fudawei.github.io/2015/09/15/sybase%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="Sybase-sql"><a href="#Sybase-sql" class="headerlink" title="Sybase_sql"></a>Sybase_sql</h2><h3 id="语法特点"><a href="#语法特点" class="headerlink" title="语法特点"></a>语法特点</h3><p>1.没有“ ”，字符串使用‘ ’包含<br>2.没有逻辑相等，赋值和逻辑相等都是=<br>3.类型不再是最严格的。任何数据都可以包含在‘ ’以内<br>4.没有bool值的概念，但是在视图中可以输入true/false<br>5.它也有关系运算符：&gt; &lt; &gt;= &lt;= = &lt;&gt; != ,它返回一个bool值<br>6.它也有逻辑运算符： ！(not) &amp;&amp;(and) ||(or)<br>7.它不区别大小写<br>8.数据库完整性（Database Integrity）是指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。</p>
<h3 id="事务的四个特点ACID"><a href="#事务的四个特点ACID" class="headerlink" title="事务的四个特点ACID"></a>事务的四个特点ACID</h3><p>A:原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。它是一个整体，不能再拆分<br>C：一致性：事务在完成时，必须使所有的数据都保持一致状态<br>I:隔离性：事务中隔离，每一个事务是单独的请求将单独的处理，与其它事务没有关系，互不影响<br>D：持久性：如果事务一旦提交，就对数据的修改永久保留</p>
<h3 id="存储过程功能"><a href="#存储过程功能" class="headerlink" title="存储过程功能"></a>存储过程功能</h3><p>存储过程为标准SQL增加了如下功能：<br>条件执行、循环控制结构、命名变量、命名过程、语句块（调用存储过程让DBMS执行一系列SQL语句）</p>
<h3 id="存储过程优点"><a href="#存储过程优点" class="headerlink" title="存储过程优点"></a>存储过程优点</h3><p>1）封装  只需要了解过程调用的输入输出就可以安全的使用数据库，防止用户跳过完整性检查<br>2）改善性能  调用存储过程时，DBMS可快速的执行存储过程中的语句，可直接转到语句的执行，无需分析，确认，优化和生成执行计划，这些步骤在预编译已经完成<br>3）减少网络流量，降低网络负载<br>4）标准组件化编程，极大的提高了程序的可移植性<br>5）安全性 系统管理员可向单独的用户授予对数据库对象的最小访问权限</p>
<h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><h3 id="索引优点-缺点"><a href="#索引优点-缺点" class="headerlink" title="索引优点/缺点"></a>索引优点/缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1.创建系统唯一性索引，可以保证每一行数据的唯一性<br>2.提高数据检索速度<br>3.加快表与表之间的连接，特别是具有主键外键关系的表之间<br>4.在针对order by 和 group by子句进行数据检索时，可以减少分组和排序的时间<br>5.查询优化器提高系统性能</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1.创建索引和维护索引要耗费时间<br>2.索引需要占用物理空间<br>3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护</p>
<p>###索引的类型</p>
<blockquote>
<ul>
<li>聚集索引：数据表的物理顺序与索引顺序相同</li>
<li>非聚集索引：数据表的物理顺序与索引顺序不同</li>
</ul>
</blockquote>
<h3 id="存储过程-VS-函数"><a href="#存储过程-VS-函数" class="headerlink" title="存储过程 VS 函数"></a>存储过程 VS 函数</h3><p>1.存储过程需要使用execute单独执行，而函数可以随处调用<br>2.用户自定义函数不能修改表中的数据，但是存储过程可以</p>
<h3 id="存储过程的执行过程"><a href="#存储过程的执行过程" class="headerlink" title="存储过程的执行过程"></a>存储过程的执行过程</h3><p>1.语法分析阶段，保证语法的正确性<br>2.解析阶段，检查该存储过程引用的对象名称是否存在<br>3.分析存储过程和生成存储过程执行计划的过程<br>4.执行阶段，执行主流在高速缓冲存储区的过程执行计划</p>
<blockquote>
<ul>
<li>注意,当存储过程引用的基础表发生结构变化时，该存储过程的执行计划将会自动优化。但是如果在表中添加了索引或者更改了索引列中<br>的数据之后，该执行计划不会自动优化，这时候应该重新编译存储过程，更新原有的执行计划。</li>
</ul>
</blockquote>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>SELECT CONCAT(Cname,Tnum) FROM course WHERE Cnum=03</p>
<h4 id="left-截取指定字符串的指定个数字符"><a href="#left-截取指定字符串的指定个数字符" class="headerlink" title="left 截取指定字符串的指定个数字符"></a>left 截取指定字符串的指定个数字符</h4><p>SELECT LEFT(Cname,5) FROM course WHERE Cnum=01<br>SELECT RIGHT(Cname,5) FROM course WHERE Cnum=01</p>
<h4 id="charIndex"><a href="#charIndex" class="headerlink" title="charIndex()"></a>charIndex()</h4><p>SELECT LOCATE(‘ne’,cname) FROM course WHERE cnum=01<br>SELECT SUBSTRING(Cname,1,3) FROM course</p>
<h3 id="delete-和-truncate"><a href="#delete-和-truncate" class="headerlink" title="delete 和 truncate"></a>delete 和 truncate</h3><p>delete from Teacher where Age&lt;20<br>–特点:<br>–1.删除是一条一条进行删除的<br>–2.每一条记录的删除都需要将操作写入到日志文件中<br>–3.标识列不会从种子值重新计算,以从上次最后一条标识列值往下计算<br>–4.这种删除可以触发delete触发器</p>
<p>–truncate table 表名 –没有条件，它是一次性删除所有数据<br>–特点：<br>–1.一次性删除所有数据，没有条件，那么日志文件只以最小化的数据写入<br>–2.它可以使用标识列从种子值重新计算<br>–3.它不能触发delete触发器<br>truncate table teacher</p>
<p>update Teacher set Salary=Salary+500 where ClassId=4 and Age&gt;20<br>–sign:正数==1  负数 ==-1  0=0<br>select SIGN(-100)</p>
<p>mysql不存在top关键词，使用limit<br>SELECT <em> FROM course WHERE cnum=(SELECT  cnum FROM sc ORDER BY cnum DESC LIMIT 0,1)<br>–使用top分页<br>select top 5 </em> from Student where StudentNo not in(select top 5 studentno from Student)</p>
<p>视图就是一张虚拟表，可以像使用子查询做为结果集一样使用视图<br>触发器:执行一个可以改变表数据的操作（增加删除和修改），会自动触发另外一系列（类似于存储过程中的模块）的操作。</p>
<p>SQL语法顺序是：<br>SELECT[DISTINCT]<br>FROM<br>WHERE<br>GROUP BY<br>HAVING<br>UNION<br>ORDER BY<br>执行顺序为：<br>FROM<br>WHERE<br>GROUP BY<br>HAVING<br>SELECT<br>DISTINCT<br>UNION<br>ORDER BY<br>The first thing that happens is loading data from the disk into memory, in order to operate on such data.<br>WITH a AS (<br>  SELECT first_name, last_name, current_date - date_of_birth age<br>  FROM author<br>)<br>SELECT *<br>FROM a<br>WHERE age &gt; 10000</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>SELECT 语句有很多特殊的规则，至少你应该熟悉以下几条<br>你仅能够使用那些能通过表引用而得来的字段<br>如果你有 GROUP BY 语句，你只能够使用 GROUP BY 语句后面的字段或者聚合函数<br>当你的语句中没有 GROUP BY 的时候，可以使用开窗函数代替聚合函数<br>当你的语句中没有 GROUP BY 的时候，你不能同时使用聚合函数和其它函数<br>有一些方法可以将普通函数封装在聚合函数中<br>存储过程要返回IQ系统错误信息 SQLCODE || ERRORMSG(*) ：(两者都为EXCEPTION后第一条SQL语句才有效果)<br>IQ中若采用 FULL JOIN 连接则不能使用 WHERE 条件，否则FULL JOIN将失效，要筛选条件则用子查询先过滤记录后再FULL JOIN；</p>
<h3 id="sybase常用SQL"><a href="#sybase常用SQL" class="headerlink" title="sybase常用SQL"></a>sybase常用SQL</h3><p>FROM后的子查询，要定义别名才可使用<br>IQ中若采用 FULL JOIN 连接则不能使用 WHERE 条件，否则FULL JOIN将失效，要筛选条件则用子查询先过滤记录后再FULL JOIN<br>根据SELECT 语句建立[临时]表的方法（ORACLE的CREATE TABLE）为 SELECT ..[*] INTO [‘#’]table_name FROM ..<br>其中如果在table_name加前缀’#’，则为会话级临时表，否则为实体表；<br>存储过程隐式游标语法：<br>FOR A AS B CURSOR FOR SELECT … FROM …<br>DO….<br>END FOR;<br>需要注意的时，这边的A 和 B 在 过程语句中都不能引用，所以为避免过程语句其他字段名与FOR SELECT 语句的字段名称重复，<br>FOR SELECT 语句的字段最好都定义别名区分<br>因Sybase为列存储模式，在执行上INSERT语句会比UPDATE语句慢，尤其表数据越多INSERT效率就越慢；所以在ETL时建议多用UPDATE而不是INSERT<br>空字符串’’在Sybase中也是个字符而不是null值，这点要注意<br>默认值和规则：Transact-SQL 提供维护实体完整性（确保为要求值得的每一列都提供值）和域完整性（确保列中的每个值都属于该列的合法值集合）的关键字</p>
<h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p>CONVERT(datetype,exp[,format-style])<br>CAST(exp AS data-type)</p>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>DAY(date_exp):返回日期天值，DAYS(date_exp,int):返回日期date_exp加int后的日期；MONTH与MONTHS、YEAR与YEARS同理；<br>DATE(exp):将表达式转换为日期，并删除任何小时、分钟或秒；兼容性：IQ<br>DATEPART(date-part,date-exp): 返回日期分量的对应值(整数)<br>GETDATE():返回系统时间<br>DATENAME(datepart,date_expr):以字符串形式返回date_expr指定部分的值,转换成合适的名字<br>DATEDIFF(datepart,date_expr1,date_expr2):返回date_expr2-date_expr1,通过指定的datepart度量<br>DATEADD（date-part,num-exp,date-exp）:返回按指定date-part分量加num-exp值后生成的date-exp值；</p>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>CEIL(num-exp)：返回大于或等于指定表达式的最小整数；兼容性：IQ&amp;ASE<br>FLOOR(numeric_expr):返回小于或等于指定值的最大整数<br>ABS(num-exp):返回数值表达式的绝对值；兼容性：IQ&amp;ASE<br>TRUNCNUM(1231.1251,2)：截取数值；不四舍五入<br>ROUND(numeric_expr,int_expr)：把数值表达式圆整到int_expr指定的精度<br>RAND([int_expr])：返回0-1之间的随机浮点数，可指定基值<br>SIGN(int_expr)：返回正+1，零0或负-1<br>SQRT(float_expr)：返回指定值的平方根<br>PI()：返回常数3.1415926<br>POWER(numeric_expr,power)：返回numeric_expr的值给power的幂<br>EXP(float_expr)：给出指定值的指数值</p>
<h3 id="常用DDL语句"><a href="#常用DDL语句" class="headerlink" title="常用DDL语句"></a>常用DDL语句</h3><p>1.删除列<br>ALTER TABLE table_name DELETE column_name<br>2.增加列<br>ALTER TABLE table_name ADD (column_name DATA_TYPE [NOT] NULL)<br>3.修改列的空与非空<br>ALTER TABLE table_name MODIFY column_name [NOT] NULL<br>4.修改列名<br>ALTER TABLE table_name RENAME old_column_name TO new_column_name<br>5.快速建立临时表<br>SELECT * INTO [#]table_name FROM …..<br>6、修改表名ALTER TABLE old_table_name RENAME new_table_name<br>7.增加主键约束<br>ALTER TABLE tb_name ADD CONSTRAINT pk_name PRIMARY KEY(col_name,..)<br>8.删除主键约束<br>ALTER TABLE tb_name DROP CONSTRAINT pk_name<br>9.建立自增长字段，与Oracle的SEQUENCE类似<br>CREATE TABLE TMP_001 (RES_ID INTEGER IDENTITY NOT NULL)<br>10.添加表注释<br>COMMENT ON TABLE table_name IS ‘….’<br>11.创建索引<br>CREATE INDEX index_name ON table_name(column_name)</p>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><p>常见瓶颈：<br>绝大多数瓶颈在于I/O子系统<br>若CPU很高，90%以上是因为索引不当<br>发生swap时，可能因为内存分配太小或过大<br>iowait太高时，想办法从索引角度入手优化，以及提高I/O设备性能，增加内存，减少排序，减少SELECT一次性读取数据量。<br>常见优化策略：<br>瞬间并发很高，采用thread pool<br>频繁order by\group by，索引入手<br>适当调整内存，不要太大或太小。一般ibp设置为50% ~ 70%为宜<br>iowait高，加内存，提高iops，减少数据读写。</p>
<p>SQL优化<br>多用简单SQL<br>少用子查询和复杂查询<br>少用复杂join，注意join驱动表是否最优<br>where不使用函数，避免无法使用索引<br>注意类型隐式转换<br>事务快速提交，但不要频繁反复提交</p>
<h3 id="查看执行计划"><a href="#查看执行计划" class="headerlink" title="查看执行计划"></a>查看执行计划</h3><p>查看语句的执行计划<br>set showplan on<br>set noexec on<br>go<br>select …….<br>go<br>set showplan off<br>set noexec off<br>go</p>
<p>查看存储过程执行计划：<br>set showplan on<br>go</p>
<p>exec sp_name<br>go<br>set showplan off<br>go</p>
<p>dbcc traceon(3604)是把dbcc的结果输出到屏幕上。<br>dbcc sqltext(spid)是看指定的sybase进程的操作语句。<br>查看其查询计划，可以用sp_showplan spid,null,null,null</p>
<h3 id="sybase系统函数"><a href="#sybase系统函数" class="headerlink" title="sybase系统函数"></a>sybase系统函数</h3><p>sp_iqtablesize ‘T1_table’  查看表的大小空间<br>select tablewidth(‘ConditionStyle’)   查看表的行宽<br>sp_iqcolumn  ‘ConditionData’  查看表中每一列的信息<br>select * from sp_table_size_statics();   此存储过程会输出所有用户表的大小</p>
<h3 id="bat启动"><a href="#bat启动" class="headerlink" title="bat启动"></a>bat启动</h3><p>dbisql -c “uid=netmax;pwd=SOPinUETZ” -host 10.89.160.6 -port 3000 -oneerror continue   -&gt; bat启动</p>
<p>###sql基础用法<br>drop table if exists tableA;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Thrift入门教程]]></title>
      <url>https://fudawei.github.io/2015/09/11/Thrift%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Thrift最初由Facebook研发，主要用于各个服务之间的RPC通信，支持跨语言，常用的语言比如C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml都支持。Thrift是一个典型的CS（客户端/服务端）结构，客户端和服务端可以使用不同的语言开发。既然客户端和服务端能使用不同的语言开发，那么一定就要有一种中间语言来关联客户端和服务端的语言，没错，这种语言就是IDL（Interface Description Language）。<br><a id="more"></a></p>
<h1 id="Thrift-IDL"><a href="#Thrift-IDL" class="headerlink" title="Thrift IDL"></a>Thrift IDL</h1><p>本节介绍Thrift的接口定义语言，Thrift IDL支持的数据类型包含：</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>thrift不支持无符号类型，因为很多编程语言不存在无符号类型，比如java</p>
<ul>
<li>byte: 有符号字节</li>
<li>i16: 16位有符号整数</li>
<li>i32: 32位有符号整数</li>
<li>i64: 64位有符号整数</li>
<li>double: 64位浮点数</li>
<li>string: 字符串  </li>
</ul>
<h2 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h2><p>集合中的元素可以是除了service之外的任何类型，包括exception。</p>
<ul>
<li>list<t>: 一系列由T类型的数据组成的有序列表，元素可以重复</t></li>
<li>set<t>:  一系列由T类型的数据组成的无序集合，元素不可重复</t></li>
<li>map<k, v="">: 一个字典结构，key为K类型，value为V类型，相当于Java中的HMap<k,v>  </k,v></k,></li>
</ul>
<h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体(struct)"></a>结构体(struct)</h2><p>就像C语言一样，thrift也支持struct类型，目的就是将一些数据聚合在一起，方便传输管理。struct的定       义形式如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct People &#123;</div><div class="line">     1: string name;</div><div class="line">     2: i32 age;</div><div class="line">     3: string sex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h2><p>枚举的定义形式和Java的Enum定义差不多，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">enum Sex &#123;</div><div class="line">    MALE,</div><div class="line">    FEMALE</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="异常-exception"><a href="#异常-exception" class="headerlink" title="异常(exception)"></a>异常(exception)</h2><p>thrift支持自定义exception，规则和struct一样，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">exception RequestException &#123;</div><div class="line">    1: i32 code;</div><div class="line">    2: string reason;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="服务-service"><a href="#服务-service" class="headerlink" title="服务(service)"></a>服务(service)</h2><p>thrift定义服务相当于Java中创建Interface一样，创建的service经过代码生成命令之后就会生成客户端和服务端的框架代码。定义形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">service HelloWordService &#123;</div><div class="line">     // service中定义的函数，相当于Java interface中定义的函数</div><div class="line">     string doAction(1: string name, 2: i32 age);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>thrift支持类似C++一样的typedef定义，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef i32 Integer</div><div class="line">typedef i64 Long</div></pre></td></tr></table></figure>
<p><strong>注意，末尾没有逗号或者分号</strong></p>
<h2 id="常量-const"><a href="#常量-const" class="headerlink" title="常量(const)"></a>常量(const)</h2><p>thrift也支持常量定义，使用const关键字，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const i32 MAX_RETRIES_TIME = 10</div><div class="line">const string MY_WEBSITE = &quot;http://fudawei.github.io&quot;;</div></pre></td></tr></table></figure>
<p><strong>末尾的分号是可选的，可有可无，并且支持16进制赋值</strong></p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>thrift的命名空间相当于Java中的package的意思，主要目的是组织代码。thrift使用关键字namespace定义命名空间，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">namespace java com.winwill.thrift</div></pre></td></tr></table></figure>
<p><strong>格式是：namespace 语言名 路径， 注意末尾不能有分号。</strong></p>
<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>thrift也支持文件包含，相当于C/C++中的include，Java中的import。使用关键字include定义，例 如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include &quot;global.thrift&quot;</div></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>thrift注释方式支持shell风格的注释，支持C/C++风格的注释，即#和//开头的语句都单当做注释，/**/包裹的语句也是注释。</p>
<h2 id="可选与必选"><a href="#可选与必选" class="headerlink" title="可选与必选"></a>可选与必选</h2><p>thrift提供两个关键字required，optional，分别用于表示对应的字段时必填的还是可选的。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct People &#123;</div><div class="line">    1: required string name;</div><div class="line">    2: optional i32 age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>表示name是必填的，age是可选的。</p>
<h1 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h1><p> 知道了怎么定义thirtf文件之后，我们需要用定义好的thrift文件生成我们需要的目标语言的源码，本文以生成java源码为例。假设现在定义了如下一个thrift文件：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">namespace java com.winwill.thrift</div><div class="line"> </div><div class="line">enum RequestType &#123;</div><div class="line">    SAY_HELLO,   //问好</div><div class="line">    QUERY_TIME,  //询问时间</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Request &#123;</div><div class="line">    1: required RequestType type;  // 请求的类型，必选</div><div class="line">    2: required string name;       // 发起请求的人的名字，必选</div><div class="line">    3: optional i32 age;           // 发起请求的人的年龄，可选</div><div class="line">&#125;</div><div class="line"></div><div class="line">exception RequestException &#123;</div><div class="line">    1: required i32 code;</div><div class="line">    2: optional string reason;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 服务名</div><div class="line">service HelloWordService &#123;</div><div class="line">    string doAction(1: Request request) throws (1:RequestException qe); // 可能抛出异常。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 在终端运行如下命令(前提是已经安装thrift)：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thrift --gen java Test.thrift</div></pre></td></tr></table></figure>
<p> 则在当前目录会生成一个gen-java目录，该目录下会按照namespace定义的路径名一次一层层生成文件夹，到gen-java/com/winwill/thrift/目录下可以看到生成的4个Java类：<br> <img src="http://7xlune.com1.z0.glb.clouddn.com/images/Thrift入门教程/thrift-gen-java.png" alt="目录结构"><br> 可以看到，thrift文件中定义的enum，struct，exception，service都相应地生成了一个Java类，这就是能支持Java语言的基本的框架代码。</p>
<h1 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h1><p>上面代码生成这一步已经将接口代码生成了，现在需要做的是实现HelloWordService的具体逻辑，实现的方式就是创建一个Java类，implements com.winwill.thrift.HelloWordService，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package com.winwill.thrift;</div><div class="line"></div><div class="line"></div><div class="line">import org.apache.commons.lang3.StringUtils;</div><div class="line">import org.apache.thrift.TException;</div><div class="line"></div><div class="line">import java.util.Date;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/9/11 15:53</div><div class="line"> */</div><div class="line">public class HelloWordServiceImpl implements com.winwill.thrift.HelloWordService.Iface &#123;</div><div class="line">    // 实现这个方法完成具体的逻辑。</div><div class="line">    public String doAction(com.winwill.thrift.Request request) throws com.winwill.thrift.RequestException, TException &#123;</div><div class="line">        System.out.println(&quot;Get request: &quot; + request);</div><div class="line">        if (StringUtils.isBlank(request.getName()) || request.getType() == null) &#123;</div><div class="line">            throw new com.winwill.thrift.RequestException();</div><div class="line">        &#125;</div><div class="line">        String result = &quot;Hello, &quot; + request.getName();</div><div class="line">        if (request.getType() == com.winwill.thrift.RequestType.SAY_HELLO) &#123;</div><div class="line">            result += &quot;, Welcome!&quot;;</div><div class="line">        &#125; else &#123;</div><div class="line">            result += &quot;, Now is &quot; + new Date().toLocaleString();</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>上面这个就是服务端的具体实现类，现在需要启动这个服务，所以需要一个启动类，启动类的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package com.winwill.thrift;</div><div class="line"></div><div class="line">import org.apache.thrift.server.TServer;</div><div class="line">import org.apache.thrift.server.TSimpleServer;</div><div class="line">import org.apache.thrift.transport.TServerSocket;</div><div class="line"></div><div class="line">import java.net.ServerSocket;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/9/11 16:07</div><div class="line"> */</div><div class="line">public class HelloWordServer &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        ServerSocket socket = new ServerSocket(7912);</div><div class="line">        TServerSocket serverTransport = new TServerSocket(socket);</div><div class="line">        com.winwill.thrift.HelloWordService.Processor processor = new com.winwill.thrift.HelloWordService.Processor(new HelloWordServiceImpl());</div><div class="line">        TServer server = new TSimpleServer(processor, serverTransport);</div><div class="line">        System.out.println(&quot;Running server...&quot;);</div><div class="line">        server.serve();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行之后看到控制台的输出为：</p>
<blockquote>
<p>Running server…</p>
</blockquote>
<h1 id="客户端请求"><a href="#客户端请求" class="headerlink" title="客户端请求"></a>客户端请求</h1><p>现在服务已经启动，可以通过客户端向服务端发送请求了，客户端的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">package com.winwill.thrift;</div><div class="line"></div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocol;</div><div class="line">import org.apache.thrift.transport.TSocket;</div><div class="line">import org.apache.thrift.transport.TTransport;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/9/11 16:13</div><div class="line"> */</div><div class="line">public class HelloWordClient &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        TTransport transport = new TSocket(&quot;localhost&quot;, 8888);</div><div class="line">        TProtocol protocol = new TBinaryProtocol(transport);</div><div class="line"></div><div class="line">        // 创建client</div><div class="line">        com.winwill.thrift.HelloWordService.Client client = new com.winwill.thrift.HelloWordService.Client(protocol);</div><div class="line"></div><div class="line">        transport.open();  // 建立连接</div><div class="line"></div><div class="line">        // 第一种请求类型</div><div class="line">        com.winwill.thrift.Request request = new com.winwill.thrift.Request()</div><div class="line">                .setType(com.winwill.thrift.RequestType.SAY_HELLO).setName(&quot;飞鸟&quot;).setAge(24);</div><div class="line">        System.out.println(client.doAction(request));</div><div class="line"></div><div class="line">        // 第二种请求类型</div><div class="line">        request.setType(com.winwill.thrift.RequestType.QUERY_TIME).setName(&quot;飞鸟&quot;);</div><div class="line">        System.out.println(client.doAction(request));</div><div class="line"></div><div class="line">        transport.close();  // 请求结束，断开连接</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行客户端代码，得到结果：</p>
<blockquote>
<p>Hello, 飞鸟, Welcome!<br>Hello, 飞鸟, Now is 2015-9-11 16:37:22</p>
</blockquote>
<p>并且此时，服务端会有请求日志：</p>
<blockquote>
<p>Running server…<br>Get request: Request(type:SAY_HELLO, name:飞鸟, age:24)<br>Get request: Request(type:QUERY_TIME, name:飞鸟, age:24)  </p>
</blockquote>
<p>可以看到，客户端成功将请求发到了服务端，服务端成功地将请求结果返回给客户端，整个通信过程完成。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>本文为作者个人理解，如理解有误，请留言相告，感激不尽；</li>
<li>本文为作者原创，转载请注明出处，原文地址：<a href="http://fudawei.github.io/2015/09/11/Thrift入门教程/">http://fudawei.github.io/2015/09/11/Thrift入门教程/</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UTF8编码]]></title>
      <url>https://fudawei.github.io/2015/09/08/UTF8%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>大家都知道，计算机中的数据都是以二进制的形式保存的，所以如果需要在计算机中存储或者在网络上传输一些字符的话，就需要用某种规则将这些字符编排成一串串的二进制数据，就像011010101011110101101这样，这个编排的过程就叫做“字符编码”。</p>
<a id="more"></a>
<h1 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h1><p>Unicode出现之前，各个国家或地区都有自己的编码方式，非常混乱，这极大地阻碍了网络信息在全世界范围内的传播与交流。所以有有一个叫ISO的牛逼组织做了一个伟大的创想：<strong>统一天下编码方式，让信息传播归一化。</strong>这个创想的结果就是制定了Unicode编码规则。</p>
<p>Unicode 是为了解决传统的字符编码方案的局限而产生的，例如ISO 8859所定义的字符虽然在不同的国家中广泛地使用，可是在不同国家间却经常出现不兼容的情况。很多传统的编码方式都有一个共同的问题，即容许电脑处理双语环境（通常使用拉丁字母以及其本地语言），但却无法同时支持多语言环境（指可同时处理多种语言混合的情况）。</p>
<p>Unicode可以容纳世界上所有的文字和字符。Unicode目有两套编码方法,UCS-2(Unicode-16)用2个字节表示一个字符,UCS-4(Unicode-32)用4个字节表示一个字符。UCS-4是由USC-2扩展来的,增加了2字节的高位。即使是老UCS-2,它也可以表示2^16=65535个字符,基本上可以容纳所有常用各国字符,所以目前基本都使用UCS-2。</p>
<h1 id="UTF8编码"><a href="#UTF8编码" class="headerlink" title="UTF8编码"></a>UTF8编码</h1><p>Unicode使用2个字节表示一个字符，ASCII码使用1个字节，所以在很多方面产生了冲突，以前处理ASCII的方法都必须重写。而且C语言用\0作为字符串结束标志,但Unicode中很多字符都含\0,C语言的字符串函数也无法正常处理Unicode。为了把unicode投入实用,出现了UTF,最常见的是UTF-8和UTF-16。<br>其中UTF-16和Unicode本身的编码是一致的，都是使用两个字节编码字符，但是因为ASCII本身只需要一个字节，这就会造成空间的浪费。UTF-32和UCS-4也是相同的。</p>
<p>主角该出场了：UTF8是一种变长的编码，它的字节数是不固定的,使用第一个字节确定字节数。第一个字节首为0即一个字节，110即2字节，1110即3字节，字符后续字节都用10开始，这样不会混淆且单字节英文字符可仍用ASCII编码。理论上UTF-8最大可以用6字节表示一个字符，但Unicode目前没有用大于0xffff的字符，实际UTF-8最多使用了3个字节。Unicode到UTF8的转换规则如下表：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/UTF8编码/utf8.png" alt=""></p>
<p>举个栗子：</p>
<p>‘强’字的unicode编码为：<code>5F3A</code>，我们对照上表将其转换成UTF8编码：</p>
<ol>
<li>5F3A在区间[0800,07FF]，所以转换成UTF8之后应该是3个字节。</li>
<li>5F3A写成二进制形式是：0101 1111 0011 1010。</li>
<li>按照UTF8的模板依次从高位取4/6/6位二进制数填入模板，得到11100101 10111100 10111010。</li>
<li>转成16进制之后得到: E5 BC BA，这就是’强’字的UTF8编码。</li>
<li>Java程序验证一把，程序如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.winwill.test;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/9/6 23:37</div><div class="line"> */</div><div class="line">public class TestEncode &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        byte[] utf8s = &quot;强&quot;.getBytes(&quot;utf-8&quot;);</div><div class="line">        System.out.println(&quot;编码字节数：&quot; + utf8s.length);</div><div class="line">        System.out.print(&quot;编码结果：&quot;);</div><div class="line">        for (int i = 0; i &lt; utf8s.length; i++) &#123;</div><div class="line">            System.out.print(String.format(&quot;%x&quot;, utf8s[i]));</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<blockquote>
<p>编码字节数：3<br>编码结果：e5bcba</p>
</blockquote>
<p>可见，整个编码过程就是这样的，没错！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[海量数据处理]]></title>
      <url>https://fudawei.github.io/2015/09/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>作者：July、youwang、yanxionglu。<br>出处：<a href="http://blog.csdn.net/v_JULY_v。" target="_blank" rel="external">http://blog.csdn.net/v_JULY_v。</a></p>
<h2 id="十道海量数据处理面试题"><a href="#十道海量数据处理面试题" class="headerlink" title="十道海量数据处理面试题"></a>十道海量数据处理面试题</h2><ul>
<li>提取出某日访问百度次数最多的那个IP。</li>
</ul>
<p>首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。<br>或者如下阐述（雪域之鹰）：<br>算法思想：分而治之+Hash<br>1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理；<br>2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址；<br>3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址；<br>4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；</p>
<ul>
<li>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。<br>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</li>
</ul>
<p>典型的Top K算法，还是在这篇文章里头有所阐述，详情请参见：十一、从头到尾彻底解析Hash表算法。<br>文中，给出的最终算法是：<br>第一步、先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计（之前写成了排序，特此订正。July、2011.04.27）；<br>第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。<br>  即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N’*O（logK），（N为1000万，N’为300万）。ok，更多，详情，请参考原文。<br>或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p>
<ul>
<li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</li>
</ul>
<p>方案：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。<br>如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。<br>对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。</p>
<ul>
<li>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</li>
</ul>
<p>还是典型的TOP K算法，解决方案如下：<br>方案1：<br>顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。<br>找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。<br>对这10个文件进行归并排序（内排序与外排序相结合）。<br>方案2：<br> 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。<br>方案3：<br>与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p>
<ul>
<li>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</li>
</ul>
<p>方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。<br>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。<br>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。<br>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。<br>方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</p>
<ul>
<li>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</li>
</ul>
<p>方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p>
<p>方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。</p>
<ul>
<li>腾讯面试题：给40亿个不重复的unsigned </li>
</ul>
<p>int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</p>
<p>与上第6题类似，我的第一反应时快速排序+二分查找。以下是其它更好的方法：<br>方案1：oo，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p>
<p>dizengrong：<br>方案2：这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下：<br>又因为2^32为40亿多，所以给定一个数可能在，也可能不在其中；<br>这里我们把40亿个数中的每一个用32位的二进制来表示<br>假设这40亿个数开始放在一个文件中。</p>
<p>然后将这40亿个数分成两类:<br>1.最高位为0<br>2.最高位为1<br>并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=20亿，而另一个&gt;=20亿（这相当于折半了）；<br>与要查找的数的最高位比较并接着进入相应的文件再查找</p>
<p>再然后把这个文件为又分成两类:<br>1.次最高位为0<br>2.次最高位为1</p>
<p>并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=10亿，而另一个&gt;=10亿（这相当于折半了）；<br>与要查找的数的次最高位比较并接着进入相应的文件再查找。<br>…….<br>以此类推，就可以找到了,而且时间复杂度为O(logn)，方案2完。</p>
<p>附：这里，再简单介绍下，位图方法：<br>使用位图法判断整形数组是否存在重复<br>判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。</p>
<p>位图法比较适合于这种情况，它的做法是按照集合中最大元素max创建一个长度为max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上1，如遇到5就给新数组的第六个元素置1，这样下次再遇到5想置位时发现新数组的第六个元素已经是1了，这说明这次的数据肯定和以前的数据存在着重复。这种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为2N。如果已知数组的最大值即能事先给新数组定长的话效率还能提高一倍。</p>
<ul>
<li>怎么在海量数据中找出重复次数最多的一个？</li>
</ul>
<p>方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p>
<ul>
<li>上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。</li>
</ul>
<p>方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第2题提到的堆机制完成。</p>
<ul>
<li>一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</li>
</ul>
<p>方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n</em>lg10)。所以总的时间复杂度，是O(n<em>le)与O(n</em>lg10)中较大的哪一个。</p>
<ul>
<li>100w个数中找出最大的100个数。</li>
</ul>
<p>方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。</p>
<p>方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。</p>
<p>方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。</p>
<p>致谢：<a href="http://www.cnblogs.com/youwang/。" target="_blank" rel="external">http://www.cnblogs.com/youwang/。</a></p>
<p>##十个海量数据处理方法大总结</p>
<p>下面的方法全部来自<a href="http://hi.baidu.com/yanxionglu/blog/博客，对海量数据的处理方法进行了一个一般性的总结，当然这些方法可能并不能完全覆盖所有的问题，但是这样的一些方法也基本可以处理绝大多数遇到的问题。下面的一些问题基本直接来源于公司的面试笔试题目，方法不一定最优，如果你有更好的处理方法，欢迎讨论。" target="_blank" rel="external">http://hi.baidu.com/yanxionglu/blog/博客，对海量数据的处理方法进行了一个一般性的总结，当然这些方法可能并不能完全覆盖所有的问题，但是这样的一些方法也基本可以处理绝大多数遇到的问题。下面的一些问题基本直接来源于公司的面试笔试题目，方法不一定最优，如果你有更好的处理方法，欢迎讨论。</a></p>
<h3 id="Bloom-filter"><a href="#Bloom-filter" class="headerlink" title="Bloom filter"></a>Bloom filter</h3><p>适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集</p>
<h3 id="基本原理及要点："><a href="#基本原理及要点：" class="headerlink" title="基本原理及要点："></a>基本原理及要点：</h3><p>对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。</p>
<p>还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)<em>(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于n</em>lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。</p>
<p>举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。</p>
<p>注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。</p>
<p>扩展：<br>Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。</p>
<p>问题实例：给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？</p>
<p>根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。</p>
<h3 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h3><p>适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存</p>
<p>基本原理及要点：<br>hash函数选择，针对字符串，整数，排列，具体相应的hash方法。<br>碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。</p>
<p>扩展：<br>d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。</p>
<p>问题实例：<br>1).海量日志数据，提取出某日访问百度次数最多的那个IP。<br>IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。</p>
<h3 id="bit-map"><a href="#bit-map" class="headerlink" title="bit-map"></a>bit-map</h3><p>适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下</p>
<p>基本原理及要点：使用bit数组来表示某些元素是否存在，比如8位电话号码</p>
<p>扩展：bloom filter可以看做是对bit-map的扩展</p>
<p>问题实例：<br>1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。<br>8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。<br>2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p>
<p>将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>适用范围：海量数据前n大，并且n比较小，堆可以放入内存</p>
<p>基本原理及要点：最大堆求前n小，最小堆求前n大。方法，比如求前n小，我们比较当前元素与最大堆里的最大元素，如果它小于最大元素，则应该替换那个最大元素。这样最后得到的n个元素就是最小的n个。适合大数据量，求前n小，n的大小比较小的情况，这样可以扫描一遍即可得到所有的前n元素，效率很高。</p>
<p>扩展：双堆，一个最大堆与一个最小堆结合，可以用来维护中位数。</p>
<p>问题实例：<br>1)100w个数中找最大的前100个数。<br>用一个100个元素大小的最小堆即可。</p>
<h3 id="双层桶划分—-其实本质上就是【分而治之】的思想"><a href="#双层桶划分—-其实本质上就是【分而治之】的思想" class="headerlink" title="双层桶划分—-其实本质上就是【分而治之】的思想"></a>双层桶划分—-其实本质上就是【分而治之】的思想</h3><p>适用范围：第k大，中位数，不重复或重复的数字<br>基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。可以通过多次缩小，双层只是一个例子。</p>
<p>扩展：<br>问题实例：<br>1).2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。<br>有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</p>
<p>2).5亿个int找它们的中位数。<br>这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。</p>
<p>实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。</p>
<h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><p>适用范围：大数据量的增删改查</p>
<p>基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</p>
<h3 id="倒排索引-Inverted-index"><a href="#倒排索引-Inverted-index" class="headerlink" title="倒排索引(Inverted index)"></a>倒排索引(Inverted index)</h3><p>适用范围：搜索引擎，关键字查询</p>
<p>基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。</p>
<p>　以英文为例，下面是要被索引的文本：<br>T0 = “it is what it is”<br>T1 = “what is it”<br>T2 = “it is a banana”</p>
<p>我们就能得到下面的反向文件索引：</p>
<p>“a”:{2}<br>“banana”: {2}<br>“is”: {0, 1, 2}<br>“it”: {0, 1, 2}<br>“what”:   {0, 1}</p>
<p>　检索的条件”what”,”is”和”it”将对应集合的交集。</p>
<p>正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。</p>
<p>扩展：<br>问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。</p>
<h3 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h3><p>适用范围：大数据的排序，去重</p>
<p>基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树</p>
<p>扩展：</p>
<p>问题实例：<br>1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。</p>
<p>这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1m做hash有些不够，所以可以用来排序。内存可以当输入缓冲区使用。</p>
<h3 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h3><p>适用范围：数据量大，重复多，但是数据种类小可以放入内存</p>
<p>基本原理及要点：实现方式，节点孩子的表示方式</p>
<p>扩展：压缩实现。</p>
<p>问题实例：<br>1).有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。<br>2).1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？<br>3).寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。</p>
<h3 id="分布式处理-mapreduce"><a href="#分布式处理-mapreduce" class="headerlink" title="分布式处理 mapreduce"></a>分布式处理 mapreduce</h3><p>适用范围：数据量大，但是数据种类小可以放入内存</p>
<p>基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。</p>
<p>扩展：<br>问题实例：<br>1).The canonical example application of MapReduce is a process to count the appearances of<br>each different word in a set of documents:<br>2).海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。<br>3).一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？</p>
<p>经典问题分析<br>上千万or亿数据（有重复），统计其中出现次数最多的前N个数据,分两种情况：可一次读入内存，不可一次读入。</p>
<p>可用思路：trie树+堆，数据库索引，划分子集分别统计，hash，分布式计算，近似统计，外排序</p>
<p>所谓的是否能一次读入内存，实际上应该指去除重复后的数据量。如果去重后数据可以放入内存，我们可以为数据建立字典，比如通过 map，hashmap，trie，然后直接进行统计即可。当然在更新每条数据的出现次数的时候，我们可以利用一个堆来维护出现次数最多的前N个数据，当然这样导致维护次数增加，不如完全统计后在求前N大效率高。</p>
<p>如果数据无法放入内存。一方面我们可以考虑上面的字典方法能否被改进以适应这种情形，可以做的改变就是将字典存放到硬盘上，而不是内存，这可以参考数据库的存储方法。</p>
<p>当然还有更好的方法，就是可以采用分布式计算，基本上就是map-reduce过程，首先可以根据数据值或者把数据hash(md5)后的值，将数据按照范围划分到不同的机子，最好可以让数据划分后可以一次读入内存，这样不同的机子负责处理各种的数值范围，实际上就是map。得到结果后，各个机子只需拿出各自的出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是reduce过程。</p>
<p>实际上可能想直接将数据均分到不同的机子上进行处理，这样是无法得到正确的解的。因为一个数据可能被均分到不同的机子上，而另一个则可能完全聚集到一个机子上，同时还可能存在具有相同数目的数据。比如我们要找出现次数最多的前100个，我们将1000万的数据分布到10台机器上，找到每台出现次数最多的前 100个，归并之后这样不能保证找到真正的第100个，因为比如出现次数最多的第100个可能有1万个，但是它被分到了10台机子，这样在每台上只有1千个，假设这些机子排名在1000个之前的那些都是单独分布在一台机子上的，比如有1001个，这样本来具有1万个的这个就会被淘汰，即使我们让每台机子选出出现次数最多的1000个再归并，仍然会出错，因为可能存在大量个数为1001个的发生聚集。因此不能将数据随便均分到不同机子上，而是要根据hash 后的值将它们映射到不同的机子上处理，让不同的机器处理一个数值范围。</p>
<p>　 而外排序的方法会消耗大量的IO，效率不会很高。而上面的分布式方法，也可以用于单机版本，也就是将总的数据根据值的范围，划分成多个不同的子文件，然后逐个处理。处理完毕之后再对这些单词的及其出现频率进行一个归并。实际上就可以利用一个外排序的归并过程。</p>
<p>　 另外还可以考虑近似计算，也就是我们可以通过结合自然语言属性，只将那些真正实际中出现最多的那些词作为一个字典，使得这个规模可以放入内存。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[海量数据处理]]></title>
      <url>https://fudawei.github.io/2015/09/06/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>作者：July、youwang、yanxionglu。<br>出处：<a href="http://blog.csdn.net/v_JULY_v。" target="_blank" rel="external">http://blog.csdn.net/v_JULY_v。</a></p>
<h2 id="十道海量数据处理面试题"><a href="#十道海量数据处理面试题" class="headerlink" title="十道海量数据处理面试题"></a>十道海量数据处理面试题</h2><ul>
<li>提取出某日访问百度次数最多的那个IP。</li>
</ul>
<p>首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。<br>或者如下阐述（雪域之鹰）：<br>算法思想：分而治之+Hash<br>1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理；<br>2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址；<br>3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址；<br>4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；</p>
<ul>
<li>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。<br>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</li>
</ul>
<p>典型的Top K算法，还是在这篇文章里头有所阐述，详情请参见：十一、从头到尾彻底解析Hash表算法。<br>文中，给出的最终算法是：<br>第一步、先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计（之前写成了排序，特此订正。July、2011.04.27）；<br>第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。<br>  即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N’*O（logK），（N为1000万，N’为300万）。ok，更多，详情，请参考原文。<br>或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p>
<ul>
<li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</li>
</ul>
<p>方案：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。<br>如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。<br>对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。</p>
<ul>
<li>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</li>
</ul>
<p>还是典型的TOP K算法，解决方案如下：<br>方案1：<br>顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。<br>找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。<br>对这10个文件进行归并排序（内排序与外排序相结合）。<br>方案2：<br> 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。<br>方案3：<br>与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p>
<ul>
<li>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</li>
</ul>
<p>方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。<br>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。<br>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。<br>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。<br>方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</p>
<ul>
<li>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</li>
</ul>
<p>方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p>
<p>方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。</p>
<ul>
<li>腾讯面试题：给40亿个不重复的unsigned </li>
</ul>
<p>int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</p>
<p>与上第6题类似，我的第一反应时快速排序+二分查找。以下是其它更好的方法：<br>方案1：oo，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p>
<p>dizengrong：<br>方案2：这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下：<br>又因为2^32为40亿多，所以给定一个数可能在，也可能不在其中；<br>这里我们把40亿个数中的每一个用32位的二进制来表示<br>假设这40亿个数开始放在一个文件中。</p>
<p>然后将这40亿个数分成两类:<br>1.最高位为0<br>2.最高位为1<br>并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=20亿，而另一个&gt;=20亿（这相当于折半了）；<br>与要查找的数的最高位比较并接着进入相应的文件再查找</p>
<p>再然后把这个文件为又分成两类:<br>1.次最高位为0<br>2.次最高位为1</p>
<p>并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=10亿，而另一个&gt;=10亿（这相当于折半了）；<br>与要查找的数的次最高位比较并接着进入相应的文件再查找。<br>…….<br>以此类推，就可以找到了,而且时间复杂度为O(logn)，方案2完。</p>
<p>附：这里，再简单介绍下，位图方法：<br>使用位图法判断整形数组是否存在重复<br>判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。</p>
<p>位图法比较适合于这种情况，它的做法是按照集合中最大元素max创建一个长度为max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上1，如遇到5就给新数组的第六个元素置1，这样下次再遇到5想置位时发现新数组的第六个元素已经是1了，这说明这次的数据肯定和以前的数据存在着重复。这种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为2N。如果已知数组的最大值即能事先给新数组定长的话效率还能提高一倍。</p>
<ul>
<li>怎么在海量数据中找出重复次数最多的一个？</li>
</ul>
<p>方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p>
<ul>
<li>上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。</li>
</ul>
<p>方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第2题提到的堆机制完成。</p>
<ul>
<li>一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</li>
</ul>
<p>方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n</em>lg10)。所以总的时间复杂度，是O(n<em>le)与O(n</em>lg10)中较大的哪一个。</p>
<ul>
<li>100w个数中找出最大的100个数。</li>
</ul>
<p>方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。</p>
<p>方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。</p>
<p>方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。</p>
<p>致谢：<a href="http://www.cnblogs.com/youwang/。" target="_blank" rel="external">http://www.cnblogs.com/youwang/。</a></p>
<p>##十个海量数据处理方法大总结</p>
<p>下面的方法全部来自<a href="http://hi.baidu.com/yanxionglu/blog/博客，对海量数据的处理方法进行了一个一般性的总结，当然这些方法可能并不能完全覆盖所有的问题，但是这样的一些方法也基本可以处理绝大多数遇到的问题。下面的一些问题基本直接来源于公司的面试笔试题目，方法不一定最优，如果你有更好的处理方法，欢迎讨论。" target="_blank" rel="external">http://hi.baidu.com/yanxionglu/blog/博客，对海量数据的处理方法进行了一个一般性的总结，当然这些方法可能并不能完全覆盖所有的问题，但是这样的一些方法也基本可以处理绝大多数遇到的问题。下面的一些问题基本直接来源于公司的面试笔试题目，方法不一定最优，如果你有更好的处理方法，欢迎讨论。</a></p>
<h3 id="Bloom-filter"><a href="#Bloom-filter" class="headerlink" title="Bloom filter"></a>Bloom filter</h3><p>适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集</p>
<h3 id="基本原理及要点："><a href="#基本原理及要点：" class="headerlink" title="基本原理及要点："></a>基本原理及要点：</h3><p>对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。</p>
<p>还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)<em>(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于n</em>lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。</p>
<p>举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。</p>
<p>注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。</p>
<p>扩展：<br>Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。</p>
<p>问题实例：给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？</p>
<p>根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。</p>
<h3 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h3><p>适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存</p>
<p>基本原理及要点：<br>hash函数选择，针对字符串，整数，排列，具体相应的hash方法。<br>碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。</p>
<p>扩展：<br>d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。</p>
<p>问题实例：<br>1).海量日志数据，提取出某日访问百度次数最多的那个IP。<br>IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。</p>
<h3 id="bit-map"><a href="#bit-map" class="headerlink" title="bit-map"></a>bit-map</h3><p>适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下</p>
<p>基本原理及要点：使用bit数组来表示某些元素是否存在，比如8位电话号码</p>
<p>扩展：bloom filter可以看做是对bit-map的扩展</p>
<p>问题实例：<br>1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。<br>8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。<br>2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p>
<p>将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>适用范围：海量数据前n大，并且n比较小，堆可以放入内存</p>
<p>基本原理及要点：最大堆求前n小，最小堆求前n大。方法，比如求前n小，我们比较当前元素与最大堆里的最大元素，如果它小于最大元素，则应该替换那个最大元素。这样最后得到的n个元素就是最小的n个。适合大数据量，求前n小，n的大小比较小的情况，这样可以扫描一遍即可得到所有的前n元素，效率很高。</p>
<p>扩展：双堆，一个最大堆与一个最小堆结合，可以用来维护中位数。</p>
<p>问题实例：<br>1)100w个数中找最大的前100个数。<br>用一个100个元素大小的最小堆即可。</p>
<h3 id="双层桶划分—-其实本质上就是【分而治之】的思想"><a href="#双层桶划分—-其实本质上就是【分而治之】的思想" class="headerlink" title="双层桶划分—-其实本质上就是【分而治之】的思想"></a>双层桶划分—-其实本质上就是【分而治之】的思想</h3><p>适用范围：第k大，中位数，不重复或重复的数字<br>基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。可以通过多次缩小，双层只是一个例子。</p>
<p>扩展：<br>问题实例：<br>1).2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。<br>有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</p>
<p>2).5亿个int找它们的中位数。<br>这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。</p>
<p>实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。</p>
<h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><p>适用范围：大数据量的增删改查</p>
<p>基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</p>
<h3 id="倒排索引-Inverted-index"><a href="#倒排索引-Inverted-index" class="headerlink" title="倒排索引(Inverted index)"></a>倒排索引(Inverted index)</h3><p>适用范围：搜索引擎，关键字查询</p>
<p>基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。</p>
<p>　以英文为例，下面是要被索引的文本：<br>T0 = “it is what it is”<br>T1 = “what is it”<br>T2 = “it is a banana”</p>
<p>我们就能得到下面的反向文件索引：</p>
<p>“a”:{2}<br>“banana”: {2}<br>“is”: {0, 1, 2}<br>“it”: {0, 1, 2}<br>“what”:   {0, 1}</p>
<p>　检索的条件”what”,”is”和”it”将对应集合的交集。</p>
<p>正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。</p>
<p>扩展：<br>问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。</p>
<h3 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h3><p>适用范围：大数据的排序，去重</p>
<p>基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树</p>
<p>扩展：</p>
<p>问题实例：<br>1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。</p>
<p>这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1m做hash有些不够，所以可以用来排序。内存可以当输入缓冲区使用。</p>
<h3 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h3><p>适用范围：数据量大，重复多，但是数据种类小可以放入内存</p>
<p>基本原理及要点：实现方式，节点孩子的表示方式</p>
<p>扩展：压缩实现。</p>
<p>问题实例：<br>1).有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。<br>2).1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？<br>3).寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。</p>
<h3 id="分布式处理-mapreduce"><a href="#分布式处理-mapreduce" class="headerlink" title="分布式处理 mapreduce"></a>分布式处理 mapreduce</h3><p>适用范围：数据量大，但是数据种类小可以放入内存</p>
<p>基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。</p>
<p>扩展：<br>问题实例：<br>1).The canonical example application of MapReduce is a process to count the appearances of<br>each different word in a set of documents:<br>2).海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。<br>3).一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？</p>
<p>经典问题分析<br>上千万or亿数据（有重复），统计其中出现次数最多的前N个数据,分两种情况：可一次读入内存，不可一次读入。</p>
<p>可用思路：trie树+堆，数据库索引，划分子集分别统计，hash，分布式计算，近似统计，外排序</p>
<p>所谓的是否能一次读入内存，实际上应该指去除重复后的数据量。如果去重后数据可以放入内存，我们可以为数据建立字典，比如通过 map，hashmap，trie，然后直接进行统计即可。当然在更新每条数据的出现次数的时候，我们可以利用一个堆来维护出现次数最多的前N个数据，当然这样导致维护次数增加，不如完全统计后在求前N大效率高。</p>
<p>如果数据无法放入内存。一方面我们可以考虑上面的字典方法能否被改进以适应这种情形，可以做的改变就是将字典存放到硬盘上，而不是内存，这可以参考数据库的存储方法。</p>
<p>当然还有更好的方法，就是可以采用分布式计算，基本上就是map-reduce过程，首先可以根据数据值或者把数据hash(md5)后的值，将数据按照范围划分到不同的机子，最好可以让数据划分后可以一次读入内存，这样不同的机子负责处理各种的数值范围，实际上就是map。得到结果后，各个机子只需拿出各自的出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是reduce过程。</p>
<p>实际上可能想直接将数据均分到不同的机子上进行处理，这样是无法得到正确的解的。因为一个数据可能被均分到不同的机子上，而另一个则可能完全聚集到一个机子上，同时还可能存在具有相同数目的数据。比如我们要找出现次数最多的前100个，我们将1000万的数据分布到10台机器上，找到每台出现次数最多的前 100个，归并之后这样不能保证找到真正的第100个，因为比如出现次数最多的第100个可能有1万个，但是它被分到了10台机子，这样在每台上只有1千个，假设这些机子排名在1000个之前的那些都是单独分布在一台机子上的，比如有1001个，这样本来具有1万个的这个就会被淘汰，即使我们让每台机子选出出现次数最多的1000个再归并，仍然会出错，因为可能存在大量个数为1001个的发生聚集。因此不能将数据随便均分到不同机子上，而是要根据hash 后的值将它们映射到不同的机子上处理，让不同的机器处理一个数值范围。</p>
<p>　 而外排序的方法会消耗大量的IO，效率不会很高。而上面的分布式方法，也可以用于单机版本，也就是将总的数据根据值的范围，划分成多个不同的子文件，然后逐个处理。处理完毕之后再对这些单词的及其出现频率进行一个归并。实际上就可以利用一个外排序的归并过程。</p>
<p>　 另外还可以考虑近似计算，也就是我们可以通过结合自然语言属性，只将那些真正实际中出现最多的那些词作为一个字典，使得这个规模可以放入内存。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大数据（一）]]></title>
      <url>https://fudawei.github.io/2015/09/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>转载自<br>海量数据处理：十道面试题与十个海量数据处理方法总结<br>作者：July、youwang、yanxionglu</p>
<h2 id="何谓海量数据处理？"><a href="#何谓海量数据处理？" class="headerlink" title="何谓海量数据处理？"></a>何谓海量数据处理？</h2><p>所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。<br>那解决办法呢?针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom filter/Hash/bit-map/堆/数据库或倒排索引/trie树，针对空间，无非就一个办法：大而化小，分而治之（hash映射），你不是说规模太大嘛，那简单啊，就把规模大化为规模小的，各个击破不就完了嘛。<br>至于所谓的单机及集群问题，通俗点来讲，单机就是处理装载数据的机器有限(只要考虑cpu，内存，硬盘的数据交互)，而集群，机器有多辆，适合分布式处理，并行计算(更多考虑节点和节点间的数据交互)。<br>再者，通过本blog内的有关海量数据处理的文章：Big Data Processing，我们已经大致知道，处理海量数据问题，无非就是：</p>
<p>分而治之/hash映射 + hash统计 + 堆/快速/归并排序；<br>双层桶划分<br>Bloom filter/Bitmap；<br>Trie树/数据库/倒排索引；<br>外排序；<br>分布式处理之Hadoop/Mapreduce。</p>
<p>从set/map谈到hashtable/hash_map/hash_set<br>稍后本文第二部分中将多次提到hash_map/hash_set，下面稍稍介绍下这些容器，以作为基础准备。一般来说，STL容器分两种，<br>序列式容器(vector/list/deque/stack/queue/heap)，<br>关联式容器。关联式容器又分为set(集合)和map(映射表)两大类，以及这两大类的衍生体multiset(多键集合)和multimap(多键映射表)，这些容器均以RB-tree完成。此外，还有第3类关联式容器，如hashtable(散列表)，以及以hashtable为底层机制完成的hash_set(散列集合)/hash_map(散列映射表)/hash_multiset(散列多键集合)/hash_multimap(散列多键映射表)。也就是说，set/map/multiset/multimap都内含一个RB-tree，而hash_set/hash_map/hash_multiset/hash_multimap都内含一个hashtable。<br>所谓关联式容器，类似关联式数据库，每笔数据或每个元素都有一个键值(key)和一个实值(value)，即所谓的Key-Value(键-值对)。当元素被插入到关联式容器中时，容器内部结构(RB-tree/hashtable)便依照其键值大小，以某种特定规则将这个元素放置于适当位置。</p>
<p> 包括在非关联式数据库中，比如，在MongoDB内，文档(document)是最基本的数据组织形式，每个文档也是以Key-Value（键-值对）的方式组织起来。一个文档可以有多个Key-Value组合，每个Value可以是不同的类型，比如String、Integer、List等等。<br>{ “name” : “July”,<br>  “sex” : “male”,<br>“age” : 23 }  </p>
<p>set/map/multiset/multimap<br>set，同map一样，所有元素都会根据元素的键值自动被排序，因为set/map两者的所有各种操作，都只是转而调用RB-tree的操作行为，不过，值得注意的是，两者都不允许两个元素有相同的键值。<br>不同的是：set的元素不像map那样可以同时拥有实值(value)和键值(key)，set元素的键值就是实值，实值就是键值，而map的所有元素都是pair，同时拥有实值(value)和键值(key)，pair的第一个元素被视为键值，第二个元素被视为实值。<br>至于multiset/multimap，他们的特性及用法和set/map完全相同，唯一的差别就在于它们允许键值重复，即所有的插入操作基于RB-tree的insert_equal()而非insert_unique()。</p>
<p>hash_set/hash_map/hash_multiset/hash_multimap<br>hash_set/hash_map，两者的一切操作都是基于hashtable之上。不同的是，hash_set同set一样，同时拥有实值和键值，且实质就是键值，键值就是实值，而hash_map同map一样，每一个元素同时拥有一个实值(value)和一个键值(key)，所以其使用方式，和上面的map基本相同。但由于hash_set/hash_map都是基于hashtable之上，所以不具备自动排序功能。为什么?因为hashtable没有自动排序功能。<br>至于hash_multiset/hash_multimap的特性与上面的multiset/multimap完全相同，唯一的差别就是它们hash_multiset/hash_multimap的底层实现机制是hashtable（而multiset/multimap，上面说了，底层实现机制是RB-tree），所以它们的元素都不会被自动排序，不过也都允许键值重复。<br>所以，综上，说白了，什么样的结构决定其什么样的性质，因为set/map/multiset/multimap都是基于RB-tree之上，所以有自动排序功能，而hash_set/hash_map/hash_multiset/hash<em>multimap都是基于hashtable之上，所以不含有自动排序功能，至于加个前缀multi</em>无非就是允许键值重复而已。<br>此外，<br>关于什么hash，请看blog内此篇文章；<br>关于红黑树，请参看blog内系列文章，<br>关于hash_map的具体应用：请看这里，关于hash_set：请看此文。<br>OK，接下来，请看本文第二部分、处理海量数据问题之六把密匙。</p>
<h4 id="密钥一-分而治之"><a href="#密钥一-分而治之" class="headerlink" title="密钥一 分而治之"></a>密钥一 分而治之</h4><p>分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序<br>海量日志数据，提取出某日访问百度次数最多的那个IP。<br>既然是海量数据处理，那么可想而知，给我们的数据那就一定是海量的。针对这个数据的海量，我们如何着手呢?对的，无非就是分而治之/hash映射 + hash统计 + 堆/快速/归并排序，说白了，就是先映射，而后统计，最后排序：<br>分而治之/hash映射：针对数据太大，内存受限，只能是：把大文件化成(取模映射)小文件，即16字方针：大而化小，各个击破，缩小规模，逐个解决<br>hash_map统计：当大文件转化了小文件，那么我们便可以采用常规的hash_map(ip，value)来进行频率统计。<br>堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。<br>具体而论，则是： “首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如%1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map对那1000个文件中的所有IP进行频率统计，然后依次找出各个文件中频率最大的那个IP）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。”–十道海量数据处理面试题与十个方法大总结。</p>
<p>关于本题，还有几个问题，如下：</p>
<p>Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中的情况，即这里采用的是mod1000算法，那么相同的IP在hash取模后，只可能落在同一个文件中，不可能被分散的。因为如果两个IP相等，那么经过Hash(IP)之后的哈希值是相同的，将此哈希值取模（如模1000），必定仍然相等。<br>那到底什么是hash映射呢？简单来说，就是为了便于计算机在有限的内存中处理big数据，从而通过一种映射散列的方式让数据均匀分布在对应的内存位置(如大数据通过取余的方式映射成小树存放在内存中，或大文件映射成多个小文件)，而这个映射散列方式便是我们通常所说的hash函数，设计的好的hash函数能让数据均匀分布而减少冲突。尽管数据映射到了另外一些不同的位置，但数据还是原来的数据，只是代替和表示这些原始数据的形式发生了变化而已。<br>OK，有兴趣的，还可以再了解下一致性hash算法，见blog内此文第五部分：<a href="http://blog.csdn.net/v_july_v/article/details/6879101。" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6879101。</a></p>
<ul>
<li>寻找热门查询，300万个查询字符串中统计最热门的10个查询</li>
</ul>
<p>原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p>解答：由上面第1题，我们知道，数据大则划为小的，如如一亿个Ip求Top 10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结。<br>但如果数据规模比较小，能一次性装入内存呢?比如这第2题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去（300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理），而现在只是需要一个合适的数据结构，在这里，HashTable绝对是我们优先的选择。<br>所以我们放弃分而治之/hash映射的步骤，直接上hash统计，然后排序。So，针对此类典型的TOP K问题，采取的对策往往是：hashmap + 堆。如下所示：</p>
<p>hash_map统计：先对这批海量数据预处理。具体方法是：维护一个Key为Query字串，Value为该Query出现次数的HashTable，即hash_map(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计；<br>堆排序：第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是：O（N） + N’ <em> O（logK），（N为1000万，N’为300万）。<br>别忘了这篇文章中所述的堆排序思路：“维护k个元素的最小堆，即用容量为k的最小堆存储最先遍历到的k个数，并假设它们即是最大的k个数，建堆费时O（k），并调整堆(费时O（logk）)后，有k1&gt;k2&gt;…kmin（kmin设为小顶堆中最小元素）。继续遍历数列，每次遍历一个元素x，与堆顶元素比较，若x&gt;kmin，则更新堆（x入堆，用时logk），否则不更新堆。这样下来，总费时O（k</em>logk+（n-k）<em>logk）=O（n</em>logk）。此方法得益于在堆中，查找等各项操作时间复杂度均为logk。”–第三章续、Top K算法问题的实现。<br>当然，你也可以采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p>
<ul>
<li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。<br>由上面那两个例题，分而治之 + hash统计 + 堆/快速排序这个套路，我们已经开始有了屡试不爽的感觉。下面，再拿几道再多多验证下。请看此第3题：又是文件很大，又是内存受限，咋办?还能怎么办呢?无非还是：</li>
</ul>
<p>分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。<br>hash_map统计：对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。<br>堆/归并排序：取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。</p>
<ul>
<li>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。<br>如果每个数据元素只出现一次，而且只出现在某一台机器中，那么可以采取以下步骤统计出现次数TOP10的数据元素：<br>堆排序：在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆，比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大）。<br>求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。<br>但如果同一个元素重复出现在不同的电脑中呢，如下例子所述：</li>
</ul>
<p>这个时候，你可以有两种方法：<br>遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，统计每台电脑中各个元素的出现次数找出TOP10，继而组合100台电脑上的TOP10，找出最终的TOP10。<br>或者，暴力求解：直接统计统计每台电脑中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出TOP10。</p>
<ul>
<li><p>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。<br>方案1：直接上：<br>hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为a0,a1,..a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。<br>hash_map统计：找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。<br>堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序，将排序好的query和对应的query_cout输出到文件中，这样得到了10个排好序的文件（记为）。最后，对这10个文件进行归并排序（内排序与外排序相结合）。根据此方案1，这里有一份实现：<a href="https://github.com/ooooola/sortquery/blob/master/querysort.py。" target="_blank" rel="external">https://github.com/ooooola/sortquery/blob/master/querysort.py。</a><br>除此之外，此题还有以下两个方法：<br>方案2：一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。<br>方案3：与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p>
</li>
<li><p>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？<br>可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p>
</li>
</ul>
<p>分而治之/hash映射：遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为，这里漏写个了a1）中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。<br>hash_set统计：求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。<br>OK，此第一种方法：分而治之/hash映射 + hash统计 + 堆/快速/归并排序，再看最后4道题，如下：</p>
<ul>
<li>怎么在海量数据中找出重复次数最多的一个？</li>
</ul>
<p>方案：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p>
<ul>
<li>上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</li>
</ul>
<p>方案：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后利用堆取出前N个出现次数最多的数据。</p>
<p>一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</p>
<p>方案1：如果文件比较大，无法一次性读入内存，可以采用hash取模的方法，将大文件分解为多个小文件，对于单个小文件利用hash_map统计出每个小文件中10个最常出现的词，然后再进行归并处理，找出最终的10个最常出现的词。<br>方案2：通过hash取模将大文件分解为多个小文件后，除了可以用hash_map统计出每个小文件中10个最常出现的词，也可以用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平准长度），最终同样找出出现最频繁的前10个词（可用堆来实现），时间复杂度是O(n</em>lg10)。</p>
<ul>
<li>1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？</li>
</ul>
<p>方案1：这题用trie树比较合适，hash_map也行。<br>方案2：from xjbzju:，1000w的数据规模插入操作完全不现实，以前试过在stl下100w元素插入set中已经慢得不能忍受，觉得基于hash的实现不会比红黑树好太多，使用vector+sort+unique都要可行许多，建议还是先hash成小文件分开处理再综合。<br>上述方案2中读者xbzju的方法让我想到了一些问题，即是set/map，与hash_set/hash_map的性能比较?共计3个问题，如下：<br>1、hash_set在千万级数据下，insert操作优于set? 这位blog：<a href="http://t.cn/zOibP7t" target="_blank" rel="external">http://t.cn/zOibP7t</a> 给的实践数据可靠不?<br>2、那map和hash_map的性能比较呢? 谁做过相关实验?</p>
<p>3、那查询操作呢，如下段文字所述?</p>
<p>或者小数据量时用map，构造快，大数据量时用hash_map?</p>
<p>rbtree PK hashtable</p>
<p>据朋友№邦卡猫№的做的红黑树和hash table的性能测试中发现：当数据量基本上int型key时，hash table是rbtree的3-4倍，但hash table一般会浪费大概一半内存。</p>
<p>因为hash table所做的运算就是个%，而rbtree要比较很多，比如rbtree要看value的数据 ，每个节点要多出3个指针（或者偏移量） 如果需要其他功能，比如，统计某个范围内的key的数量，就需要加一个计数成员。<br>且1s rbtree能进行大概50w+次插入，hash table大概是差不多200w次。不过很多的时候，其速度可以忍了，例如倒排索引差不多也是这个速度，而且单线程，且倒排表的拉链长度不会太大。正因为基于树的实现其实不比hashtable慢到哪里去，所以数据库的索引一般都是用的B/B+树，而且B+树还对磁盘友好(B树能有效降低它的高度，所以减少磁盘交互次数)。比如现在非常流行的NoSQL数据库，像MongoDB也是采用的B树索引。关于B树系列，请参考本blog内此篇文章：从B树、B+树、B*树谈到R 树。更多请待后续实验论证。</p>
<ul>
<li><p>一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。<br>方案1：首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。</p>
</li>
<li><p>100w个数中找出最大的100个数。<br>方案1：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w<em>100)。<br>方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w</em>100)。<br>方案3：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。<br>接下来，咱们来看第二种方法，双层捅划分。</p>
</li>
</ul>
<h4 id="密匙二、多层划分"><a href="#密匙二、多层划分" class="headerlink" title="密匙二、多层划分"></a>密匙二、多层划分</h4><p>多层划分—-其实本质上还是分而治之的思想，重在“分”的技巧上！<br>适用范围：第k大，中位数，不重复或重复的数字<br>基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。</p>
<p>问题实例：</p>
<ul>
<li>2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。<br>有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</li>
<li>5亿个int找它们的中位数。<br>思路一：这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。<br>实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。<br>思路二@绿色夹克衫：同样需要做两遍统计，如果数据存在硬盘上，就需要读取2次。<br>方法同基数排序有些像，开一个大小为65536的Int数组，第一遍读取，统计Int32的高16位的情况，也就是0-65535，都算作0,65536 - 131071都算作1。就相当于用该数除以65536。Int32 除以 65536的结果不会超过65536种情况，因此开一个长度为65536的数组计数就可以。每读取一个数，数组中对应的计数+1，考虑有负数的情况，需要将结果加32768后，记录在相应的数组内。<br>第一遍统计之后，遍历数组，逐个累加统计，看中位数处于哪个区间，比如处于区间k，那么0- k-1的区间里数字的数量sum应该&lt;n/2（2.5亿）。而k+1 - 65535的计数和也&lt;n/2，第二遍统计同上面的方法类似，但这次只统计处于区间k的情况，也就是说(x / 65536) + 32768 = k。统计只统计低16位的情况。并且利用刚才统计的sum，比如sum = 2.49亿，那么现在就是要在低16位里面找100万个数(2.5亿-2.49亿)。这次计数之后，再统计一下，看中位数所处的区间，最后将高位和低位组合一下就是结果了。</li>
</ul>
<h4 id="密匙三：Bloom-filter-Bitmap"><a href="#密匙三：Bloom-filter-Bitmap" class="headerlink" title="密匙三：Bloom filter/Bitmap"></a>密匙三：Bloom filter/Bitmap</h4><p>Bloom filter<br>关于什么是Bloom filter，请参看blog内此文：</p>
<p>海量数据处理之Bloom Filter详解<br>适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集<br>基本原理及要点：<br>对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。<br>还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)<em>(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于n</em>lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。<br>举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。<br>注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。</p>
<p>扩展：<br>Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。</p>
<p>可以看下上文中的第6题：</p>
<p>“6、给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？</p>
<p>根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。</p>
<p>同时，上文的第5题：给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。”</p>
<p>Bitmap<br>关于什么是Bitmap，请看blog内此文第二部分：<a href="http://blog.csdn.net/v_july_v/article/details/6685962。" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6685962。</a><br>下面关于Bitmap的应用，可以看下上文中的第13题，以及另外一道新题：</p>
<p>“13、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</p>
<p>方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。<br>方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。”</p>
<p>15、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？<br>方案1：frome oo，用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p>
<h4 id="密匙四、Trie树-数据库-倒排索引"><a href="#密匙四、Trie树-数据库-倒排索引" class="headerlink" title="密匙四、Trie树/数据库/倒排索引"></a>密匙四、Trie树/数据库/倒排索引</h4><p>Trie树</p>
<p>适用范围：数据量大，重复多，但是数据种类小可以放入内存<br>基本原理及要点：实现方式，节点孩子的表示方式<br>扩展：压缩实现。<br>问题实例：</p>
<p>上面的第2题：寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。<br>上面的第5题：有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。<br>1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？<br>上面的第8题：一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词。其解决方法是：用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度），然后是找出出现最频繁的前10个词。<br>更多有关Trie树的介绍，请参见此文：从Trie树（字典树）谈到后缀树。</p>
<p>数据库索引<br>适用范围：大数据量的增删改查<br>基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</p>
<p>关于数据库索引及其优化，更多可参见此文：<a href="http://www.cnblogs.com/pkuoliver/archive/2011/08/17/mass-data-topic-7-index-and-optimize.html；" target="_blank" rel="external">http://www.cnblogs.com/pkuoliver/archive/2011/08/17/mass-data-topic-7-index-and-optimize.html；</a><br>关于MySQL索引背后的数据结构及算法原理，这里还有一篇很好的文章：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html；" target="_blank" rel="external">http://blog.codinglabs.org/articles/theory-of-mysql-index.html；</a><br>关于B 树、B+ 树、B* 树及R 树，本blog内有篇绝佳文章：<a href="http://blog.csdn.net/v_JULY_v/article/details/6530142。" target="_blank" rel="external">http://blog.csdn.net/v_JULY_v/article/details/6530142。</a><br>倒排索引(Inverted index)<br>适用范围：搜索引擎，关键字查询<br>基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。<br>　以英文为例，下面是要被索引的文本：<br>T0 = “it is what it is”<br>T1 = “what is it”<br>T2 = “it is a banana”<br>我们就能得到下面的反向文件索引：<br>“a”:{2}<br>“banana”: {2}<br>“is”: {0, 1, 2}<br>“it”: {0, 1, 2}<br>“what”:{0, 1}<br>　检索的条件”what”,”is”和”it”将对应集合的交集。</p>
<p>正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。<br>扩展：<br>问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。</p>
<p>关于倒排索引的应用，更多请参见：</p>
<p>第二十三、四章：杨氏矩阵查找，倒排索引关键词Hash不重复编码实践，<br>第二十六章：基于给定的文档生成倒排索引的编码与实践。</p>
<h4 id="密匙五、外排序"><a href="#密匙五、外排序" class="headerlink" title="密匙五、外排序"></a>密匙五、外排序</h4><p>适用范围：大数据的排序，去重<br>基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树<br>问题实例：<br>1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。<br>这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1M做hash明显不够，所以可以用来排序。内存可以当输入缓冲区使用。</p>
<p>关于多路归并算法及外排序的具体应用场景，请参见blog内此文：</p>
<p>第十章、如何给10^7个数据量的磁盘文件排序</p>
<h4 id="密匙六、分布式处理之Mapreduce"><a href="#密匙六、分布式处理之Mapreduce" class="headerlink" title="密匙六、分布式处理之Mapreduce"></a>密匙六、分布式处理之Mapreduce</h4><p>MapReduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。但如果你要我再通俗点介绍，那么，说白了，Mapreduce的原理就是一个归并排序。</p>
<p>适用范围：数据量大，但是数据种类小可以放入内存<br>基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。<br>问题实例：</p>
<p>The canonical example application of MapReduce is a process to count the appearances of each different word in a set of documents:<br>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。<br>一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？<br>更多具体阐述请参见blog内：</p>
<p>从Hadhoop框架与MapReduce模式中谈海量数据处理，<br>及MapReduce技术的初步了解与学习。<br>其它模式/方法论，结合操作系统知识<br>至此，六种处理海量数据问题的模式/方法已经阐述完毕。据观察，这方面的面试题无外乎以上一种或其变形，然题目为何取为是：秒杀99%的海量数据处理面试题，而不是100%呢。OK，给读者看最后一道题，如下：<br>非常大的文件，装不进内存。每行一个int类型数据，现在要你随机取100个数。<br>我们发现上述这道题，无论是以上任何一种模式/方法都不好做，那有什么好的别的方法呢？我们可以看看：操作系统内存分页系统设计(说白了，就是映射+建索引)。<br>Windows 2000使用基于分页机制的虚拟内存。每个进程有4GB的虚拟地址空间。基于分页机制，这4GB地址空间的一些部分被映射了物理内存，一些部分映射硬盘上的交换文 件，一些部分什么也没有映射。程序中使用的都是4GB地址空间中的虚拟地址。而访问物理内存，需要使用物理地址。 关于什么是物理地址和虚拟地址，请看：<br>物理地址 (physical address): 放在寻址总线上的地址。放在寻址总线上，如果是读，电路根据这个地址每位的值就将相应地址的物理内存中的数据放到数据总线中传输。如果是写，电路根据这个 地址每位的值就将相应地址的物理内存中放入数据总线上的内容。物理内存是以字节(8位)为单位编址的。<br>虚拟地址 (virtual address): 4G虚拟地址空间中的地址，程序中使用的都是虚拟地址。 使用了分页机制之后，4G的地址空间被分成了固定大小的页，每一页或者被映射到物理内存，或者被映射到硬盘上的交换文件中，或者没有映射任何东西。对于一 般程序来说，4G的地址空间，只有一小部分映射了物理内存，大片大片的部分是没有映射任何东西。物理内存也被分页，来映射地址空间。对于32bit的 Win2k，页的大小是4K字节。CPU用来把虚拟地址转换成物理地址的信息存放在叫做页目录和页表的结构里。<br>物理内存分页，一个物理页的大小为4K字节，第0个物理页从物理地址 0x00000000 处开始。由于页的大小为4KB，就是0x1000字节，所以第1页从物理地址 0x00001000 处开始。第2页从物理地址 0x00002000 处开始。可以看到由于页的大小是4KB，所以只需要32bit的地址中高20bit来寻址物理页。<br>返回上面我们的题目：非常大的文件，装不进内存。每行一个int类型数据，现在要你随机取100个数。针对此题，我们可以借鉴上述操作系统中内存分页的设计方法，做出如下解决方案：<br>操作系统中的方法，先生成4G的地址表，在把这个表划分为小的4M的小文件做个索引，二级索引。30位前十位表示第几个4M文件，后20位表示在这个4M文件的第几个，等等，基于key value来设计存储，用key来建索引。</p>
<p>但如果现在只有10000个数，然后怎么去随机从这一万个数里面随机取100个数？请读者思考。更多海里数据处理面试题，请参见此文第一部分：<a href="http://blog.csdn.net/v_july_v/article/details/6685962。" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6685962。</a></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>十道海量数据处理面试题与十个方法大总结；<br>海量数据处理面试题集锦与Bit-map详解；<br>十一、从头到尾彻底解析Hash表算法；<br>海量数据处理之Bloom Filter详解；<br>从Trie树（字典树）谈到后缀树；<br>第三章续、Top K算法问题的实现；<br>第十章、如何给10^7个数据量的磁盘文件排序；<br>从B树、B+树、B*树谈到R 树；<br>第二十三、四章：杨氏矩阵查找，倒排索引关键词Hash不重复编码实践；<br>第二十六章：基于给定的文档生成倒排索引的编码与实践；<br>从Hadhoop框架与MapReduce模式中谈海量数据处理；<br>第十六~第二十章：全排列，跳台阶，奇偶排序，第一个只出现一次等问题；<br><a href="http://blog.csdn.net/v_JULY_v/article/category/774945；" target="_blank" rel="external">http://blog.csdn.net/v_JULY_v/article/category/774945；</a><br>STL源码剖析第五章，侯捷著；<br>2012百度实习生招聘笔试题：<a href="http://blog.csdn.net/hackbuteer1/article/details/7542774。" target="_blank" rel="external">http://blog.csdn.net/hackbuteer1/article/details/7542774。</a></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>经过上面这么多海量数据处理面试题的轰炸，我们依然可以看出这类问题是有一定的解决方案/模式的，所以，不必将其神化。然这类面试题所包含的问题还是比较简单的，若您在这方面有更多实践经验，欢迎随时来信与我不吝分享：zhoulei0907@yahoo.cn。当然，自会注明分享者及来源。<br>不过，相信你也早就意识到，若单纯论海量数据处理面试题，本blog内的有关海量数据处理面试题的文章已涵盖了你能在网上所找到的70~80%。但有点，必须负责任的敬告大家：无论是这些海量数据处理面试题也好，还是算法也好，面试时，70~80%的人不是倒在这两方面，而是倒在基础之上(诸如语言，数据库，操作系统，网络协议等等)，所以，无论任何时候，基础最重要，没了基础，便什么都不是。<br>最后，推荐国外一面试题网站：<a href="http://www.careercup.com/，以及个人正在读的Redis/MongoDB绝佳站点：http://blog.nosqlfan.com/。" target="_blank" rel="external">http://www.careercup.com/，以及个人正在读的Redis/MongoDB绝佳站点：http://blog.nosqlfan.com/。</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux进阶]]></title>
      <url>https://fudawei.github.io/2015/09/05/Linux%E8%BF%9B%E9%98%B6/</url>
      <content type="html"><![CDATA[<p>welcome to you</p>
<h2 id="Linux-skill"><a href="#Linux-skill" class="headerlink" title="Linux skill"></a>Linux skill</h2><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><ol>
<li>Linux系统中的/proc文件系统有什么用？<br>/proc文件系统是一个基于内存的文件系统，其维护着关于当前正在运行的内核状态信息，其中包括CPU、内存、分区划分、I/O地址、直接内存访问通道 和正在运行的进程</li>
<li>如何在/usr目录下找出大小超过10MB的文件？<br>find /usr -size +10M</li>
<li>如何在/home目录下找出120天之前被修改过的文件？<br>find /home -mtime +120</li>
<li>如何在/var目录下找出90天之内未被访问过的文件？<br>find /var ! -atime -90</li>
<li>整个目录树下查找文件core，如发现则无需提示直接删除它们<br>find / -name core -exec {} \;</li>
<li>ll | awk {print $3,owns,$9} 这条命令是在做什么？</li>
<li>Linux中的at命令有什么用？<br>at命令用来安排一个程序在未来的做一次一次性执行。所有提交的任务都被放在 /var/spool/at 目录下并且到了执行时间的时候通过atd守护进程来执行。</li>
<li>linux中lspci命令的作用是什么？<br>lspci命令用来显示你的系统上PCI总线和附加设备的信息。</li>
<li>export PS1 = <code>$LOGNAME@hostname:\$PWD:</code> 这条命令是在做什么？<br>这条export命令会更改登录提示符来显示用户名、本机名和当前工作目录。</li>
<li>CSSViewer<br>它有一个浮动面板，上面不但指明鼠标所在之地的身份，还提供其字体、文本、颜色、背景、框、定位和效果属性的说明。 CSSViewer可以快速提供你所需要的基本CSS信息。</li>
<li>Vim 会记录文件的更改，你很容易可以回退到之前某个时间。该命令是相当直观的。比如： :earlier 1m<br>会把文件回退到 1 分钟以前的状态。<br>可以使用下面的命令进行相反的转换：:later</li>
<li>ls <em>[0-9]</em> 显示包含数字的文件名和目录名</li>
<li>tree 显示文件和目录由根目录开始的树形结构(1)<br>lstree 显示文件和目录由根目录开始的树形结构(2)</li>
<li>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录</li>
<li>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接</li>
</ol>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径</p>
<ol>
<li>useradd -s /bin/sh -d /usr/gem -g group –G adm,root gem<br>新建了一个用户gem，该用户的登录Shell是/bin/sh，它属于group用户组，同时又属于adm和root用户组，group用户组是其主组</li>
<li>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下</li>
<li>tar -zcvf archive.tar.gz dir1 创建一个gzip格式的压缩包</li>
<li>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS</li>
<li>文本处理<br>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT</li>
</ol>
<p>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中</p>
<p>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”</p>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘/ <em>#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ </em>$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00*/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分<br>22.<br>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址</p>
<h2 id="UML-skill"><a href="#UML-skill" class="headerlink" title="UML skill"></a>UML skill</h2><p>开发模型： 瀑布模型 螺线模型  增量模型<br>黑盒测试：考虑程序的功能，而不是实际代码<br>百合测试：通过程序代码来设计测试数据，使测试数据能很好覆盖语句及执行路径<br>泛化绘制为从孩子指向双亲的空三角箭头<br>泛化使多态操作成为可能，即操作的实现方法由实际对象的类来决定<br>内部类可以看成是服务类的特殊形式，即类可以服务包含它的外部类，内部类作为外部类的一部分，可以提取器外部类的私有属性<br>如果多个活动者之间存在很多共性，就可以使用泛化来分解共性行为。<br>与包含关系不同，在扩展关系中，箭头的方向是从扩展用例到基用例。<br>通过多态，一个通用接口可以实现不同的行为特征<br>关联用一条无线线段表示，代表一种双向关系</p>
<h2 id="vim-skill"><a href="#vim-skill" class="headerlink" title="vim skill"></a>vim skill</h2><p>U可以撤销一行的改变<br>u命令和ctrl-R来撤销和重做<br>w 2w  b 2b  向前或者向后移动word个长度   e 到达当前单词的末尾<br>fx 在当前航搜寻字符<br>%匹配跳转<br>/the> 匹配以the结尾的单词  /\<the 匹配以the开头的单词="" \<the\="">匹配the<br>set incsearch 在输入时开始搜索<br>3dw 3次删除word   d3w 删除3个word<br>f&lt; 找到第一个&lt;    df&lt; 删除到&lt;   .重复之前的操作<br>four -&gt;&gt; five    /four  cwfive  n .  n .<br>ye y$复制到尾部<br>diw 删除光标所在的单词<br>set filetype 检测语言类型<br>多次匹配 ： /a<em>  匹配 a aa aaa…<br>/(ab)</em><br>/ab+<br>/folder\=<br>/a.*b<br>/foo|bar<br>/one|two|three</the></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[程序员八荣八耻]]></title>
      <url>https://fudawei.github.io/2015/09/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%AB%E8%8D%A3%E5%85%AB%E8%80%BB/</url>
      <content type="html"><![CDATA[<p>以动手实践为荣，以只看不练为耻。<br>以打印日志为荣，以出错不报为耻。<br>以局部变量为荣，以全局变量为耻。<br>以单元测试为荣，以手工测试为耻。<br>以代码重用为荣，以复制粘贴为耻。<br>以多态应用为荣，以分支判断为耻。<br>以定义常量为荣，以魔法数字为耻。<br>以总结思考为荣，以不求甚解为耻。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[日志处理]log4j配置详解]]></title>
      <url>https://fudawei.github.io/2015/08/31/%5B%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86%5Dlog4j%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Log4j有三个主要的组件：Loggers(记录器)，Appenders (输出源)和Layouts(布局)。这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出。综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置。</p>
<a id="more"></a>
<h2 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h2><p>Loggers组件被分为五个级别：</p>
<ul>
<li>DEBUG</li>
<li>INFO</li>
<li>WARN</li>
<li>ERROR</li>
<li>FATAL  </li>
</ul>
<p>各个级别的顺序是这样那个的：</p>
<blockquote>
<p><strong>DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</strong></p>
</blockquote>
<p>可以简单地理解为级别越大越重要。<br>Log4j有一个规则：只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。</p>
<h2 id="Appender"><a href="#Appender" class="headerlink" title="Appender"></a>Appender</h2><p>Appender用来规定日志输出的目的地是哪里，可以是控制台，文件，数据库等等。<br>常见的Appender有以下几种：</p>
<ul>
<li>org.apache.log4j.ConsoleAppender（控制台）</li>
<li>org.apache.log4j.FileAppender（文件）</li>
<li>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</li>
<li>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</li>
<li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li>
</ul>
<p>在配置文件中是这样配置的：</p>
<blockquote>
<p>log4j.appender.appenderName = className<br>log4j.appender.appenderName.Option1 = value1<br>…<br>log4j.appender.appenderName.OptionN = valueN  </p>
</blockquote>
<p>其中appenderName是Appender的名字，可以随意起，只要满足命名规范就行，Option1，Option2，…，OptionN是这个appender的各种属性。</p>
<h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><p>Layout用来规定日志是以什么样的格式输出，需要输出哪些信息。Layout提供四种日志输出样式，如根据HTML样式、自由指定样式、包含日志级别与信息的样式和包含日志时间、线程、类别等信息的样式。<br>常见的Layout如下：</p>
<ul>
<li>org.apache.log4j.HTMLLayout（以HTML表格形式布局）</li>
<li>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</li>
<li>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</li>
<li>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）</li>
</ul>
<p>在配置文件中这样配置的：</p>
<blockquote>
<p>log4j.appender.appenderName.layout =className<br>log4j.appender.appenderName.layout.Option1 = value1<br>…<br>log4j.appender.appenderName.layout.OptionN = valueN  </p>
</blockquote>
<p>含义和Appender的配置是一样的，就不另作解释了。</p>
<h2 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h2><p>在实际应用中，要使Log4j在系统中运行须事先设定配置文件。配置文件事实上也就是对Logger、Appender及Layout进行相应设定。 Log4j支持两种配置文件格式，一种是XML格式的文件，一种是properties属性文件。下面以properties属性文件为例介绍。</p>
<h3 id="配置Logger"><a href="#配置Logger" class="headerlink" title="配置Logger"></a>配置Logger</h3><blockquote>
<p>log4j.rootLogger = [ level ] , appenderName1, appenderName2, …<br>log4j.additivity.org.apache=false # 表示Logger不会在父Logger的appender里输出，默认为true。  </p>
</blockquote>
<p><strong>level</strong> ：设定日志记录的最低级别，可设的值有OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别，Log4j建议只使用中间四个级别。通过在这里设定级别，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO级别，则应用程序中所有DEBUG级别的日志信息将不会被打印出来。<br><strong>appenderName</strong>：就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。<br>例如：log4j.rootLogger＝INFO,A1,B2,C3</p>
<h3 id="配置Appender"><a href="#配置Appender" class="headerlink" title="配置Appender"></a>配置Appender</h3><blockquote>
<p>log4j.appender.appenderName = className</p>
</blockquote>
<p><strong>appenderName</strong>: Appender的名字，自定义，在log4j.rootLogger设置中使用；<br><strong>className</strong>：Appender的类的全名（包含包名），常用的Appender的className如下：</p>
<ul>
<li>org.apache.log4j.ConsoleAppender（控制台）</li>
<li>org.apache.log4j.FileAppender（文件）</li>
<li>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</li>
<li>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</li>
<li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li>
</ul>
<h4 id="ConsoleAppender的选项"><a href="#ConsoleAppender的选项" class="headerlink" title="ConsoleAppender的选项"></a>ConsoleAppender的选项</h4><ul>
<li><strong>Threshold</strong>=WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>
<li><strong>ImmediateFlush</strong>=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>
<li><strong>Target</strong>=System.err：默认值是System.out。</li>
</ul>
<h4 id="FileAppender选项"><a href="#FileAppender选项" class="headerlink" title="FileAppender选项"></a>FileAppender选项</h4><ul>
<li><strong>Threshold</strong>=WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>
<li><strong>ImmediateFlush</strong>=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>
<li><strong>Append</strong>=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</li>
<li><strong>File</strong>=D:/logs/logging.log4j：指定消息输出到logging.log4j文件中</li>
</ul>
<h4 id="DailyRollingFileAppender选项"><a href="#DailyRollingFileAppender选项" class="headerlink" title="DailyRollingFileAppender选项"></a>DailyRollingFileAppender选项</h4><ul>
<li><strong>Threshold</strong>=WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>
<li><strong>ImmediateFlush</strong>=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>
<li><strong>Append</strong>=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</li>
<li><strong>File</strong>=D:/logs/logging.log4j：指定当前消息输出到logging.log4j文件中。</li>
<li><strong>DatePattern</strong>=’.’yyyy-MM：每月滚动一次日志文件，即每月产生一个新的日志文件。当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。<br>另外，也可以指定按周、天、时、分等来滚动日志文件，对应的格式如下：<ul>
<li>‘.’yyyy-MM：每月</li>
<li>‘.’yyyy-ww：每周</li>
<li>‘.’yyyy-MM-dd：每天</li>
<li>‘.’yyyy-MM-dd-a：每天两次</li>
<li>‘.’yyyy-MM-dd-HH：每小时</li>
<li>‘.’yyyy-MM-dd-HH-mm：每分钟</li>
</ul>
</li>
</ul>
<h4 id="RollingFileAppender选项"><a href="#RollingFileAppender选项" class="headerlink" title="RollingFileAppender选项"></a>RollingFileAppender选项</h4><ul>
<li><strong>Threshold</strong>=WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>
<li><strong>ImmediateFlush</strong>=true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>
<li><strong>Append</strong>=false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</li>
<li><strong>File</strong>=D:/logs/logging.log4j：指定消息输出到logging.log4j文件中。</li>
<li><strong>MaxFileSize=100KB：后缀可以是</strong>KB, MB 或者GB**。在日志文件到达该大小时，将会自动滚动，即将原来的内容移到logging.log4j.1文件中。</li>
<li><strong>MaxBackupIndex</strong>=2：指定可以产生的滚动文件的最大数，例如，设为2则可以产生logging.log4j.1，logging.log4j.2两个滚动文件和一个logging.log4j文件。</li>
</ul>
<h3 id="配置Layout"><a href="#配置Layout" class="headerlink" title="配置Layout"></a>配置Layout</h3><blockquote>
<p>log4j.appender.appenderName.layout=className</p>
</blockquote>
<p>常见的className如下：</p>
<ul>
<li>org.apache.log4j.HTMLLayout（以HTML表格形式布局）</li>
<li>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</li>
<li>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</li>
<li>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</li>
</ul>
<h4 id="HTMLLayout选项"><a href="#HTMLLayout选项" class="headerlink" title="HTMLLayout选项"></a>HTMLLayout选项</h4><ul>
<li><strong>LocationInfo</strong>=true：输出java文件名称和行号，默认值是false。</li>
<li><strong>Title</strong>=My Logging： 默认值是Log4J Log Messages。</li>
</ul>
<h4 id="PatternLayout选项"><a href="#PatternLayout选项" class="headerlink" title="PatternLayout选项"></a>PatternLayout选项</h4><ul>
<li><strong>ConversionPattern</strong>=%m%n：设定以怎样的格式显示消息。</li>
</ul>
<p>各种格式化说明如下：</p>
<ol>
<li>%p：输出日志信息的优先级，即DEBUG，INFO，WARN，ERROR，FATAL。</li>
<li>%d：输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，如：%d{yyyy/MM/dd HH:mm:ss,SSS}。</li>
<li>%r：输出自应用程序启动到输出该log信息耗费的毫秒数。</li>
<li>%t：输出产生该日志事件的线程名。</li>
<li>%l：输出日志事件的发生位置，相当于%c.%M(%F:%L)的组合，包括类全名、方法、文件名以及在代码中的行数。例如：test.TestLog4j.main(TestLog4j.java:10)。</li>
<li>%c：输出日志信息所属的类目，通常就是所在类的全名。</li>
<li>%M：输出产生日志信息的方法名。</li>
<li>%F：输出日志消息产生时所在的文件名称。</li>
<li>%L:：输出代码中的行号。</li>
<li>%m:：输出代码中指定的具体日志信息。</li>
<li>%n：输出一个回车换行符，Windows平台为”\r\n”，Unix平台为”\n”。</li>
<li>%x：输出和当前线程相关联的NDC(嵌套诊断环境)，尤其用到像java servlets这样的多客户多线程的应用中。</li>
<li>%%：输出一个”%”字符。</li>
</ol>
<p>另外，还可以在%与格式字符之间加上修饰符来控制其最小长度、最大长度、和文本的对齐方式。如：</p>
<ul>
<li>c：指定输出category的名称，最小的长度是20，如果category的名称长度小于20的话，默认的情况下右对齐。</li>
<li>%-20c：”-“号表示左对齐。</li>
<li>%.30c：指定输出category的名称，最大的长度是30，如果category的名称长度大于30的话，就会将左边多出的字符截掉，但小于30的话也不会补空格。</li>
</ul>
<h2 id="log4j的默认配置"><a href="#log4j的默认配置" class="headerlink" title="log4j的默认配置"></a>log4j的默认配置</h2><p>log4j配置支持xml和properties两种格式的文件，默认先在程序的classpath目录下检查是否有log4j.xml文件，如果没有再出招log4j.properties文件。<br>log4j的包中的LogManager类在加载的时候有个静态代码块是这样写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">static &#123;</div><div class="line">    // By default we use a DefaultRepositorySelector which always returns &apos;h&apos;.</div><div class="line">    Hierarchy h = new Hierarchy(new RootLogger((Level) Level.DEBUG));</div><div class="line">    repositorySelector = new DefaultRepositorySelector(h);</div><div class="line"></div><div class="line">    /** Search for the properties file log4j.properties in the CLASSPATH.  */</div><div class="line">    String override =OptionConverter.getSystemProperty(DEFAULT_INIT_OVERRIDE_KEY,</div><div class="line">                               null);</div><div class="line"></div><div class="line">    // if there is no default init override, then get the resource</div><div class="line">    // specified by the user or the default config file.</div><div class="line">    if(override == null || &quot;false&quot;.equalsIgnoreCase(override)) &#123;</div><div class="line"></div><div class="line">      String configurationOptionStr = OptionConverter.getSystemProperty(</div><div class="line">                              DEFAULT_CONFIGURATION_KEY, </div><div class="line">                              null);</div><div class="line"></div><div class="line">      String configuratorClassName = OptionConverter.getSystemProperty(</div><div class="line">                                                   CONFIGURATOR_CLASS_KEY, </div><div class="line">                           null);</div><div class="line"></div><div class="line">      URL url = null;</div><div class="line"></div><div class="line">      // if the user has not specified the log4j.configuration</div><div class="line">      // property, we search first for the file &quot;log4j.xml&quot; and then</div><div class="line">      // &quot;log4j.properties&quot;</div><div class="line">      if(configurationOptionStr == null) &#123;  </div><div class="line">    url = Loader.getResource(DEFAULT_XML_CONFIGURATION_FILE);</div><div class="line">    if(url == null) &#123;</div><div class="line">      url = Loader.getResource(DEFAULT_CONFIGURATION_FILE);</div><div class="line">    &#125;</div><div class="line">      &#125; else &#123;</div><div class="line">    try &#123;</div><div class="line">      url = new URL(configurationOptionStr);</div><div class="line">    &#125; catch (MalformedURLException ex) &#123;</div><div class="line">      // so, resource is not a URL:</div><div class="line">      // attempt to get the resource from the class path</div><div class="line">      url = Loader.getResource(configurationOptionStr); </div><div class="line">    &#125;   </div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      // If we have a non-null url, then delegate the rest of the</div><div class="line">      // configuration to the OptionConverter.selectAndConfigure</div><div class="line">      // method.</div><div class="line">      if(url != null) &#123;</div><div class="line">    LogLog.debug(&quot;Using URL [&quot;+url+&quot;] for automatic log4j configuration.&quot;);      </div><div class="line">    OptionConverter.selectAndConfigure(url, configuratorClassName, </div><div class="line">                       LogManager.getLoggerRepository());</div><div class="line">      &#125; else &#123;</div><div class="line">    LogLog.debug(&quot;Could not find resource: [&quot;+configurationOptionStr+&quot;].&quot;);</div><div class="line">      &#125;</div><div class="line">    &#125;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[slf4j的优势与使用原理]]></title>
      <url>https://fudawei.github.io/2015/08/26/slf4j%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>slf4j的全称是Simple Loging Facade For Java，即它仅仅是一个为Java程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如JDBC一样，只是一种规则而已。所以单独的slf4j是不能工作的，必须搭配其他具体的日志实现方案，比如apache的<strong>org.apache.log4j.Logger</strong>，jdk自带的<strong>java.util.logging.Logger</strong>等等。<br><a id="more"></a></p>
<h1 id="slf4j的优势"><a href="#slf4j的优势" class="headerlink" title="slf4j的优势"></a>slf4j的优势</h1><p>知道什么是slf4j之后我们应该明白为什么要使用slf4j，为什么不适用具体的日志实现方案。笔者理解，slf4j主要有以下几点优势：</p>
<h2 id="与客户端解耦"><a href="#与客户端解耦" class="headerlink" title="与客户端解耦"></a>与客户端解耦</h2><p>想象一下下面的场景：</p>
<blockquote>
<p>有一个别人写的很棒的类库，里面使用的是jdk自带的java.util.logging.Logger这个日志系统，现在你有一个程序需要用到这个类库，并且你自己的程序现在是使用apache的org.apache.log4j.Logger这个日志系统。那么问题来了，如果你的程序导入了这个类库，那么是不是必须两种日志系统都要支持，那么你是不是需要多配置一些东西，多维护一些东西？耗费了太多维护成本，你想死的心都有了吧？</p>
</blockquote>
<p>有问题就要有解决方案，不错，解决方案就是：<strong>使用slf4j</strong>。</p>
<p>slf4j只是一种接口，它本身并不关心你底层使用的是什么日志实现方案，所以它支持各种日志实现方案。简单的说，只要我们在类库中使用slf4j打日志，那么底层使用什么日志实现方案是使用者决定的，怎么决定？依靠配置文件和jar库。</p>
<h2 id="省内存"><a href="#省内存" class="headerlink" title="省内存"></a>省内存</h2><p>如果大家之前使用过log4j，那么一定基本都是这样用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package com.winwill.test;</div><div class="line"></div><div class="line">import org.apache.log4j.Logger;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/8/26 21:54</div><div class="line"> */</div><div class="line">public class TestLog4j &#123;</div><div class="line">    private static final Logger LOGGER = Logger.getLogger(TestLog4j.class);</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String message = &quot;Hello World.&quot;;</div><div class="line">        LOGGER.info(&quot;This is a test message: &quot; + message);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到log4j的info函数有两种使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void info(Object message)</div><div class="line">public void info(Object message, Throwable t)</div></pre></td></tr></table></figure>
<p>第一个参数是要输出的信息，假设要输出的是一个字符串，并且字符串中包含变量，则message参数就必须使用字符串相加操作，就比如上面测试代码的14行一样。姑且不说字符串相加是一个比较消耗性能的操作，字符串是一个不可变对象，一旦创建就不能被修改，创建的字符串会保存在String池中，占用内存。更糟糕的是如果配置文件中配置的日志级别是ERROR的话，这行info日志根本不会输出，则相加得到的字符串对象是一个非必须对象，白白浪费了内存空间。有人会说了，那我可以这样写啊：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.winwill.test;</div><div class="line"></div><div class="line">import org.apache.log4j.Logger;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/8/26 21:54</div><div class="line"> */</div><div class="line">public class TestLog4j &#123;</div><div class="line">    private static final Logger LOGGER = Logger.getLogger(TestLog4j.class);</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String message = &quot;Hello World.&quot;;</div><div class="line">        if (LOGGER.isInfoEnabled()) &#123;</div><div class="line">            LOGGER.info(&quot;This is a test message: &quot; + message);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样不就解决了白白浪费内存的问题了吗？没错，这是一个变通方案，但是这样的代码太繁琐，不直观！</p>
<p>再来看看slf4j的打日志的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.winwill.test;</div><div class="line"></div><div class="line"></div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/8/26 21:54</div><div class="line"> */</div><div class="line">public class TestLog4j &#123;</div><div class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(TestLog4j.class);</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String message = &quot;Hello World.&quot;;</div><div class="line">        LOGGER.info(&quot;This is a test message: &#123;&#125;&quot;, message);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到没有，打日志的时候使用了{}占位符，这样就不会有字符串拼接操作，减少了无用String对象的数量，节省了内存。并且，记住，在生产最终日志信息的字符串之前，这个方法会检查一个特定的日志级别是不是打开了，这不仅降低了内存消耗而且预先降低了CPU去处理字符串连接命令的时间。这里是使用SLF4J日志方法的代码，来自于slf4j-log4j12-1.6.1.jar中的Log4j的适配器类Log4jLoggerAdapter。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void debug(String format, Object arg1, Object arg2) &#123;</div><div class="line">    if (logger.isDebugEnabled()) &#123;</div><div class="line">        FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);</div><div class="line">        logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="slf4j的使用与绑定原理"><a href="#slf4j的使用与绑定原理" class="headerlink" title="slf4j的使用与绑定原理"></a>slf4j的使用与绑定原理</h1><p>前面介绍了slf4j的优势，本节介绍怎么使用slf4j以及其中的原理，前文说到了，单独的slf4j是不能工作的，必须带上其他具体的日志实现方案。就以apache的log4j作为具体日志实现方案为例，如果在工程中要使用slf4j作为接口，并且要用log4j作为具体实现方案，那么我们需要做的事情如下：（下面的xxx表示具体版本号）</p>
<ul>
<li>将slf4j-api-xxx.jar加入工程classpath中；</li>
<li>将slf4j-log4jxx-xxx.jar加入工程classpath中；</li>
<li>将log4j-xxx.jar加入工程classpath中；</li>
<li>将log4j.properties（log4j.xml）文件加入工程classpath中。</li>
</ul>
<p>介绍一下工作原理：</p>
<p>首先，slf4j-api作为slf4j的接口类，使用在程序代码中，这个包提供了一个Logger类和LoggerFactory类，Logger类用来打日志，LoggerFactory类用来获取Logger；slf4j-log4j是连接slf4j和log4j的桥梁，怎么连接的呢？我们看看slf4j的LoggerFactory类的getLogger函数的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Return a logger named corresponding to the class passed as parameter, using</div><div class="line"> * the statically bound &#123;@link ILoggerFactory&#125; instance.</div><div class="line"> *</div><div class="line"> * @param clazz the returned logger will be named after clazz</div><div class="line"> * @return logger</div><div class="line"> */</div><div class="line">public static Logger getLogger(Class clazz) &#123;</div><div class="line">  return getLogger(clazz.getName());</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * Return a logger named according to the name parameter using the statically</div><div class="line"> * bound &#123;@link ILoggerFactory&#125; instance.</div><div class="line"> *</div><div class="line"> * @param name The name of the logger.</div><div class="line"> * @return logger</div><div class="line"> */</div><div class="line">public static Logger getLogger(String name) &#123;</div><div class="line">  ILoggerFactory iLoggerFactory = getILoggerFactory();</div><div class="line">  return iLoggerFactory.getLogger(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">  public static ILoggerFactory getILoggerFactory() &#123;</div><div class="line">  if (INITIALIZATION_STATE == UNINITIALIZED) &#123;</div><div class="line">    INITIALIZATION_STATE = ONGOING_INITIALIZATION;</div><div class="line">    performInitialization();</div><div class="line">  &#125;</div><div class="line">  switch (INITIALIZATION_STATE) &#123;</div><div class="line">    case SUCCESSFUL_INITIALIZATION:</div><div class="line">      return StaticLoggerBinder.getSingleton().getLoggerFactory();</div><div class="line">    case NOP_FALLBACK_INITIALIZATION:</div><div class="line">      return NOP_FALLBACK_FACTORY;</div><div class="line">    case FAILED_INITIALIZATION:</div><div class="line">      throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);</div><div class="line">    case ONGOING_INITIALIZATION:</div><div class="line">      // support re-entrant behavior.</div><div class="line">      // See also http://bugzilla.slf4j.org/show_bug.cgi?id=106</div><div class="line">      return TEMP_FACTORY;</div><div class="line">  &#125;</div><div class="line">  throw new IllegalStateException(&quot;Unreachable code&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>追踪到最后，发现LoggerFactory.getLogger()首先获取一个ILoggerFactory接口，然后使用该接口获取具体的Logger。获取ILoggerFactory的时候用到了一个StaticLoggerBinder类，仔细研究我们会发现StaticLoggerBinder这个类并不是slf4j-api这个包中的类，而是slf4j-log4j包中的类，这个类就是一个中间类，它用来将抽象的slf4j变成具体的log4j，也就是说具体要使用什么样的日志实现方案，就得靠这个StaticLoggerBinder类。再看看slf4j-log4j包种的这个StaticLoggerBinder类创建ILoggerFactory长什么样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private final ILoggerFactory loggerFactory;</div><div class="line"></div><div class="line">private StaticLoggerBinder() &#123;</div><div class="line">  loggerFactory = new Log4jLoggerFactory();</div><div class="line">  try &#123;</div><div class="line">    Level level = Level.TRACE;</div><div class="line">  &#125; catch (NoSuchFieldError nsfe) &#123;</div><div class="line">    Util</div><div class="line">        .report(&quot;This version of SLF4J requires log4j version 1.2.12 or later. See also http://www.slf4j.org/codes.html#log4j_version&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ILoggerFactory getLoggerFactory() &#123;</div><div class="line">  return loggerFactory;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到slf4j-log4j中的StaticLoggerBinder类创建的ILoggerFactory其实是一个<strong>org.slf4j.impl.Log4jLoggerFactory</strong>，这个类的getLogger函数是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public Logger getLogger(String name) &#123;</div><div class="line">  Logger slf4jLogger = loggerMap.get(name);</div><div class="line">  if (slf4jLogger != null) &#123;</div><div class="line">    return slf4jLogger;</div><div class="line">  &#125; else &#123;</div><div class="line">    org.apache.log4j.Logger log4jLogger;</div><div class="line">    if(name.equalsIgnoreCase(Logger.ROOT_LOGGER_NAME))</div><div class="line">      log4jLogger = LogManager.getRootLogger();</div><div class="line">    else</div><div class="line">      log4jLogger = LogManager.getLogger(name);</div><div class="line"></div><div class="line">    Logger newInstance = new Log4jLoggerAdapter(log4jLogger);</div><div class="line">    Logger oldInstance = loggerMap.putIfAbsent(name, newInstance);</div><div class="line">    return oldInstance == null ? newInstance : oldInstance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就在其中创建了真正的<strong>org.apache.log4j.Logger</strong>，也就是我们需要的具体的日志实现方案的Logger类。就这样，整个绑定过程就完成了，没晕吧？log4j.properties(log4j.xml)的具体配置下一篇文章会详细介绍。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[代码战争]]></title>
      <url>https://fudawei.github.io/2015/08/13/%E4%BB%A3%E7%A0%81%E6%88%98%E4%BA%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一天我路过一座桥，碰巧看见一个人想跳河自杀。我跑过去对他大喊道：“别跳，别死啊。”<br>“为什么不让我跳？”他说。<br><a id="more"></a><br>“因为还有很多东西值得我们活下去啊。”<br>“有吗？比如说？”<br>“呃……你做什么工作？”<br>“程序员。”<br>“我也是！瞧，有共同点了吧。你是软件还是硬件？”<br>“软件。”<br>“我也是！PC 还是 Web？”<br>“PC。”<br>“我也是！Windows 还是 Linux 平台？”<br>“Linux。”<br>“我也是！那你使用 C 还是 C++？”<br>“C++。”<br>“我也是。1998 年的 C++ 98 还是 2011 年的 C++ 11？”<br>“2011 年的 C++ 11。”<br>“我也是。大括号写在后面还是写在下一行？”<br>“下一行。”<br>“去死吧！你这个异教徒人渣！”我一把将他推下桥去。</p>
</blockquote>
<p>以上段子来源于<a href="http://www.zhihu.com/question/33490847#answer-18353949" target="_blank" rel="external">知乎</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JDK工具学习七]jcmd命令使用]]></title>
      <url>https://fudawei.github.io/2015/08/01/%5BJDK%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E4%B8%83%5Djcmd%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在JDK 1.7之后，新增了一个命令行工具jcmd。它是一个多功能工具，可以用来导出堆，查看java进程，导出线程信息，执行GC等。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>下面这个命令能够列出当前运行的所有虚拟机：<br><a id="more"></a><br><img src="http://img.blog.csdn.net/20150604171002087" alt="这里写图片描述"></p>
<p>参数-l表示列出所有java虚拟机，针对每一个虚拟机，可以使用help命令列出该虚拟机支持的所有命令，如下图所示，以21024这个进程为例：</p>
<p><img src="http://img.blog.csdn.net/20150604171153752" alt="这里写图片描述"></p>
<h3 id="查看虚拟机启动时间VM-uptime"><a href="#查看虚拟机启动时间VM-uptime" class="headerlink" title="查看虚拟机启动时间VM.uptime"></a>查看虚拟机启动时间VM.uptime</h3><p><img src="http://img.blog.csdn.net/20150604171358740" alt="这里写图片描述"></p>
<h3 id="打印线程栈信息Thread-print"><a href="#打印线程栈信息Thread-print" class="headerlink" title="打印线程栈信息Thread.print"></a>打印线程栈信息Thread.print</h3><p><img src="http://img.blog.csdn.net/20150604171538533" alt="这里写图片描述"></p>
<h3 id="查看系统中类统计信息GC-class-histogram"><a href="#查看系统中类统计信息GC-class-histogram" class="headerlink" title="查看系统中类统计信息GC.class_histogram"></a>查看系统中类统计信息GC.class_histogram</h3><p>执行如下命令：</p>
<blockquote>
<p>[qifuguang@Mac~]$ jcmd 21024 GC.class_histogram</p>
</blockquote>
<p>得到结果如下：<br><img src="http://img.blog.csdn.net/20150604172039832" alt="这里写图片描述"></p>
<h3 id="导出堆信息GC-heap-dump"><a href="#导出堆信息GC-heap-dump" class="headerlink" title="导出堆信息GC.heap_dump"></a>导出堆信息GC.heap_dump</h3><p>使用如下命令可以导出当前堆栈信息，这个命令功能和 <a href="http://blog.csdn.net/飞鸟/article/details/46337339" target="_blank" rel="external">jmap -dump</a><br>功能一样</p>
<p><img src="http://img.blog.csdn.net/20150604172154322" alt="这里写图片描述"></p>
<h3 id="获取系统Properties内容VM-system-properties"><a href="#获取系统Properties内容VM-system-properties" class="headerlink" title="获取系统Properties内容VM.system_properties"></a>获取系统Properties内容VM.system_properties</h3><p><img src="http://img.blog.csdn.net/20150604172452662" alt="这里写图片描述"></p>
<h3 id="获取启动参数VM-flags"><a href="#获取启动参数VM-flags" class="headerlink" title="获取启动参数VM.flags"></a>获取启动参数VM.flags</h3><p><img src="http://img.blog.csdn.net/20150604172713990" alt="这里写图片描述"></p>
<h3 id="获取所有性能相关数据PerfCounter-print"><a href="#获取所有性能相关数据PerfCounter-print" class="headerlink" title="获取所有性能相关数据PerfCounter.print"></a>获取所有性能相关数据PerfCounter.print</h3><p><img src="http://img.blog.csdn.net/20150604172655777" alt="这里写图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从以上示例可以看出，jcmd拥有jmap的大部分功能，并且Oracle官方也建议使用jcmd代替jmap。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JDK工具学习六]jstack命令使用]]></title>
      <url>https://fudawei.github.io/2015/08/01/%5BJDK%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E5%85%AD%5Djstack%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>jstack可用于导出java运用程序的线程堆栈，其基本使用语法为：</p>
<blockquote>
<p>jstack [-l] pid</p>
</blockquote>
<p>-l 选项用于打印锁的额外信息。<br><a id="more"></a></p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>下面这段代码运行之后会出现死锁现象(因为线程1持有lock1，在等待lock2，线程2持有lock2在等待lock1，造成了循环等待，形成死锁)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">package com.winwill.deadlock;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/6/4 16:45</div><div class="line"> */</div><div class="line">public class TestDeadLock &#123;</div><div class="line">    private static final Object lock1 = new Object();</div><div class="line">    private static final Object lock2 = new Object();</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        Thread t1 = new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (lock1) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(1000);</div><div class="line">                    &#125; catch (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    synchronized (lock2) &#123;</div><div class="line">                        System.out.println(&quot;线程1执行....&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread t2 = new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (lock2) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(1000);</div><div class="line">                    &#125; catch (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    synchronized (lock1) &#123;</div><div class="line">                        System.out.println(&quot;线程2执行...&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们运行这段代码，然后使用jstack命令导出这个程序的线程堆栈信息：</p>
<blockquote>
<p>[qifuguang@Mac~]$ jstack -l 21023 &gt; /tmp/deadlock.txt</p>
</blockquote>
<p>打开导出的线程堆栈信息文件，文件末尾如下所示：</p>
<p><img src="http://img.blog.csdn.net/20150604165946198" alt="这里写图片描述"></p>
<p>如图所示，导出的线程堆栈文件中明确提示发现死锁，并且指明了死锁的原因。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>jstack不仅能够导出线程堆栈，还能自动进行死锁检测，输出线程死锁原因。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JDK工具学习五]jhat命令使用]]></title>
      <url>https://fudawei.github.io/2015/08/01/%5BJDK%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E4%BA%94%5Djhat%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>jhat(Java Head Analyse Tool)是jdk自带的用来分析java堆快照的工具，具体的使用方法是：</p>
<blockquote>
<p>jhat dump_file_name<br><a id="more"></a></p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>在此以<a href="http://blog.csdn.net/飞鸟/article/details/46337339" target="_blank" rel="external">前文</a>dump出来的文件（dump.bin）为例，演示怎么使用jhat分析堆文件。<br><img src="http://img.blog.csdn.net/20150602234741933" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20150602234954912" alt="这里写图片描述"></p>
</blockquote>
<p>上图中使用jhat命令打开了之前dump出来的堆快照文件，可以看到，命令成功执行后会在命令执行的本机启动一个http服务，可以在浏览器上打开本机的7000端口查看详细的分析结果：</p>
<p><img src="http://img.blog.csdn.net/20150602235100896" alt="这里写图片描述"></p>
<p>页面中显示了所有非平台类信息，点击链接进入，可以查看选中的类的超类，ClassLoader以及该类的实例等信息。此外，在页面的地步，jhat还为开发人员提供了其他查询方式。如图所示：</p>
<p><img src="http://img.blog.csdn.net/20150602235508379" alt="这里写图片描述"></p>
<p>通过这些链接，开发人员可以查看所有类信息（包含java平台的类），所有根节点，finalizer对象等等信息。最后提供了OQL查询工具，开发人员可以输入OQL语言查询相应的类。关于OQL，笔者就不过多介绍，想了解更多的可以点击<a href="http://su1216.iteye.com/blog/1535776" target="_blank" rel="external">这里</a>了解。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JDK工具学习四]jmap命令使用]]></title>
      <url>https://fudawei.github.io/2015/08/01/%5BJDK%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E5%9B%9B%5Djmap%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>jmap是一个多功能的命令。它可以生成java程序的堆dump文件，也可以查看堆内对象实例的统计信息，查看ClassLoader的信息以及Finalizer队列。<br><a id="more"></a></p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="导出对象统计信息"><a href="#导出对象统计信息" class="headerlink" title="导出对象统计信息"></a>导出对象统计信息</h3><p>下面的命令生成PID为2500的java成粗的对象的统计信息，并输出到out.txt文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ jmap -histo 2500 &gt; out.txt</div><div class="line">[qifuguang@winwill~]$</div><div class="line">[qifuguang@winwill~]$</div><div class="line">[qifuguang@winwill~]$</div><div class="line">[qifuguang@winwill~]$</div><div class="line">[qifuguang@winwill~]$</div></pre></td></tr></table></figure></p>
<p>生成的文件如下：<br><img src="http://img.blog.csdn.net/20150602231204933" alt="这里写图片描述"><br>从文件中可以看到，统计信息显示了内存中实例的数量和合计。</p>
<h3 id="导出程序堆快照"><a href="#导出程序堆快照" class="headerlink" title="导出程序堆快照"></a>导出程序堆快照</h3><p>下面的命令导出PID为2500的java程序当前的堆快照：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[qifuguang@winwill~]$ jmap -dump:format=b,file=dump.bin 2500</div><div class="line">Dumping heap to /home/qifuguang/dump.bin ...</div><div class="line">Heap dump file created</div></pre></td></tr></table></figure></p>
<p>该命令成功地将运用程序的当前的堆快照导出到了dump.bin文件，之后可以使用Visual VM，MAT等工具分析对快照文件。</p>
<h3 id="查看Finalizer队列"><a href="#查看Finalizer队列" class="headerlink" title="查看Finalizer队列"></a>查看Finalizer队列</h3><p>下面的命令查看虚拟机Finalizer队列的信息：<br><img src="http://img.blog.csdn.net/20150602233132638" alt="这里写图片描述"><br>从图中可以看到，队列中堆积了大量的TestFinalizer$LY对象实例，还有其他一些对象。</p>
<h3 id="查看ClassLoader信息"><a href="#查看ClassLoader信息" class="headerlink" title="查看ClassLoader信息"></a>查看ClassLoader信息</h3><p>下面的命令显示了虚拟机当前的ClassLoader信息：<br><img src="http://img.blog.csdn.net/20150602233406536" alt="这里写图片描述"><br>从图中可以看到，当前虚拟机一共有3个ClassLoader，bootstrap加载了492个对象，对象总大小为943655byte，同时还显示了各个ClassLoader之间的父子关系。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JDK工具学习三]jinfo命令使用]]></title>
      <url>https://fudawei.github.io/2015/08/01/%5BJDK%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E4%B8%89%5Djinfo%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>jinfo可以用来查看正在运行的java运用程序的扩展参数，甚至支持在运行时动态地更改部分参数，他的基本使用语法如下：</p>
<blockquote>
<p>jinfo -&lt; option &gt; &lt; pid &gt;<br><a id="more"></a><br>其中option可以为以下信息：</p>
<ul>
<li>-flag&lt; name &gt;: 打印指定java虚拟机的参数值。</li>
<li>-flag [+|-]&lt; name &gt;：设置或取消指定java虚拟机参数的布尔值。</li>
<li>-flag &lt; name &gt;=&lt; value &gt;：设置指定java虚拟机的参数的值。</li>
</ul>
</blockquote>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><ol>
<li><p>下面的命令显示了新生代对象晋升到老年代对象的最大年龄。在运行程序运行时并没有指定这个参数，但是通过jinfo，可以查看这个参数的当前的值。<br> <img src="http://img.blog.csdn.net/20150602225904273" alt="这里写图片描述"></p>
</li>
<li><p>下面的命令显示是否打印gc详细信息：<br> <img src="http://img.blog.csdn.net/20150602230032273" alt="这里写图片描述"></p>
</li>
<li><p>下面的命令在运用程序运行时动态打开打印详细gc信息开关：<br> <img src="http://img.blog.csdn.net/20150602230121712" alt="这里写图片描述"></p>
</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>jinfo虽然可以在java程序运行时动态地修改虚拟机参数，但并不是所有的参数都支持动态修改。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JDK工具学习二]jstat命令使用]]></title>
      <url>https://fudawei.github.io/2015/08/01/%5BJDK%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E4%BA%8C%5Djstat%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>jstat是一个可以用于观察java应用程序运行时相关信息的工具，功能非常强大，可以通过它查看堆信息的详细情况。 </p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>jstat命令的基本使用语法如下：<br><a id="more"></a><br><strong>jstat -option [-t] [-h] pid [interval] [count]</strong></p>
<ul>
<li>选项option可以由以下值构成。<ul>
<li><strong>-class</strong>：显示ClassLoader的相关信息。</li>
<li><strong>-compiler</strong>：显示JIT编译的相关信息。</li>
<li><strong>-gc</strong>：显示与gc相关的堆信息。</li>
<li><strong>-gccapacity</strong>：显示各个代的容量及使用情况。</li>
<li><strong>-gccause</strong>：显示垃圾回收的相关信息（同-gcutil），同时显示最后一次或当前正在发生的垃圾回收的诱因。</li>
<li><strong>-gcnew</strong>：显示新生代信息。</li>
<li><strong>-gcnewcapacity</strong>：显示新生代大小与使用情况。</li>
<li><strong>-gcold</strong>：显示老生代和永久代的信息。</li>
<li><strong>-gcoldcapacity</strong>：显示老年代的大小。</li>
<li><strong>-gcpermcapacity</strong>：显示永久代的大小。</li>
<li><strong>-gcutil</strong>：显示垃圾收集信息。</li>
<li><strong>-printcompilation</strong>：输出JIT编译的方法信息。  </li>
</ul>
</li>
<li>-t参数可以在输出信息前面加上一个Timestamp列，显示程序运行的时间。</li>
<li>-h参数可以在周期性的数据输出时，输出多少行数据后，跟着输出一个表头信息。</li>
<li>interval参数用于指定输出统计数据的周期，单位为毫秒(ms)。</li>
<li>count参数用于指定一共输出多少次数据。</li>
</ul>
<h2 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h2><h3 id="class使用"><a href="#class使用" class="headerlink" title="-class使用"></a>-class使用</h3><p>下面命令输出pid为2500这个进程的ClassLoader相关信息，每秒统计一次信息，一共输出两次。<br><img src="http://img.blog.csdn.net/20150602003709009" alt="这里写图片描述"><br>Loaded表示载入的类的数量，第一个Bytes表示载入的类的合计大小，Unloaded表示卸载的类数量，第二个Bytes表示卸载的类的合计大小，Time表示加载和卸载类花的总的时间。</p>
<h3 id="compiler使用"><a href="#compiler使用" class="headerlink" title="-compiler使用"></a>-compiler使用</h3><p>下面的命令查看JIT编译的信息：<br><img src="http://img.blog.csdn.net/20150602004116925" alt="这里写图片描述"></p>
<p>Compiled表示编译任务执行的次数，Failed表示编译失败的次数，Invalid表示编译不可用的次数，Time表示编译的总耗时，FailedType表示最后一次编译的类型，FailedMethod表示最后一次编译失败的类名和方法名。</p>
<h3 id="gc使用"><a href="#gc使用" class="headerlink" title="-gc使用"></a>-gc使用</h3><p>下面的命令显示与gc相关的堆信息的输出：<br><img src="http://img.blog.csdn.net/20150602004613119" alt="这里写图片描述"></p>
<ul>
<li>S0C：s0(from)的大小(KB)</li>
<li>S1C：s1(from)的大小(KB)</li>
<li>S0U：s0(from)已使用的空间(KB)</li>
<li>S1U：s1(from)已经使用的空间(KB)</li>
<li>EC：eden区的大小(KB)</li>
<li>EU：eden区已经使用的空间(KB)</li>
<li>OC：老年代大小(KB)</li>
<li>OU：老年代已经使用的空间(KB)</li>
<li>PC：永久区大小(KB)</li>
<li>PU：永久区已经使用的空间(KB)</li>
<li>YGC：新生代gc次数</li>
<li>YGCT：新生代gc耗时</li>
<li>FGC：Full gc次数</li>
<li>FGCT：Full gc耗时</li>
<li>GCT：gc总耗时</li>
</ul>
<h3 id="gccapacity使用"><a href="#gccapacity使用" class="headerlink" title="-gccapacity使用"></a>-gccapacity使用</h3><p>下面的命令显示了各个代的信息，与-gc相比，它不仅输出了各个代的当前大小，还输出了各个代的最大值与最小值：<br><img src="http://img.blog.csdn.net/20150602005310719" alt="这里写图片描述"></p>
<ul>
<li>NGCMN：新生代最小值(KB)</li>
<li>NGCMX：新生代最大值(KB)</li>
<li>NGC：当前新生代大小(KB)</li>
<li>OGCMN：老年大最小值(KB)</li>
<li>OGCMX：老年代最大值(KB)</li>
<li>OGC：当前老年代大小(KB)</li>
<li>PGCMN：永久代最小值(KB)</li>
<li>PGCMX：永久代最大值(KB)</li>
</ul>
<h3 id="gccause使用"><a href="#gccause使用" class="headerlink" title="-gccause使用"></a>-gccause使用</h3><p>下面命令显示最近一次gc的原因，以及当前gc的原因：<br><img src="http://img.blog.csdn.net/20150602005843699" alt="这里写图片描述"></p>
<ul>
<li>LGCC：上次gc的原因，从图中可以看到上次gc的原因是Allocation Failure</li>
<li>GCC：当前gc的原因，图中当前没有gc</li>
</ul>
<h3 id="gcnew使用"><a href="#gcnew使用" class="headerlink" title="-gcnew使用"></a>-gcnew使用</h3><p>下面的命令显示新生代的详细信息:<br><img src="http://img.blog.csdn.net/20150602005922047" alt="这里写图片描述"></p>
<ul>
<li>TT：新生代对象晋升到老年代对象的年龄。</li>
<li>MTT：新生代对象晋升到老年代对象的年龄的最大值。</li>
<li>DSS：所需的Survivor区的大小。</li>
</ul>
<h3 id="gcnewcapacity使用"><a href="#gcnewcapacity使用" class="headerlink" title="-gcnewcapacity使用"></a>-gcnewcapacity使用</h3><p>下面的命令详细输出了新生代各个区的大小信息：<br><img src="http://img.blog.csdn.net/20150602010141932" alt="这里写图片描述"></p>
<ul>
<li>S0CMX：s0区的最大值(KB)</li>
<li>S1CMX：s1区的最大值(KB)</li>
<li>ECMX：eden区的最大值(KB)</li>
</ul>
<h3 id="gcold使用"><a href="#gcold使用" class="headerlink" title="-gcold使用"></a>-gcold使用</h3><p>下面的命令显示老年代gc概况：<br><img src="http://img.blog.csdn.net/20150602010345984" alt="这里写图片描述"></p>
<h3 id="gcoldcapacity使用"><a href="#gcoldcapacity使用" class="headerlink" title="-gcoldcapacity使用"></a>-gcoldcapacity使用</h3><p>下面的命令用于显示老年代的容量信息：<br><img src="http://img.blog.csdn.net/20150602010443688" alt="这里写图片描述"></p>
<h3 id="gcpermcapacity使用"><a href="#gcpermcapacity使用" class="headerlink" title="-gcpermcapacity使用"></a>-gcpermcapacity使用</h3><p>下面的命令用于显示永久区的使用情况：<br><img src="http://img.blog.csdn.net/20150602010716581" alt="这里写图片描述"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[JDK工具学习一]jps命令使用]]></title>
      <url>https://fudawei.github.io/2015/08/01/%5BJDK%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E4%B8%80%5Djps%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>jps命令类似于linux下的ps命令，用于列出当前正在运行的所有java进程。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>直接运行不加任何参数就能列出所有java进程的pid和类的短名称。例如：<br><a id="more"></a><br><img src="http://img.blog.csdn.net/20150602000405556" alt="这里写图片描述"></p>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><h4 id="q参数"><a href="#q参数" class="headerlink" title="-q参数"></a>-q参数</h4><p>-q可以指定jps只列出pid,而不输出类的短名称，例如：</p>
<p><img src="http://img.blog.csdn.net/20150602000630371" alt="这里写图片描述"></p>
<h4 id="m参数"><a href="#m参数" class="headerlink" title="-m参数"></a>-m参数</h4><p>-m参数可以用于列出传递给java进程主函数的参数，例如：</p>
<p><img src="http://img.blog.csdn.net/20150602000614119" alt="这里写图片描述"><br>这里可以看到传递给jps（jps本身也是java进程）进程的参数就是-m</p>
<h4 id="l参数"><a href="#l参数" class="headerlink" title="-l参数"></a>-l参数</h4><p>-l参数用于输出主类的完整路径，例如：</p>
<p><img src="http://img.blog.csdn.net/20150602000748827" alt="这里写图片描述"></p>
<h4 id="v参数"><a href="#v参数" class="headerlink" title="-v参数"></a>-v参数</h4><p>-v参数可以列出传递给java虚拟机的参数，例如：</p>
<p><img src="http://img.blog.csdn.net/20150602000948557" alt="这里写图片描述"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Java]直接内存和堆内存的性能比较]]></title>
      <url>https://fudawei.github.io/2015/08/01/%5BJava%5D%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><blockquote>
<p>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。<strong>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</strong><br>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。<br><a id="more"></a><br>上面这段话引用自<a href="http://book.51cto.com/art/201107/278886.htm" target="_blank" rel="external">该文章</a></p>
</blockquote>
<h2 id="代码实验"><a href="#代码实验" class="headerlink" title="代码实验"></a>代码实验</h2><p>注意到上面这段话中的黑体字：这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据，然而这个“一些场景”具体指什么呢？我们通过代码做个实验看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">package com.winwill.jvm;</div><div class="line"></div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">import java.nio.ByteBuffer;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15-5-26 下午8:23</div><div class="line"> */</div><div class="line">public class TestDirectMemory &#123;</div><div class="line">    /**</div><div class="line">     * 测试DirectMemory和Heap读写速度。</div><div class="line">     */</div><div class="line">    @Test</div><div class="line">    public void testDirectMemoryWriteAndReadSpeed() &#123;</div><div class="line">        long tsStart = System.currentTimeMillis();</div><div class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(400);</div><div class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</div><div class="line">            for (int j = 0; j &lt; 100; j++) &#123;</div><div class="line">                buffer.putInt(j);</div><div class="line">            &#125;</div><div class="line">            buffer.flip();</div><div class="line">            for (byte j = 0; j &lt; 100; j++) &#123;</div><div class="line">                buffer.getInt();</div><div class="line">            &#125;</div><div class="line">            buffer.clear();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;DirectMemory读写耗用： &quot; + (System.currentTimeMillis() - tsStart) + &quot; ms&quot;);</div><div class="line">        tsStart = System.currentTimeMillis();</div><div class="line">        buffer = ByteBuffer.allocate(400);</div><div class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</div><div class="line">            for (int j = 0; j &lt; 100; j++) &#123;</div><div class="line">                buffer.putInt(j);</div><div class="line">            &#125;</div><div class="line">            buffer.flip();</div><div class="line">            for (byte j = 0; j &lt; 100; j++) &#123;</div><div class="line">                buffer.getInt();</div><div class="line">            &#125;</div><div class="line">            buffer.clear();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;Heap读写耗用： &quot; + (System.currentTimeMillis() - tsStart) + &quot; ms&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 测试DirectMemory和Heap内存申请速度。</div><div class="line">     */</div><div class="line">    @Test</div><div class="line">    public void testDirectMemoryAllocate() &#123;</div><div class="line">        long tsStart = System.currentTimeMillis();</div><div class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</div><div class="line">            ByteBuffer buffer = ByteBuffer.allocateDirect(400);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;DirectMemory申请内存耗用： &quot; + (System.currentTimeMillis() - tsStart) + &quot; ms&quot;);</div><div class="line">        tsStart = System.currentTimeMillis();</div><div class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</div><div class="line">            ByteBuffer buffer = ByteBuffer.allocate(400);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;Heap申请内存耗用： &quot; + (System.currentTimeMillis() - tsStart) + &quot; ms&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行这段代码，得到的结果如下：<br><img src="http://img.blog.csdn.net/20150527134843409" alt="代码执行结果"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>从上面的实验结果可以看出，直接内存在读和写的性能都优于堆内内存，但是内存申请速度却不如堆内内存，所以可以归纳一下： <strong>直接内存适用于不常申请，但是需要频繁读取的场景，在需要频繁申请的场景下不应该使用直接内存(DirectMemory)，而应该使用堆内内存(HeapMemory)。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[类加载机制]]></title>
      <url>https://fudawei.github.io/2015/07/22/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ul>
<li>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。它们开始的顺序如下图所示：<br><br><br><center><img src="http://o99dg8ap9.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.jpg" alt=""></center><br><br></li>
<li><p>其中<strong>类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。</strong>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序<strong>开始</strong>，而不是按顺序<strong>进行</strong>或<strong>完成</strong>，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段</p>
<p>这里简要说明下Java中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定：</p>
<ul>
<li>静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的</li>
</ul>
</li>
<li><p>动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的</p>
<a id="more"></a>
</li>
</ul>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
</li>
<li><p>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</p>
</li>
</ul>
<p>注意，这里第1条中的二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等</p>
<ul>
<li><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载</p>
</li>
<li><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据</p>
</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul>
<li><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果</p>
<p>站在<strong>Java虚拟机</strong>的角度来讲，只存在两种不同的类加载器：</p>
</li>
<li><p>启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分</p>
</li>
<li><p>所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类</p>
</li>
</ul>
<p>站在<strong>Java开发人员</strong>的角度来看，类加载器可以大致划分为以下三类：</p>
<ul>
<li><p>启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的</p>
</li>
<li><p>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器</p>
</li>
<li><p>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</p>
</li>
</ul>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。<strong>因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</strong></p>
<ul>
<li><p>在执行非置信代码之前，自动验证数字签名</p>
</li>
<li><p>动态地创建符合用户特定需要的定制化构建类</p>
</li>
<li><p>从特定的场所取得java class，例如数据库中和网络中</p>
</li>
</ul>
<p>事实上当使用Applet的时候，就用到了特定的ClassLoader，因为这时需要从网络上加载java class，并且要检查相关的安全信息，应用服务器也大都使用了自定义的ClassLoader技术</p>
<ul>
<li>这几种类加载器的层次关系如下图所示：</li>
</ul>
<p><br></p>
<p><center><img src="http://o99dg8ap9.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B62.jpg" alt=""></center><br><br></p>
<ul>
<li><p>这种层次关系称为类加载器的<strong>双亲委派模型</strong>。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式</p>
</li>
<li><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类</p>
</li>
<li><p>使用双亲委派模型来组织类加载器之间的关系，<strong>有一个很明显的好处，就是Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系</strong>，这对于保证Java程序的稳定运作很重要。例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类</p>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p> 验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：<strong>文件格式的验证、元数据的验证、字节码验证和符号引用验证</strong></p>
<ul>
<li><p>文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的</p>
</li>
<li><p>元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息</p>
</li>
<li><p>字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为</p>
</li>
<li><p>符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验</p>
</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<hr>
<h4 id="类变量分配内存"><a href="#类变量分配内存" class="headerlink" title="类变量分配内存"></a>类变量分配内存</h4><ul>
<li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中</li>
</ul>
<hr>
<h4 id="数据默认值"><a href="#数据默认值" class="headerlink" title="数据默认值"></a>数据默认值</h4><p>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值</p>
<ul>
<li><p>假设一个类变量的定义为：public static int value = 3；</p>
</li>
<li><p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器’&lt;’clinit&gt;（）方法之中的，<strong>所以把value赋值为3的动作将在初始化阶段才会执行</strong></p>
</li>
<li><p>下表列出了Java中所有基本数据类型以及reference类型的默认零值：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th style="text-align:center">默认零值</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td>long</td>
<td style="text-align:center">0L</td>
</tr>
<tr>
<td>short</td>
<td style="text-align:center">(short)0</td>
</tr>
<tr>
<td>char</td>
<td style="text-align:center">‘\u0000’</td>
</tr>
<tr>
<td>byte</td>
<td style="text-align:center">(byte)0</td>
</tr>
<tr>
<td>boolean</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td>float</td>
<td style="text-align:center">0.0f</td>
</tr>
<tr>
<td>double</td>
<td style="text-align:center">0.0d</td>
</tr>
<tr>
<td>reference</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
<p>这里还需要注意如下几点：</p>
<ul>
<li><p>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过</p>
</li>
<li><p>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值</p>
</li>
<li><p>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</p>
</li>
<li><p>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值</p>
</li>
</ul>
<hr>
<h4 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h4><p>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值</p>
<ul>
<li><p>假设上面的类变量value被定义为： public static final int value = 3；</p>
</li>
<li><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。回忆 <a href="http://www.qiuchengjia.cn/2016/07/23/JVM/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" target="_blank" rel="external">上一篇博文</a> 中对象被动引用的第2个例子，便是这种情况。<strong>我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中</strong></p>
</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在Class类文件结构一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）</p>
</li>
<li><p>对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行</p>
</li>
<li><p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型</p>
</li>
</ul>
<h4 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h4><ul>
<li>判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析</li>
</ul>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><ul>
<li>对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示：</li>
</ul>
<p><br></p>
<p><center><img src="http://o99dg8ap9.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B63.jpg" alt=""></center><br><br></p>
<ul>
<li>从下面一段代码的执行结果中很容易看出来字段解析的搜索顺序：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">11</span>;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"执行了super类静态语句块"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">33</span>;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"执行了父类静态语句块"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"执行了子类静态语句块"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        System.out.println(Child.m);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行结果如下：</li>
</ul>
<blockquote>
<p>执行了super类静态语句块<br>    执行了父类静态语句块<br>    33</p>
</blockquote>
<ul>
<li>如果注释掉Father类中对m定义的那一行，则输出结果如下：</li>
</ul>
<blockquote>
<p>  执行了super类静态语句块<br>    11</p>
</blockquote>
<ul>
<li><p>另外，很明显这就是<a href="http://www.qiuchengjia.cn/2016/07/23/JVM/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" target="_blank" rel="external">上篇博文</a>中的第1个例子的情况，这里我们便可以分析如下：static变量发生在静态解析阶段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由于在子类中没有查找到与m相匹配的字段，那么m便不会与子类关联在一起，因此并不会触发子类的初始化</p>
</li>
<li><p><strong>最后需要注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译。</strong>如果对上面的代码做些修改，将Super改为接口，并将Child类继承Father类且实现Super接口，那么在编译时会报出如下错误：</p>
</li>
</ul>
<blockquote>
<p>StaticTest.java:24: 对 m 的引用不明确，Father 中的 变量 m 和 Super 中的 变量 m<br>都匹配<br>                System.out.println(Child.m);<br>                                        ^<br>1 错误</p>
</blockquote>
<h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><ul>
<li>对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口</li>
</ul>
<h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><ul>
<li>与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程</clinit></li>
</ul>
<h4 id="‘-lt-’clinit-gt-（）方法的执行规则"><a href="#‘-lt-’clinit-gt-（）方法的执行规则" class="headerlink" title="‘&lt;’clinit&gt;（）方法的执行规则"></a>‘&lt;’clinit&gt;（）方法的执行规则</h4><ul>
<li><p>‘&lt;’clinit&gt;（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访。</p>
</li>
<li><p>‘&lt;’clinit&gt;（）方法与实例构造器<init>（）方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的’&lt;’clinit&gt;（）方法执行之前，父类的’&lt;’clinit&gt;（）方法已经执行完毕。因此，在虚拟机中第一个被执行的’&lt;’clinit&gt;（）方法的类肯定是java.lang.Object</init></p>
</li>
<li><p>‘&lt;’clinit&gt;（）方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成’&lt;’clinit&gt;（）方法</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成’&lt;’clinit&gt;（）方法。但是接口鱼类不同的是：执行接口的’&lt;’clinit&gt;（）方法不需要先执行父接口的’&lt;’clinit&gt;（）方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的’&lt;’clinit&gt;（）方法</p>
</li>
<li><p>虚拟机会保证一个类的’&lt;’clinit&gt;（）方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的’&lt;’clinit&gt;（）方法，其他线程都需要阻塞等待，直到活动线程执行’&lt;’clinit&gt;（）方法完毕。如果在一个类的’&lt;’clinit&gt;（）方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的</p>
</li>
</ul>
<p>下面给出一个简单的例子，以便更清晰地说明如上规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        a = <span class="number">2</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        System.out.println(Child.b);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>执行上面的代码，会打印出2，也就是说b的值被赋为了2</p>
</li>
<li><p>我们来看得到该结果的步骤。首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用’&lt;’clinit&gt;（）方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的’&lt;’clinit&gt;（）方法，根据规则2，在此之前，要先执行完其父类Father的’&lt;’clinit&gt;（）方法，又根据规则1，在执行’&lt;’clinit&gt;（）方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，因此当触发执行Father的’&lt;’clinit&gt;（）方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的’&lt;’clinit&gt;（）方法，这样便会将b的赋值为2</p>
</li>
<li><p>如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。很明显是根据规则1，执行Father的’&lt;’clinit&gt;（）方法时，根据顺序先执行了static语句块中的内容，后执行了“public static int a = 1;”语句</p>
</li>
<li><p>另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量），在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于’&lt;’clinit&gt;（）方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始</li>
</ul>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul>
<li><a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="external">传送门</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu安装小结]]></title>
      <url>https://fudawei.github.io/2015/06/09/Ubuntu%E5%AE%89%E8%A3%85%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="Ubuntu-中apt-get用法："><a href="#Ubuntu-中apt-get用法：" class="headerlink" title="Ubuntu 中apt-get用法："></a>Ubuntu 中apt-get用法：</h3><p>查找软件<br>命令： apt-cache search keyword</p>
<p>查询软件状态<br>命令： apt-cache policy softname</p>
<p>安装软件<br>命令： apt-get install softname1 softname2 softname3……</p>
<p>卸载软件<br>命令： apt-get remove softname1 softname2 softname3……</p>
<p>卸载并清除配置<br>命令： apt-get remove –purge softname1</p>
<p>更新软件信息数据库<br>命令： apt-get update</p>
<p>进行系统升级<br>命令： apt-get upgrade</p>
<p>搜索软件包<br>命令： apt-cache search softname1 softname2 softname3……</p>
<p>Deb软件包相关安装与卸载<br>安装deb软件包<br>命令： dpkg -i xxx.deb</p>
<h3 id="TimeNet4-的安装"><a href="#TimeNet4-的安装" class="headerlink" title="TimeNet4 的安装"></a>TimeNet4 的安装</h3><p>apt-get install openjdk-7-jre<br>apt-get install build-essential<br>apt-get install unixodbc-dev<br>apt-get install liblpsolve55-dev</p>
<p>run /TimeNET/bin/startGUI</p>
<h3 id="Qt5-3安装"><a href="#Qt5-3安装" class="headerlink" title="Qt5.3安装"></a>Qt5.3安装</h3><p><a href="https://download.qt.io/archive/qt/5.3/5.3.0/" target="_blank" rel="external">下载</a> qt-opensource-linux-x64-5.3.0.run<br>安装依赖 sudo apt-get install build-essential libgl1-mesa-dev<br>赋予权限 chmod +x qt-opensource-linux-x64-5.3.0.run<br>执行 ./qt-opensource-linux-x64-5.3.0.run</p>
<h3 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h3><p>解压之后<br>sudo gedit /etc/environment<br>添加如下<br>PATH=”/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/tecn/jdk1.7.0_55/bin”<br>CLASSPATH=”/home/tecn/jdk1.7.0_55/lib:.”       注意后面有个点<br>JAVA_HOME=”/home/tecn/jdk1.7.0_55/“<br>注销或重启使环境变量生效  执行java -version</p>
<p>已经装有openjdk启用官方jdk的方法：<br>依次终端执行：<br>sudo update-alternatives –install /usr/bin/java java /home/tecn/jdk1.7.0_55/bin/java 445<br>sudo update-alternatives –install /usr/bin/javac javac /home/tecn/jdk1.7.0_55/bin/javac 445<br>sudo update-alternatives –config java<br>将会提示，要维持当前值[*]请按回车键，或者输入选择的编号：<br>输入优先级为 445 的那项的编号，回车即可。</p>
<h3 id="centso安装pip-下载源码安装"><a href="#centso安装pip-下载源码安装" class="headerlink" title="centso安装pip 下载源码安装"></a>centso安装pip 下载源码安装</h3><p>wget –no-check-certificate <a href="https://github.com/pypa/pip/archive/1.5.5.tar.gz" target="_blank" rel="external">https://github.com/pypa/pip/archive/1.5.5.tar.gz</a><br>tar zvxf 1.5.5.tar.gz    #解压文件<br>cd pip-1.5.5/<br>python setup.py install</p>
<p>你可以检查日志或者控制 Shadowsocks 的运行：<br>supervisorctl tail -f shadowsocks stderr<br>supervisorctl restart shadowsocks</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java面试题]]></title>
      <url>https://fudawei.github.io/2014/09/15/Java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><ol>
<li>String类为什么是final的。<br>效率和安全，性能</li>
<li><p>HashMap的源码，实现原理，底层结构。</p>
</li>
<li><p>说说你知道的几个Java集合类：list、set、queue、map实现类咯。。。<br>List: ArrayList  LinkedList  Vector  Stack<br>Set : TreeSet  HashSet<br>Queur: BlockingQueue   Deque<br>Map : HashMap  Hashtable</p>
</li>
<li>描述一下ArrayList和LinkedList各自实现和区别<br>ArrayList 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。<br>LinkedList 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率低。</li>
<li><p>Java中的队列都有哪些，有什么区别。</p>
</li>
<li><p>反射中，Class.forName和classloader的区别<br>Class.forName(className)装载的class已经被初始化，而ClassLoader.loadClass(className)装载的class还没有被link。<br>一般情况下，这两个方法效果一样，都能装载Class。但如果程序依赖于Class是否被初始化，就必须用Class.forName(name)了。</p>
</li>
<li>Java7、Java8的新特性(baidu问的,好BT)<br>lambda 流式编程  函数式接口</li>
<li>Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高</li>
<li><p>Java内存泄露的问题调查定位：jmap，jstack的使用等等</p>
</li>
<li><p>string、stringbuilder、stringbuffer区别<br>StringBuilder &gt; StringBuffer &gt; String  速度<br>StringBuffer 线程安全的</p>
</li>
<li>hashtable和hashmap的区别<br>线程安全 &amp;&amp; null值两方面<br>13 .异常的结构，运行时异常和非运行时异常，各举个例子<br>1)非受检的：NullPointerException,ClassCastException,ArrayIndexsOutOfBoundsException,ArithmeticException(算术异常，除0溢出)<br>2)受检：Exception,FileNotFoundException,IOException,SQLException.</li>
<li>String a= “abc” String b = “abc” String c = new String(“abc”) String d = “ab” + “c” .他们之间用 == 比较的结果</li>
<li>String 类的常用方法<br>String.toCharArray()  String.getBytes()  String.length()   String.indexOf(String str)   String.subString()<br>String.split()    toUpperCase()   replace()</li>
<li>Java 的引用类型有哪几种</li>
<li><p>抽象类和接口的区别</p>
</li>
<li><p>java的基础类型和字节大小。<br>char  16bit  |   short   16bit  |   byte    8bit | int  32bit   |   long   64bit  |  floag   32bit  |  double  64bit</p>
</li>
<li>Hashtable,HashMap,ConcurrentHashMap 底层实现原理与线程安全问题</li>
<li>自己实现一个Map。</li>
<li><p>Hash冲突怎么办？哪些解决散列冲突的方法？</p>
</li>
<li><p>HashMap冲突很厉害，最差性能，你会怎么解决?从O（n）提升到log（n）咯，用二叉排序树的思路说了一通</p>
</li>
<li>rehash</li>
<li>hashCode() 与 equals() 生成算法、方法怎么重写</li>
</ol>
<h3 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h3><ol>
<li>讲讲IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞。</li>
<li>讲讲NIO。<br>Channels and Buffers（通道和缓冲区）：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中</li>
<li>String 编码UTF-8 和GBK的区别?<br>GBK占用两个字节；UTF8对于英文占用一个字节，对于中文占用两个字节</li>
<li>什么时候使用字节流、什么时候使用字符流?<br>字节流在操作时本身不会用到缓冲区；而字符流在操作时用到了缓冲区，通过缓冲区再操作文件<br>所有的文件在硬盘或在传输时都是以字节的方式进行的，包括图片等都是按字节的方式存储的，而字符是只有在内存中才会形成，所以在开发中，字节流使用较为广泛。<br>程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。<br>如果要java程序实现一个拷贝功能，应该选用字节流进行操作（可能拷贝的是图片），并且采用边读边写的方式（节省内存）</li>
<li>递归读取文件夹下的文件，代码怎么实现</li>
</ol>
<h3 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h3><ol>
<li><p>session和cookie的区别和联系，session的生命周期，多个服务部署时session管理。</p>
</li>
<li><p>servlet的一些相关问题</p>
</li>
<li>webservice相关问题</li>
<li>jdbc连接，forname方式的步骤，怎么声明使用一个事务。举例并具体代码</li>
<li>无框架下配置web.xml的主要配置内容</li>
<li>jsp和servlet的区别</li>
</ol>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ol>
<li>Java的内存模型以及GC算法</li>
<li>jvm性能调优都做了什么</li>
<li>介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明</li>
<li>介绍GC 和GC Root不正常引用。</li>
<li>自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展</li>
<li>jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析</li>
<li>数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）</li>
<li>老年代中数组的访问方式</li>
<li>GC 算法，永久代对象如何 GC ， GC 有环怎么处理</li>
<li>谁会被 GC ，什么时候 GC</li>
<li>如果想不被 GC 怎么办</li>
<li>如果想在 GC 中生存 1 次怎么办</li>
</ol>
<h3 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h3><ol>
<li>hibernate和ibatis的区别</li>
<li>讲讲mybatis的连接池。</li>
<li>spring框架中需要引用哪些jar包，以及这些jar包的用途</li>
<li>springMVC的原理</li>
<li>springMVC注解的意思</li>
<li>spring中beanFactory和ApplicationContext的联系和区别</li>
<li>spring注入的几种方式（循环注入）</li>
<li>spring如何实现事物管理的</li>
<li>springIOC</li>
<li>spring AOP的原理</li>
<li>hibernate中的1级和2级缓存的使用方式以及区别原理（Lazy-Load的理解）</li>
<li>Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。<br>六、多线程</li>
<li>Java创建线程之后，直接调用start()方法和run()的区别</li>
<li>常用的线程池模式以及不同线程池的使用场景</li>
<li>newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。</li>
<li>多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。</li>
<li>了解可重入锁的含义，以及ReentrantLock 和synchronized的区别</li>
<li>同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高</li>
<li>atomicinteger和volatile等线程安全操作的关键字的理解和使用</li>
<li>线程间通信，wait和notify</li>
<li>定时线程的使用</li>
<li>场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。</li>
<li>进程和线程的区别</li>
<li>什么叫线程安全？举例说明</li>
<li>线程的几种状态</li>
<li>并发、同步的接口或方法</li>
<li>HashMap 是否线程安全，为何不安全。 ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。</li>
<li>J.U.C下的常见类的使用。 ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。</li>
<li>简单介绍下多线程的情况，从建立一个线程开始。然后怎么控制同步过程，多线程常用的方法和结构</li>
<li>volatile的理解</li>
<li>实现多线程有几种方式，多线程同步怎么做，说说几个线程里常用的方法</li>
</ol>
<h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><ol>
<li>http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。</li>
<li>socket通信，以及长连接，分包，连接异常断开的处理。</li>
<li>socket通信模型的使用，AIO和NIO。</li>
<li>socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。</li>
<li>同步和异步，阻塞和非阻塞。<br>异步的概念和同步相对。当一个异步过程调用发出后，调用者不会立刻得到结果。实际处理这个调用的部件是在调用发出后，通过状态、通知来通知<br>调用者，或通过回调函数处理这个调用。<br>阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。<br>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。<br>有同步阻塞、异步阻塞、同步非阻塞、异步非阻塞</li>
<li>OSI七层模型，包括TCP,IP的一些基本知识</li>
<li>http中，get post的区别</li>
<li>说说http,tcp,udp之间关系和区别。</li>
<li>说说浏览器访问www.taobao.com，经历了怎样的过程。<br>本地缓存   DNS缓存  迭代查询和递归查询</li>
<li>HTTP协议、  HTTPS协议，SSL协议及完整交互过程；</li>
<li>tcp的拥塞，快回传，ip的报文丢弃</li>
<li>https处理的一个过程，对称加密和非对称加密</li>
<li>head各个特点和区别</li>
</ol>
<h3 id="数据库MySql"><a href="#数据库MySql" class="headerlink" title="数据库MySql"></a>数据库MySql</h3><ol>
<li>MySql的存 储引擎的不同</li>
<li>单个索引、联合索引、主键索引</li>
<li>Mysql怎么分表，以及分表后如果想按条件分页查询怎么办(如果不是按分表字段来查询的话，几乎效率低下，无解)</li>
<li>分表之后想让一个id多个表是自增的，效率实现</li>
<li>MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离</li>
<li>写SQL语句。。。</li>
<li><p>索引的数据结构，B+树</p>
</li>
<li><p>事务的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题</p>
</li>
<li><p>数据库的锁：行锁，表锁；乐观锁，悲观锁</p>
</li>
<li><p>数据库事务的几种粒度；<br>事务四个特性 ： 原子性  一致性  隔离性   持久性</p>
</li>
<li><p>关系型和非关系型数据库区别</p>
<blockquote>
<ul>
<li>非关系型数据库的优势：</li>
</ul>
</blockquote>
</li>
<li>性能<br>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li>
<li>可扩展性<br>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。<blockquote>
<ul>
<li>关系型数据库的优势：</li>
</ul>
</blockquote>
</li>
<li>复杂查询<br>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li>
<li><p>事务支持<br>使得对于安全性能很高的数据访问要求得以实现。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3></li>
<li><p>单例模式：饱汉、饿汉。以及饿汉中的延迟加载,双重检查</p>
</li>
<li>工厂模式、装饰者模式、观察者模式。</li>
<li>工厂方法模式的优点（低耦合、高内聚，开放封闭原则）</li>
</ol>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol>
<li>使用随机算法产生一个数，要求把1-1000W之间这些数全部生成。（考察高效率，解决产生冲突的问题）</li>
<li>两个有序数组的合并排序</li>
<li>一个数组的倒序</li>
<li>计算一个正整数的正平方根</li>
<li>说白了就是常见的那些查找、排序算法以及各自的时间复杂度</li>
<li>二叉树的遍历算法</li>
<li>DFS,BFS算法</li>
<li>比较重要的数据结构，如链表，队列，栈的基本理解及大致实现。</li>
<li>排序算法与时空复杂度（快排为什么不稳定，为什么你的项目还在用）</li>
<li>逆波兰计算器</li>
<li>Hoffman 编码</li>
<li>查找树与红黑树</li>
</ol>
<h3 id="并发与性能调优"><a href="#并发与性能调优" class="headerlink" title="并发与性能调优"></a>并发与性能调优</h3><ol>
<li>有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?</li>
<li>高并发情况下，我们系统是如何支撑大量的请求的</li>
<li>集群如何同步会话状态</li>
<li>负载均衡的原理<br>5 .如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）</li>
<li>如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。</li>
<li>假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。</li>
<li>如何查找 造成 性能瓶颈出现的位置，是哪个位置照成性能瓶颈。</li>
<li>你的项目中使用过缓存机制吗？有没用用户非本地缓存</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.常用的linux下的命令</p>
<p>排序：<br>在待排序的文件中，若存在多个关键字相同的记录，经过排序后，这些具有相同关键字的记录之间的相对次序保持不变，该排序<br>方法是稳定的；若具有相同关键字的记录之间的相对次序发生变化，则称这种排序方法是不稳定的。<br>排序时不涉及数据的内外存交换，称之为内部排序；反之，排序过程要进行数据的内外存交换，称之为外部排序。</p>
<p>冒泡排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void bublbleSort(int[] source) &#123;</div><div class="line">		for(int i = source.length-1;i &gt; 0;i --) &#123;</div><div class="line">			for(int j = 0; j &lt; i; j ++) &#123;</div><div class="line">				if(source[j] &gt; source[j+1]) &#123;</div><div class="line">					swap(source,j,j+1);</div><div class="line">				&#125;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>选择排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void selectSort(int[] source) &#123;</div><div class="line">		for(int i = 0;i&lt;source.length;i++) &#123;</div><div class="line">			for(int j = i+1;j&lt;source.length;j++) &#123;</div><div class="line">				if(source[i] &gt; source[j]) &#123;</div><div class="line">					swap(source, j, i);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>插入排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static void insertSort(int[] source) &#123;</div><div class="line">		for(int i = 0;i&lt;source.length;i++) &#123;</div><div class="line">			for(int j =i;(j&gt;0 &amp;&amp; source[j] &lt; source[j-1]);j--) &#123;</div><div class="line">					swap(source, j, j-1);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>快速排序</p>
<h3 id="利用StringBuilder-重写toString-方法"><a href="#利用StringBuilder-重写toString-方法" class="headerlink" title="利用StringBuilder 重写toString()方法"></a>利用StringBuilder 重写toString()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public String toString() &#123;</div><div class="line">        StringBuilder sb = new StringBuilder(&quot;[&quot;);</div><div class="line">        Field[] fields = getClass().getDeclaredFields();</div><div class="line">        for (Field field : fields) &#123;</div><div class="line">            try &#123;</div><div class="line">                field.setAccessible(true);</div><div class="line">                sb.append(field.getName()).append(&quot;:&quot;).append(field.get(this)).append(&quot;,&quot;);</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 去掉多于的逗号</div><div class="line">        if(sb.length() &gt; 1)&#123;</div><div class="line">            sb.deleteCharAt(sb.length()-1);</div><div class="line">        &#125;</div><div class="line">        sb.append(&quot;]&quot;);</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="字节和位的转化"><a href="#字节和位的转化" class="headerlink" title="字节和位的转化"></a>字节和位的转化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Byte转Bit</div><div class="line"> */</div><div class="line">public static String byteToBit(byte b) &#123;</div><div class="line">    return &quot;&quot; + (byte) ((b &gt;&gt; 7) &amp; 0x1) + (byte) ((b &gt;&gt; 6) &amp; 0x1)</div><div class="line">            + (byte) ((b &gt;&gt; 5) &amp; 0x1) + (byte) ((b &gt;&gt; 4) &amp; 0x1)</div><div class="line">            + (byte) ((b &gt;&gt; 3) &amp; 0x1) + (byte) ((b &gt;&gt; 2) &amp; 0x1)</div><div class="line">            + (byte) ((b &gt;&gt; 1) &amp; 0x1) + (byte) ((b &gt;&gt; 0) &amp; 0x1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Bit转Byte</div><div class="line"> */</div><div class="line">public static byte BitToByte(String byteStr) &#123;</div><div class="line">    int re, len;</div><div class="line">    if (null == byteStr) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    len = byteStr.length();</div><div class="line">    if (len != 4 &amp;&amp; len != 8) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (len == 8) &#123;// 8 bit处理</div><div class="line">        if (byteStr.charAt(0) == &apos;0&apos;) &#123;// 正数</div><div class="line">            re = Integer.parseInt(byteStr, 2);</div><div class="line">        &#125; else &#123;// 负数</div><div class="line">            re = Integer.parseInt(byteStr, 2) - 256;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;// 4 bit处理</div><div class="line">        re = Integer.parseInt(byteStr, 2);</div><div class="line">    &#125;</div><div class="line">    return (byte) re;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReadWriteLock 中若Reader优先的话会无限期地延迟 writer，而 writer 优先会减少可能的并发。</p>
<h3 id="垃圾收集算法："><a href="#垃圾收集算法：" class="headerlink" title="垃圾收集算法："></a>垃圾收集算法：</h3><p>可达性分析： 将一些列gc roots 对象作为起始点，当一个对象到gc roots 没有任何引用链相连时，则不可用<br>一、标记-清除算法<br>    缺点：效率低，会产生空间碎片<br>二、复制算法<br>    一块Eden，两块survivor清理时将一块Eden和一块survivor上存活的对象复制到剩下的那块survivor上，之后清理掉前两者。<br>三、标记-整理算法<br>    标记后，将所有存活的对象向一段移动，剩下的清理。<br>四、分代收集算法<br>    商业虚拟机均用此，根据对象存活周期的不同分为新生代和老年代，新生代用复制算法，老年代用标记清除算法和标记整理算法。</p>
<h3 id="wait-、sleep-、notify-、notifyAll-区别"><a href="#wait-、sleep-、notify-、notifyAll-区别" class="headerlink" title="wait()、sleep()、notify()、notifyAll()区别"></a>wait()、sleep()、notify()、notifyAll()区别</h3><p>wait():使一个线程处于等待状态，并且释放锁。<br>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。此方法不会释放锁。<br>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程(一般是最先开始等待的线程)，而且不是按优先级。<br>notityAll():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
<p>JDK1.5中提供了多线程升级的解决方案：将同步synchonized替换成了显式的Lock操作，将Object中的wait、notify、notifyAll替换成了Condition对象。</p>
<h3 id="Lock的方法摘要："><a href="#Lock的方法摘要：" class="headerlink" title="Lock的方法摘要："></a>Lock的方法摘要：</h3><p>void lock()  获取锁。<br>Condition newCondition() 返回绑定到此 Lock 实例的新 Condition 实例。<br>void unlock() 释放锁。<br>Condition方法摘要：<br>void await() 造成当前线程在接到信号或被中断之前一直处于等待状态。<br>void signal() 唤醒一个等待线程。<br>void signalAll() 唤醒所有等待线程。</p>
<h3 id="守护线程-后台线程"><a href="#守护线程-后台线程" class="headerlink" title="守护线程(后台线程)"></a>守护线程(后台线程)</h3><p>setDaemon(boolean on):将该线程标记为守护线程或者用户线程。当正在运行的线程都是守护线程时，java虚拟机jvm退出；所以该方法必须在启动线程前调用；</p>
<h3 id="进程线程管程区别"><a href="#进程线程管程区别" class="headerlink" title="进程线程管程区别"></a>进程线程管程区别</h3><p>进程 ： 一个程序在一个数据集合上的一次运行过程，是资源分配的最小单位，进程无法突破进程边界存取其他进程内的存储空间<br>线程 ： 线程是进程中的一个实体，是被系统独立调度和执行的最小单位，同一进程所产生的线程共享同一内存空间。<br>管程： 管程是定义了一个数据结构和在该数据结构上的能为并发进程锁执行的一组操作，这组操作能同步进程和改变管程上的数据<br>进程间通信 信号量、消息队列、共享内存</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>产生死锁的条件：　互斥、请求与保持、不剥夺条件、循环等待条件<br>解除与预防：<br>1.采用资源静态分配策略，破坏”部分分配”条件<br>2.允许进程剥夺使用其他进程占有的资源，破坏不可剥夺条件<br>3.采用资源有序分配法，破坏环路条件</p>
<h3 id="静态链接库和动态链接库"><a href="#静态链接库和动态链接库" class="headerlink" title="静态链接库和动态链接库"></a>静态链接库和动态链接库</h3><p>都是共享代码的方式，如果采用静态链接库，lib中的指令都全部被直接包含在最终生成的exe文件中了。但是若使用dll，该dll不被包含在最终exe文件中，exe文件执行时可以动态的引用和卸载这个与exe独立的dll文件。</p>
<h3 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h3><p>1.聚集索引的顺序就是数据的物理存储顺序，非聚集索引的索引顺序与物理顺序无关。<br>2.一个表只能包含一个聚集索引，可以有多个非聚集索引<br>3.聚集索引对于那些经常要搜索范围值的列有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻<br>4.非索引存储中的项目按索引键值的顺序存储，而表中信息按另一种顺序存储。</p>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>1、寻找jre目录，寻找jvm.dll，并初始化JVM；<br>2、产生一个Bootstrap Loader（启动类加载器）；<br>3、Bootstrap Loader自动加载Extended Loader（标准扩展类加载器），并将其父Loader设为Bootstrap Loader。<br>4、Bootstrap Loader自动加载AppClass Loader（系统类加载器），并将其父Loader设为Extended Loader。<br>5、最后由AppClass Loader加载HelloWorld类。</p>
<h3 id="类加载器的特点"><a href="#类加载器的特点" class="headerlink" title="类加载器的特点"></a>类加载器的特点</h3><p>1、运行一个程序时，总是由AppClass Loader（系统类加载器）开始加载指定的类。<br>2、在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载。<br>3、Bootstrap Loader（启动类加载器）是最顶级的类加载器了，其父加载器为null.</p>
<h3 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h3><p>1.在启动一个java程序的同时会诞生一个虚拟机实例，当该程序退出时，虚拟机实例也随之消亡。如果在同一计算机同时运行三个java程序，会得到三个java虚拟机实例。每个java程序都运行在自己的java虚拟机实例中。<br>2.java栈是由许多栈帧组成的，一个栈帧包含一个java方法调用的状态。当线程调用一个java方法时，虚拟机压入一个新的栈帧到该线程的java栈中；当该方法返回时，这个栈帧被从java栈中弹出并抛弃。<br>3.对于一个正在运行java方法的线程而言，它的PC寄存器总是指向下一条将被执行的指令。</p>
<h3 id="什么是ThreadLocal类-怎么使用它？"><a href="#什么是ThreadLocal类-怎么使用它？" class="headerlink" title="什么是ThreadLocal类,怎么使用它？"></a>什么是ThreadLocal类,怎么使用它？</h3><p>一个线程局部变量(ThreadLocal variables)为每个线程方便地提供了一个单独的变量。<br>ThreadLocal 实例通常作为静态的私有的(private static)字段出现在一个类中，这个类用来关联一个线程。当多个线程访问 ThreadLocal 实例时，每个线程维护 ThreadLocal 提供的独立的变量副本。</p>
<blockquote>
<p>常用的使用可在 DAO 模式中见到，当 DAO 类作为一个单例类时，数据库链接(connection)被每一个线程独立的维护，互不影响。(基于线程的单例)</p>
</blockquote>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>1.为避免其他程序创建该类对象，将构造函数私有化<br>2.为了其他程序访问到该类对象，须在本类中创建一个该类私有对象<br>3.为了方便其他程序访问该类对象，可对外提供一个公共访问方式<br>比如API中的Runtime类就是单例设计模式。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>(1)最终的意思，可以用于修饰类，方法，变量。<br>(2)final修饰的类不能被继承。final修饰的方法不能被重写。final修饰的变量是一个常量。只能被赋值一次。<br>  内部类只能访问被final修饰的局部变量。</p>
<h3 id="模板设计模式："><a href="#模板设计模式：" class="headerlink" title="模板设计模式："></a>模板设计模式：</h3><p>在定义功能时，功能的一部分是确定的，有一部分是不确定的，而且确定的部分在使用不确定的部分，<br>可将不确定的部分暴露出去，由该类的子类去完成。<br>如：求一段程序的运行时间例子。</p>
<h3 id="Mess"><a href="#Mess" class="headerlink" title="Mess"></a>Mess</h3><p>不重写Bean的hashCode()方法是否会对性能带来影响？<br>如果一个计算hash的方法写得不好，直接的影响是，当向HashMap中添加元素的时候会更频繁地造成冲突<br>对于一个不可修改的类，它的每个对象是不是都必须声明成final的？<br>不尽然，可以将成员声明为private，不为它提供setter方法，同时不会通过任何方法泄漏出对此成员的引用高就可以不被别的类修改。注意：把对象声明为final仅仅保证了它不会被重新赋值，你仍然可以通过此引用过来修改引用对象的属性。</p>
<h3 id="什么是不可修改对象-Immutable-Object-？你能否写一个例子？"><a href="#什么是不可修改对象-Immutable-Object-？你能否写一个例子？" class="headerlink" title="什么是不可修改对象(Immutable Object)？你能否写一个例子？"></a>什么是不可修改对象(Immutable Object)？你能否写一个例子？</h3><p>不可修改对象是那些一旦被创建就不能修改的对象。例如Java中的String类就是不可修改的。大多数这样的类通常都是final类型的，因为这样可以避免自己被继承继而被覆盖方法，你同样要保证你的类不要通过任何方法暴露成员，当你通过类函数返回一个可修改对象的时候，返回一个类成功的副本，防止客户代码通过此引用修改了成员对象的属性。</p>
<h3 id="双亲委派模型的工作过程为："><a href="#双亲委派模型的工作过程为：" class="headerlink" title="双亲委派模型的工作过程为："></a>双亲委派模型的工作过程为：</h3><p>1、前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。<br>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。<br>2、当前 classLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.<br>3、当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。<br>classloader 有两种装载class的方式<br>1、隐式：运行过程中，碰到new方式生成对象时，隐式调用classLoader到JVM<br>2、显式：通过class.forname()动态加载</p>
<h3 id="JVM-运行时数据区-JVM-Runtime-Area"><a href="#JVM-运行时数据区-JVM-Runtime-Area" class="headerlink" title="JVM 运行时数据区 (JVM Runtime Area)"></a>JVM 运行时数据区 (JVM Runtime Area)</h3><p>6个区域：<br>1、PC程序计数器：一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器, NAMELY存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。Java 的多线程机制离不开程序计数器，每个线程都有一个自己的PC，以便完成不同线程上下文环境的切换。<br>2、java虚拟机栈：与 PC 一样，java 虚拟机栈也是线程私有的。每一个 JVM 线程都有自己的 java 虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈<br>帧在虚拟机栈中从入栈到出栈的过程。<br>3、本地方法栈：与虚拟机栈的作用相似，虚拟机栈为虚拟机执行执行java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务。<br>4、Java堆：被所有线程共享的一块存储区域，在虚拟机启动时创建，它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。<br>Java堆在JVM启动的时候就被创建，堆中储存了各种对象，这些对象被自动管理内存系统（Automatic Storage Management System，也即是常说的 “Garbage Collector（垃圾回收器）”）所管理。这些对象无需、也无法显示地被销毁。<br>JVM将Heap分为两块：新生代New Generation和旧生代Old Generation<br>Note:<br>堆在JVM是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是new开销比较大的原因。<br>5、方法区<br>方法区和堆区域一样，是各个线程共享的内存区域，它用于存储每一个类的结构信息，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。当开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。<br>方法区也是全局共享的，在虚拟机启动时候创建。在一定条件下它也会被GC。这块区域对应Permanent Generation 持久代。 XX：PermSize指定大小。<br>6、运行时常量池其空间从方法区中分配，存放的为类中固定的常量信息、方法和域的引用信息。</p>
<h3 id="获得给定数字n的第i位"><a href="#获得给定数字n的第i位" class="headerlink" title="获得给定数字n的第i位"></a>获得给定数字n的第i位</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 从右往左数第i位</div><div class="line">public static int getBit(int num,int i)&#123;</div><div class="line">        int result = num &amp; (i-1&lt;&lt;1);</div><div class="line">        return result &gt; 0? 1:0;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="重写equals方法"><a href="#重写equals方法" class="headerlink" title="重写equals方法"></a>重写equals方法</h3><p>1.使用==符号检查“参数是否为这个对象的引用”。如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。<br>2.使用instanceof操作符检查“参数是否为正确的类型”。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。<br>3.把参数转换成正确的类型。因为转换之前进行过instanceof测试，所以确保会成功。<br>4.对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回true;否则返回false。<br>5.当编写完成了equals方法之后，检查“对称性”、“传递性”、“一致性”。</p>
<h3 id="重写hashCode方法意义？"><a href="#重写hashCode方法意义？" class="headerlink" title="重写hashCode方法意义？"></a>重写hashCode方法意义？</h3><ul>
<li>在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。</li>
<li>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li>
<li>如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。</li>
<li>如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。</li>
</ul>
<p>###hashCode()和equals()方法有何重要性？<br>HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。<br>同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：<br>（1）如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。<br>（2）如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。</p>
<h3 id="transient变量有什么特点"><a href="#transient变量有什么特点" class="headerlink" title="transient变量有什么特点?"></a>transient变量有什么特点?</h3><p>答案：transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。</p>
<h3 id="String和StringTokenizer的区别是什么？"><a href="#String和StringTokenizer的区别是什么？" class="headerlink" title="String和StringTokenizer的区别是什么？"></a>String和StringTokenizer的区别是什么？</h3><p>答案：StringTokenizer是一个用来分割字符串的工具类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">StringTokenizer st = new StringTokenizer(”Hello World”);</div><div class="line">// 根据delim分割字符串，false表示delim不参与输出</div><div class="line">StringTokenizer st = new StringTokenizer(&quot;www.baidu.com&quot;, &quot;.a&quot;, false);</div><div class="line">while (st.hasMoreTokens()) &#123;</div><div class="line">    System.out.println(st.nextToken());</div><div class="line">&#125;</div><div class="line">输出：</div><div class="line">Hello</div><div class="line">World</div></pre></td></tr></table></figure></p>
<h3 id="HashMap和HashTable有何不同？"><a href="#HashMap和HashTable有何不同？" class="headerlink" title="HashMap和HashTable有何不同？"></a>HashMap和HashTable有何不同？</h3><p>1.HashMap允许key和value为null，而HashTable不允许。<br>2.HashTable是同步的，而HashMap不是。所以HashMap适合单线程环境，HashTable适合多线程环境。<br>3.假如你想要遍历顺序，你很容易从HashMap转向LinkedHashMap，但是HashTable不是这样的，它的顺序是不可预知的。<br>4.HashMap提供对key的Set进行遍历，因此它是fail-fast的，但HashTable提供对key的Enumeration进行遍历，它不支持fail-fast。<br>5.HashTable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。</p>
<h3 id="fail-fast-amp-amp-fail-safe"><a href="#fail-fast-amp-amp-fail-safe" class="headerlink" title="fail-fast &amp;&amp; fail-safe"></a>fail-fast &amp;&amp; fail-safe</h3><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p>
<p>我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。<br>   这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HashIterator() &#123;</div><div class="line">    expectedModCount = modCount;</div><div class="line">    if (size &gt; 0) &#123; // advance to first entry</div><div class="line">    Entry[] t = table;</div><div class="line">    while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</div><div class="line">        ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：<br>   注意到modCount声明为volatile，保证线程之间修改的可见性。</p>
<h3 id="保证集合不被修改"><a href="#保证集合不被修改" class="headerlink" title="保证集合不被修改"></a>保证集合不被修改</h3><p>在作为参数传递之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。</p>
<h3 id="final关键字-1"><a href="#final关键字-1" class="headerlink" title="final关键字"></a>final关键字</h3><ul>
<li>final修饰变量：<br>final修饰的变量只能被赋值一次，可以是在声明的时候进行初始化，也可以是在初始化函数中进行初始化，基本数据类型在赋值后它的值无法改变，如果是一个对象的引用则不能再指向其它对象，但是这个对象的值是可以改变的。比如一个指向StringBuilder的对象A，A不能再被赋值，但是这个StringBuilder对象的值是可以改变的。</li>
<li>final修饰的方法：<br>final修饰的方法不能被子类重写，Java编程思想中是这样说的：<br>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；</li>
<li>final修饰的类：<br>final修饰的类不能被继承，也就是说它所有的实现都不能被改变，方法不能被重写。常用于设计一些不想让使用者改变的类。</li>
</ul>
<h3 id="单例适用场景"><a href="#单例适用场景" class="headerlink" title="单例适用场景"></a>单例适用场景</h3><ul>
<li>控制资源的使用，通过线程同步来控制资源的并发访问</li>
<li>控制实例的产生，以达到节约资源的目的</li>
<li>控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li>
</ul>
<h3 id="堆内存三部分（新生代、老年代、永久代）"><a href="#堆内存三部分（新生代、老年代、永久代）" class="headerlink" title="堆内存三部分（新生代、老年代、永久代）"></a>堆内存三部分（新生代、老年代、永久代）</h3><p>1.新生代，新生区是类的诞生、成长、消亡的区域，一个类在这里产生、应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区和幸存者区，<br>所有的类都是在伊甸区被创建的，幸存区有两个：0区（Survivor 0）和1区(Survivor 1)。当伊甸区的空间用完，程序又需要创建对象，JVM的垃圾回收器将<br>对伊甸区进行垃圾回收，将伊甸区中的不再被其他对象所引用的对象进行销毁。然后将伊甸区中的剩余对象移动到幸存0区，若幸存0区也满了，再对该区进行<br>垃圾回收，然后移动到1区，如果1区也满了，就移动到老年区。<br>2.老年代，用于保存从新生区筛选出来的java对象，一般池对象都在这个区域活跃。<br>3.永久代 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class Interface 的元数据，也就是说，它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被回收器回收的，关闭JVM才会释放此区域所占用的内存。<br>![java垃圾回收之新生代老年代永久代][1]</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>由于疏忽或错误造成程序未能释放已经不再使用的内存，失去了对该段内存的控制，造成内存浪费。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>1.标记-清除算法<br>首先标记出所有需要回收的对象，在标完成后统一回收掉所有被标记的对象。缺点：效率不高，且标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致运行过程中需要分配大对象的时候无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作<br>2.复制算法<br>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清理掉，内存使用率不高，现在商业虚拟机比如HotSpot都采用8:1的比例（Eden:Survivor）<br>3.标记-整理算法<br>把存活对象往内存的一端移动，然后直接回收边界以外的内存，提高了内存利用率，适合在收集对象存活时间较长的老年代。<br>4.分代收集算法<br>根据对象的存活时间把内存分为新生代和老年代，根据各代对象的存活特点，每个代采用不同的垃圾回收算法，新生代采用标记-复制算法，老年代采用标记-整理算法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Java锁学习三]锁在应用层的优化思路]]></title>
      <url>https://fudawei.github.io/2014/08/01/%E9%94%81%E5%9C%A8%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</url>
      <content type="html"><![CDATA[<h2 id="减少锁持有时间"><a href="#减少锁持有时间" class="headerlink" title="减少锁持有时间"></a>减少锁持有时间</h2><p>如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public synchronized void test() &#123;</div><div class="line">        executeMethod1();</div><div class="line">        multiThreadExecute();</div><div class="line">        executeMethod2();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>如果真正存在资源的竞争，需要加锁的函数是multiThreadExecute(),其他两个函数executeMethod1和executeMethod2都没有资源的竞争时，这样写只会增加线程持有锁的时间，就会导致其他线程等待这个锁的时间增长，影响性能。这种情况下，应该修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void test() &#123;</div><div class="line">    executeMethod1();</div><div class="line">    synchronized (this) &#123;</div><div class="line">        MultiThreadExecute();</div><div class="line">    &#125;</div><div class="line">    executeMethod2();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h2><p>这个思路最典型的例子就是JDK中的重要成员ConcurrentHashMap，ConcurrentHashMap将整个区间分成若干个Segment（默认是16个），每一个Segment都是一个子map，每个Segment都拥有自己的一把锁。当需要向map中插入数据时，并不是先申请所有的锁，而是根据需要插入的数据的key的hashcode计算出应该从插入到哪一个Segment，然后再申请这个Segment的锁。所以理想情况下，ConcurrentHashMap最多可能有16个线程真正同时插入数据。</p>
<p>但是较小锁粒度会有一个问题：如果需要访问全局数据（这时需要取得全局锁），消耗的资源会比较多。以ConcurrentHashMap为例，put操作使用分段锁提高了并发，但是size()函数却没那么幸运，size函数返回map中所有有效的元素个数，所以需要访问所有数据，也就需要取得所有的锁，损耗的性能是比较多的。</p>
<h2 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h2><p>同样以JDK中的重要成员LinkedBlockingQueue为例，take()和put()函数分别从队列中取得数据和向队列中添加元素。因为LinkedBlockingQueue是链表实现的，take和put操作分别在队头和队尾操作，互不影响，所以这两个操作就不应该公用一把锁。下面是jdk中LinkedBlockingQueue的代码的一部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Tail of linked list.</div><div class="line"> * Invariant: last.next == null</div><div class="line"> */</div><div class="line">private transient Node&lt;E&gt; last;</div><div class="line"></div><div class="line">/** Lock held by take, poll, etc */</div><div class="line">private final ReentrantLock takeLock = new ReentrantLock();</div><div class="line"></div><div class="line">/** Wait queue for waiting takes */</div><div class="line">private final Condition notEmpty = takeLock.newCondition();</div><div class="line"></div><div class="line">/** Lock held by put, offer, etc */</div><div class="line">private final ReentrantLock putLock = new ReentrantLock();</div><div class="line"></div><div class="line">/** Wait queue for waiting puts */</div><div class="line">private final Condition notFull = putLock.newCondition();</div></pre></td></tr></table></figure></p>
<p>可以看到分别定义了takeLock和putLock，这两个操作不适用同一把锁，削弱了锁竞争的可能性，提高了性能。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>所谓的锁粗化就是如果代码中有连续的对同一把锁的申请操作，则需要考虑将这些锁操作合并为一个。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void test() &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        // do sth</div><div class="line">    &#125;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        // do sth</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样的代码应该合并为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void test() &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        // do sth</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>锁粗化的思想和减少锁持有时间是相反的，但是在不同的场合下，他们的效果并不相同，需要我们权衡利弊再做决策。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java圾收集机制]]></title>
      <url>https://fudawei.github.io/2014/07/23/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h3><p> Java中的垃圾回收一般是在Java堆中进行，因为堆中几乎存放了Java中所有的对象实例。谈到Java堆中的垃圾回收，自然要谈到引用。在JDK1.2之前，Java中的引用定义很很纯粹：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。但在JDK1.2之后，Java对引用的概念进行了扩充，将其分为<strong>强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种</strong>，引用强度依次减弱</p>
<ul>
<li><p><strong>强引用：</strong>如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象</p>
</li>
<li><p><strong>软引用：</strong>它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用</p>
</li>
<li><p><strong>弱引用：</strong>它也是用来描述非需对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存岛下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用</p>
</li>
<li><p><strong>虚引用：</strong>最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用</p>
</li>
</ul>
<a id="more"></a>
<h3 id="垃圾对象的判定"><a href="#垃圾对象的判定" class="headerlink" title="垃圾对象的判定"></a>垃圾对象的判定</h3><p>Java堆中存放着几乎所有的对象实例，垃圾收集器对堆中的对象进行回收前，要先确定这些对象是否还有用，判定对象是否为垃圾对象有如下算法：</p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ul>
<li><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器值就减1，任何时刻计数器都为0的对象就是不可能再被使用的</p>
</li>
<li><p>引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的选择，<strong>当Java语言并没有选择这种算法来进行垃圾回收，主要原因是它很难解决对象之间的相互循环引用问题</strong></p>
</li>
</ul>
<h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p><strong>Java和C#中都是采用根搜索算法来判定对象是否存活的。</strong>这种算法的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。在Java语言里，可作为GC Roots的兑现包括下面几种：</p>
<ul>
<li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p>
</li>
<li><p>方法区中的类静态属性引用的对象</p>
</li>
<li><p>方法区中的常量引用的对象</p>
</li>
<li><p>本地方法栈中JNI（Native方法）的引用对象</p>
</li>
</ul>
<p>实际上，在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。当对象没有覆盖finalize（）方法，或finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。如果该对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize（）方法。finalize（）方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize（）方法最多只会被系统自动调用一次），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize（）方法中让该对象重引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul>
<li>判定除了垃圾对象之后，便可以进行垃圾回收了。下面介绍一些垃圾收集算法，由于垃圾收集算法的实现涉及大量的程序细节，因此这里主要是阐明各算法的实现思想，而不去细论算法的具体实现</li>
</ul>
<h4 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h4><p>标记—清除算法是最基础的收集算法，它分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。标记—清除算法的执行情况如下图所示：</p>
<ul>
<li><p>回收前状态</p>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6.jpg" alt=""></center>
</li>
<li><p>回收后状态</p>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B61.jpg" alt=""></center>

</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B62.jpg" alt=""></center>


<p>该算法有如下缺点：</p>
<ul>
<li><p>标记和清除过程的效率都不高</p>
</li>
<li><p>标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作</p>
</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法是针对标记—清除算法的缺点，在其基础上进行改进而得到的，它讲课用内存按容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉。复制算法有如下优点：</p>
<ul>
<li><p>每次只对一块内存进行回收，运行高效</p>
</li>
<li><p>只需移动栈顶指针，按顺序分配内存即可，实现简单</p>
</li>
<li><p>内存回收时不用考虑内存碎片的出现</p>
</li>
</ul>
<p>它的缺点是：可一次性分配的最大内存缩小了一半</p>
<p>复制算法的执行情况如下图所示：</p>
<ul>
<li>回收前状态：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B63.jpg" alt=""></center>

<ul>
<li>回收后状态：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B64.jpg" alt=""></center>

<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B65.jpg" alt=""></center>

<h4 id="标记—整理算法"><a href="#标记—整理算法" class="headerlink" title="标记—整理算法"></a>标记—整理算法</h4><p>复制算法比较适合于新生代，在老年代中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。标记—整理算法的回收情况如下所示：</p>
<ul>
<li>回收前状态：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B66.jpg" alt=""></center>

<ul>
<li>回收后状态：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B67.jpg" alt=""></center>

<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B62.jpg" alt=""></center>

<h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><ul>
<li><strong>当前商业虚拟机的垃圾收集 都采用分代收集</strong>，它根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收</li>
</ul>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><ul>
<li>垃圾收集器是内存回收算法的具体实现，Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别。Sun  HotSpot虚拟机1.6版包含了如下收集器：Serial、ParNew、Parallel Scavenge、CMS、Serial Old、Parallel Old。这些收集器以不同的组合形式配合工作来完成不同分代区的垃圾收集工作</li>
</ul>
<h3 id="垃圾回收分析"><a href="#垃圾回收分析" class="headerlink" title="垃圾回收分析"></a>垃圾回收分析</h3><p>在用代码分析之前，我们对内存的分配策略明确以下三点：</p>
<ul>
<li><p>对象优先在Eden分配</p>
</li>
<li><p>大对象直接进入老年代</p>
</li>
<li><p>长期存活的对象将进入老年代</p>
</li>
</ul>
<p>对垃圾回收策略说明以下两点：</p>
<ul>
<li><p>新生代GC（Minor GC）：发生在新生代的垃圾收集动作，因为Java对象大多都具有朝生夕灭的特性，因此Minor GC非常频繁，一般回收速度也比较快</p>
</li>
<li><p>老年代GC（Major GC/Full GC）：发生在老年代的GC，出现了Major GC，经常会伴随至少一次Minor GC。由于老年代中的对象生命周期比较长，因此Major GC并不频繁，一般都是等待老年代满了后才进行Full GC，而且其速度一般会比Minor GC慢10倍以上。另外，如果分配了Direct Memory，在老年代中进行Full GC时，会顺便清理掉Direct Memory中的废弃对象</p>
</li>
</ul>
<p>下面我们来看如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlotGc</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        <span class="keyword">byte</span>[] holder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>*<span class="number">1024</span>*<span class="number">1024</span>];  </div><div class="line">        System.gc();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>代码很简单，就是向内存中填充了32MB的数据，然后通过虚拟机进行垃圾收集。在Javac编译后，我们执行如下指令：java -verbose:gc SlotGc来查看垃圾收集的结果，得到如下输出信息：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[GC <span class="number">208</span>K-&gt;<span class="number">134</span>K(<span class="number">5056</span>K), <span class="number">0.0017306</span> secs]</div><div class="line"></div><div class="line">[Full GC <span class="number">134</span>K-&gt;<span class="number">134</span>K(<span class="number">5056</span>K), <span class="number">0.0121194</span> secs]</div><div class="line"></div><div class="line">[Full GC <span class="number">32902</span>K-&gt;<span class="number">32902</span>K(<span class="number">37828</span>K), <span class="number">0.0094149</span> sec</div></pre></td></tr></table></figure>
<ul>
<li><p>注意第三行，“-&gt;”之前的数据表示垃圾回收前堆中存活对象所占用的内存大小，“-&gt;”之后的数据表示垃圾回收堆中存活对象所占用的内存大小，括号中的数据表示堆内存的总容量，0.0094149 sec 表示垃圾回收所用的时间。</p>
</li>
<li><p>从结果中可以看出，System.gc(（）运行后并没有回收掉这32MB的内存，这应该是意料之中的结果，因为变量holder还处在作用域内，虚拟机自然不会回收掉holder引用的对象所占用的内存。</p>
</li>
<li><p>我们把代码修改如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlotGc</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        &#123;  </div><div class="line">        <span class="keyword">byte</span>[] holder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>*<span class="number">1024</span>*<span class="number">1024</span>];  </div><div class="line">        &#125;  </div><div class="line">        System.gc();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>加入花括号后，holder的作用域被限制在了花括号之内，因此，在执行System.gc（）时，holder引用已经不能再被访问，逻辑上来讲，这次应该会回收掉holder引用的对象所占的内存。但查看垃圾回收情况时，输出信息如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[GC <span class="number">208</span>K-&gt;<span class="number">134</span>K(<span class="number">5056</span>K), <span class="number">0.0017100</span> secs]</div><div class="line"></div><div class="line">[Full GC <span class="number">134</span>K-&gt;<span class="number">134</span>K(<span class="number">5056</span>K), <span class="number">0.0125887</span> secs]</div><div class="line"></div><div class="line">[Full GC <span class="number">32902</span>K-&gt;<span class="number">32902</span>K(<span class="number">37828</span>K), <span class="number">0.0089226</span> secs]</div></pre></td></tr></table></figure>
<ul>
<li>很明显，这32MB的数据并没有被回收。下面我们再做如下修改：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlotGc</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        &#123;  </div><div class="line">        <span class="keyword">byte</span>[] holder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>*<span class="number">1024</span>*<span class="number">1024</span>];  </div><div class="line">        holder = <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">        System.gc();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这次得到的垃圾回收信息如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[GC <span class="number">208</span>K-&gt;<span class="number">134</span>K(<span class="number">5056</span>K), <span class="number">0.0017194</span> secs]</div><div class="line"></div><div class="line">[Full GC <span class="number">134</span>K-&gt;<span class="number">134</span>K(<span class="number">5056</span>K), <span class="number">0.0124656</span> secs]</div><div class="line"></div><div class="line">[Full GC <span class="number">32902</span>K-&gt;<span class="number">134</span>K(<span class="number">37828</span>K), <span class="number">0.0091637</span> secs]</div></pre></td></tr></table></figure>
<ul>
<li><p>说明这次holder引用的对象所占的内存被回收了。我们慢慢来分析</p>
</li>
<li><p><strong>首先明确一点：holder能否被回收的根本原因是局部变量表中的Slot是否还存有关于holder数组对象的引用</strong></p>
</li>
<li><p>在第一次修改中，虽然在holder作用域之外进行回收，但是在此之后，没有对局部变量表的读写操作，holder所占用的Slot还没有被其他变量所复用（回忆Java内存区域与内存溢出一文中关于Slot的讲解），所以作为GC Roots一部分的局部变量表仍保持者对它的关联。这种关联没有被及时打断，因此GC收集器不会将holder引用的对象内存回收掉。 在第二次修改中，在GC收集器工作前，手动将holder设置为null值，就把holder所占用的局部变量表中的Slot清空了，因此，这次GC收集器工作时将holder之前引用的对象内存回收掉了</p>
</li>
<li><p>当然，我们也可以用其他方法来将holder引用的对象内存回收掉，只要复用holder所占用的slot即可，比如在holder作用域之外执行一次读写操作</p>
</li>
<li><p>为对象赋null值并不是控制变量回收的最好方法，以恰当的变量作用域来控制变量回收时间才是最优雅的解决办法。另外，赋null值的操作在经过虚拟机JIT编译器优化后会被消除掉，经过JIT编译后，System.gc（）执行时就可以正确地回收掉内存，而无需赋null值</p>
</li>
</ul>
<h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><p>Java虚拟机的内存管理与垃圾收集是虚拟机结构体系中最重要的组成部分，对程序（尤其服务器端）的性能和稳定性有着非常重要的影响。性能调优需要具体情况具体分析，而且实际分析时可能需要考虑的方面很多，这里仅就一些简单常用的情况作简要介绍</p>
<ul>
<li><p>我们可以通过给Java虚拟机分配超大堆（前提是物理机的内存足够大）来提升服务器的响应速度，但分配超大堆的前提是有把握把应用程序的Full GC频率控制得足够低，因为一次Full GC的时间造成比较长时间的停顿。控制Full GC频率的关键是保证应用中绝大多数对象的生存周期不应太长，尤其不能产生批量的、生命周期长的大对象，这样才能保证老年代的稳定</p>
</li>
<li><p>Direct Memory在堆内存外分配，而且二者均受限于物理机内存，且成负相关关系，因此分配超大堆时，如果用到了NIO机制分配使用了很多的Direct Memory，则有可能导致Direct Memory的OutOfMemoryError异常，这时可以通过-XX:MaxDirectMemorySize参数调整Direct Memory的大小</p>
</li>
<li><p>除了Java堆和永久代以及直接内存外，还要注意下面这些区域也会占用较多的内存，这些内存的总和会受到操作系统进程最大内存的限制：</p>
</li>
</ul>
<ol>
<li><p><strong>线程堆栈：</strong>可通过-Xss调整大小，内存不足时抛出StackOverflowError（纵向无法分配，即无法分配新的栈帧）或OutOfMemoryError（横向无法分配，即无法建立新的线程）</p>
</li>
<li><p><strong>Socket缓冲区：</strong>每个Socket连接都有Receive和Send两个缓冲区，分别占用大约37KB和25KB的内存。如果无法分配，可能会抛出IOException：Too many open files异常</p>
</li>
<li><p><strong>JNI代码：</strong>如果代码中使用了JNI调用本地库，那本地库使用的内存也不在堆中</p>
</li>
<li><p><strong>虚拟机和GC：</strong>虚拟机和GC的代码执行也要消耗一定的内存</p>
</li>
</ol>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul>
<li><a href="http://blog.csdn.net/ns_code/article/details/18076173" target="_blank" rel="external">传送门</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Javac编译与JIT编译]]></title>
      <url>https://fudawei.github.io/2014/07/23/Javac%E7%BC%96%E8%AF%91%E4%B8%8EJIT%E7%BC%96%E8%AF%91/</url>
      <content type="html"><![CDATA[<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><ul>
<li>不论是物理机还是虚拟机，大部分的程序代码从开始编译到最终转化成物理机的目标代码或虚拟机能执行的指令集之前，都会按照如下图所示的各个步骤进行：</li>
</ul>
<p><br></p>
<p><center><img src="http://dubbo.io/dubbo-architecture-roadmap.jpg-version=1&amp;modificationDate=1331143666000.jpg" alt=""></center><br><br></p>
<ul>
<li><p>其中绿色的模块可以选择性实现。很容易看出，上图中间的那条分支是解释执行的过程（即一条字节码一条字节码地解释执行，如JavaScript），而下面的那条分支就是传统编译原理中从源代码到目标机器代码的生成过程</p>
</li>
<li><p>如今，基于物理机、虚拟机等的语言，大多都遵循这种基于现代经典编译原理的思路，在执行前先对程序源码进行词法解析和语法解析处理，把源码转化为抽象语法树。<strong>对于一门具体语言的实现来说，词法和语法分析乃至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。也可以把抽象语法树或指令流之前的步骤实现一个半独立的编译器，这类代表是Java语言。又或者可以把这些步骤和执行引擎全部集中在一起实现，如大多数的JavaScript执行器</strong></p>
</li>
</ul>
<a id="more"></a>
<h2 id="javac编译"><a href="#javac编译" class="headerlink" title="javac编译"></a>javac编译</h2><ul>
<li><p>在Java中提到“编译”，自然很容易想到Javac编译器将<em>.java文件编译成为</em>.class文件的过程，<strong>这里的Javac编译器称为前端编译器</strong>，其他的前端编译器还有诸如Eclipse JDT中的增量式编译器ECJ等。相对应的还有<strong>后端编译器</strong>，它在程序运行期间将字节码转变成机器码<strong>（现在的Java程序在运行时基本都是解释执行加编译执行）</strong>，如<strong>HotSpot虚拟机自带的JIT（Just In Time Compiler）编译器（分Client端和Server端）</strong>。另外，有时候还有可能会碰到静态提前编译器（AOT，Ahead Of Time Compiler）直接把*.java文件编译成本地机器代码，如GCJ、Excelsior JET等，这类编译器我们应该比较少遇到。</p>
</li>
<li><p>下面简要说下Javac编译（前端编译）的过程</p>
</li>
</ul>
<h3 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h3><ul>
<li><p>词法分析是将源代码的字符流转变为标记（Token）集合。单个字符是程序编写过程中的的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符等都可以成为标记，比如整型标志int由三个字符构成，但是它只是一个标记，不可拆分</p>
</li>
<li><p>语法分析是根据Token序列来构造抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，如bao、类型、修饰符、运算符等。经过这个步骤后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在<strong>抽象语法树之</strong>上</p>
</li>
</ul>
<h3 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h3><ul>
<li>完成了语法分析和词法分析之后，下一步就是填充符号表的过程。符号表是由一组符号地址和符号信息构成的表格。符号表中所登记的信息在编译的不同阶段都要用到，在语义分析（后面的步骤）中，符号表所登记的内容将用于语义检查和产生中间代码，在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据</li>
</ul>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是读结构上正确的源程序进行上下文有关性质的审查。语义分析过程分为标注检查和数据及控制流分析两个步骤：</p>
<ul>
<li><p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量和赋值之间的数据类型是否匹配等</p>
</li>
<li><p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题</p>
</li>
</ul>
<h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><ul>
<li>字节码生成是Javac编译过程的最后一个阶段。字节码生成阶段不仅仅是把前面各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。 实例构造器<init>（）方法和类构造器<clinit>（）方法就是在这个阶段添加到语法树之中的（这里的实例构造器并不是指默认的构造函数，而是指我们自己重载的构造函数，如果用户代码中没有提供任何构造函数，那编译器会自动添加一个没有参数、访问权限与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成了）</clinit></init></li>
</ul>
<h2 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h2><ul>
<li><p>Java程序最初是仅仅通过解释器解释执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其当某个方法或代码块运行的特别频繁时，这种方式的执行效率就显得很低。于是后来在虚拟机中引入了<strong>JIT编译器（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器</strong></p>
</li>
<li><p>现在主流的商用虚拟机（如Sun HotSpot、IBM J9）中几乎都同时包含解释器和编译器（三大商用虚拟机之一的JRockit是个例外，它内部没有解释器，因此会有启动相应时间长之类的缺点，但它主要是面向服务端的应用，这类应用一般不会重点关注启动时间）。二者各有优势：<strong>当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率。解释执行可以节约内存，而编译执行可以提升效率</strong></p>
</li>
<li><p>HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作</p>
</li>
</ul>
<h3 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h3><p>运行过程中会被即时编译器编译的“热点代码”有两类：</p>
<ul>
<li><p>被多次调用的方法</p>
</li>
<li><p>被多次调用的循环体</p>
</li>
</ul>
<p>两种情况，编译器都是以整个方法作为编译对象，这种编译也是虚拟机中标准的编译方式。要知道一段代码或方法是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）。目前主要的热点 判定方式有以下两种：</p>
<ul>
<li><p><strong>基于采样的热点探测：</strong>采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测</p>
</li>
<li><p><strong>基于计数器的热点探测：</strong>采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨</p>
</li>
</ul>
<p>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器</p>
<ul>
<li><p>方法调用计数器用来统计方法调用的次数，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数</p>
</li>
<li><p>回边计数器用于统计一个方法中循环体代码执行的次数（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”</p>
</li>
<li><p>在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阀值，当计数器的值超过了阀值，就会触发JIT编译。触发了JIT编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本</p>
</li>
<li><p>由于方法计数器触发即时编译的过程与回边计数器触发即时编译的过程类似，因此这里仅给出方法调用计数器触发即时编译的流程：</p>
</li>
</ul>
<p><img src="http://o99dg8ap9.bkt.clouddn.com/Javac%E7%BC%96%E8%AF%91%E4%B8%8EJIT%E7%BC%96%E8%AF%911.jpg" alt=""></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Javac字节码编译器与虚拟机内的JIT编译器的执行过程合起来其实就等同于一个传统的编译器所执行的编译过程</li>
</ul>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul>
<li><a href="http://blog.csdn.net/ns_code/article/details/18009455" target="_blank" rel="external">传送门</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多态性实现机制——静态分派与动态分派]]></title>
      <url>https://fudawei.github.io/2014/07/23/%E5%A4%9A%E6%80%81%E6%80%A7%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/</url>
      <content type="html"><![CDATA[<h3 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h3><ul>
<li><p>Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。这个特性给Java带来了更强大的动态扩展能力，使得可以在类运行期间才能确定某些目标方法的直接引用，称为动态连接，也有一部分方法的符号引用在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。这在前面的“Java内存区域与内存溢出”一文中有提到</p>
</li>
<li><p>静态解析成立的前提是：方法在程序真正执行前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在编译器进行编译时就必须确定下来，这类方法的调用称为解析</p>
</li>
<li><p>在Java语言中，<strong>符合“编译器可知，运行期不可变”这个要求的方法主要有静态方法和私有方法两大类</strong>，前者与类型直接关联，后者在外部不可被访问，这两种方法都不可能通过继承或别的方式重写出其他的版本，<strong>因此它们都适合在类加载阶段进行解析</strong></p>
</li>
</ul>
<p>Java虚拟机里共提供了四条方法调用字节指令，分别是：</p>
<ul>
<li><p>invokestatic：调用静态方法</p>
</li>
<li><p>invokespecial：调用实例构造器<init>方法、私有方法和父类方法</init></p>
</li>
<li><p>invokevirtual：调用所有的虚方法</p>
</li>
<li><p>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象</p>
</li>
</ul>
<a id="more"></a>
<p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法四类，它们在类加载时就会把符号引用解析为该方法的直接引用。这些方法可以称为<strong>非虚方法</strong>（还包括final方法），与之相反，其他方法就称为<strong>虚方法</strong>（final方法除外）。这里要特别说明下final方法，虽然调用final方法使用的是invokevirtual指令，但是由于它无法覆盖，没有其他版本，所以也无需对方发接收者进行多态选择。Java语言规范中明确说明了final方法是一种非虚方法</p>
<ul>
<li>解析调用一定是个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用转化为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是静态的也可能是动态的，根据分派依据的宗量数（方法的调用者和方法的参数统称为方法的宗量）又可分为单分派和多分派。两类分派方式两两组合便构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况</li>
</ul>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><ul>
<li><strong>所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派，静态分派的最典型应用就是多态性中的方法重载。</strong>静态分派发生在编译阶段，因此确定静态分配的动作实际上不是由虚拟机来执行的。下面通过一段方法重载的示例程序来更清晰地说明这种分派机制：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;  </div><div class="line">&#125;    </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticPai</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Human hum)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"I am human"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Man hum)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"I am man"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Woman hum)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"I am woman"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        Human man = <span class="keyword">new</span> Man();  </div><div class="line">        Human woman = <span class="keyword">new</span> Woman();  </div><div class="line">        StaticPai sp = <span class="keyword">new</span> StaticPai();  </div><div class="line">        sp.say(man);  </div><div class="line">        sp.say(woman);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>上面代码的执行结果如下：</p>
<blockquote>
<p>I am human<br>I am human</p>
</blockquote>
</li>
<li><p>以上结果的得出应该不难分析。在分析为什么会选择参数类型为Human的重载方法去执行之前，先看如下代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Human man = <span class="keyword">new</span> Man（）;</div></pre></td></tr></table></figure>
<ul>
<li><p>我们把上面代码中的<strong>“Human”称为变量的静态类型</strong>，后面的<strong>“Man”称为变量的实际类型</strong>。静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的，而实际类型变化的结果在运行期才可确定</p>
</li>
<li><p>回到上面的代码分析中，在调用say（）方法时，方法的调用者（回忆上面关于宗量的定义，方法的调用者属于宗量）都为sp的前提下，使用哪个重载版本，完全取决于传入参数的数量和数据类型（方法的参数也是数据宗量）。代码中刻意定义了两个静态类型相同、实际类型不同的变量，可见<strong>编译器（不是虚拟机，因为如果是根据静态类型做出的判断，那么在编译期就确定了）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。</strong>并且静态类型是编译期可知的，所以在编译阶段，Javac编译器就根据参数的静态类型决定使用哪个重载版本。这就是静态分派最典型的应用</p>
</li>
</ul>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><ul>
<li>动态分派与多态性的另一个重要体现——方法覆写有着很紧密的关系。向上转型后调用子类覆写的方法便是一个很好地说明动态分派的例子。这种情况很常见，因此这里不再用示例程序进行分析。很显然，在判断执行父类中的方法还是子类中覆盖的方法时，如果用静态类型来判断，那么无论怎么进行向上转型，都只会调用父类中的方法，但实际情况是，根据对父类实例化的子类的不同，调用的是不同子类中覆写的方法，<strong>很明显，这里是要根据变量的实际类型来分派方法的执行版本的。而实际类型的确定需要在程序运行时才能确定下来，这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派</strong></li>
</ul>
<h3 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h3><ul>
<li><p>前面给出：方法的接受者（亦即方法的调用者）与方法的参数统称为方法的宗量。但分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择</p>
</li>
<li><p>为了方便理解，下面给出一段示例代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eat</span></span>&#123;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drink</span></span>&#123;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Eat arg)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"爸爸在吃饭"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Drink arg)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"爸爸在喝水"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Eat arg)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"儿子在吃饭"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Drink arg)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"儿子在喝水"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDoublePai</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        Father father = <span class="keyword">new</span> Father();  </div><div class="line">        Father child = <span class="keyword">new</span> Child();  </div><div class="line">        father.doSomething(<span class="keyword">new</span> Eat());  </div><div class="line">        child.doSomething(<span class="keyword">new</span> Drink());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>运行结果应该很容易预测到，如下：</li>
</ul>
<blockquote>
<p>爸爸在吃饭<br>    儿子在喝水</p>
</blockquote>
<ul>
<li><p>我们首先来看编译阶段编译器的选择过程，即静态分派过程。这时候选择目标方法的依据有两点：一是方法的接受者（即调用者）的静态类型是Father还是Child，二是方法参数类型是Eat还是Drink。<strong>因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型</strong></p>
</li>
<li><p>再来看运行阶段虚拟机的选择，即动态分派过程。由于编译期已经了确定了目标方法的参数类型（编译期根据参数的静态类型进行静态分派），因此唯一可以影响到虚拟机选择的因素只有此方法的接受者的实际类型是Father还是Child。<strong>因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型</strong></p>
</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/%E5%A4%9A%E6%80%81%E6%80%A7%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE.jpg" alt=""></center>

<ul>
<li>根据以上论证，我们可以总结如下：目前的Java语言（JDK1.6）是一门<strong>静态多分派、动态单分派的语言</strong></li>
</ul>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul>
<li><a href="http://blog.csdn.net/ns_code/article/details/17965867" target="_blank" rel="external">传送门</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Class类文件结构]]></title>
      <url>https://fudawei.github.io/2014/07/17/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h3 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h3><ul>
<li>如图，源码经过编译得到的字节码文件可以由运行Java虚拟机的机器运行，因此可以说字节码是Java语言跨平台的基石，同样也是其他语言跨平台的有效途径</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt=""></center>

<ul>
<li>只要目标语言的编译器按照Java字节码存储规范进行编译，那么得到的class文件都可以被正确执行</li>
</ul>
<a id="more"></a>
<h3 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h3><ul>
<li><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据。根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种伪结构中只有两种数据类型：<strong>无符号数和表</strong></p>
</li>
<li><p>无符号数属于基本数据类型，主要可以用来描述数字、索引符号、数量值或者按照UTF-8编码构成的字符串值，大小使用u1、u2、u4、u8分别表示1字节、2字节、4字节和8字节</p>
</li>
<li><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯以“_info”结尾。那么表是干嘛的呢？<strong>表主要用于描述有层次关系的复合结构的数据，比如方法、字段</strong>。需要注意的是class文件是没有分隔符的，所以每个的二进制数据类型都是严格定义的</p>
</li>
<li><p>整个Class文件本质上就是一张表，它由如下所示的数据项构成</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>magic(魔术)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version(次版本号)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version(主版本号)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count(常量个数)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool(常量池表)</td>
<td style="text-align:center">constant_pool_count - 1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags(类的访问控制权限)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class(类名)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class(父类名)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count(接口个数)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces(接口名)</td>
<td style="text-align:center">interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count(域个数)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields(域的表)</td>
<td style="text-align:center">fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count(方法的个数)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods(方法表)</td>
<td style="text-align:center">methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attribute_count(附加属性的个数)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes(附加属性的表)</td>
<td style="text-align:center">attributes_count</td>
</tr>
</tbody>
</table>
<ul>
<li><p>从表中可以看出，无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的该数据项的形式，称这一系列连续的摸一个类型的数据为某一类型的集合，比如，fields_count个field_info表数据构成了字段表集合。这里需要说明的是：Class文件中的数据项，都是严格按照上表中的顺序和数量被严格限定的，每个字节代表的含义，长度，先后顺序等都不允许改变</p>
</li>
<li><p>在class文件中，主要分为魔数、Class文件的版本号、常量池、访问标志、类索引（还包括父类索引和接口索引集合）、字段表集合、方法表集合、属性表集合。下面就分别对每一种文件进行说明</p>
</li>
</ul>
<h3 id="魔数与Class文件版本号"><a href="#魔数与Class文件版本号" class="headerlink" title="魔数与Class文件版本号"></a>魔数与Class文件版本号</h3><ul>
<li><p>每个class字节码文件头4个字节为魔数，作用是用于确定该文件是否能被虚拟机接受，固定为0xCAFEBABE</p>
</li>
<li><p>第5和第6个字节是次版本号，第7和第8是主版本号。因此，字节码文件的版本号确定了能执行该程序的虚拟机JDK版本。</p>
</li>
<li><p>用Sublime text打开自己的一个class文件，主版本号是50，因此要求JDK至少是1.6以上版本</p>
</li>
</ul>
<blockquote>
<p>cafe babe 0000 0032 00f1 0a00 3d00 7707<br>0078 0800 790a 0002 007a 0700 7b0a 0005<br>0077 0800 7c0a 0005 007d 0800 7e0a 0005<br>007f 0a00 8000 810a 001a 0082 0a00 1a00<br>830a 001a 0084 0700 850a 000f 0077 0800<br>860b 0087 0088 0700 890b 008a 008b 0800<br>8c08 008d 0800 8e07 008f 0800 9007 0091<br>0700 9207 0093 0700 940a 001d 007a 0a00<br>1c00 950a 001b 0096 0a00 1b00 9708 0098<br>0a00 9900 9a08 009b 0800 9c0a 001a 009d</p>
</blockquote>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul>
<li><p>常量池可以简单理解为class文件的资源从库，这种数据类型是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的项目之一</p>
</li>
<li><p>常量池中主要存放两大类常量：字面量和符号引用。字面量比较接近于Java层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用总结起来则包括了下面三类常量：</p>
</li>
<li><p><strong>类和接口的全限定名（即带有包名的Class名，如：org.lxh.test.TestClass）</strong></p>
</li>
<li><p><strong>字段的名称和描述符（private、static等描述符）</strong></p>
</li>
<li><p><strong>方法的名称和描述符（private、static等描述符）</strong></p>
</li>
</ul>
<p>虚拟机在加载Class文件时才会进行动态连接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中</p>
<h4 id="符号引用和直接引用的区别与关联"><a href="#符号引用和直接引用的区别与关联" class="headerlink" title="符号引用和直接引用的区别与关联"></a>符号引用和直接引用的区别与关联</h4><ul>
<li><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中</p>
</li>
<li><p>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。<strong>如果有了直接引用，那说明引用的目标必定已经存在于内存之中了</strong></p>
</li>
</ul>
<p>在常量池中每一项常量都是一个表，在jdk1.7中共有14中常量类型，所以常量池的项目就对应14张表，这14张表的每种类型都不一样。但是有一个共同特点：表开始的第一位都是一个u1类型的标志位，代表这个常量属于哪种类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标记</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整形字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整形字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类&amp;接口符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口方法符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段&amp;方法部分符号引用</td>
</tr>
</tbody>
</table>
<ul>
<li>需要注意的是，在Class文件中，方法、字段都需要引用CONSTANT-Utf8_info类型的常量，所以这种类型的常量的长度有一定的限制，也就是Java中方法、字段的最大长度。在CONSTANT-Utf8_info中，其length的值u2，<strong>说明Java虚拟机只能编译最大大约64KB的变量或者方法名。超过的话将不会进行编译</strong></li>
</ul>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><ul>
<li>常量池之后的数据结构是访问标志(access_flags),这个标志主要用于识别一些类或者接口层次的访问信息，主要包括：这个Class是类还是接口、是否定义public、是否定义abstract类型；如果是类的话是否被声明为final等。具体的标志访问如下：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%844.jpg" alt=""></center>

<h3 id="类索引、父类索引和接口索引集合"><a href="#类索引、父类索引和接口索引集合" class="headerlink" title="类索引、父类索引和接口索引集合"></a>类索引、父类索引和接口索引集合</h3><ul>
<li>这个数据项主要用于确定这个类的继承关系。其中类索引和父类所以都是一个u2类型的数据，而接口索引集合是一组u2类型的数据。在Java中由于不允许多继承，所以父类索引是唯一的，但是一个类可以实现多个接口，所以得到的接口索引是一个集合，表示这个类实现了哪些接口</li>
</ul>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表用于描述接口或者类中声明的变量。字段包括类级变量和实例级变量，但是不包括方法内部声明的局部变量（这些变量是存储在Java虚拟机栈中的局部变量表中的）。自然，描述一个字段的信息包括：字段的作用域（public、protected、private）、实例变量与否（static）、可变性（final）、并发可见性（volatile）、可否被序列化（transient）、字段数据类型（基本数据类型、对象、数组）、字段名称。字段的信息也被存放在一张表中，其字段表包括三种类型：</p>
<ul>
<li><p>u2类型访问标志（access_flags）</p>
</li>
<li><p>u2类型的name_index（字段的简单名称）</p>
</li>
<li><p>u2类型的描述符（descriptor_index）</p>
</li>
</ul>
<p>其访问标志在access_flags中，如下图所示：</p>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%843.jpg" alt=""></center>

<ul>
<li>上面出现了简单名称，上文中出现了全限定名，以及这里出现的描述符，三者有什么区别呢？其中全限定名称比较好理解，就是类的完整路径信息。而简单名称则是指没有类型和参数修饰的方法或者字段名称，比如一个方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">    System.out.println(a+b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么这个方法的简单名称就是inc。</p>
<ul>
<li>相对于以上两者，描述符相对复杂一些。描述符的主要的作用是描述字段的数据类型、方法的参数列表和返回值。其中我们熟悉的void，在Class文件中用V表示。下面是完整的描述符标志的含义：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%842.jpg" alt=""></center>

<ul>
<li><p>对于数组类型，每一维度使用一个前置的“[”字符描述，如果是二维数组，那么就有两个“[”符号。比如“java.lang.String[][]”会被记录成“[[Ljava.lang.String;”</p>
</li>
<li><p>对于方法，则是按照县参数列表后返回值的顺序进行描述的。比如方法int inc(int a,int[] b,char[][] c,int d)的描述符是“(I[I[[CI)I”</p>
</li>
</ul>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><ul>
<li><p>JVM中堆方法表的描述与字段表是一致的，包括了：访问标志、名称索引、描述符索引、属性表集合。方法表单额结构与字段表是一致的，区别在于访问标志的不同.在方法中不能了用volatile和transient关键字修饰，所以这两个标志不能用在方法表中。在方法中添加了字段不能使用的访问标志，比如方法可以使用synchronized、native、strictfp、abstract关键字修饰，所以在方法表中就增加了相应的访问标志</p>
</li>
<li><p>要注意的是，如果父类方法没有在子类中重写，那么在方法中不会自动出现来自父类的方法信息。同样的，有可能添加编译器自动增加的方法，比如方法</p>
</li>
</ul>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><ul>
<li>前面的Class文件、字段表和方法表都可以携带自己的属性信息，这个信息用属性表进行描述，用于描述某些场景专有的信息。在属性表中没有类似Class文件的数据项目类型和顺序的严格要求，只要新的属性不与现有的属性名重复，任何人都可以向属性表中写入自己定义的属性信息</li>
</ul>
<h4 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h4><ul>
<li>Java程序方法体中的代码经过javac编译最终编译成的字节码指令就保存在Code属性中。但是并非所有的方法表都必须存在这个属性。Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code）和元数据（Metadata，包括类、字段、方法定义及其其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有其他的数据项目都用于描述元数据</li>
</ul>
<h4 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h4><ul>
<li>这个属性的作用是列举出方法中可能抛出的受查异常（Checked Exception），也就是描述throws 后的列举的异常</li>
</ul>
<h4 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h4><ul>
<li>主要用于描述Java源代码行号与字节码行号之间的对应关系。这个属性也不是必须的。如果没有这个属性，对程序的直接影响就是当抛出异常的时候无法显示对应的行号；并且在调试的时候无法通过设置断点的方法是调试程序</li>
</ul>
<h4 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h4><ul>
<li>用于描述栈帧中局部变量表中的变量与Java源码中定义的变量的之间的关系。也不属于必须的属性。如果没有这个属性，产生的直接影响就是当别人引用这个方法的时候，所有的参数名称都会丢失，IDE将会使用诸如args0、args1之类的参数进行显示。自然，当调试程序的时候，显示的参数名称是不可知的</li>
</ul>
<h4 id="SourceFile属性"><a href="#SourceFile属性" class="headerlink" title="SourceFile属性"></a>SourceFile属性</h4><ul>
<li>用于记录这个Class文件的源码文件名称。如果不使用这个属性，那么当抛出异常的时候，堆栈中将不会显示出错代码所属的文件名</li>
</ul>
<h4 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h4><p>作用是通知虚拟机自动为静态变量赋值。要注意的是，只有被static关键字修饰的额变量才可以使用这个属性（类变量）。对于非类变量，初始化是在方法中进行的；对于类变量可以选择两种方式进行变量的初始化：一是在类构造器方法中使用；二是是ConstantValue属性。目前Sun Hotspot的选择原则是：如果一个变量同时使用static和final关键字修饰，并且这个变量是基本数据类型或者java.lang.String类型的话，就使用ConstantValue属性进行初始化。如果没有被final修饰或者并非是基本数据类型，那么将会选择使用方法进行初始化</p>
<h4 id="InnerClass属性"><a href="#InnerClass属性" class="headerlink" title="InnerClass属性"></a>InnerClass属性</h4><ul>
<li>这个属性主要用于记录内部类与宿主类之间的关联关系</li>
</ul>
<h4 id="Deprecated以及Synthetic属性"><a href="#Deprecated以及Synthetic属性" class="headerlink" title="Deprecated以及Synthetic属性"></a>Deprecated以及Synthetic属性</h4><ul>
<li><p>这两个属性都属于标志类型的布尔属性，只存在有没有的区别。</p>
</li>
<li><p>Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，可以通过注解@deprecated实现</p>
</li>
<li><p>Synthetic属性代表此字段并不是由Java源码产生的，而是通过编译器自行添加的</p>
</li>
</ul>
<h4 id="StackMapTable属性"><a href="#StackMapTable属性" class="headerlink" title="StackMapTable属性"></a>StackMapTable属性</h4><ul>
<li>该属性的目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器</li>
</ul>
<h4 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h4><ul>
<li>这个属性是专门用来记录泛型类型的，因为在Java语言采用的是擦除法实现的泛型，在字节码（Code属性）中，泛型信息编译之后会被擦除。擦除法的优点是能够节省泛型所占的内存空间，缺点是在运行期间无法通过反射得到泛型信息，而Signature属性则弥补了这一缺陷。现在的Java反射API已经能够得到泛型信息，功劳就在于这个属性</li>
</ul>
<h4 id="BootstrapMethods属性"><a href="#BootstrapMethods属性" class="headerlink" title="BootstrapMethods属性"></a>BootstrapMethods属性</h4><ul>
<li>这个属性用于保存invokedynamic指令引用的引导方法限定符。（该指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法）</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java内存区域与内存溢出]]></title>
      <url>https://fudawei.github.io/2014/07/15/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
      <content type="html"><![CDATA[<h3 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h3><p><center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.png" alt=""></center><br><a id="more"></a></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li><p>当前线程所执行的字节码的行号指示器</p>
</li>
<li><p>当前线程私有</p>
</li>
<li><p>不会出现OutOfMemoryError情况</p>
</li>
</ul>
<h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h3><ul>
<li><p>线程私有，生命周期与线程相同</p>
</li>
<li><p>java方法执行的内存模型，每个方法执行的同时都会创建一个栈帧，存储局部变量表(基本类型、对象引用)、操作数栈、动态链接、方法出口等信息</p>
</li>
<li><p>在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现</p>
</li>
<li><p>StackOverflowError异常：当线程请求的栈深度大于虚拟机所允许的深度</p>
</li>
<li><p>OutOfMemoryError异常：如果栈的扩展时无法申请到足够的内存</p>
</li>
</ul>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><ul>
<li><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量</p>
</li>
<li><p>存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和returnAddress类型（它指向了一条字节码指令的地址）</p>
</li>
<li><p>局部变量表所需的内存空间在编译期间完成分配，即在Java程序被编译成Class文件时，就确定了所需分配的最大局部变量表的容量</p>
</li>
<li><p>当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小</p>
</li>
</ul>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><ul>
<li><p>操作数栈又称为操作栈 </p>
</li>
<li><p>操作数栈的最大深度在编译的时候确定</p>
</li>
<li><p>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。因此我们也称Java虚拟机是基于栈的，这点不同于Android虚拟机，Android虚拟机是基于寄存器的</p>
</li>
<li><p>基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些；而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差</p>
</li>
</ul>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><ul>
<li>每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接</li>
</ul>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><ul>
<li>当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息</li>
</ul>
<ul>
<li>方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>与虚拟机栈相似，主要为虚拟机使用到的Native方法服务，在HotSpot虚拟机中直接把本地方法栈与虚拟机栈二合一</li>
</ul>
<h3 id="Java堆-Java-Heap"><a href="#Java堆-Java-Heap" class="headerlink" title="Java堆(Java Heap)"></a>Java堆(Java Heap)</h3><ul>
<li><p>Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域</p>
</li>
<li><p>几乎所有的对象实例和数组都在这类分配内存 </p>
</li>
<li><p>Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆” </p>
</li>
<li><p>Java堆只要求在逻辑上是连续的</p>
</li>
<li><p>在虚拟机启动时创建</p>
</li>
<li><p>OutOfMemoryError异常：当在堆中没有内存完成实例分配，且堆也无法再扩展时</p>
</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li><p>线程间共享</p>
</li>
<li><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p>
</li>
<li><p>OutOfMemoryError异常：当方法区无法满足内存的分配需求时</p>
</li>
</ul>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul>
<li><p>方法区的一部分</p>
</li>
<li><p>用于存放编译期生成的各种字面量与符号引用</p>
</li>
<li><p>OutOfMemoryError异常：当常量池无法再申请到内存时</p>
</li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul>
<li><p>NIO可以使用Native函数库直接分配堆外内存，堆中的DirectByteBuffer对象作为这块内存的引用进行操作</p>
</li>
<li><p>大小不受Java堆大小的限制，受本机(服务器)内存限制</p>
</li>
<li><p>OutOfMemoryError异常：系统内存不足时</p>
</li>
</ul>
<h3 id="HotSpot虚拟机"><a href="#HotSpot虚拟机" class="headerlink" title="HotSpot虚拟机"></a>HotSpot虚拟机</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>虚拟机遇到一条new指令时，首先将去检查这个对象的参数是否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，必须先执行类的加载过程。<br>在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存大小再类加载完成后便可确定。内存分配可以采用“指针碰撞”与“空闲列表”的方式</p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>java程序需要通过栈上的reference数据来操作堆上的具体对象。访问方式有使用句柄和直接指针两种。</p>
<ul>
<li>句柄访问 java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</li>
</ul>
<p><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAvern%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt=""></p>
<ul>
<li>直接指针访问 java堆对象的布局中必须考虑如何放置访问类型数据的相关信息，reference中存储的就是对象地址</li>
</ul>
<p><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAvern%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt=""></p>
<h4 id="两种访问方式的比较"><a href="#两种访问方式的比较" class="headerlink" title="两种访问方式的比较"></a>两种访问方式的比较</h4><ul>
<li><p>使用句柄访问最大的好处是reference中存储的是稳定的句柄地址，在对象被移动（GC时移动对象是很普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改</p>
</li>
<li><p>使用直接指针访问方式的最大好处是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本</p>
</li>
<li><p>HotSpot虚拟机采用指针访问方式进行对象访问，从整个软件开发范围看，各种语言和框架使用句柄来访问的情况也非常常见</p>
</li>
</ul>
<h3 id="内存溢出测试方法"><a href="#内存溢出测试方法" class="headerlink" title="内存溢出测试方法"></a>内存溢出测试方法</h3><table>
<thead>
<tr>
<th>内存区域</th>
<th style="text-align:left">内存溢出的测试方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java堆</td>
<td style="text-align:left">无限循环地new对象出来，在List中保存引用，以不被垃圾收集器回收。另外，该区域也有可能发生内存泄露（Memory Leak），出现问题时，要注意区别</td>
</tr>
<tr>
<td>方法区</td>
<td style="text-align:left">生成大量的动态类，或无线循环调用String的intern()方法产生不同的String对象实例，并在List中保存其引用，以不被垃圾收集器回收。后者测试常量池，前者测试方法区的非常量池部分</td>
</tr>
<tr>
<td>虚拟机栈和本地方法栈</td>
<td style="text-align:left">单线程：递归调用一个简单的方法（如不断累积的方法）会抛出StackOverError <br><br>多线程：无限循环地创建线程，并为每个线程无限循环地增加内存，会抛出OutOfMemoryError</td>
</tr>
</tbody>
</table>
<ul>
<li>这里有一点要重点说明，在多线程情况下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常</li>
</ul>
<h3 id="OutOfMemoryError异常实例"><a href="#OutOfMemoryError异常实例" class="headerlink" title="OutOfMemoryError异常实例"></a>OutOfMemoryError异常实例</h3><ul>
<li><p>内存泄露，对象已经死了，无法通过垃圾收集器进行自动回收，通过找出泄露的代码位置和原因，才好确定解决方案</p>
</li>
<li><p>内存溢出，内存中的对象都还必须存活着，这说明Java堆分配空间不足，检查堆设置大小（-Xmx与-Xms），检查代码是否存在对象生命周期太长、持有状态时间过长的情况</p>
</li>
</ul>
<h4 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h4><ul>
<li><p>Java堆用于存储对象实例，我们只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免GC清除这些对象，就会在对象数量到达最大堆的容量限制后产生内存溢出异常</p>
</li>
<li><p>VM Args: -Xms10m -Xmx10m</p>
</li>
<li><p>-XX:+HeapDumpOnOutOfMemoryError</p>
</li>
<li><p>XX:+HeapDumpOnOutOfMemoryError这个参数可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList; </div><div class="line"><span class="keyword">import</span> java.util.List; </div><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xms10m -Xmx10m -XX:+HeapDumpOnOutOfMemoryError</div><div class="line"> */ </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123; </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123; </div><div class="line">        <span class="keyword">private</span> String name; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OOMObject</span><span class="params">(String name)</span> </span>&#123; </div><div class="line">            <span class="keyword">this</span>.name = name; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </div><div class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;(); </div><div class="line">        <span class="keyword">long</span> i = <span class="number">1</span>; </div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; </div><div class="line">            list.add(<span class="keyword">new</span> OOMObject(<span class="string">"IpConfig..."</span> + i++)); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>抛出的异常：</li>
</ul>
<blockquote>
<p>Dumping heap to java_pid27828.hprof …<br>Heap dump file created [14123367 bytes in 0.187 secs]<br>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space<br>at java.lang.AbstractStringBuilder.&lt;init&gt;(AbstractStringBuilder.java:45)<br>at java.lang.StringBuilder.&lt;init&gt;(StringBuilder.java:92)<br>at com.baoxian.HeapOOM.main(HeapOOM.java:22)</p>
</blockquote>
<p>注：出现Java堆内存溢出时，异常堆栈信息java.lang.OutOfMemoryError后面会紧跟着JavaHeapSpace。</p>
<p>要解决这个异常，一般手段是首先通过内存映像分析工具比如Eclipse Memory Analyzer对dump出来的堆转储快照进行分析，重点是确认内存中对象是否是必要的，也就是要弄清楚到底是出现了内存泄露Memory Leak还是内存溢出Memory Overflow。</p>
<p>如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们。掌握了泄露对象的类型信息，以及GC Roots引用链的信息，就可以比较准确的定位出泄露代码的位置了。</p>
<p>如果不存在泄露，那么就该修改-Xms和-Xms堆参数看能否加大点。</p>
<h4 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h4><ul>
<li>-Xoss参数设置本地方法栈大小，对于HotSpot没用。栈容量只由-Xss参数设定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xss128k</div><div class="line"> * <span class="doctag">@author</span> Administrator</div><div class="line"> *</div><div class="line"> */ </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123; </div><div class="line">        stackLength++; </div><div class="line">        stackLeak(); </div><div class="line">    &#125; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123; </div><div class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF(); </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            oom.stackLeak(); </div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; </div><div class="line">            System.out.println(<span class="string">"stack length: "</span> + oom.stackLength); </div><div class="line">            <span class="keyword">throw</span> e; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>抛出异常：</li>
</ul>
<blockquote>
<p>stack length: 1007<br>Exception in thread “main” java.lang.StackOverflowError<br>at com.baoxian.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)<br>at com.baoxian.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)<br>at com.baoxian.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)<br>at com.baoxian.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)</p>
</blockquote>
<h4 id="运行时常量池溢出"><a href="#运行时常量池溢出" class="headerlink" title="运行时常量池溢出"></a>运行时常量池溢出</h4><ul>
<li>运行时常量池分配在方法区内，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList; </div><div class="line"><span class="keyword">import</span> java.util.List; </div><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M</div><div class="line"> */ </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </div><div class="line">        <span class="comment">// 使用List保持着常量池引用，避免Full GC回收常量池行为 </span></div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;;(); </div><div class="line">        <span class="comment">// 10MB的PermSize在integer范围内足够产生OOM了 </span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </div><div class="line">            list.add(String.valueOf(i++).intern()); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>异常：</li>
</ul>
<blockquote>
<p>Exception in thread “main” java.lang.OutOfMemoryError: PermGen space<br>at java.lang.String.intern(Native Method)<br>at com.baoxian.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:18)</p>
</blockquote>
<ul>
<li>运行时常量池溢出，在java.lang.OutOfMemoryError后面紧跟着是PermGen space</li>
</ul>
<h4 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h4><ul>
<li><p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述符、方法描述等。对于这个区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。比如动态代理会生成动态类</p>
</li>
<li><p>使用CGLib技术直接操作字节码运行，生成大量的动态类。当前很多主流框架如Spring和Hibernate对类进行增强都会使用CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存</p>
</li>
<li><p>异常：</p>
</li>
</ul>
<blockquote>
<p>Exception in thread “main” java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method)</p>
</blockquote>
<ul>
<li><p>同样，跟常量池一样，都是PermGen space字符串出现</p>
</li>
<li><p>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是非常苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用GCLib字节码技术外，常见的还有：大量JSP或动态产生的JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi应用等</p>
</li>
</ul>
<h4 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h4><ul>
<li><p>DirectMemory容量可以通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值-Xmx指定一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M</div><div class="line"> */ </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </div><div class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>]; </div><div class="line">        unsafeField.setAccessible(<span class="keyword">true</span>); </div><div class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>); </div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; </div><div class="line">            unsafe.allocateMemory(_1MB); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在OutOfMemoryError后面不会有任何东西了，这就是DirectMemory内存溢出了</p>
</li>
</ul>
<h3 id="Java中获取JVM内存使用情况"><a href="#Java中获取JVM内存使用情况" class="headerlink" title="Java中获取JVM内存使用情况"></a>Java中获取JVM内存使用情况</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.text.DecimalFormat;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line">* 显示JVM总内存，JVM最大内存和总空闲内存</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayAvailableMemory</span><span class="params">()</span> </span>&#123;</div><div class="line"> </div><div class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(“<span class="number">0.00</span>″) ;</div><div class="line"> </div><div class="line"><span class="comment">//显示JVM总内存</span></div><div class="line"><span class="keyword">long</span> totalMem = Runtime.getRuntime().totalMemory();</div><div class="line"> </div><div class="line">System.out.println(df.format(totalMem <span class="number">1000000F</span>) + ” MB”);</div><div class="line"> </div><div class="line"><span class="comment">//显示JVM尝试使用的最大内存</span></div><div class="line"><span class="keyword">long</span> maxMem = Runtime.getRuntime().maxMemory();</div><div class="line">System.out.println(df.format(maxMem <span class="number">1000000F</span>) + ” MB”);</div><div class="line"> </div><div class="line"><span class="comment">//空闲内存</span></div><div class="line"><span class="keyword">long</span> freeMem = Runtime.getRuntime().freeMemory();</div><div class="line">System.out.println(df.format(freeMem <span class="number">1000000F</span>) + ” MB”);</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line">* Starts the program</div><div class="line">* <span class="doctag">@param</span> args the command line arguments</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">new</span> Main().displayAvailableMemory();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IntelliJ IDEA工具使用笔记]]></title>
      <url>https://fudawei.github.io/2014/06/09/IntelliJ-IDEA%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>IntelliJ IDEA 工具使用<br><a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/settings-introduce-1.html" target="_blank" rel="external">参考极客学院</a><br>ctrl+N 输入类名，从下拉列表选择<br>pyCharm Tips -&gt;<br>Open directory -&gt; Open in current window -&gt; Add to currently opended projects<br>Ctrl+shitf+T 快速打开类</p>
<p>Ctrl+空格  快速补全<br>ctrl+空格 两次，补全类名无论该类是否被引入<br>Ctrl+G find usages in the popup menu<br>ctrl+shift+空格  View | Quick Document   查看方法文档 （查看外部文档 用 Shift+F2）<br>F3    jump to declarations<br>ctrl+F3   浏览该类大致结构   Navigate  | File Structure<br>alt+shift+R     快速重命名    Refactor | Rename<br>补全的时候使用Tab<br>shift+click 或者 鼠标中键<br>alt+F1<br>ctrl+D  重复所选块<br>ctrl+p   此时，如果光标在括号中间，可以显示所需参数<br>ctrl+q   最后一次修改的地方<br>ctrl+shift+上    移动<br>alt+enter  自动导入包<br>alt+F7  查找该方法，类 在其他地方的使用情况<br>ctrl+O  覆盖基类方法<br>ctrl+Q 快速文档<br>ctrl+B  跳转定义<br>ctrl+F12  类结构<br>重命名变量  选中 shift+F6<br>ctrl+I 实现接口方法<br>alt+insert  生成getter、setter方法<br>ctrl+alt+T  surround with<br>ctrl+shift+空格   补全new<br>ctrl+shift+backspace  适用于跟代码很深，需要返回原来的编辑位置<br>Alt+Q  查看当前所属于哪个类<br>Ctrl+E  最近打开的文件<br>Ctrl+J  呼出 Live Template abbreviation   eg： it ctrl+J<br>方法之间有虚线分割： open the editor settings and select the Show method separators check box in the Appearance page.<br>Alt+Up/Down  当前类的方法之间循环切换<br>while debugging the program, select its text in the editor (you may press a Ctrl+W a few times to efficiently perform this operation) and press Alt+F8.</p>
<p>To quickly evaluate the value of any expression while debugging the program, hold Alt and click this expression to see its value and calculate it, call a method, etc.</p>
<p>Alt+Shift+C  快速浏览该项目最近操作<br>Ctrl+空格    完成html,css等的文件名称|属性补全<br>直接写出文件名称，会提示是否创建该文件<br>Ctrl+Shift+I 快速浏览某类或方法<br>Alt+Shift+F10 you can access the Run/Debug dropdown<br>You can quickly open a Maven project by selecting a pom.xml file in the File | Open dialog. The corresponding Maven project is imported with default settings, without launching the wizard.</p>
<p>eg:<br>private FileOutputStream 此时按下 ctrl+shift+空格  会补全一个本地变量 fileOutputStream</p>
<p>.IntelliJ IDEA 这个目录保存IntelliJ的配置，如果配置乱了可以删掉这个目录重新设置</p>
<ol>
<li>config 目录：是 IntelliJ IDEA 个性化化配置目录，这个目录主要记录了：IDE 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、Project 的 tasks 记录等等个性化的设置。</li>
<li>system 目录是 IntelliJ IDEA 系统文件目录，里面主要有：缓存、索引、容器文件输出等等<br>可以修改 bin/idea.properties里面的  idea.config.path=F:/360SycDir/idea_config/config 来指定config目录位置，同步自己的配置文件<br>右键 开启Toolbox</li>
</ol>
<p>Appearance 可以修改主题及主题字体<br>Font  可以修改代码字体<br>Console Font 可以修改控制台字体</p>
<p>如果遇到蓝屏断电等情况可能会造成InteliJ崩溃，缓存索引出问题，此时可以点击File-Invalidate Caches 就可以了</p>
<p>编译三种方式</p>
<ol>
<li>Compile： 对选定的目标（java类文件）进行强制性编译，不管目标是否被修改过</li>
<li>Rebuild：对选定的目标（Project)进行强制性编译，由于Rebuild的目标是Project，所以时间较长</li>
<li>Make   ：使用最多的编译操作，对选定的目标（Project或Module）进行编译，但是只编译修改过的文件</li>
</ol>
<p>点击项目栏可以直接进行搜索<br>has no Save button. Since in IntelliJ IDEA you can undo refactorings and revert changes from Local History<br>Code | Reformat Code  (CTRL+ALT+L)   格式化代码<br>Code | Optimiza Import (CTRL+ALT+O)  优化导入</p>
<p>Ctrl+F9 Make Project  可以映射Ctrl+S为Make Project，因为IntelliJ没有保存的概念<br>Shift X 2 可以呼出搜索框<br>Alt+左右箭头   切换Tab页<br>Smart completion   Ctrl+Shift+空格<br>Ctrl+Shift+F12 最大化窗口<br>Ctrl+E 最近文件<br>Ctrl+Tab  切换最近文件<br>Ctrl+F12    类文件结构   可以直接搜索<br>Shift+Alt+Up/Down   移动行<br>Ctrl+Y  删除行<br>查看提示  Alt+Enter<br>Ctrl+I  实现接口方法<br>Ctrl+H  在接口文件中查看接口被那些类实现<br>Ctrl+U  查看源代码<br>Alt+Left/Right 退回上一层代码</p>
<p>Shift+F10  Run<br>Shift+F9   Debug<br>Ctrl+F9    Make<br>Ctrl+F10   Update application</p>
<p>Shift+F9   Debug<br>Ctrl+Shift+I  快速浏览该类<br>Ctrl+Alt+T   Surround With<br>Ctrl+Alt+J  Surround with live template<br>Ctrl+Alt+U  UML图<br>Ctrl+Shift+Alt+T   重命名一个变量<br>Ctrl+G   定位到行</p>
<p>Ctrl+Shift+A  可以查看搜索所有的快捷键<br>Alt+Enter  快速修正<br>Alt+Insert  生成getter、setter方法<br>在左边的文件位置，可以直接按下Alt+Enter 新建文件<br>Ctrl+Q  快速浏览API说明<br>Ctrl+P 查看API参数<br>Ctrl+Shift+N  查找某个文件并定位到具体行数  Hello:18 表示定位到18行<br>Ctrl+空格  快速补全<br>ctrl+空格 两次，补全类名无论该类是否被引入<br>Ctrl+G find usages in the popup menu<br>ctrl+shift+空格  View | Quick Document   查看方法文档 （查看外部文档 用 Shift+F2）<br>F3    jump to declarations<br>ctrl+F3   浏览该类大致结构   Navigate  | File Structure<br>alt+shift+R     快速重命名    Refactor | Rename<br>补全的时候使用Tab<br>shift+click 或者 鼠标中键<br>alt+F1<br>ctrl+D  重复所选块<br>ctrl+p   此时，如果光标在括号中间，可以显示所需参数<br>ctrl+q   最后一次修改的地方<br>ctrl+shift+上    移动<br>alt+enter  自动导入包<br>alt+F7  查找该方法在其他地方的使用情况<br>ctrl+o  覆盖基类方法</p>
<p>模板用法，可以在  Editor | Live Templates修改，使用的时候Tab即可</p>
<h3 id="Eclipse-VS-IntelliJ-IDEA"><a href="#Eclipse-VS-IntelliJ-IDEA" class="headerlink" title="Eclipse VS  IntelliJ IDEA"></a>Eclipse VS  IntelliJ IDEA</h3><table>
<thead>
<tr>
<th>template</th>
<th>Eclipse</th>
<th>IntelliJ IDEA</th>
</tr>
</thead>
<tbody>
<tr>
<td>Define a main method</td>
<td>main</td>
<td>psvm</td>
</tr>
<tr>
<td>Iterate over an array</td>
<td>for</td>
<td>itar</td>
</tr>
<tr>
<td>Iterate over a collection</td>
<td>for</td>
<td>itco</td>
</tr>
<tr>
<td>Iterate over a list</td>
<td>for</td>
<td>itli</td>
</tr>
<tr>
<td>Iterate over an iterable</td>
<td>foreach</td>
<td>iter</td>
</tr>
<tr>
<td>print to System out</td>
<td>sysout</td>
<td>sout</td>
</tr>
<tr>
<td>print to System err</td>
<td>syserr</td>
<td>serr</td>
</tr>
</tbody>
</table>
<p>apply a template to an expression you’ve already typed<br>eg .ifn   -&gt;   if(..==null){…}Statement<br>Editor  | General   | Postfix Completion</p>
<p>选中项目 - View -open module settings  - &gt; SDKS   可以指定多种SDK，方便在不同项目中切换<br>新建的包以层级目录显示 在设置齿轮 Compate empty middle package 去掉勾选</p>
<p>调试<br>step into   F7<br>smart step into  shift+F7<br>step over   F8<br>step over  F8<br>step out   shift+F8<br>Resume    F9<br>Toggle breakpoint   Ctrl+F8<br>Evaluate expression Alt+F8</p>
<p>deploying to application servers in IntelliJ IDEA is more or less similar to what you are probably used to in Eclipse</p>
<p>new Date().var 自动赋值给本地变量</p>
<p>断点进入后，点击Drop Frame按钮之后，断点重新回到方法体之外<br>IntelliJ自动补全功能默认区分大小写，可以在 Code Completion 中把Case sensitive completion 设置为None<br>Auto Import 中开启自动导包功能</p>
<p>Code Folding  设置哪些类型是默认折叠的<br>若文件太多行数，可以进行垂直或水平分割修改代码<br>Debug状态下，如果要批量删除断点，可以点击左下角的红点，选中要删除的断点删除<br>Ctrl+Alt+T 选择自定义折叠代码区域功能<br>Editor Tabs show tabs in single row 把Tab分多行显示<br>Java- Code Generation 把注释放在紧贴代码的头部<br>Compiler -&gt; 在make或者rebuild过程很慢的时候，可以增加此堆的内存设置，一般大内存的机器设置1500<br>Editor-&gt;General 中设置查看最近文件数量</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Guava库学习]]></title>
      <url>https://fudawei.github.io/2014/06/09/Guava%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>Guava库学习</p>
<h3 id="Junit使用"><a href="#Junit使用" class="headerlink" title="Junit使用"></a>Junit使用</h3><blockquote>
<p>在InteliJ中，test目录右键，Mark Directory as -&gt; Test Source Root 然后在里面@Test引入Junit.jar即可编写测试用例</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>使用Files类来执行那些基本的任务，比如：移动或复制文件，或读取文件内容到一个字符串集合</li>
</ul>
</blockquote>
<ul>
<li><p>Closer类，提供了一种非常干净的方式，确保Closeable实例被正确的关闭</p>
</li>
<li><p>ByteSource 和 CharSource类，提供了不可变的输入流（Input）和读（Reader）</p>
</li>
<li><p>ByteSink 和 CharSink类，提供了不可变的输出流（Output）和写（Writer）</p>
</li>
<li><p>CharStreams和ByteStreams类，为读Readers、写Writers、输入流InputStreams、输出流OutputStreams 提供了一些静态的实用方法</p>
</li>
<li><p>BaseEncoding类，提供了编码和解码字节序列和ASCII字符的方法</p>
</li>
</ul>
<h5 id="文件的复制"><a href="#文件的复制" class="headerlink" title="文件的复制"></a>文件的复制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void testFile() throws IOException &#123;</div><div class="line">        File original = new File(&quot;D:\\test.txt&quot;);</div><div class="line">        File copy = new File(&quot;D:\\test3.txt&quot;);</div><div class="line">        Files.move(original,copy);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="文件的移动-重命名"><a href="#文件的移动-重命名" class="headerlink" title="文件的移动/重命名"></a>文件的移动/重命名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void readFileIntoListOfStirngTest() throws IOException &#123;</div><div class="line">        File file = new File(&quot;D:\\test3.txt&quot;);</div><div class="line">        List&lt;String&gt; expectedLines = Lists.newArrayList(&quot;hello one&quot;,&quot;two Hello&quot;,&quot;hello three&quot;);</div><div class="line">        List&lt;String&gt; readLine = Files.readLines(file,Charsets.UTF_8);</div><div class="line">        assertThat(expectedLines, is(readLine));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="像字符串一样处理文件"><a href="#像字符串一样处理文件" class="headerlink" title="像字符串一样处理文件"></a>像字符串一样处理文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">实现LineProcessor接口，此处采用集合泛型</div><div class="line">public class ToListLineProcessor implements LineProcessor&lt;List&lt;String&gt;&gt; &#123;</div><div class="line">    private static final Splitter splitter = Splitter.on(&quot;,&quot;);</div><div class="line">    private List&lt;String&gt; bookTitle = Lists.newArrayList();</div><div class="line">    private static final int TITLE_INDEX = 1;</div><div class="line">    // 文件的每一行都会经过processLine处理</div><div class="line">    @Override</div><div class="line">    public boolean processLine(String line) throws IOException &#123;</div><div class="line">        bookTitle.add(Iterables.get(splitter.split(line),TITLE_INDEX));</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    // 最终返回的结果</div><div class="line">    @Override</div><div class="line">    public List&lt;String&gt; getResult() &#123;</div><div class="line">        return bookTitle;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Test</div><div class="line">    public void readLinesWithProcessors() throws IOException &#123;</div><div class="line">        File file = new File(&quot;D:\\test3.txt&quot;);</div><div class="line">        List&lt;String&gt; readLines = Files.readLines(file, Charsets.UTF_8,new ToListLineProcessor());</div><div class="line">        List&lt;String&gt; expectedLines = Lists.newArrayList(&quot;hello&quot;,&quot;world&quot;,&quot;hello&quot;);</div><div class="line">        assertThat(expectedLines,is(readLines));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="文件的哈希值"><a href="#文件的哈希值" class="headerlink" title="文件的哈希值"></a>文件的哈希值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void testFilesHashing() throws IOException &#123;</div><div class="line">        File file = new File(&quot;D:\\test3.txt&quot;);</div><div class="line">        HashCode hashCode = Files.hash(file, Hashing.md5());</div><div class="line">        System.out.println(hashCode.toString().length());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="文件写和追加数据"><a href="#文件写和追加数据" class="headerlink" title="文件写和追加数据"></a>文件写和追加数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void appendingWritingFileTest() throws IOException &#123;</div><div class="line">        File file = new File(&quot;D:\\hello.txt&quot;);</div><div class="line">        file.deleteOnExit();</div><div class="line">        String hamletQuoteStart = &quot;To be ,or not to be&quot;;</div><div class="line">        Files.write(hamletQuoteStart, file, Charsets.UTF_8);</div><div class="line">        String hamletQuoteEnd = &quot;,that is the question&quot;;</div><div class="line">        Files.append(hamletQuoteEnd, file, Charsets.UTF_8);</div><div class="line">        assertThat(Files.toString(file, Charsets.UTF_8),is(hamletQuoteStart+hamletQuoteEnd));</div><div class="line"></div><div class="line">        String overWrites = &quot;OverWriting the file&quot;;</div><div class="line">        Files.write(overWrites, file, Charsets.UTF_8);</div><div class="line">        assertThat(Files.toString(file, Charsets.UTF_8), is(overWrites));</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们可以通过Files类提供的静态工厂方法来创建ByteSource、ByteSink、 CharSource、CharSink实例<br>我们将专注于ByteSource和ByteSink对象，CharSource和 CharSink对象与之相似，只是使用的是字符<br>ByteSource类表示一个可读的字节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void createByteSourceFromFileTest() throws IOException &#123;</div><div class="line">        File f1 = new File(&quot;D:\\test2.txt&quot;);</div><div class="line">        ByteSource byteSource = Files.asByteSource(f1);</div><div class="line">        byte[] readByte = byteSource.read();</div><div class="line">        assertThat(readByte,is(Files.toByteArray(f1)));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>ByteSink类表示一个可写的字节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void testCreateFileByteSink() throws IOException &#123;</div><div class="line">        File dest = new File(&quot;D:\\test.txt&quot;);</div><div class="line">        ByteSink byteSink = Files.asByteSink(dest);</div><div class="line">        File file = new File(&quot;D:\\test2.txt&quot;);</div><div class="line">        byteSink.write(Files.toByteArray(file));</div><div class="line">        assertThat(Files.toByteArray(dest), is(Files.toByteArray(file)));</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void copyToByteSinkTest() throws IOException &#123;</div><div class="line">        File source = new File(&quot;D:\\test.txt&quot;);</div><div class="line">        File dest = new File(&quot;D:\\test2.txt&quot;);</div><div class="line">        ByteSource byteSource = Files.asByteSource(source);</div><div class="line">        ByteSink byteSink = Files.asByteSink(dest);</div><div class="line">        byteSource.copyTo(byteSink);</div><div class="line">        assertThat(Files.toByteArray(dest), is(Files.toByteArray(source)));</div></pre></td></tr></table></figure>
<p>ByteStreams是一个实用的程序类，用来处理InputStream和OutputStream实例，CharStreams则是用来处理Reader和Writer实例的程序类。</p>
<h3 id="Strings类和Charsets类"><a href="#Strings类和Charsets类" class="headerlink" title="Strings类和Charsets类"></a>Strings类和Charsets类</h3><h6 id="Charsets类"><a href="#Charsets类" class="headerlink" title="Charsets类"></a>Charsets类</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Test</div><div class="line">    public void testCharsets()&#123;</div><div class="line">        print(Charsets.UTF_8);</div><div class="line">        print(Charsets.ISO_8859_1);</div><div class="line">        byte[] bytes;</div><div class="line">        try &#123;</div><div class="line">            bytes = string.getBytes(&quot;UTF-8&quot;);</div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        // Charsets类则包装了一些常用的 字符集常量，</div><div class="line">        // 使用Charsets封装的字符集避免处理异常</div><div class="line">        bytes = string.getBytes(Charsets.UTF_8);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="Strings类"><a href="#Strings类" class="headerlink" title="Strings类"></a>Strings类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void testString()&#123;</div><div class="line">        char c = &apos;s&apos;;</div><div class="line">        // 将param1的长度改变为length，长度不足的话向后追加字符param2</div><div class="line">        print(Strings.padEnd(string,6,c));</div><div class="line">        // 也有padStart()方法，向前追加，长度超出默认返回原字符</div><div class="line">        print(Strings.padStart(string,6,c));</div><div class="line">        print(Strings.nullToEmpty(null));</div><div class="line">        print(Strings.emptyToNull(&quot; &quot;));</div><div class="line">        print(Strings.isNullOrEmpty(null));</div><div class="line">        print(Strings.repeat(string,3));</div><div class="line">        // 返回两个字符串相同的前缀</div><div class="line">        print(Strings.commonPrefix(&quot;nihaoma?&quot;,&quot;nibuhaoma?&quot;));</div><div class="line">        // 返回两个字符串相同的后缀</div><div class="line">        print(Strings.commonSuffix(&quot;nihaoma?&quot;,&quot;nibuhaoma?&quot;));</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="ComparisonChain类的学习和使用"><a href="#ComparisonChain类的学习和使用" class="headerlink" title="ComparisonChain类的学习和使用"></a>ComparisonChain类的学习和使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Girl implements Comparable&lt;Girl&gt;&#123;</div><div class="line">    private String name;</div><div class="line">    private double height;</div><div class="line">    private String face;</div><div class="line"></div><div class="line">    public Girl(String face, double height, String name) &#123;</div><div class="line">        this.face = face;</div><div class="line">        this.height = height;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    // 使用了建造者模式</div><div class="line">    @Override</div><div class="line">    public int compareTo(Girl o) &#123;</div><div class="line">        return ComparisonChain.start()</div><div class="line">                .compare(name,o.name)</div><div class="line">                .compare(height,o.height)</div><div class="line">                .compare(face,o.face)</div><div class="line">                .result();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Joiner类的学习使用"><a href="#Joiner类的学习使用" class="headerlink" title="Joiner类的学习使用"></a>Joiner类的学习使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class JoinTest &#123;</div><div class="line">    private static String sep = &quot;|&quot;;</div><div class="line">    private static List list = initTestingData();</div><div class="line">    // HashMap 的一种新写法</div><div class="line">    private static Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;() &#123;</div><div class="line">        private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            put(&quot;i love u&quot;, &quot;u love me&quot;);</div><div class="line">            put(&quot;i like u&quot;, &quot;u like me&quot;);</div><div class="line">            put(&quot;i hate u&quot;, &quot;u hate me&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    private static List initTestingData() &#123;</div><div class="line">        List list = new ArrayList();</div><div class="line">        for (int i = 0; i &lt; 20; i++) &#123;</div><div class="line">            if (i % 5 == 0) &#123;</div><div class="line">                list.add(null);</div><div class="line">            &#125; else</div><div class="line">                list.add(&quot;test&quot; + i);</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testBuildStringWithJoin()&#123;</div><div class="line">        String str = Joiner.on(sep).skipNulls().join(list);</div><div class="line">        System.out.println(str);</div><div class="line">        String str2 = Joiner.on(sep).useForNull(&quot;hello&quot;).join(list);</div><div class="line">        System.out.println(str2);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testJoinerStringBuilder()&#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        Joiner joiner = Joiner.on(sep).skipNulls();</div><div class="line">        joiner.appendTo(sb,&quot;i love me&quot;,&quot;i like u &quot;,null,&quot;i hate u&quot;);</div><div class="line">        System.out.println(sb.toString());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testMapJoiner()&#123;</div><div class="line">        String str = Joiner.on(sep).withKeyValueSeparator(&quot;=&quot;).join(map);</div><div class="line">        System.out.println(str);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testJoiner()&#123;</div><div class="line">        String str1 = Joiner.on(&quot;;&quot;).skipNulls().join(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,null));</div><div class="line">        assertEquals(str1,&quot;a;b;c&quot;);</div><div class="line">        String str2 = Joiner.on(&quot;,&quot;).join(Arrays.asList(1,5,7));</div><div class="line">        assertEquals(str2,&quot;1,5,7&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">输出</div><div class="line">test1|test2|test3|test4|test6|test7|test8|test9|test11|test12|test13|test14|test16|test17|test18|test19</div><div class="line">hello|test1|test2|test3|test4|hello|test6|test7|test8|test9|hello|test11|test12|test13|test14|hello|test16|test17|test18|test19</div><div class="line">i love me|i like u |i hate u</div><div class="line">i hate u=u hate me|i like u=u like me|i love u=u love me</div></pre></td></tr></table></figure>
<p>skipNulls（）方法用于过滤集合中为null的元素，然后返回一个新的Joiner对象实例；<br>useForNull(String nullText)方法用于将集合中为null的元素替换成指定的字符串，并返回新的Joiner对象实例；<br>withKeyValueSeparator(String separator)方法，处理map时使用，接收map中key和value之间的分隔符；<br>join方法则用来接收需要处理的集合对象或object[]对象数组，返回处理后的字符串表示。</p>
<h3 id="Splitter的应用"><a href="#Splitter的应用" class="headerlink" title="Splitter的应用"></a>Splitter的应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void testSplitter() &#123;</div><div class="line">        // omitEmptyStrings方法用于忽略分割后产生的空值</div><div class="line">        Iterable strings = Splitter.on(separator).omitEmptyStrings()</div><div class="line">                .split(string);</div><div class="line">        // [i hate u=u hate me , i like u=u like me , i love u=u love me]</div><div class="line">        System.out.println(strings);</div><div class="line">        // trimResults方法用于处理分割后每一项中的空白符</div><div class="line">        Iterable strings2 = Splitter.on(separator)</div><div class="line">                .trimResults().split(string);</div><div class="line">        // [i hate u=u hate me, i like u=u like me, , , i love u=u love me]</div><div class="line">        System.out.println(strings2);</div><div class="line"></div><div class="line">        Iterable&lt;String&gt; string3 = Splitter.on(separator).omitEmptyStrings().trimResults().split(string);</div><div class="line">        System.out.println(string3);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">输出为</div><div class="line">[i hate u=u hate me , i like u=u like me , i love u=u love me]</div><div class="line">[i hate u=u hate me, i like u=u like me, , , i love u=u love me]</div><div class="line">[i hate u=u hate me, i like u=u like me, i love u=u love me]</div><div class="line"></div><div class="line">@Test</div><div class="line">    public void testMapSplitter() &#123;</div><div class="line">        Splitter.MapSplitter mapSplitter = Splitter.on(separator)</div><div class="line">                .omitEmptyStrings().withKeyValueSeparator(separator2);</div><div class="line">        Map&lt;String, String&gt; map = mapSplitter.split(string);</div><div class="line">        Set keySet = map.keySet();</div><div class="line">        // [i hate u, i like u, i love u]</div><div class="line">        System.out.println(keySet);</div><div class="line">    &#125;</div><div class="line">输出为</div><div class="line">[i hate u, i like u, i love u]</div></pre></td></tr></table></figure>
<p>Splitter是通过Splitter.on(分隔符).split(字符串)来处理字符串，与Joiner类似，通过静态on（）方法，我 们构建了一个Splitter对象，其中提供了两种常用的方法，分别是omitEmptyStrings（）和trimResults（），这两个方法的 调用都会返回一个新的Splitter对象实例。<br>omitEmptyStrings（）用于忽略字符串分割后产生的空值元素，trimResults（）用于去除字符串分割后子元素中的空白符。<br>与Joiner类似，Splitter也提供了一个内部类MapSplitter来处理字符串，返回map集合，调用方法为 withKeyValueSeparator(separator)，在静态on()方法之后调用，在分割后的子项中根据指定的separator再次分 割成key-value键值对，返回的结果为map集合。</p>
<h3 id="Guava-Collection学习"><a href="#Guava-Collection学习" class="headerlink" title="Guava Collection学习"></a>Guava Collection学习</h3><p>FluentIterable是一个抽象类同时实现了 Iterable接口，内部提供了一个静态的from方法，用于接收一个Iterable接口的实现作为参数，返回一个包装了Iterable接口的 FluentIterable实例。FluentIterable可以链式调用toList、toSet、 toMap、 toSortedList以及toSortedSet等方法，转换为我们熟悉的集合类型。</p>
<p>FluentIterable.filter和FluentIterable.transform方法，顾名思义，分别用于集合的过滤和转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class Girl&#123;</div><div class="line">private List&lt;Girl&gt; girls;</div><div class="line"></div><div class="line">    @Before</div><div class="line">    public void setUp()&#123;</div><div class="line">        Girl g1 = new Girl(17, &quot;nice&quot;);</div><div class="line">        Girl g2 = new Girl(18, &quot;beauty&quot;);</div><div class="line">        Girl g3 = new Girl(19, &quot;nice&quot;);</div><div class="line">        Girl g4 = new Girl(18, &quot;nice&quot;);</div><div class="line">        girls = Lists.newArrayList(g1,g2,g3,g4);</div><div class="line">    &#125;</div><div class="line">    @Test</div><div class="line">    public void testFluentIterable()&#123;</div><div class="line">        /**</div><div class="line">         * from方法：用于包装Iterable接口，返回FluentIterable实例</div><div class="line">         * filter方法：用于过滤集合中元素，返回过滤后的集合</div><div class="line">         */</div><div class="line">        FluentIterable.from(girls).filter(new Predicate&lt;Girl&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public boolean apply(Girl girl) &#123;</div><div class="line">                return &quot;nice&quot;.equals(girl.getFace());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        /**</div><div class="line">         * transform方法：用于根据指定Function转换集合元素，返回转换后的集合</div><div class="line">         */</div><div class="line">        FluentIterable&lt;String&gt; fluentIterable = FluentIterable.from(girls).transform(new Function&lt;Girl, String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public String apply(Girl girl) &#123;</div><div class="line">                return Joiner.on(&quot;,&quot;).join(girl.getAge(), girl.getFace());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">filter(Predicate&lt;? super E&gt; predicate)：</div><div class="line">---&gt; 接收一个Predicate作为参数，过滤那些能够满足predicate的元素，返回FluentIterable实例。</div><div class="line"></div><div class="line">transform(Function&lt;? super E, T&gt; function)：</div><div class="line">---&gt; 接收一个Function作为参数，相应转换集合中的元素，返回FluentIterable实例。</div></pre></td></tr></table></figure>
<h4 id="Collections-Lists"><a href="#Collections-Lists" class="headerlink" title="Collections Lists"></a>Collections Lists</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"> @Test</div><div class="line">    public void testLists() &#123;</div><div class="line">        /**</div><div class="line">         * 一些构造List实例的方法很简单</div><div class="line">         * 如：newArrayList(),newLinkedList()等</div><div class="line">         * 这里不再赘述</div><div class="line">         */</div><div class="line">        String str = &quot;i love u&quot;;//测试用</div><div class="line">        String[] strs = &#123;&quot;i like u&quot;, &quot;i miss u&quot;&#125;;//测试用</div><div class="line">        /**</div><div class="line">         * asList：返回一个不可变的List</div><div class="line">         * 其中包含指定的第一个元素和附加的元素数组组成</div><div class="line">         * 修改这个数组将反映到返回的List上</div><div class="line">         */</div><div class="line">        List&lt;String&gt; list = Lists.asList(str, strs);</div><div class="line">        System.out.println(list); //[i love u, i like u, i miss u]</div><div class="line">        strs[1] = &quot;i hate u&quot;;//对strs数组的修改会反映到List中</div><div class="line">        System.out.println(list);//[i love u, i like u, i hate u]</div><div class="line">        /**</div><div class="line">         * transform：根据传进来的function对fromList进行相应的处理</div><div class="line">         * 并将处理得到的结果存入到新的list对象中返回</div><div class="line">         */</div><div class="line">        List&lt;String&gt; newList = Lists.transform(list, new Function&lt;String, String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public String apply(String input) &#123;</div><div class="line">                //这里简单的对集合中的元素转换为大写</div><div class="line">                return input.toUpperCase();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        System.out.println(newList);//[I LOVE U, I LIKE U, I HATE U]</div><div class="line">         /**</div><div class="line">         * partition：根据size传入的List进行切割，切割成符合要求的小的List</div><div class="line">         * 并将这些小的List存入一个新的List对象中返回</div><div class="line">         */</div><div class="line">        List&lt;List&lt;String&gt;&gt; lists = Lists.partition(list, 2);</div><div class="line">        System.out.println(lists);//[[i love u, i like u], [i hate u]]</div><div class="line">        /**</div><div class="line">         * charactersOf：将传进来的String或者CharSequence分割为单个的字符</div><div class="line">         * 并存入到一个ImmutableList对象中返回</div><div class="line">         * ImmutableList：一个高性能、不可变的、随机访问列表的实现</div><div class="line">         */</div><div class="line">        ImmutableList&lt;Character&gt; characters = Lists.charactersOf(&quot;realfighter&quot;);</div><div class="line">        System.out.println(characters);//[r, e, a, l, f, i, g, h, t, e, r]</div><div class="line">        /**</div><div class="line">         * reverse：返回一个传入List内元素倒序后的List</div><div class="line">         */</div><div class="line">        List&lt;String&gt; reverse = Lists.reverse(list);</div><div class="line">        System.out.println(reverse);//[i hate u, i like u, i love u]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">输出</div><div class="line">[i love u, i like u, i miss u]</div><div class="line">[i love u, i like u, i hate u]</div><div class="line">[I LOVE U, I LIKE U, I HATE U]</div><div class="line">[[i love u, i like u], [i hate u]]</div><div class="line">[r, e, a, l, f, i, g, h, t, e, r]</div><div class="line">[i hate u, i like u, i love u]</div></pre></td></tr></table></figure>
<h3 id="CharMatcher"><a href="#CharMatcher" class="headerlink" title="CharMatcher"></a>CharMatcher</h3><p>字符串匹配 &amp;&amp; 字符处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void testCharMatcher()&#123;</div><div class="line">        assertEquals(CharMatcher.DIGIT.retainFrom(&quot;some text 889983 and more&quot;),&quot;889983&quot;);</div><div class="line">        assertEquals(CharMatcher.DIGIT.removeFrom(&quot;some text 889983 and more&quot;),&quot;some text  and more&quot;);</div><div class="line">        assertEquals(CharMatcher.anyOf(&quot;abcxy&quot;).removeFrom(&quot;abcdefgxyz&quot;),&quot;defgz&quot;);</div><div class="line">        String str1 = CharMatcher.inRange(&apos;a&apos;,&apos;f&apos;)</div><div class="line">                .and(CharMatcher.isNot(&apos;c&apos;))</div><div class="line">                .and(CharMatcher.isNot(&apos;e&apos;))</div><div class="line">                .or(CharMatcher.is(&apos;z&apos;))</div><div class="line">                .replaceFrom(&quot;abyczef&quot;,&quot;*&quot;);</div><div class="line">        assertEquals(str1,&quot;**yc*e*&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="Big-Endian-和-Little-Endian"><a href="#Big-Endian-和-Little-Endian" class="headerlink" title="Big Endian 和 Little Endian"></a>Big Endian 和 Little Endian</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class CharUtil &#123;</div><div class="line">    /**</div><div class="line">     * big endian是指低地址存放最高有效字节（MSB），而little endian则是低地址存放最低有效字节（LSB）</div><div class="line">     * @param</div><div class="line">     *          bytes</div><div class="line">     * @return</div><div class="line">     *          int</div><div class="line">     */</div><div class="line">    public static int byte2Int(byte[] bytes)&#123;</div><div class="line">        int num = bytes[3] &amp; 0xFF;</div><div class="line">        num |= (bytes[2] &lt;&lt; 8) &amp; 0xFF00;</div><div class="line">        num |= (bytes[1] &lt;&lt; 16) &amp; 0xFF0000;</div><div class="line">        num |= (bytes[0] &lt;&lt; 24) &amp; 0xFF000000;</div><div class="line">        return num;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static byte[] int2ByteArray(int i)&#123;</div><div class="line">        byte[] result = new byte[4];</div><div class="line">        result[0] = (byte) ((i &gt;&gt; 24) &amp; 0xFF);</div><div class="line">        result[1] = (byte)((i &gt;&gt; 16 ) &amp; 0xFF);</div><div class="line">        result[2] = (byte)((i &gt;&gt; 8 ) &amp; 0xFF);</div><div class="line">        result[3] = (byte)(i &amp; 0xFF);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class testNum &#123;</div><div class="line">    @Test</div><div class="line">    public void testByte2Int()&#123;</div><div class="line"></div><div class="line">        byte[] bb = new byte[]&#123;0,0,1,1&#125;;</div><div class="line">        System.out.println(CharUtil.byte2Int(bb));</div><div class="line">    &#125;</div><div class="line">    @Test</div><div class="line">    public void testInt2ByteArray()&#123;</div><div class="line">        byte[] bt = CharUtil.int2ByteArray(258);</div><div class="line">        for (int i = 0; i &lt; bt.length; i++) &#123;</div><div class="line">            byte b = bt[i];</div><div class="line">            System.out.println(b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：OutputStream中直接写入一个int类型，会截取低8位，丢弃高24位，因此需要将基本类型先转换为字节流。Java采用的是BigEndian字节序，所有的网络协议都是采用BigEndian字节序来进行传输的，因此我们在进行数据的传输时，需要先将其转换成BigEndian字节序；同理，在数据接收时，也需要进行响应的转换</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Guava概览]]></title>
      <url>https://fudawei.github.io/2014/05/12/Guava%E6%A6%82%E8%A7%88/</url>
      <content type="html"><![CDATA[<p>Guava 是一个 Google 的基于java1.6的类库集合的扩展项目，包括 collections, caching, primitives support, concurrency libraries, common annotations, string processing, I/O, 等等. 这些高质量的 API 可以使你的JAVa代码更加优雅，更加简洁，让你工作更加轻松愉悦。下面我们就开启优雅Java编程学习之旅！</p>
<p>　　项目相关信息：</p>
<p>　　官方首页：<a href="http://code.google.com/p/guava-libraries" target="_blank" rel="external">http://code.google.com/p/guava-libraries</a><br>　　官方下载：<a href="http://code.google.com/p/guava-libraries/downloads/list" target="_blank" rel="external">http://code.google.com/p/guava-libraries/downloads/list</a><br>　　官方文档：<a href="http://docs.guava-libraries.googlecode.com/git/javadoc" target="_blank" rel="external">http://docs.guava-libraries.googlecode.com/git/javadoc</a><br>                    <a href="http://www.ostools.net/apidocs/apidoc?api=guava" target="_blank" rel="external">http://www.ostools.net/apidocs/apidoc?api=guava</a></p>
<p>　　源码包的简单说明：<br>　　com.google.common.annotations：普通注解类型。<br>　　com.google.common.base：基本工具类库和接口。<br>　　com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存。<br>　　com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类，这里你会发现很多好玩的集合。<br>　　com.google.common.eventbus：发布订阅风格的事件总线。<br>　　com.google.common.hash： 哈希工具包。<br>　　com.google.common.io：I/O工具包。<br>　　com.google.common.math：原始算术类型和超大数的运算工具包。<br>　　com.google.common.net：网络工具包。<br>　　com.google.common.primitives：八种原始类型和无符号类型的静态工具包。<br>　　com.google.common.reflect：反射工具包。<br>　　com.google.common.util.concurrent：多线程工具包。</p>
<p>　　类库使用手册：</p>
<p>　　一.  基本工具类：让使用Java语言更令人愉悦。</p>
<p>　　1. 使用和避免 null：null 有语言歧义， 会产生令人费解的错误， 反正他总是让人不爽。很多 Guava 的工具类在遇到 null 时会直接拒绝或出错，而不是默默地接受他们。<br>　　2. 前提条件：更容易的对你的方法进行前提条件的测试。<br>　　3. 常见的对象方法： 简化了Object常用方法的实现， 如 hashCode() 和 toString()。<br>　　4. 排序： Guava 强大的 “fluent Comparator”比较器， 提供多关键字排序。<br>　　5. Throwable类： 简化了异常检查和错误传播。</p>
<p>　　二.  集合类：集合类库是 Guava 对 JDK 集合类的扩展， 这是 Guava 项目最完善和为人所知的部分。</p>
<p>　　1. Immutable collections（不变的集合）： 防御性编程， 不可修改的集合，并且提高了效率。<br>　　2. New collection types(新集合类型)：JDK collections 没有的一些集合类型，主要有：multisets，multimaps，tables， bidirectional maps等等<br>　　3. Powerful collection utilities（强大的集合工具类）： java.util.Collections 中未包含的常用操作工具类<br>　　4. Extension utilities（扩展工具类）: 给 Collection 对象添加一个装饰器? 实现迭代器? 我们可以更容易使用这些方法。</p>
<p>　　三.  缓存: 本地缓存，可以很方便的操作缓存对象，并且支持各种缓存失效行为模式。</p>
<p>　　四.  Functional idioms（函数式）: 简洁, Guava实现了Java的函数式编程，可以显著简化代码。</p>
<p>　　五. Concurrency（并发）：强大,简单的抽象,让我们更容易实现简单正确的并发性代码。</p>
<p>　　1. ListenableFuture（可监听的Future）: Futures,用于异步完成的回调。<br>　　2. Service: 控制事件的启动和关闭，为你管理复杂的状态逻辑。</p>
<p>　　六. Strings: 一个非常非常有用的字符串工具类: 提供 splitting，joining， padding 等操作。</p>
<p>　　七. Primitives: 扩展 JDK 中未提供的对原生类型（如int、char等）的操作， 包括某些类型的无符号的变量。</p>
<p>　　八. Ranges: Guava 一个强大的 API，提供 Comparable 类型的范围处理， 包括连续和离散的情况。</p>
<p>　　九. I/O: 简化 I/O 操作, 特别是对 I/O 流和文件的操作, for Java 5 and 6.</p>
<p>　　十. Hashing: 提供比 Object.hashCode() 更复杂的 hash 方法, 提供 Bloom filters.</p>
<p>　　十一. EventBus: 基于发布-订阅模式的组件通信，但是不需要明确地注册在委托对象中。</p>
<p>　　十二. Math: 优化的 math 工具类，经过完整测试。</p>
<p>　　十三. Reflection: Guava 的 Java 反射机制工具类。</p>
<p>null对象不是Object对象的实例。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java反射]]></title>
      <url>https://fudawei.github.io/2014/05/04/Java%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<p>1、Java反射的概念<br>    反射含义：可以获取正在运行的Java对象。<br>2、Java反射的功能<br>    1)可以判断运行时对象所属的类<br>    2)可以判断运行时对象所具有的成员变量和方法<br>    3)通过反射甚至可以调用到private的方法<br>    4)生成动态代理<br>3、实现Java反射的类<br>    1)Class：它表示正在运行的Java应用程序中的类和接口<br>    2)Field：提供有关类或接口的属性信息，以及对它的动态访问权限<br>    3)Constructor：提供关于类的单个构造方法的信息以及对它的访问权限<br>    4)Method：提供关于类或接口中某个方法信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">POJO</div><div class="line">public class Employee implements Cloneable&#123;</div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	private int[] arr;</div><div class="line">	public Employee()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public Employee(String name, int age, int[] arr) &#123;</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">		this.arr = arr;</div><div class="line">	&#125;</div><div class="line">	public int[] getArr() &#123;</div><div class="line">		return arr;</div><div class="line">	&#125;</div><div class="line">	public void setArr(int[] arr) &#123;</div><div class="line">		this.arr = arr;</div><div class="line">	&#125;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void display()&#123;</div><div class="line">		System.out.println(&quot;name=&quot;+name+&quot; ;age=&quot;+age);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void send(String message)&#123;</div><div class="line">		System.out.println(message);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String toString() &#123;</div><div class="line">		return &quot;Employee [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException &#123;</div><div class="line"></div><div class="line">		System.out.println(&quot;------------反射机制获取类的三种方法---------------&quot;);</div><div class="line">		Class&lt;?&gt; c1 = Class.forName(&quot;com.reflect.Employee&quot;); // 注意全类名</div><div class="line">		Class&lt;?&gt; c2 = Employee.class;</div><div class="line">		Employee e = new Employee(&quot;lisan&quot;, 18, new int[]&#123;12,13&#125;);</div><div class="line">		Class&lt;?&gt; c3 = e.getClass();</div><div class="line">		// 创建对象</div><div class="line">		Object o = c1.newInstance();</div><div class="line">		// 获取属性 ，分为所有的属性和指定的属性</div><div class="line">		System.out.println(&quot;---------------获取全部属性---------------&quot;);</div><div class="line">		Class&lt;?&gt; c = Class.forName(&quot;java.lang.Integer&quot;);</div><div class="line">		Field[] fs = c.getDeclaredFields();</div><div class="line">		StringBuffer sb = new StringBuffer();</div><div class="line">		sb.append(Modifier.toString(c.getModifiers())+&quot; class &quot;+c.getSimpleName()+&quot;&#123;\n&quot;);</div><div class="line">		for(Field field : fs)&#123;</div><div class="line">			sb.append(&quot;\t&quot;);</div><div class="line">			sb.append(Modifier.toString(field.getModifiers())+&quot; &quot;);  //获得属性的修饰符，例如public，static</div><div class="line">			sb.append(field.getType().getSimpleName()+&quot; &quot;);  //属性的类型的名字</div><div class="line">			sb.append(field.getName()+&quot;;\n&quot;);  //属性的名字+回车</div><div class="line">		&#125;</div><div class="line">		sb.append(&quot;&#125;&quot;);</div><div class="line">		System.out.println(sb);</div><div class="line">		System.out.println(&quot;---------------获取部分属性-----------------&quot;);</div><div class="line">		Field nameF = c1.getDeclaredField(&quot;name&quot;);</div><div class="line">		Field ageF = c1.getDeclaredField(&quot;age&quot;);</div><div class="line">		Object oo = c1.newInstance();</div><div class="line">		nameF.setAccessible(true); // 使用反射机制可以打破封装性，导致了java对象的属性不安全。</div><div class="line">		ageF.setAccessible(true);  // 使用反射机制可以打破封装性，导致了java对象的属性不安全。</div><div class="line">		nameF.set(oo, &quot;lisan&quot;);  // 给oo对象的name属性赋值&quot;lisan&quot;</div><div class="line">		ageF.set(oo,18);   // 给oo对象的age属性赋值&quot;11&quot;</div><div class="line">		System.out.println(nameF.get(oo));  // 得到oo对象的name属性的值</div><div class="line">		System.out.println(ageF.get(oo));   // 得到oo对象的age属性的值</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">输出--&gt;</div><div class="line">------------反射机制获取类的三种方法---------------</div><div class="line">---------------获取全部属性---------------</div><div class="line">public final class Integer&#123;</div><div class="line">	public static final int MIN_VALUE;</div><div class="line">	public static final int MAX_VALUE;</div><div class="line">	public static final Class TYPE;</div><div class="line">	static final char[] digits;</div><div class="line">	static final char[] DigitTens;</div><div class="line">	static final char[] DigitOnes;</div><div class="line">	static final int[] sizeTable;</div><div class="line">	private final int value;</div><div class="line">	public static final int SIZE;</div><div class="line">	private static final long serialVersionUID;</div><div class="line">	static final boolean $assertionsDisabled;</div><div class="line">&#125;</div><div class="line">---------------获取部分属性-----------------</div><div class="line">lisan</div><div class="line">18</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">public class TestReflect &#123;</div><div class="line">	public static void main(String[] args) throws ClassNotFoundException &#123;</div><div class="line">		Class&lt;Employee&gt; c1 = Employee.class;</div><div class="line">		Class&lt;?&gt; c2 = Class.forName(&quot;com.reflect.Employee&quot;);</div><div class="line">		// 获取类的修饰符</div><div class="line">		int mod = c1.getModifiers();</div><div class="line">		System.out.println(mod);</div><div class="line">		System.out.println(Modifier.toString(mod));</div><div class="line">		// 获得类全名</div><div class="line">		String name = c1.getName();</div><div class="line">		System.out.println(name);</div><div class="line">		// 获得父类</div><div class="line">		Class superClass = c1.getSuperclass();</div><div class="line">		System.out.println(superClass);</div><div class="line">		// 获取c1实现的接口</div><div class="line">		Class[] interfaces = c1.getInterfaces();</div><div class="line">		for (Class t : interfaces) &#123;</div><div class="line">			System.out.println(&quot;interfacesName = &quot; + t.getName());</div><div class="line">		&#125;</div><div class="line">		//获取指定类的成员变量</div><div class="line">		System.out.println(&quot;-----------获取指定类的成员变量-----------&quot;);</div><div class="line">		Field[] fields = c1.getDeclaredFields();</div><div class="line">		for (Field field : fields) &#123;</div><div class="line">			String modifier = Modifier.toString(field.getModifiers());</div><div class="line">			Class&lt;?&gt; type = field.getType();</div><div class="line">			String name2 = field.getName();</div><div class="line">			if(type.isArray())&#123;</div><div class="line">				String arrType = type.getComponentType().getName()+&quot;[]&quot;;</div><div class="line">				System.out.println(&quot;&quot;+modifier+&quot; &quot;+arrType+&quot; &quot;+name2+&quot;;&quot;);</div><div class="line">			&#125;else&#123;</div><div class="line">				System.out.println(&quot;&quot;+modifier+&quot; &quot;+type+&quot; &quot;+name2+&quot;;&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		// 获取类的构造方法</div><div class="line">		System.out.println(&quot;------------获取类的构造方法--------------&quot;);</div><div class="line">		Constructor[] constructors = c1.getDeclaredConstructors();</div><div class="line">		for (Constructor constructor : constructors) &#123;</div><div class="line">			String name3 = constructor.getName(); //构造方法名</div><div class="line">			String modi = Modifier.toString(constructor.getModifiers()); //获取访问修饰符</div><div class="line">			System.out.print(&quot;&quot; + modi +&quot; &quot; + name3 + &quot;(&quot;);</div><div class="line">			Class[] paramTypes = constructor.getParameterTypes(); //获取构造方法中的参数</div><div class="line">		for (int i = 0; i &lt; paramTypes.length; i++) &#123;</div><div class="line">			// 从第二个参数开始加符号</div><div class="line">			if (i &gt; 0) &#123;</div><div class="line">				System.out.print(&quot;,&quot;);</div><div class="line">			&#125;</div><div class="line">			if (paramTypes[i].isArray()) &#123;</div><div class="line">				System.out.print(paramTypes[i].getComponentType().getName()+&quot;[]&quot;);</div><div class="line">			&#125; else &#123;</div><div class="line">				System.out.print(paramTypes[i].getName());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;);&quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// 获取成员方法</div><div class="line">		System.out.println(&quot;---------获取成员方法----------&quot;);</div><div class="line">		Method[] methods = c1.getDeclaredMethods();</div><div class="line">		for (Method method : methods) &#123;</div><div class="line">			String modif = Modifier.toString(method.getModifiers());</div><div class="line">			Class returnType = method.getReturnType();</div><div class="line">			if(returnType.isArray())&#123;</div><div class="line">				String arrType = returnType.getComponentType().getName()+&quot;[]&quot;;</div><div class="line">				System.out.print(&quot;&quot;+modif+&quot; &quot;+arrType+&quot; &quot;+method.getName()+&quot;(&quot;);</div><div class="line">			&#125;else&#123;</div><div class="line">				System.out.print(&quot;&quot;+modif+&quot; &quot;+returnType.getName()+&quot; &quot;+method.getName()+&quot;(&quot;);</div><div class="line">			&#125;</div><div class="line">			Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</div><div class="line">			for(int i=0;i&lt;paramTypes.length;i++)&#123;</div><div class="line">				if(i&gt;0)&#123;</div><div class="line">					System.out.print(&quot;,&quot;);</div><div class="line">				&#125;</div><div class="line">				if(paramTypes[i].isArray())&#123;</div><div class="line">					System.out.print(paramTypes[i].getComponentType().getName()+&quot;[]&quot;);</div><div class="line">				&#125;else&#123;</div><div class="line">					System.out.print(paramTypes[i].getName());</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			System.out.println(&quot;);&quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// java动态绑定</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">输出---&gt;</div><div class="line">1</div><div class="line">public</div><div class="line">com.reflect.Employee</div><div class="line">class java.lang.Object</div><div class="line">interfacesName = java.lang.Cloneable</div><div class="line">-----------获取指定类的成员变量-----------</div><div class="line">private class java.lang.String name;</div><div class="line">private int age;</div><div class="line">private int[] arr;</div><div class="line">------------获取类的构造方法--------------</div><div class="line">public com.reflect.Employee();</div><div class="line">public com.reflect.Employee(java.lang.String,int,int[]);</div><div class="line">---------获取成员方法----------</div><div class="line">public java.lang.String toString();</div><div class="line">public java.lang.String getName();</div><div class="line">public void setName(java.lang.String);</div><div class="line">public int[] getArr();</div><div class="line">public void setArr(int[]);</div><div class="line">public void setAge(int);</div><div class="line">public void send(java.lang.String);</div><div class="line">public void display();</div><div class="line">public int getAge();</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java锁类型]]></title>
      <url>https://fudawei.github.io/2014/04/15/Java%E9%94%81%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁适用于锁竞争不那么激烈的情况，和同步块比较小的情况，由于线程的阻塞和释放都是基于信号量（操作系统课本的汇编示例代码还记得不），并且<br>有用户态和内核态的频繁切换以及线程上下文切换开销比较大，对于前述的两种情况阻塞和释放竞争锁的线程显得没那么的必要，所以引入了自旋锁，但是<br>自旋锁也有不好的地方，ABA问题，单核无效（依赖环境），太依赖于当前线程的执行环境。<br>ABA 问题：在CAS操作中将判断“V的值是否仍然为A？”，并且如果是的话就继续执行更新操作。在大多数情况下，这种判断是足够的。然而，有时候还需要<br>知道 “自从上次看到V的值为A以来，这个值是否发生了变化？”在某些算法中，如果V值首先由A编程B,在由B编程A，那么仍然被认为发生了变化，并需要重新<br>执 行算法中的某些步骤。<br>解决方法： 使用原子工具类 AtomicStampedReference以 及AtomicMarkableReference支持在两个变量上执行原子的条件更新。AtomicStampedReference将<br>更新一个“对象 —-引用”二元组，通过在引用上加上“版本号”，从而避免ABA问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class SpinLock &#123;</div><div class="line">    private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;();</div><div class="line"></div><div class="line">    public void lock()&#123;</div><div class="line">        Thread currentThread = Thread.currentThread();</div><div class="line">        //循环cas来判断锁是否被占用，第一个为期望值，如果为null说明锁未被占用，设置当前线程占用</div><div class="line">        while(owner.compareAndSet(null,currentThread))&#123;</div><div class="line">            //这里一般会调用java.util.concurrent.locks.AbstractOwnableSynchronizer的setExclusiveOwnerThread(Thread t)方法来设置独占锁</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void unlock()&#123;</div><div class="line">        Thread currentThread = Thread.currentThread();</div><div class="line"></div><div class="line">        owner.compareAndSet(currentThread,null);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。<br>在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁<br>可重入锁最大的作用是避免死锁<br>Test1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Test implements Runnable&#123;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		get();</div><div class="line">	&#125;</div><div class="line">	public synchronized void get()&#123;</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">		set();</div><div class="line">	&#125;</div><div class="line">	public synchronized void set()&#123;</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Test test = new Test();</div><div class="line">		new Thread(test).start();</div><div class="line">		new Thread(test).start();</div><div class="line">		new Thread(test).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Test2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Test implements Runnable&#123;</div><div class="line">	ReentrantLock lock = new ReentrantLock();</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		get();</div><div class="line">	&#125;</div><div class="line">	public void get()&#123;</div><div class="line">		lock.lock();</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">		set();</div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line">	public void set()&#123;</div><div class="line">		lock.lock();</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Test test = new Test();</div><div class="line">		new Thread(test).start();</div><div class="line">		new Thread(test).start();</div><div class="line">		new Thread(test).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">两次输出结果一样，即同一个线程id被连续输出两次</div></pre></td></tr></table></figure></p>
<h3 id="阻塞锁"><a href="#阻塞锁" class="headerlink" title="阻塞锁"></a>阻塞锁</h3><p>能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字，ReentrantLock，Object.wait()\notify(),LockSupport.park()/unpart()<br>阻塞锁的优势在于，阻塞的线程不会占用cpu时间， 不会导致 CPu占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。<br>在竞争激烈的情况下 阻塞锁的性能要明显高于 自旋锁。<br>理想的情况则是; 在线程竞争不激烈的情况下，使用自旋锁，竞争激烈的情况下使用，阻塞锁。</p>
<h3 id="ThreadLocal-用法"><a href="#ThreadLocal-用法" class="headerlink" title="ThreadLocal 用法"></a>ThreadLocal 用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static ThreadLocal&lt;Long&gt; TIME_THRE = new ThreadLocal&lt;Long&gt;()&#123;</div><div class="line">		protected Long initialValue() &#123;</div><div class="line">			return System.currentTimeMillis();</div><div class="line">		&#125;;</div><div class="line">	&#125;;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java开发常用程序库]]></title>
      <url>https://fudawei.github.io/2014/04/15/Java%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>在很多人眼中，Java已经是一门垂垂老矣的语言，但并不妨碍Java世界依然在前进。如果你曾离开Java，云游于其它世界，或是每日只在遗留代码中挣扎，或许是时候抬起头，看看老Java中的新东西。</p>
<h4 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h4><p>一句话，只要你做Java项目，就应该用Guava。<br>guava是Google出品的一套Java核心库，在我看来，它甚至应该是JDK的一部分。作为一个Java程序员，如果你没抱怨过JDK的设计，只能说明一点，你写得程序还是太少。正是JDK设计不彰，才有了一些项目来补充JDK的不足。如果说老Java程序员应该听说过Apache Commons Lang，那新Java程序员该知道的就是Guava了。<br>下面以一个统计单词出现个数的小程序作为这个段落的结尾，虽然无法与许多其它语言的实现相提并论，但作为一个Java程序员，你不妨想一下按照传统方式，这段代码应该是什么样子。<br>  String content = Files.toString(new File(args[0]), Charset.defaultCharset());<br>  Iterable texts = Splitter.on(CharMatcher.WHITESPACE)<br>                                                 .omitEmptyStrings()<br>                                                 .trimResults()<br>                                                 .split(content);<br>  Multiset collection = HashMultiset.create(texts);</p>
<h4 id="Joda-Time"><a href="#Joda-Time" class="headerlink" title="Joda Time"></a>Joda Time</h4><p>Date firstDayOf2013 = new Date(113, 0, 1);<br>如果你是个Java新手，你能猜出113是从哪来的吗？（好吧，它是2013-1900，至于为什么是1900，这真得问API的设计者了）。<br>Joda Time就是人们实在无法忍受这样东西的产物。同样的代码用Joda Time实现：<br>  DateTime firstDayOf2013 = new DateTime().withDate(2013, 1, 1);<br>无论如何，你知道这能看出这些参数的含义了。不只如此，你还可以计算两天后是什么日子：<br>  firstDate.plusDays(2);<br>日期格式化，也是JDK Date系列API里一大特色，你必须把代码写成下面这样：<br>  new SimpleDateFormat(“yyyy.MM.dd”).format(firstDayOf2013)<br>作为一个初始化很慢的构造函数，你还必须每次调用，因为它不是线程安全的。同样的代码，在Joda Time里，我们可以用DateTimeFormatter：</p>
<p>  DateTimeFormatter formatter = DateTimeFormat.forPattern(“yyyy.MM.dd”);</p>
<p>  …</p>
<p>  formatter.print(dateTime);</p>
<p>请尽管放心大胆把formatter声明成一个字段，因为它是线程安全的。</p>
<p>当然，Joda Time的强大远不止于此。当然，JDK也并不是那么完全的自暴自弃，于是，有了一个JSR 310专门设计新的Date API。JSR 310的spec lead是Steven Colebourne，此人正是Joda Time的作者。不过，虽然JSR 310为我们描绘了Date的全新景象，但Java 8出来之前就先别打它的主意了，乖乖地用Joda Time吧。</p>
<h4 id="Hamcrest"><a href="#Hamcrest" class="headerlink" title="Hamcrest"></a>Hamcrest</h4><p>一句话，如果你写单元测试，就应该用Hamcrest。<br>如今不写单元测试，你都不好意思说自己在做工程项目了。但你一般这么写断言呢？如果你还写成下面这样，我只能说你落伍了：</p>
<p>  assertEquals(a, b);</p>
<p>请告诉我，哪个是执行结果，哪个是预期结果，不管你是怎样，反正大多数情况下，我是记不住的。所以，这个在只重功能不重可读性年代产生的API该更新了。于是，Hamcrest就是为了解决这样的问题而生的。</p>
<p>  assertThat(a, is(b));</p>
<p>很明显，前面一个是执行结果，后面一个是预期结果，当然这只是一个简单的例子。由于Hamcrest引入了matcher的概念（就是你看到的is部分），我们可以进行更多的组合：</p>
<p>  assertThat(number, greaterThan(5));<br>  assertThat(text, startsWith(“Hello”));<br>  assertThat(array, hasItem(“World”));</p>
<p>Hamcrest如此好用，以至于JUnit已经将其吸纳进去。如果你现在用的JUnit是4.4之后的版本，那你已经有了Hamcrest。无需额外的配置，就可以拿过来用。</p>
<h4 id="Mockito"><a href="#Mockito" class="headerlink" title="Mockito"></a>Mockito</h4><p>写单元测试不用Mock框架几乎是一件不可能的事，我是说Mock框架，不是Mock模式哦！对于老Java程序员来说，提起Mock框架，率先在脑海中撞线的多半是JMock或EasyMock。</p>
<p>使用Mockito，只要有一个理由就够了，简单。相比于JMock，它不用写checking，相比于EasyMock，它省去了replay。下面是个例子：</p>
<p>  List mockedList = mock(List.class);<br>  when(mockedList.get(0)).thenReturn(“first”);<br>  System.out.println(mockedList.get(0));</p>
<p>当然，Mockito还是非常强大的。<br>最后再强调一遍，无论使用哪个框架，请尽量不要使用verify，也就是传说中的Mock模式，那是把代码拉入泥潭的开始。</p>
<h4 id="SLF4J和Logback"><a href="#SLF4J和Logback" class="headerlink" title="SLF4J和Logback"></a>SLF4J和Logback</h4><p>日志几乎是稍微有点规模的项目躲不开的一个东西，如果你是个老Java程序员，你必然知道Log4J，多半也知道Commons Logging。是时候把它们扔掉了，因为有SLF4J和Logback了。SLF4J要替代Commons Logging，而Logback的目标是Log4J。<br>只凭一点就足以让我们对SLF4J义无反顾了，你还记得用Commons Logging写出这样的代码吗？</p>
<p>  if (logger.debugEnable()) {<br>    logger.debug(“Hello, “, name);<br>  }</p>
<p>而SLF4J的写法只有一句话：</p>
<p>  logger.debug(“Hello, {}”, name);</p>
<p>从根源来说，这是时代造成的，Commons Logging是Java 5之前产生的，那时候还没有变参，所以，我们不得不说，它老了。</p>
<p>至于Logback，性能是最重要的噱头，当然，还有一些其它的理由。理由里有一点并未提及，但对于开发人员很贴心的改进，就是日志模式的改进，还记得Log4J那密码一样的日志模式吗？</p>
<p>  %d{dd MMM yyyy HH:mm:ss} [%t] %-5p %m%n</p>
<p>下面是Logback的版本，不用查文档，我也看出每段表示的都是什么：</p>
<p>  %d{dd MMM yyyy HH:mm:ss} [%thread] %-5level %msg%n</p>
<p>这里介绍的几个程序库都是很通用的，无论是你做怎样的开发，应该都或多或少给你一些帮助。时间未曾停步，Java开发也未曾停留，如果你是个老Java程序员，是时候更新一下自己的知识了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java里面的设计模式]]></title>
      <url>https://fudawei.github.io/2014/04/15/Java%E9%87%8C%E9%9D%A2%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>###Structural（结构模式）</p>
<h4 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter:"></a>Adapter:</h4><p>把一个接口或是类变成另外一种。<br>java.util.Arrays#asList()<br>javax.swing.JTable(TableModel)<br>java.io.InputStreamReader(InputStream)<br>java.io.OutputStreamWriter(OutputStream)<br>javax.xml.bind.annotation.adapters.XmlAdapter#marshal()<br>javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()</p>
<h4 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge:"></a>Bridge:</h4><p>把抽象和实现解藕，于是接口和实现可在完全独立开来。<br>AWT (提供了抽象层映射于实际的操作系统)<br>JDBC</p>
<h4 id="Composite"><a href="#Composite" class="headerlink" title="Composite:"></a>Composite:</h4><p>让使用者把单独的对象和组合对象混用。<br>javax.swing.JComponent#add(Component)<br>java.awt.Container#add(Component)<br>java.util.Map#putAll(Map)<br>java.util.List#addAll(Collection)<br>java.util.Set#addAll(Collection)</p>
<h4 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator:"></a>Decorator:</h4><p>为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。这个模式在JDK中几乎无处不在，所以，下面的列表只是一些典型的。<br>java.io.BufferedInputStream(InputStream)<br>java.io.DataInputStream(InputStream)<br>java.io.BufferedOutputStream(OutputStream)<br>java.util.zip.ZipOutputStream(OutputStream)<br>java.util.Collections#checked<a href="">List|Map|Set|SortedSet|SortedMap</a></p>
<h4 id="Facade"><a href="#Facade" class="headerlink" title="Facade:"></a>Facade:</h4><p>用一个简单的接口包状一组组件，接口，抽象或是子系统。<br>java.lang.Class<br>javax.faces.webapp.FacesServlet<br>Flyweight:<br>有效率地存储大量的小的对象。<br>java.lang.Integer#valueOf(int)<br>java.lang.Boolean#valueOf(boolean)<br>java.lang.Byte#valueOf(byte)<br>java.lang.Character#valueOf(char)</p>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy:"></a>Proxy:</h4><p>用一个简单的对象来代替一个复杂的对象。<br>java.lang.reflect.Proxy<br>RMI</p>
<h3 id="Creational（创建模式）"><a href="#Creational（创建模式）" class="headerlink" title="Creational（创建模式）"></a>Creational（创建模式）</h3><h4 id="Abstract-factory"><a href="#Abstract-factory" class="headerlink" title="Abstract factory:"></a>Abstract factory:</h4><p>创建一组有关联的对象实例。这个模式在JDK中也是相当的常见，还有很多的framework例如Spring。我们很容易找到这样的实例。</p>
<p>java.util.Calendar#getInstance()<br>java.util.Arrays#asList()<br>java.util.ResourceBundle#getBundle()<br>java.sql.DriverManager#getConnection()<br>java.sql.Connection#createStatement()<br>java.sql.Statement#executeQuery()<br>java.text.NumberFormat#getInstance()<br>javax.xml.transform.TransformerFactory#newInstance()</p>
<h4 id="Builder"><a href="#Builder" class="headerlink" title="Builder:"></a>Builder:</h4><p>主要用来简化一个复杂的对象的创建。这个模式也可以用来实现一个 Fluent Interface。<br>java.lang.StringBuilder#append()<br>java.lang.StringBuffer#append()<br>java.sql.PreparedStatement<br>javax.swing.GroupLayout.Group#addComponent()</p>
<h4 id="Factory"><a href="#Factory" class="headerlink" title="Factory:"></a>Factory:</h4><p>简单来说，按照需求返回一个类型的实例。<br>java.lang.Proxy#newProxyInstance()<br>java.lang.Object#toString()<br>java.lang.Class#newInstance()<br>java.lang.reflect.Array#newInstance()<br>java.lang.reflect.Constructor#newInstance()<br>java.lang.Boolean#valueOf(String)<br>java.lang.Class#forName()</p>
<h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype:"></a>Prototype:</h4><p>使用自己的实例创建另一个实例。有时候，创建一个实例然后再把已有实例的值拷贝过去，是一个很复杂的动作。所以，使用这个模式可以避免这样的复杂性。<br>java.lang.Object#clone()<br>java.lang.Cloneable</p>
<h4 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton:"></a>Singleton:</h4><p>只允许一个实例。在 Effective Java中建议使用Emun.<br>java.lang.Runtime#getRuntime()<br>java.awt.Toolkit#getDefaultToolkit()<br>java.awt.GraphicsEnvironment#getLocalGraphicsEnvironment()<br>java.awt.Desktop#getDesktop()<br>Behavioral(行为模式)</p>
<h4 id="Chain-of-responsibility"><a href="#Chain-of-responsibility" class="headerlink" title="Chain of responsibility:"></a>Chain of responsibility:</h4><p>把一个对象在一个链接传递直到被处理。在这个链上的所有的对象有相同的接口（抽象类）但却有不同的实现。<br>java.util.logging.Logger#log()<br>javax.servlet.Filter#doFilter()</p>
<h4 id="Command"><a href="#Command" class="headerlink" title="Command:"></a>Command:</h4><p>把一个或一些命令封装到一个对象中。<br>java.lang.Runnable<br>javax.swing.Action</p>
<h4 id="Interpreter"><a href="#Interpreter" class="headerlink" title="Interpreter:"></a>Interpreter:</h4><p>一个语法解释器的模式。</p>
<p>java.util.Pattern<br>java.text.Normalizer<br>java.text.Format</p>
<h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator:"></a>Iterator:</h4><p>提供一种一致的方法来顺序遍历一个容器中的所有元素。<br>java.util.Iterator<br>java.util.Enumeration</p>
<h4 id="Mediator"><a href="#Mediator" class="headerlink" title="Mediator:"></a>Mediator:</h4><p>用来减少对象单的直接通讯的依赖关系。使用一个中间类来管理消息的方向。<br>java.util.Timer<br>java.util.concurrent.Executor#execute()<br>java.util.concurrent.ExecutorService#submit()<br>java.lang.reflect.Method#invoke()</p>
<h4 id="Memento"><a href="#Memento" class="headerlink" title="Memento:"></a>Memento:</h4><p>给一个对象的状态做一个快照。Date类在内部使用了一个long型来做这个快照。<br>java.util.Date<br>java.io.Serializable</p>
<h4 id="Null-Object"><a href="#Null-Object" class="headerlink" title="Null Object:"></a>Null Object:</h4><p>这个模式用来解决如果一个Collection中没有元素的情况。<br>java.util.Collections#emptyList()<br>java.util.Collections#emptyMap()<br>java.util.Collections#emptySet()</p>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer:"></a>Observer:</h4><p>允许一个对象向所有的侦听的对象广播自己的消息或事件。<br>java.util.EventListener<br>javax.servlet.http.HttpSessionBindingListener<br>javax.servlet.http.HttpSessionAttributeListener<br>javax.faces.event.PhaseListener</p>
<h4 id="State"><a href="#State" class="headerlink" title="State:"></a>State:</h4><p>这个模式允许你可以在运行时很容易地根据自身内部的状态改变对象的行为。<br>java.util.Iterator<br>javax.faces.lifecycle.LifeCycle#execute()</p>
<h4 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy:"></a>Strategy:</h4><p>定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。<br>java.util.Comparator#compare()<br>javax.servlet.http.HttpServlet<br>javax.servlet.Filter#doFilter()</p>
<h4 id="Template-method"><a href="#Template-method" class="headerlink" title="Template method:"></a>Template method:</h4><p>允许子类重载部分父类而不需要完全重写。<br>java.util.Collections#sort()<br>java.io.InputStream#skip()<br>java.io.InputStream#read()<br>java.util.AbstractList#indexOf()</p>
<h4 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor:"></a>Visitor:</h4><p>作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作.<br>javax.lang.model.element.Element 和javax.lang.model.element.ElementVisitor<br>javax.lang.model.type.TypeMirror 和javax.lang.model.type.TypeVisitor</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java内存模型]]></title>
      <url>https://fudawei.github.io/2014/04/15/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-4/73912420.jpg" alt="java核心要点"><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-15/55500961.jpg" alt="java内存模型"></p>
<ol>
<li>主内存包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。</li>
<li><p>Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成</p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p> 关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>
</li>
</ol>
<blockquote>
<p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则</p>
</blockquote>
<ul>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>
</ul>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java线程池]]></title>
      <url>https://fudawei.github.io/2014/03/08/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<p>1、线程池简介：<br>多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。<br>假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。<br>如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。<br>一个线程池包括以下四个基本组成部分：<br>1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；<br>2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；<br>3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态<br>4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。<br>线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。<br>线程池不仅调整T1,T3产生的时间段，而且它还显著减少了创建线程的数目，看一个例子：<br>假设一个服务器一天要处理50000个请求，并且每个请求需要一个单独的线程完成。在线程池中，线程数一般是固定的，所以产生线程总数不会超过线程池中线程的数目，而如果服务器不利用线程池来处理这些请求则线程总数为50000。一般线程池大小是远小于50000。所以利用线程池的服务器程序不会为了创建50000而在处理请求时浪费时间，从而提高效率。</p>
<p>代码实现中并没有实现任务接口，而是把Runnable对象加入到线程池管理器（ThreadPool），然后剩下的事情就由线程池管理器（ThreadPool）来完成了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line">package mine.util.thread;</div><div class="line">import java.util.LinkedList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 线程池类，线程管理器：创建线程，执行任务，销毁线程，获取线程基本信息</div><div class="line"> */</div><div class="line">public final class ThreadPool &#123;</div><div class="line">    // 线程池中默认线程的个数为5</div><div class="line">    private static int worker_num = 5;</div><div class="line">    // 工作线程</div><div class="line">    private WorkThread[] workThrads;</div><div class="line">    // 未处理的任务</div><div class="line">    private static volatile int finished_task = 0;</div><div class="line">    // 任务队列，作为一个缓冲,List线程不安全</div><div class="line">    private List&lt;Runnable&gt; taskQueue = new LinkedList&lt;Runnable&gt;();</div><div class="line">    private static ThreadPool threadPool;</div><div class="line"></div><div class="line">    // 创建具有默认线程个数的线程池</div><div class="line">    private ThreadPool() &#123;</div><div class="line">        this(5);</div><div class="line">    &#125;</div><div class="line">    // 创建线程池,worker_num为线程池中工作线程的个数</div><div class="line">    private ThreadPool(int worker_num) &#123;</div><div class="line">        ThreadPool.worker_num = worker_num;</div><div class="line">        workThrads = new WorkThread[worker_num];</div><div class="line">        for (int i = 0; i &lt; worker_num; i++) &#123;</div><div class="line">            workThrads[i] = new WorkThread();</div><div class="line">            workThrads[i].start();// 开启线程池中的线程</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 单态模式，获得一个默认线程个数的线程池</div><div class="line">    public static ThreadPool getThreadPool() &#123;</div><div class="line">        return getThreadPool(ThreadPool.worker_num);</div><div class="line">    &#125;</div><div class="line">    // 单态模式，获得一个指定线程个数的线程池,worker_num(&gt;0)为线程池中工作线程的个数</div><div class="line">    // worker_num&lt;=0创建默认的工作线程个数</div><div class="line">    public static ThreadPool getThreadPool(int worker_num1) &#123;</div><div class="line">        if (worker_num1 &lt;= 0)</div><div class="line">            worker_num1 = ThreadPool.worker_num;</div><div class="line">        if (threadPool == null)</div><div class="line">            threadPool = new ThreadPool(worker_num1);</div><div class="line">        return threadPool;</div><div class="line">    &#125;</div><div class="line">    // 执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定</div><div class="line">    public void execute(Runnable task) &#123;</div><div class="line">        synchronized (taskQueue) &#123;</div><div class="line">            taskQueue.add(task);</div><div class="line">            taskQueue.notify();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定</div><div class="line">    public void execute(Runnable[] task) &#123;</div><div class="line">        synchronized (taskQueue) &#123;</div><div class="line">            for (Runnable t : task)</div><div class="line">                taskQueue.add(t);</div><div class="line">            taskQueue.notify();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定</div><div class="line">    public void execute(List&lt;Runnable&gt; task) &#123;</div><div class="line">        synchronized (taskQueue) &#123;</div><div class="line">            for (Runnable t : task)</div><div class="line">                taskQueue.add(t);</div><div class="line">            taskQueue.notify();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 销毁线程池,该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁</div><div class="line">    public void destroy() &#123;</div><div class="line">        while (!taskQueue.isEmpty()) &#123;// 如果还有任务没执行完成，就先睡会吧</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(10);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 工作线程停止工作，且置为null</div><div class="line">        for (int i = 0; i &lt; worker_num; i++) &#123;</div><div class="line">            workThrads[i].stopWorker();</div><div class="line">            workThrads[i] = null;</div><div class="line">        &#125;</div><div class="line">        threadPool=null;</div><div class="line">        taskQueue.clear();// 清空任务队列</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回工作线程的个数</div><div class="line">    public int getWorkThreadNumber() &#123;</div><div class="line">        return worker_num;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回已完成任务的个数,这里的已完成是只出了任务队列的任务个数，可能该任务并没有实际执行完成</div><div class="line">    public int getFinishedTasknumber() &#123;</div><div class="line">        return finished_task;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回任务队列的长度，即还没处理的任务个数</div><div class="line">    public int getWaitTasknumber() &#123;</div><div class="line">        return taskQueue.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 覆盖toString方法，返回线程池信息：工作线程个数和已完成任务个数</div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;WorkThread number:&quot; + worker_num + &quot;  finished task number:&quot;</div><div class="line">                + finished_task + &quot;  wait task number:&quot; + getWaitTasknumber();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 内部类，工作线程</div><div class="line">     */</div><div class="line">    private class WorkThread extends Thread &#123;</div><div class="line">        // 该工作线程是否有效，用于结束该工作线程</div><div class="line">        private boolean isRunning = true;</div><div class="line"></div><div class="line">        /*</div><div class="line">         * 关键所在啊，如果任务队列不空，则取出任务执行，若任务队列空，则等待</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            Runnable r = null;</div><div class="line">            while (isRunning) &#123;// 注意，若线程无效则自然结束run方法，该线程就没用了</div><div class="line">                synchronized (taskQueue) &#123;</div><div class="line">                    while (isRunning &amp;&amp; taskQueue.isEmpty()) &#123;// 队列为空</div><div class="line">                        try &#123;</div><div class="line">                            taskQueue.wait(20);</div><div class="line">                        &#125; catch (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    if (!taskQueue.isEmpty())</div><div class="line">                        r = taskQueue.remove(0);// 取出任务</div><div class="line">                &#125;</div><div class="line">                if (r != null) &#123;</div><div class="line">                    r.run();// 执行任务</div><div class="line">                &#125;</div><div class="line">                finished_task++;</div><div class="line">                r = null;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 停止工作，让该线程自然执行完run方法，自然结束</div><div class="line">        public void stopWorker() &#123;</div><div class="line">            isRunning = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//测试线程池</div><div class="line">public class TestThreadPool &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 创建3个线程的线程池</div><div class="line">        ThreadPool t = ThreadPool.getThreadPool(3);</div><div class="line">        t.execute(new Runnable[] &#123; new Task(), new Task(), new Task() &#125;);</div><div class="line">        t.execute(new Runnable[] &#123; new Task(), new Task(), new Task() &#125;);</div><div class="line">        System.out.println(t);</div><div class="line">        t.destroy();// 所有线程都执行完成才destory</div><div class="line">        System.out.println(t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 任务类</div><div class="line">    static class Task implements Runnable &#123;</div><div class="line">        private static volatile int i = 1;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;// 执行任务</div><div class="line">            System.out.println(&quot;任务 &quot; + (i++) + &quot; 完成&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">运行结果：</div><div class="line">WorkThread number:3  finished task number:0  wait task number:6</div><div class="line">任务 1 完成</div><div class="line">任务 2 完成</div><div class="line">任务 3 完成</div><div class="line">任务 4 完成</div><div class="line">任务 5 完成</div><div class="line">任务 6 完成</div><div class="line">WorkThread number:3  finished task number:6  wait task number:0</div><div class="line"></div><div class="line">分析：由于并没有任务接口，传入的可以是自定义的任何任务，所以线程池并不能准确的判断该任务是否真正的已经完成（真正完成该任务是这个任务的run方法执行完毕），只能知道该任务已经出了任务队列，正在执行或者已经完成。</div></pre></td></tr></table></figure></p>
<p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/java.current.gif" alt="java.util.concurrent"><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/0_1319784243mu5f.gif" alt="java.util.concurrent"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[单例模式]]></title>
      <url>https://fudawei.github.io/2014/03/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="如何正确地写出单例模式"><a href="#如何正确地写出单例模式" class="headerlink" title="如何正确地写出单例模式"></a>如何正确地写出单例模式</h1><p>转自 <a href="https://github.com/biezhi/java-bible" target="_blank" rel="external">reference</a><br>单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。</p>
<h3 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h3><p>当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">         instance = <span class="keyword">new</span> Singleton();</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p>
<h3 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h3><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">        instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。</p>
<h3 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h3><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 <code>instance == null</code>，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         <span class="comment">//Single Checked</span></div><div class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                 <span class="comment">//Double Checked</span></div><div class="line">                instance = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>
<ol>
<li>给 instance 分配内存</li>
<li>调用 Singleton 的构造函数来初始化成员变量</li>
<li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li>
</ol>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
<p>我们只需要将 instance 变量声明成 volatile 就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; <span class="comment">//声明成 volatile</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p>
<p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。</p>
<h3 id="饿汉式-static-final-field"><a href="#饿汉式-static-final-field" class="headerlink" title="饿汉式 static final field"></a>饿汉式 static final field</h3><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="comment">//类加载时就初始化</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p>
<h3 id="静态内部类-static-nested-class"><a href="#静态内部类-static-nested-class" class="headerlink" title="静态内部类 static nested class"></a>静态内部类 static nested class</h3><p>我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>
<h3 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举 Enum"></a>枚举 Enum</h3><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，文章开头给出的第一种方法不算正确的写法。</p>
<p>就我个人而言，一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）会倾向于使用静态内部类，如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p>
<h3 id="Read-More"><a href="#Read-More" class="headerlink" title="Read More"></a>Read More</h3><ul>
<li><a href="http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html" target="_blank" rel="external">Double Checked Locking on Singleton Class in Java</a></li>
<li><a href="http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html" target="_blank" rel="external">http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html</a></li>
<li><a href="http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html" target="_blank" rel="external">How to create thread safe Singleton in Java</a></li>
<li><a href="http://javarevisited.blogspot.com/2011/03/10-interview-questions-on-singleton.html" target="_blank" rel="external">10 Singleton Pattern Interview questions in Java</a></li>
</ul>
<p>由于作者这篇文章写的非常好，我也就没有重写 <a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/#from=biezhi.me" target="_blank" rel="external">原文出处</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java面试问题总结]]></title>
      <url>https://fudawei.github.io/2014/03/02/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h4 id="java锁类型"><a href="#java锁类型" class="headerlink" title="java锁类型"></a>java锁类型</h4><ul>
<li>自旋锁，为解决由用户态和内核态的频繁切换以及线程上下文切换开销比较大引入自旋锁。问题：ABA,单核无效。解决：AtomicStampedReference将更新一个“对象 —-引用”二元组，通过在引用上加上“版本号”，从而避免ABA问题。</li>
<li>可重入锁，可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。<br>在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁。可重入锁最大的作用是避免死锁。</li>
<li>阻塞锁，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字，ReentrantLock，Object.wait()\notify(),LockSupport.park()/unpark()。阻塞锁的优势在于，阻塞的线程不会占用cpu时间， 不会导致 CPU占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。</li>
</ul>
<h4 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h4><p>(主内存、工作内存、交互、八种操作lock,unlock、重排序三类)</p>
<ol>
<li>从主存复制变量到当前工作内存 (read and load)</li>
<li>执行代码，改变共享变量 (use and assign)</li>
<li>用工作内存数据刷新主存相关的内容 (store and write)</li>
</ol>
<h4 id="进程线程管程区别"><a href="#进程线程管程区别" class="headerlink" title="进程线程管程区别"></a>进程线程管程区别</h4><ul>
<li>进程 ：一个程序在一个数据集合上的一次运行过程，是资源分配的最小单位，进程无法突破进程边界存取其他进程内的存储空间</li>
<li>线程 ：线程是进程中的一个实体，是被系统独立调度和执行的最小单位，同一进程所产生的线程共享同一内存空间。</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>产生死锁的条件：互斥、请求与保持、不剥夺条件、循环等待条件<br><em>解除与预防</em><br>1.采用资源静态分配策略，破坏”部分分配”条件<br>2.允许进程剥夺使用其他进程占有的资源，破坏不可剥夺条件<br>3.采用资源有序分配法，破坏环路条件</p>
<h4 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><p>1.聚集索引的顺序就是数据的物理存储顺序，非聚集索引的索引顺序与物理顺序无关。<br>2.一个表只能包含一个聚集索引，可以有多个非聚集索引<br>3.聚集索引对于那些经常要搜索范围值的列有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻<br>4.非索引存储中的项目按索引键值的顺序存储，而表中信息按另一种顺序存储。</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>1.为避免其他程序创建该类对象，将构造函数私有化<br>2.为了其他程序访问到该类对象，须在本类中创建一个该类私有对象<br>3.为了方便其他程序访问该类对象，可对外提供一个公共访问方式<br>比如API中的Runtime类就是单例设计模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Singleton&#123;</div><div class="line">	private static Singleton instance;</div><div class="line">	private static byte[] lock = new byte[1];</div><div class="line">	private Singleton&#123; &#125;</div><div class="line">	public static Singleton getInstance()&#123;</div><div class="line">		if(instance == null)&#123;</div><div class="line">			synchronized(lock)&#123;</div><div class="line">				if(instance == null) &#123;</div><div class="line">					instance = new Singleton();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><ol>
<li>final修饰变量：final修饰的变量只能被赋值一次，可以是在声明的时候进行初始化，也可以是在初始化函数中进行初始化，基本数据类型在赋值后它的值无法改变，如果是一个对象的引用则不能再指向其它对象，但是这个对象的值是可以改变的。比如一个指向StringBuilder的对象A，A不能再被赋值，但是这个StringBuilder对象的值是可以改变的。</li>
<li>final修饰的方法：final修饰的方法不能被子类重写</li>
<li>final修饰的类：final修饰的类不能被继承，也就是说它所有的实现都不能被改变，方法不能被重写。常用于设计一些不想让使用者改变的类。</li>
</ol>
<h4 id="fail-fast-amp-amp-fail-safe"><a href="#fail-fast-amp-amp-fail-safe" class="headerlink" title="fail-fast &amp;&amp; fail-safe"></a>fail-fast &amp;&amp; fail-safe</h4><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：<br>注意到modCount声明为volatile，保证线程之间修改的可见性。</p>
<h4 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h4><ul>
<li>新生代，新生区是类的诞生、成长、消亡的区域，一个类在这里产生、应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区和幸存者区，所有的类都是在伊甸区被创建的，幸存区有两个：0区（Survivor 0）和1区(Survivor 1)。当伊甸区的空间用完，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收，将伊甸区中的不再被其他对象所引用的对象进行销毁。然后将伊甸区中的剩余对象移动到幸存0区，若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区，如果1区也满了，就移动到老年区。</li>
<li>老年代，用于保存从新生区筛选出来的java对象，一般池对象都在这个区域活跃。</li>
<li>永久代 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class Interface 的元数据，也就是说，它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被回收器回收的，关闭JVM才会释放此区域所占用的内存。</li>
</ul>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul>
<li>标记-清除算法<br>首先标记出所有需要回收的对象，在标完成后统一回收掉所有被标记的对象。缺点：效率不高，且标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致运行过程中需要分配大对象的时候无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
<li>复制算法<br>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清理掉，内存使用率不高，现在商业虚拟机比如HotSpot都采用8:1的比例（Eden:Survivor）</li>
<li>标记-整理算法<br>把存活对象往内存的一端移动，然后直接回收边界以外的内存，提高了内存利用率，适合在收集对象存活时间较长的老年代。</li>
<li>分代收集算法<br>根据对象的存活时间把内存分为新生代和老年代，根据各代对象的存活特点，每个代采用不同的垃圾回收算法，新生代采用标记-复制算法，老年代采用标记-整理算法。</li>
</ul>
<h4 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h4><p>transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。</p>
<h4 id="重写equals方法"><a href="#重写equals方法" class="headerlink" title="重写equals方法"></a>重写equals方法</h4><p>1.使用==符号检查“参数是否为这个对象的引用”。如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。<br>2.使用instanceof操作符检查“参数是否为正确的类型”。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。<br>3.把参数转换成正确的类型。因为转换之前进行过instanceof测试，所以确保会成功。<br>4.对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回true;否则返回false。<br>5.当编写完成了equals方法之后，检查“对称性”、“传递性”、“一致性”。</p>
<h4 id="重写hashCode的意义"><a href="#重写hashCode的意义" class="headerlink" title="重写hashCode的意义"></a>重写hashCode的意义</h4><ol>
<li>在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。</li>
<li>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li>
<li>如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。</li>
<li>如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。</li>
</ol>
<h4 id="JVM-运行时数据区-JVM-Runtime-Area"><a href="#JVM-运行时数据区-JVM-Runtime-Area" class="headerlink" title="JVM 运行时数据区 (JVM Runtime Area)"></a>JVM 运行时数据区 (JVM Runtime Area)</h4><p>6个区域：<br>1、PC程序计数器：一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器, NAMELY存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。Java 的多线程机制离不开程序计数器，每个线程都有一个自己的PC，以便完成不同线程上下文环境的切换。<br>2、java虚拟机栈：与 PC 一样，java 虚拟机栈也是线程私有的。每一个 JVM 线程都有自己的 java 虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈<br>帧在虚拟机栈中从入栈到出栈的过程。<br>3、本地方法栈：与虚拟机栈的作用相似，虚拟机栈为虚拟机执行执行java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务。<br>4、Java堆：被所有线程共享的一块存储区域，在虚拟机启动时创建，它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。<br>Java堆在JVM启动的时候就被创建，堆中储存了各种对象，这些对象被自动管理内存系统（Automatic Storage Management System，也即是常说的 “Garbage Collector（垃圾回收器）”）所管理。这些对象无需、也无法显示地被销毁。<br>JVM将Heap分为两块：新生代New Generation和旧生代Old Generation<br><strong> 堆在JVM是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是new开销比较大的原因 </strong><br>5、方法区<br>方法区和堆区域一样，是各个线程共享的内存区域，它用于存储每一个类的结构信息，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。当开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。<br>方法区也是全局共享的，在虚拟机启动时候创建。在一定条件下它也会被GC。这块区域对应Permanent Generation 持久代。<br>6、运行时常量池其空间从方法区中分配，存放的为类中固定的常量信息、方法和域的引用信息。</p>
<h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><p>1.降低资源消耗，重用已经创建好的线程，降低创建和销毁的开销<br>2.提高响应速度，不用等待创建线程就能立即执行<br>3.提高线程的可管理性，统一分配、调优和监控<br>4.防止服务器过载，防止内存溢出或者CPU耗尽</p>
<h4 id="简单工厂-工厂方法-抽象工厂"><a href="#简单工厂-工厂方法-抽象工厂" class="headerlink" title="简单工厂 工厂方法 抽象工厂"></a>简单工厂 工厂方法 抽象工厂</h4><ul>
<li>简单工厂: 抽象了同一类型(比如不同品牌的笔记本电脑)产品的生产过程,通过工厂类来实现对不同产品生产过程的选择</li>
<li>工厂方法: 不仅抽象了产品类的生产过程,还抽象了工厂类本身. 将特定的产品的生产过程和特定的工厂相对应. 将原先工厂类中的选择提升到工程类以上的层级—即客户层级. 通过选择特定的工厂,来选择生产特定的产品.</li>
<li>抽象工厂: 在工厂方法的基础上,将特定的产品生产过程和特定的工厂类之间的对应关系解除,使得工厂类和产品类之间能够产生更多灵活的组合方式.</li>
</ul>
<h4 id="对象引用的类型"><a href="#对象引用的类型" class="headerlink" title="对象引用的类型"></a>对象引用的类型</h4><ul>
<li>Reference(or named Strong Reference)（ 强引用）：普通类型的引用。</li>
<li>SoftReference（ 软引用）：被这种引用指向的对象，如果此对象没要再被其他Strong Reference引用的话，可能在任何时候被GC。虽然是可能在任何时候被GC，但是通常是在可用内存数比较低的时候，并且在程序抛出OutOfMemoryError之前才发生对此对象的GC。SoftReference通常被用作实现Cache的对象引用，如果这个对象被GC了，那么他可以在任何时候再重新被创建。另外，根据JDK文档中介绍，实际JVM的实现是鼓励不回收最近创建和最近使用的对象。SoftReference 类的一个典型用途就是用于内存敏感的高速缓存。</li>
<li>WeakReference（弱引用）：如果一个被WeakReference引用的对象，当没要任何SoftReference和StrongReference引用时，立即会被GC。和SoftReference的区别是：WeakReference对象是被eagerly collected，即一旦没要任何SoftReference和StrongReference引用，立即被清楚；而只被SoftReference引用的对象，不回立即被清楚，只有当内存不够，即将发生OutOfMemoryError时才被清除，而且是先清除不常用的。SoftReference适合实现Cache用。WeakReference 类的一个典型用途就是规范化映射（ canonicalized mapping ）</li>
<li>PhantomReference（虚引用）：当没有StrongReference，SoftReference和WeakReference引用时，随时可被GC。通常和ReferenceQueue联合使用，管理和清除与被引用对象（没有finalize方法）相关的本地资源。</li>
</ul>
<h4 id="五层协议的网络体系结构"><a href="#五层协议的网络体系结构" class="headerlink" title="五层协议的网络体系结构"></a>五层协议的网络体系结构</h4><ol>
<li>物理层，物理层任务是透明传输比特流。</li>
<li>数据链路层，将网络层交下来的IP数据包组装成帧，在两个相邻节点间的链路上透明的传输帧中的数据，每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）</li>
<li>网络层，把运输层产生的报文段封装成分组或包进行传送</li>
<li>运输层，负责向两个主机中进程之间的通信提供服务，运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务，分用则是运输层把收到的信息分别交付上面应用层中的相应进程。</li>
<li>应用层，直接为用户的应用进程提供服务。</li>
</ol>
<p>title: java面试问题总结<br>date: 2016-04-16 12:09:00<br>categories: [java,面试]</p>
<h2 id="tags-java-面试"><a href="#tags-java-面试" class="headerlink" title="tags: [java,面试]"></a>tags: [java,面试]</h2><h4 id="java锁类型-1"><a href="#java锁类型-1" class="headerlink" title="java锁类型"></a>java锁类型</h4><ul>
<li>自旋锁，为解决由用户态和内核态的频繁切换以及线程上下文切换开销比较大引入自旋锁。问题：ABA,单核无效。解决：AtomicStampedReference将更新一个“对象 —-引用”二元组，通过在引用上加上“版本号”，从而避免ABA问题。</li>
<li>可重入锁，可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。<br>在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁。可重入锁最大的作用是避免死锁。</li>
<li>阻塞锁，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字，ReentrantLock，Object.wait()\notify(),LockSupport.park()/unpark()。阻塞锁的优势在于，阻塞的线程不会占用cpu时间， 不会导致 CPU占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。</li>
</ul>
<h4 id="java内存模型-1"><a href="#java内存模型-1" class="headerlink" title="java内存模型"></a>java内存模型</h4><p>(主内存、工作内存、交互、八种操作lock,unlock、重排序三类)</p>
<ol>
<li>从主存复制变量到当前工作内存 (read and load)</li>
<li>执行代码，改变共享变量 (use and assign)</li>
<li>用工作内存数据刷新主存相关的内容 (store and write)</li>
</ol>
<h4 id="进程线程管程区别-1"><a href="#进程线程管程区别-1" class="headerlink" title="进程线程管程区别"></a>进程线程管程区别</h4><ul>
<li>进程 ：一个程序在一个数据集合上的一次运行过程，是资源分配的最小单位，进程无法突破进程边界存取其他进程内的存储空间</li>
<li>线程 ：线程是进程中的一个实体，是被系统独立调度和执行的最小单位，同一进程所产生的线程共享同一内存空间。</li>
</ul>
<h4 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h4><p>产生死锁的条件：互斥、请求与保持、不剥夺条件、循环等待条件<br><em>解除与预防</em><br>1.采用资源静态分配策略，破坏”部分分配”条件<br>2.允许进程剥夺使用其他进程占有的资源，破坏不可剥夺条件<br>3.采用资源有序分配法，破坏环路条件</p>
<h4 id="聚集索引和非聚集索引-1"><a href="#聚集索引和非聚集索引-1" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><p>1.聚集索引的顺序就是数据的物理存储顺序，非聚集索引的索引顺序与物理顺序无关。<br>2.一个表只能包含一个聚集索引，可以有多个非聚集索引<br>3.聚集索引对于那些经常要搜索范围值的列有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻<br>4.非索引存储中的项目按索引键值的顺序存储，而表中信息按另一种顺序存储。</p>
<h4 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h4><p>1.为避免其他程序创建该类对象，将构造函数私有化<br>2.为了其他程序访问到该类对象，须在本类中创建一个该类私有对象<br>3.为了方便其他程序访问该类对象，可对外提供一个公共访问方式<br>比如API中的Runtime类就是单例设计模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Singleton&#123;</div><div class="line">	private static Singleton instance;</div><div class="line">	private static byte[] lock = new byte[1];</div><div class="line">	private Singleton&#123; &#125;</div><div class="line">	public static Singleton getInstance()&#123;</div><div class="line">		if(instance == null)&#123;</div><div class="line">			synchronized(lock)&#123;</div><div class="line">				if(instance == null) &#123;</div><div class="line">					instance = new Singleton();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="单例适用场景"><a href="#单例适用场景" class="headerlink" title="单例适用场景"></a>单例适用场景</h4><p>控制资源的使用，通过线程同步来控制资源的并发访问<br>控制实例的产生，以达到节约资源的目的<br>控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</p>
<h4 id="final关键字-1"><a href="#final关键字-1" class="headerlink" title="final关键字"></a>final关键字</h4><ol>
<li>final修饰变量：final修饰的变量只能被赋值一次，可以是在声明的时候进行初始化，也可以是在初始化函数中进行初始化，基本数据类型在赋值后它的值无法改变，如果是一个对象的引用则不能再指向其它对象，但是这个对象的值是可以改变的。比如一个指向StringBuilder的对象A，A不能再被赋值，但是这个StringBuilder对象的值是可以改变的。</li>
<li>final修饰的方法：final修饰的方法不能被子类重写</li>
<li>final修饰的类：final修饰的类不能被继承，也就是说它所有的实现都不能被改变，方法不能被重写。常用于设计一些不想让使用者改变的类。</li>
</ol>
<h4 id="fail-fast-amp-amp-fail-safe-1"><a href="#fail-fast-amp-amp-fail-safe-1" class="headerlink" title="fail-fast &amp;&amp; fail-safe"></a>fail-fast &amp;&amp; fail-safe</h4><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：<br>注意到modCount声明为volatile，保证线程之间修改的可见性。</p>
<h4 id="堆内存-1"><a href="#堆内存-1" class="headerlink" title="堆内存"></a>堆内存</h4><ul>
<li>新生代，新生区是类的诞生、成长、消亡的区域，一个类在这里产生、应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区和幸存者区，所有的类都是在伊甸区被创建的，幸存区有两个：0区（Survivor 0）和1区(Survivor 1)。当伊甸区的空间用完，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收，将伊甸区中的不再被其他对象所引用的对象进行销毁。然后将伊甸区中的剩余对象移动到幸存0区，若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区，如果1区也满了，就移动到老年区。</li>
<li>老年代，用于保存从新生区筛选出来的java对象，一般池对象都在这个区域活跃。</li>
<li>永久代 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class Interface 的元数据，也就是说，它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被回收器回收的，关闭JVM才会释放此区域所占用的内存。</li>
</ul>
<h4 id="垃圾收集算法-1"><a href="#垃圾收集算法-1" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul>
<li>标记-清除算法<br>首先标记出所有需要回收的对象，在标完成后统一回收掉所有被标记的对象。缺点：效率不高，且标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致运行过程中需要分配大对象的时候无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
<li>复制算法<br>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清理掉，内存使用率不高，现在商业虚拟机比如HotSpot都采用8:1的比例（Eden:Survivor）</li>
<li>标记-整理算法<br>把存活对象往内存的一端移动，然后直接回收边界以外的内存，提高了内存利用率，适合在收集对象存活时间较长的老年代。</li>
<li>分代收集算法<br>根据对象的存活时间把内存分为新生代和老年代，根据各代对象的存活特点，每个代采用不同的垃圾回收算法，新生代采用标记-复制算法，老年代采用标记-整理算法。</li>
</ul>
<h4 id="transient-1"><a href="#transient-1" class="headerlink" title="transient"></a>transient</h4><p>transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。</p>
<h4 id="重写equals方法-1"><a href="#重写equals方法-1" class="headerlink" title="重写equals方法"></a>重写equals方法</h4><p>1.使用==符号检查“参数是否为这个对象的引用”。如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。<br>2.使用instanceof操作符检查“参数是否为正确的类型”。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。<br>3.把参数转换成正确的类型。因为转换之前进行过instanceof测试，所以确保会成功。<br>4.对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回true;否则返回false。<br>5.当编写完成了equals方法之后，检查“对称性”、“传递性”、“一致性”。</p>
<h4 id="重写hashCode的意义-1"><a href="#重写hashCode的意义-1" class="headerlink" title="重写hashCode的意义"></a>重写hashCode的意义</h4><ol>
<li>在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。</li>
<li>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li>
<li>如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。</li>
<li>如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。</li>
</ol>
<h4 id="JVM-运行时数据区-JVM-Runtime-Area-1"><a href="#JVM-运行时数据区-JVM-Runtime-Area-1" class="headerlink" title="JVM 运行时数据区 (JVM Runtime Area)"></a>JVM 运行时数据区 (JVM Runtime Area)</h4><p>6个区域：<br>1、PC程序计数器：一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器, NAMELY存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。Java 的多线程机制离不开程序计数器，每个线程都有一个自己的PC，以便完成不同线程上下文环境的切换。<br>2、java虚拟机栈：与 PC 一样，java 虚拟机栈也是线程私有的。每一个 JVM 线程都有自己的 java 虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈<br>帧在虚拟机栈中从入栈到出栈的过程。<br>3、本地方法栈：与虚拟机栈的作用相似，虚拟机栈为虚拟机执行执行java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务。<br>4、Java堆：被所有线程共享的一块存储区域，在虚拟机启动时创建，它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。<br>Java堆在JVM启动的时候就被创建，堆中储存了各种对象，这些对象被自动管理内存系统（Automatic Storage Management System，也即是常说的 “Garbage Collector（垃圾回收器）”）所管理。这些对象无需、也无法显示地被销毁。<br>JVM将Heap分为两块：新生代New Generation和旧生代Old Generation<br><strong> 堆在JVM是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是new开销比较大的原因 </strong><br>5、方法区<br>方法区和堆区域一样，是各个线程共享的内存区域，它用于存储每一个类的结构信息，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。当开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。<br>方法区也是全局共享的，在虚拟机启动时候创建。在一定条件下它也会被GC。这块区域对应Permanent Generation 持久代。<br>6、运行时常量池其空间从方法区中分配，存放的为类中固定的常量信息、方法和域的引用信息。</p>
<h4 id="线程池的好处-1"><a href="#线程池的好处-1" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><p>1.降低资源消耗，重用已经创建好的线程，降低创建和销毁的开销<br>2.提高响应速度，不用等待创建线程就能立即执行<br>3.提高线程的可管理性，统一分配、调优和监控<br>4.防止服务器过载，防止内存溢出或者CPU耗尽</p>
<h4 id="简单工厂-工厂方法-抽象工厂-1"><a href="#简单工厂-工厂方法-抽象工厂-1" class="headerlink" title="简单工厂 工厂方法 抽象工厂"></a>简单工厂 工厂方法 抽象工厂</h4><ul>
<li>简单工厂: 抽象了同一类型(比如不同品牌的笔记本电脑)产品的生产过程,通过工厂类来实现对不同产品生产过程的选择</li>
<li>工厂方法: 不仅抽象了产品类的生产过程,还抽象了工厂类本身. 将特定的产品的生产过程和特定的工厂相对应. 将原先工厂类中的选择提升到工程类以上的层级—即客户层级. 通过选择特定的工厂,来选择生产特定的产品.</li>
<li>抽象工厂: 在工厂方法的基础上,将特定的产品生产过程和特定的工厂类之间的对应关系解除,使得工厂类和产品类之间能够产生更多灵活的组合方式.</li>
</ul>
<h4 id="对象引用的类型-1"><a href="#对象引用的类型-1" class="headerlink" title="对象引用的类型"></a>对象引用的类型</h4><ul>
<li>Reference(or named Strong Reference)（ 强引用）：普通类型的引用。</li>
<li>SoftReference（ 软引用）：被这种引用指向的对象，如果此对象没要再被其他Strong Reference引用的话，可能在任何时候被GC。虽然是可能在任何时候被GC，但是通常是在可用内存数比较低的时候，并且在程序抛出OutOfMemoryError之前才发生对此对象的GC。SoftReference通常被用作实现Cache的对象引用，如果这个对象被GC了，那么他可以在任何时候再重新被创建。另外，根据JDK文档中介绍，实际JVM的实现是鼓励不回收最近创建和最近使用的对象。SoftReference 类的一个典型用途就是用于内存敏感的高速缓存。</li>
<li>WeakReference（弱引用）：如果一个被WeakReference引用的对象，当没要任何SoftReference和StrongReference引用时，立即会被GC。和SoftReference的区别是：WeakReference对象是被eagerly collected，即一旦没要任何SoftReference和StrongReference引用，立即被清楚；而只被SoftReference引用的对象，不回立即被清楚，只有当内存不够，即将发生OutOfMemoryError时才被清除，而且是先清除不常用的。SoftReference适合实现Cache用。WeakReference 类的一个典型用途就是规范化映射（ canonicalized mapping ）</li>
<li>PhantomReference（虚引用）：当没有StrongReference，SoftReference和WeakReference引用时，随时可被GC。通常和ReferenceQueue联合使用，管理和清除与被引用对象（没有finalize方法）相关的本地资源。</li>
</ul>
<h4 id="五层协议的网络体系结构-1"><a href="#五层协议的网络体系结构-1" class="headerlink" title="五层协议的网络体系结构"></a>五层协议的网络体系结构</h4><ol>
<li>物理层，物理层任务是透明传输比特流。</li>
<li>数据链路层，将网络层交下来的IP数据包组装成帧，在两个相邻节点间的链路上透明的传输帧中的数据，每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）</li>
<li>网络层，把运输层产生的报文段封装成分组或包进行传送</li>
<li>运输层，负责向两个主机中进程之间的通信提供服务，运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务，分用则是运输层把收到的信息分别交付上面应用层中的相应进程。</li>
<li>应用层，直接为用户的应用进程提供服务。</li>
</ol>
<h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><ol>
<li>select 尽量少用*，只查询需要的列</li>
<li>多表连接时使用别名，提高sql解释效率，减少重名错误</li>
<li>where中把限制条件最大的放前面，利用数据库查询优化器优化</li>
<li>时分秒不必要时，选择Date类型而不是DateTime类型</li>
<li><blockquote>
<p>=比&gt;更容易定位索引</p>
</blockquote>
</li>
<li>like “R%”使用索引，like “%R”不使用索引</li>
<li>在where中尽量使用被索引的列</li>
</ol>
<h4 id="SQL和NoSQL区别"><a href="#SQL和NoSQL区别" class="headerlink" title="SQL和NoSQL区别"></a>SQL和NoSQL区别</h4><blockquote>
<ul>
<li>非关系型数据库的优势：</li>
</ul>
<ol>
<li>性能<br>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li>
<li>可扩展性<br>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li>
</ol>
<ul>
<li>关系型数据库的优势：</li>
</ul>
<ol>
<li>复杂查询<br>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li>
<li>事务支持<br>使得对于安全性能很高的数据访问要求得以实现。</li>
</ol>
</blockquote>
<h4 id="Cookie-amp-amp-Session"><a href="#Cookie-amp-amp-Session" class="headerlink" title="Cookie &amp;&amp; Session"></a>Cookie &amp;&amp; Session</h4><h4 id="Get-amp-amp-Post"><a href="#Get-amp-amp-Post" class="headerlink" title="Get &amp;&amp; Post"></a>Get &amp;&amp; Post</h4><h4 id="事务的四个特点ACID"><a href="#事务的四个特点ACID" class="headerlink" title="事务的四个特点ACID:"></a>事务的四个特点ACID:</h4><p>A:原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。它是一个整体，不能再拆分<br>C：一致性：事务在完成时，必须使所有的数据都保持一致状态。。某种程度的一致<br>I:隔离性：事务中隔离，每一个事务是单独的请求将单独的处理，与其它事务没有关系，互不影响<br>D：持久性：如果事务一旦提交，就对数据的修改永久保留</p>
<h4 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h4><ol>
<li>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li>
<li>类可以实现很多个接口，但是只能继承一个抽象类</li>
<li>类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不4. 实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li>
<li>抽象类可以在不提供接口方法实现的情况下实现接口。</li>
<li>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</li>
<li>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</li>
</ol>
<h3 id="并行计算与分布式计算"><a href="#并行计算与分布式计算" class="headerlink" title="并行计算与分布式计算"></a>并行计算与分布式计算</h3><p>1.并行计算借助并行算法和并行编程语言能够实现进程及并行和线程级并行；而分布式计算只是将任务分成小块到各个计算机分别计算各自执行<br>2.粒度方面，并行计算中，处理器间的交互一般很频繁，往往具有细粒度和的开销的特征并且被认为是可靠的；分布式计算中，处理器间的交互不频繁，粗粒度，并被认为是不可靠的，并行计算注重短的执行时间，分布式计算则注重长的正常运行时间。<br>java中断机制是一种协作机制，也就是说通常并不能直接终止另一个线程，而需要被中断的线程自己处理中断</p>
<p>通常情况下，根线程组是System线程组，system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。也就是说system线程组是最顶级的父线程组<br>Thread.currentThread().getThreadGroup()  // 获得当前线程的线程组</p>
<h3 id="线程组和线程池的区别"><a href="#线程组和线程池的区别" class="headerlink" title="线程组和线程池的区别"></a>线程组和线程池的区别</h3><p>线程组和线程池作用不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。<br>注意： ThreadLocalMap 对象是以this指向的ThreadLocal对象为键进行查找的，和set方法是相对应的。<br>每一个线程都有一个独立的ThreadLocalMap 副本，它所存储的值，只能被当前线程读取和修改。</p>
<h3 id="java内存模型-2"><a href="#java内存模型-2" class="headerlink" title="java内存模型"></a>java内存模型</h3><p>每个线程都有自己的工作内存，工作内存存储了主存的某些变量的副本，当然线程的工作内存是有限制的，当线程操作某个对象时，执行顺序如下：<br>1.从主存复制变量到当前工作内存 (read and load)<br>2.执行代码，改变共享变量   (use and assign)<br>3.用工作内存数据刷新主存相关的内容   (store and write)<br>线程在引用变量时不能直接从内存中引用，如果线程工作内存中没有该变量，会从主存拷贝一个副本到工作内存中，read and load ，完成后线程会引用该副本，当同一线程再度引用该字段时，可能重新从主存获取变量副本 read load use ,也有可能直接引用原来的的副本，也就是说read load use顺序由JVM决定。产生时序性问题。</p>
<p>加锁和释放锁都需要此对象的资源，那肯定对象越小越好，所以方法块加锁使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private byte[] lock = new byte[1];</div><div class="line">public void methodB()&#123;</div><div class="line">	synchronized(lock)&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ReentrantLock 是工作中使用频率最高的方法块加锁</p>
<h3 id="Lock-与-synchronized-区别"><a href="#Lock-与-synchronized-区别" class="headerlink" title="Lock 与 synchronized 区别"></a>Lock 与 synchronized 区别</h3><ol>
<li>Lock使用起来更灵活，但是必须有释放锁的动作配合</li>
<li>Lock必须手动释放和开启锁，而synchronized不需要手动释放和开启锁</li>
<li>Lock只适用于代码块锁，而synchronized对象之间是互斥关系</li>
</ol>
<h3 id="单例模式-2"><a href="#单例模式-2" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Singleton&#123;</div><div class="line">	private static Singleton instance;</div><div class="line">	private static byte[] lock = new byte[1];</div><div class="line">	private Singleton&#123; &#125;</div><div class="line">	public static Singleton getInstance()&#123;</div><div class="line">		if(instance == null)&#123;</div><div class="line">			synchronized(lock)&#123;</div><div class="line">				if(instance == null) &#123;</div><div class="line">					instance = new Singleton();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CopyOnWrite机制"><a href="#CopyOnWrite机制" class="headerlink" title="CopyOnWrite机制"></a>CopyOnWrite机制</h3><p>CopyOnWrite 写时复制的容器，当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器copy，复制出一个新的容器，然后新的容器里<br>、添加元素，添加完元素之后，再将当前容器的引用指向新的容器。</p>
<p>线程池一定要在合理的单例模式下才有效</p>
<h3 id="线程池的好处-2"><a href="#线程池的好处-2" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><p>1.降低资源消耗，重用已经创建好的线程，降低创建和销毁的开销<br>2.提高响应速度，不用等待创建线程就能立即执行<br>3.提高线程的可管理性，统一分配、调优和监控<br>4.防止服务器过载，防止内存溢出或者CPU耗尽</p>
<h3 id="对象引用的类型-2"><a href="#对象引用的类型-2" class="headerlink" title="对象引用的类型"></a>对象引用的类型</h3><p>Reference(or named Strong Reference)（ 强引用）：普通类型的引用。<br>SoftReference（ 软引用）：被这种引用指向的对象，如果此对象没要再被其他Strong Reference引用的话，可能在任何时候被GC。虽然是可能在任何时候被GC，但是通常是在可用内存数比较低的时候，并且在程序抛出OutOfMemoryError之前才发生对此对象的GC。SoftReference通常被用作实现Cache的对象引用，如果这个对象被GC了，那么他可以在任何时候再重新被创建。另外，根据JDK文档中介绍，实际JVM的实现是鼓励不回收最近创建和最近使用的对象。SoftReference 类的一个典型用途就是用于内存敏感的高速缓存。<br>WeakReference（弱引用）：如果一个被WeakReference引用的对象，当没要任何SoftReference和StrongReference引用时，立即会被GC。和SoftReference的区别是：WeakReference对象是被eagerly collected，即一旦没要任何SoftReference和StrongReference引用，立即被清楚；而只被SoftReference引用的对象，不回立即被清楚，只有当内存不够，即将发生OutOfMemoryError时才被清除，而且是先清除不常用的。SoftReference适合实现Cache用。WeakReference 类的一个典型用途就是规范化映射（ canonicalized mapping ）<br>PhantomReference（虚引用）：当没有StrongReference，SoftReference和WeakReference引用时，随时可被GC。通常和ReferenceQueue联合使用，管理和清除与被引用对象（没有finalize方法）相关的本地资源。</p>
<h3 id="简单工厂-工厂方法-抽象工厂-2"><a href="#简单工厂-工厂方法-抽象工厂-2" class="headerlink" title="简单工厂 工厂方法 抽象工厂"></a>简单工厂 工厂方法 抽象工厂</h3><p>简单工厂: 抽象了同一类型(比如不同品牌的笔记本电脑)产品的生产过程,通过工厂类来实现对不同产品生产过程的选择<br>工厂方法: 不仅抽象了产品类的生产过程,还抽象了工厂类本身. 将特定的产品的生产过程和特定的工厂相对应. 将原先工厂类中的选择提升到工程类以上的层级—即客户层级. 通过选择特定的工厂,来选择生产特定的产品.<br>抽象工厂: 在工厂方法的基础上,将特定的产品生产过程和特定的工厂类之间的对应关系解除,使得工厂类和产品类之间能够产生更多灵活的组合方式.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试题]]></title>
      <url>https://fudawei.github.io/2014/03/02/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>判断一块内存空间是否符合垃圾收集器标准是：</p>
<ol>
<li>给对象赋予了控制null，以后再也没掉用过</li>
<li>给对象赋予了新值，即重新分配了内存空间<h3 id="Object-基类方法包含"><a href="#Object-基类方法包含" class="headerlink" title="Object 基类方法包含"></a>Object 基类方法包含</h3>clone()  创建并返回对象的一个副本<br>equals()  notify()  notifyAll()   wait()  toString()<br>finalize()   当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法<br>hashCode()   返回该对象的哈希值</li>
</ol>
<h3 id="不通过构造函数能创建对象吗？"><a href="#不通过构造函数能创建对象吗？" class="headerlink" title="不通过构造函数能创建对象吗？"></a>不通过构造函数能创建对象吗？</h3><p>1.用new语句创建<br>2.运用反射，调用java.lang.Class 或者  java.lang.reflect.ConStruct 类的newInstance()实例方法<br>3.调用对象的clone() 方法<br>4.运用反序列手段，调用java.io.ObjectInputStream 对象的readObject() 方法</p>
<h3 id="有哪几种存储结构？"><a href="#有哪几种存储结构？" class="headerlink" title="有哪几种存储结构？"></a>有哪几种存储结构？</h3><p>1.随机存取。可以任意存取任意一个元素<br>2.顺序存取。只能从前到后逐个访问，比如链表结构<br>3.索引存取。索引存取是为某个关键字建立索引表，从所有的表中得到地址，在直接访问<br>4.散列存取。建立散列表，根据key计算出存储位置，相当于一种索引</p>
<p>百度或淘宝搜索时，出现搜索建议，采用什么数据结构实现？<br>字典树，是一种噶洗漱的变种，一种用于快速检索的多叉树结构。用于统计和排序大量的字符串，经常被搜索引擎用于文本词频<br>统计。核心思想是空间换时间。利用该字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<p>String s = “a”+”b”+”c”+”d”+”e”  产生了一个对象，因为赋值符号右边的字母都是常量，对于常量，编译时就直接存储他们<br>的字面值，而不是他们的引用。在编译时就把他们连接的结果提取出来变成了”abcde”<br>new String(“jinder”) 实际创建了2个对象，一个是”jinder”通过””双引号创建的，另一个是通过new创建的，只不过他们创建<br>的时期不同，一个是编译期，一个是运行期。<br>运行期调用String类型的intern()方法可以向StringPool中动态添加对象</p>
<p>简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？<br>Lock 能完成synchronized所实现的所有功能。主要不同点是，Lock 有比synchronized更精确的线程语义和更好的性能。synchronized<br>会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。</p>
<p>只要当前JVM实例尚存在任何一个非守护线程没有结束，守护线程就全部工作;只有当最后一个非守护线程结束时，守护线程随着JVM一同<br>结束任务。守护线程最典型的应用就是GC。</p>
<h3 id="存储过程和函数的区别是什么？"><a href="#存储过程和函数的区别是什么？" class="headerlink" title="存储过程和函数的区别是什么？"></a>存储过程和函数的区别是什么？</h3><p>存储过程是用户定义的一系列SQL语句的集合，设计特定表或其他对象的任务，用户可以调用存储过程，而函数通常是数据库已经定义的<br>方法，它接受参数并返回某种类型的值，而且不涉及特定用户表。<br>游标作用是什么？怎样判断游标到了最后？<br>游标用来定位结果集中的行，通过判断@@FETCH_STATUS，可以判断游标是否到了最后，通常此变量不等于0表示出错或者到了最后。<br>行级触发器在所影响的每一行触发一次。</p>
<h3 id="数据库查询优化"><a href="#数据库查询优化" class="headerlink" title="数据库查询优化"></a>数据库查询优化</h3><p>执行数据库查询时，如果要查询的数据有很多，假设1000万，用什么办法可以提高查询效率？在数据库方面或java代码方面优化 ？<br>1.在数据库方面<br>建立索引   分区（MySQL，比如按时间分区）   尽量使用固定长度的字段    限制字段长度<br>2.在数据库 I/O 方面<br>增加缓冲区    如果涉及表的级联，不同的表存储在不同的磁盘上，以增加IO速度<br>3.在SQL方面<br>优化sql语句，减少比较次数     限制返回的条目数（MySQL 里面用limit）<br>4.在java方面<br>对于反复查询使用的查询，使用PreparedStatement 减少查询次数</p>
<p>unique 约束能够约束一列保证该列值唯一，但允许有空值</p>
<h3 id="NAT技术"><a href="#NAT技术" class="headerlink" title="NAT技术"></a>NAT技术</h3><p>NAT 技术（网络地址转换）是一种将一个IP地址域映射到另一个IP地址域的技术，从而为终端主机提供透明路由。NAT 包括静态网络地址<br>转换、动态网络地址转换、端口映射等。NAT 常用语私有地址域与工友地址的转换，解决IP地址匮乏的问题、在防火墙上实现了NAT以后<br>可以隐藏受保护网络的内部拓扑结构，在一定程度上提高网络的安全性。</p>
<h3 id="IP-地址分配"><a href="#IP-地址分配" class="headerlink" title="IP 地址分配"></a>IP 地址分配</h3><p>A 类地址 １-127      0<br>B 类地址 128 - 191   10<br>C 类地址 192-223     110<br>FTP 是有连接的服务，必须基于TCP协议</p>
<h3 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h3><p>第一次握手：建立连接时，客户端发送SYN包到服务器，并进入SYN_SEND状态，等待服务器确认。<br>第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器<br>进入SYN_RECV状态。<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认宝ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED<br>状态，完成三次握手。<br>完成三次握手后，客户端和服务器开始传送数据。<br>未连接队列：在三次握手协议中，服务器维护一个未连接队列，该队列未每个客户端的SYN包开设一个条目，该条目表明服务器已收到SYN<br>包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于SYN_RECV状态，当服务器收到客户端的确认包，<br>删除该条目，服务器进入ESTABLISHED状态。</p>
<h3 id="ping命令基于什么协议？"><a href="#ping命令基于什么协议？" class="headerlink" title="ping命令基于什么协议？"></a>ping命令基于什么协议？</h3><p>ICMP Internet 控制消息协议是TCP/IP 协议族的一个自协议，用于在IP主机、路由器之间传递控制消息，控制消息是指网路通不通，<br>主机是否可达，路由是否可用等网络本身的消息。ping命令向指定的IP地址发送一定长度的数据包，按照约定，若指定的IP存在的话，<br>会返回同样大小的数据包，若在特定的时间没有返回，超时，则认为IP不存在。</p>
<p>子网掩码是用来判断任意两台计算机的IP地址是否属于同一子网络的根据。两台计算机各自的IP地址域子网掩码进行AND运算之后，<br>如果得出的结果是相同的额，则说明两台计算机是处于同一个子网络的，可以进行直接的通信。</p>
<h3 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h3><p>Iterator 接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的<br>过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。<br>如何确保N个线程可以访问N个资源同时又不导致死锁？<br>指定获取锁的顺序，并强制线程按照指定的顺序获取锁。</p>
<h3 id="在监视器-Monitor-内部，是如何做线程同步的？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？"></a>在监视器(Monitor)内部，是如何做线程同步的？</h3><p>监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个<br>对象引用相关联。线程在获取锁之前不允许执行同步代码。</p>
<h3 id="同步方法和同步代码块的区别？"><a href="#同步方法和同步代码块的区别？" class="headerlink" title="同步方法和同步代码块的区别？"></a>同步方法和同步代码块的区别？</h3><p>同步方法默认用this或者当前类class对象作为锁；<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；</p>
<p>应用程序可以使用Executor框架来创建线程池 (创建线程的方式还有 继承Thread类，实现Runnable接口 )</p>
<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><p>重载发生在同一个类里面，多个方法名相同但是形参列表不同的情况，返回类型可以相同也可以不同。<br>重写发生在父类子类里面，子类重新定义了父类方法，方法重写（覆盖）必须有相同的方法名、形参列表和返回类型。</p>
<h3 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h3><p>Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：<br>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。<br>类可以实现很多个接口，但是只能继承一个抽象类<br>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。<br>抽象类可以在不提供接口方法实现的情况下实现接口。<br>Java 接口中声明的变量默认都是final的。抽象类可以包含非final的变量。<br>Java 接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。<br>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。<br>也可以参考JDK8中抽象类和接口的区别</p>
<h3 id="HashMap和Hashtable区别？"><a href="#HashMap和Hashtable区别？" class="headerlink" title="HashMap和Hashtable区别？"></a>HashMap和Hashtable区别？</h3><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：<br>HashMap允许键和值是null，而Hashtable不允许键或者值是null。<br>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。</p>
<h3 id="Java中的HashMap的工作原理？"><a href="#Java中的HashMap的工作原理？" class="headerlink" title="Java中的HashMap的工作原理？"></a>Java中的HashMap的工作原理？</h3><p>Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合<br>/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key<br>已经存在了，value会被更新成新值;若计算出来的索引位置相同，形成Entry链。</p>
<p>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？<br>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，<br>而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全<br>失败的迭代器永远不会抛出这样的异常。</p>
<h3 id="ArrayList和LinkedList区别？"><a href="#ArrayList和LinkedList区别？" class="headerlink" title="ArrayList和LinkedList区别？"></a>ArrayList和LinkedList区别？</h3><p>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：<br>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。<br>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p>
<h3 id="Array和ArrayList区别？"><a href="#Array和ArrayList区别？" class="headerlink" title="Array和ArrayList区别？"></a>Array和ArrayList区别？</h3><p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。<br>Array大小是固定的，ArrayList的大小是动态变化的。<br>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</p>
<h3 id="Iterator和ListIterator的区别？"><a href="#Iterator和ListIterator的区别？" class="headerlink" title="Iterator和ListIterator的区别？"></a>Iterator和ListIterator的区别？</h3><p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引</p>
<h3 id="Comparable和Comparator接口"><a href="#Comparable和Comparator接口" class="headerlink" title="Comparable和Comparator接口"></a>Comparable和Comparator接口</h3><p>Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。<br>Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序。</p>
<h3 id="Java优先级队列-Priority-Queue-？"><a href="#Java优先级队列-Priority-Queue-？" class="headerlink" title="Java优先级队列(Priority Queue)？"></a>Java优先级队列(Priority Queue)？</h3><p>PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供<br>一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，<br>riorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。</p>
<p>什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？<br>CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励<br>用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是：CallableStament.prepareCall();</p>
<p>PreparedStatement比Statement有什么优势？<br>PreparedStatements是预编译的，因此，性能会更好。同时，不同的查询参数值，PreparedStatement可以重用。</p>
<h3 id="URL编码和URL解码？"><a href="#URL编码和URL解码？" class="headerlink" title="URL编码和URL解码？"></a>URL编码和URL解码？</h3><p>URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。</p>
<h3 id="doGet-方法和doPost-方法区别？"><a href="#doGet-方法和doPost-方法区别？" class="headerlink" title="doGet()方法和doPost()方法区别？"></a>doGet()方法和doPost()方法区别？</h3><p>doGet: GET 方法会把键值对追加在请求的URL后面。因为URL对字符数目有限制， 限制了用在客户端请求的参数值的数目。并且请求中<br>的参数值是可见的 ，不够安全。<br>doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。<br>最后，通过POST请求传递的敏感信息对外部客户端是不可见的。</p>
<h3 id="解释下Servlet的生命周期。"><a href="#解释下Servlet的生命周期。" class="headerlink" title="解释下Servlet的生命周期。"></a>解释下Servlet的生命周期。</h3><p>对每一个客户端的请求，Servlet引擎 载入Servlet，调用它的init()方法，完成Servlet的初始化。然后，Servlet 对象通过为每一个<br>请求单独调用service()方法来处理所有随后来自客户端的请求，最后，调用Servlet的destroy()方法把Servlet卸载掉。</p>
<h3 id="什么是Servlet？"><a href="#什么是Servlet？" class="headerlink" title="什么是Servlet？"></a>什么是Servlet？</h3><p>Servlet 是用来处理客户端请求并产生动态网页内容的Java类。Servlet 主要是用来处理或者是存储HTML表单提交的数据，产生动态内容</p>
<h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>Java 程序可以加载一个运行时才得知名称的 class，获悉其完整构造（但不包括methods定义），并生成其对象实体、<br>或对其fields设值、或唤起其methods。</p>
<h3 id="匿名内部类的变量必须final修饰？"><a href="#匿名内部类的变量必须final修饰？" class="headerlink" title="匿名内部类的变量必须final修饰？"></a>匿名内部类的变量必须final修饰？</h3><p>首先内部类的生命周期是成员级别的，而局部变量的生命周期是在方法体之类，当mRun方法执行，new<br>的线程运行，新线程里面会睡一秒。主线程会继续执行，mRun执行完毕，name属性生命周期结束，Java就是为了杜绝这种错误，严格要求<br>内部类中方位局部变量，必须使用final关键字修饰。局部变量被final修饰之后，此时会在内存中保有一份局部变得的复制品，当内部类<br>访问的时候其实访问的是这个复制品。</p>
<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test() &#123;</div><div class="line">	Integer a = new Integer(1000) ; int b = 1000;</div><div class="line">	Integer c = new Integer(10); Integer d = new Integer(10);</div><div class="line">	System.out.println(a == b);    //true   自动拆箱为int</div><div class="line">	System.out.println(c == d);    //false</div><div class="line">&#125;</div><div class="line">//Integer.java valueOf 方法中把-128-127 缓存了下来。官方解释是小的数字使用的频率比较高， 为了优化性能，把这之间的数缓存了下来</div><div class="line">@Test</div><div class="line">public void testInteger()&#123;</div><div class="line">	Integer a = 1000,b=1000;</div><div class="line">	Integer c = 100,d=100;</div><div class="line">	System.out.println(a==b);   //false  new出来的</div><div class="line">	System.out.println(c==d);   //true   缓存中的</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>[reference] <a href="http://www.imooc.com/article/2964" target="_blank" rel="external">http://www.imooc.com/article/2964</a></p>
<h3 id="调用三种方式"><a href="#调用三种方式" class="headerlink" title="调用三种方式"></a>调用三种方式</h3><p>模块之间都存在一定的调用关系，从调用方式上看，可以分为三类同步调用、异步调用和回调。同步调用是一种阻塞式调用，异步调用是一种<br>类似消息或事件的机制解决了同步阻塞的问题，回调是一种双向的调用模式，也就是说，被调用的接口被调用时也会调用对方的接口，例如A<br>要调用B,B在执行完又要调用A。<br>public interface FileNameFilter{<br>    boolean accept(File dir,String name);<br>}</p>
<h3 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h3><p>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。<br>一个接口能继承另一个接口，这和类之间的继承比较相似。也就是说实现某一个接口之后，可能要实现的方法不是直接接口定义的方法，<br>可能是该接口继承于另外一个接口的方法。<br>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：<br>1.建立一个公共的父接口<br>2.向一个类添加数据类型</p>
<h3 id="SQL三范式"><a href="#SQL三范式" class="headerlink" title="SQL三范式"></a>SQL三范式</h3><p>SQL语言支持关系数据库的三级模式结构，其中，视图对应外模式，基本表对应模式，存储文件对应内模式。<br>通过分解，可以将一个低一级别的关系模式转换成若干个高一级范式的关系模式，这种过程叫做规范化。<br>eg: FIRST(Sno,Sname,Status,City,Pno,Qty)<br>依赖关系： F={ Sno-&gt; Sname,Sno-&gt;Status,Status-&gt;City,(Sno,Pno)-&gt;Qty}</p>
<ul>
<li>1NF(第一范式)<br>定义：若关系模式R的每一个分量是不可再分的数据项，则关系模式R属于第一范式<br>FIRST属于第一范式，但1NF存在4个问题：<br>冗余度大，每个Sno,Sname,Status,City 要与其供应的零件的种类一样多<br>引起修改操作的不一致性<br>插入异常，若某个供应者某些信息没有提供(比如没有Pno)则不能进行插入操作</li>
<li>2NF(第二范式)<br>定义：若关系模式R属于1NF,且每一个非主属性完全依赖于码，则关系模式R属于2NF<br>也就是说，当1NF消除了非主属性对码的部分函数依赖，则成为2NF<br>将FIRST分解为 FIRST1(Sno,Sname,Status,City) 和 FIRST2(Sno,Pno,Qty) 分解后，FIRST1 的 非主属性 Sname,Status,City 完全依赖<br>于码 Sno,FIRST2的非主属性 Qty 完全依赖于码 Sno,Pno,所以属于2NF</li>
<li>3NF(第三范式)<br>若关系模式中不存在这样的码X，属性组Y以及非主属性Z，使得X-&gt;Y,Y-Z成立，则关系模式R属于3NF<br>即当2NF消除了非主属性对码的传递函数依赖，则成为3NF<br>分解为 FIRST1(Sno,Sname,Status)  FIRST2(Status,City)   FIRST3(Sno,Pno,Qty)<br>3NF的模式肯定是2NF,产生冗余和异常的两个重要原因是部分依赖和传递依赖，因为3NF模式中不存在非主属性对码的部分函数依赖和<br>传递函数依赖，所以具有较高的性能，通常变换为3NF或更高级别的凡是，这种变化过程成为“关系模式的规范化处理”<h3 id="Webservice"><a href="#Webservice" class="headerlink" title="Webservice"></a>Webservice</h3>W  ebService是一种跨编程语言和跨操作系统平台的远程调用技术。<br>远程调用，就是一台计算机a上的一个程序可以调用到另外一台计算机b上的一个对象的方法，譬如，银联提供给商场的pos刷卡系统，<br>商场的POS机转账调用的转账方法的代码其实是跑在银行服务器上。再比如，amazon，天气预报系统，淘宝网，校内网，百度等把自己的<br>系统服务以webservice服务的形式暴露出来，让第三方网站和程序可以调用这些服务功能，这样扩展了自己系统的市场占有率，就是<br>所谓的SOA应用。<br> WebService是建立可互操作的分布式应用程序的新平台，是一个平台，是一套标准。它定义了应用程序如何在Web上实现互操作性<br>Web service平台必须提供一种标准来描述Web service，让客户可以得到足够的信息来调用这个Web service<br>XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术。<br>WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务<br>对象的返回结果是什么）。XML是WebService平台中表示数据的格式。<br>SOAP协议 = HTTP协议 + XML数据格式<br>WSDL(Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。<br>它是WebService客户端和服务器端都能理解的标准格式。<h3 id="Java-String-split-用法"><a href="#Java-String-split-用法" class="headerlink" title="Java String.split()用法"></a>Java String.split()用法</h3>String.split(“\.”) //用 . 分割字符串<br>acount=?and uu =? or n=?”,把三个都分隔出来可以用String.split(“and|or”); //分割多个</li>
</ul>
<p>需要在程序中存储许多字符串常量，所以就想到了枚举</p>
<h3 id="获取用户IP"><a href="#获取用户IP" class="headerlink" title="获取用户IP"></a>获取用户IP</h3><p>public static String getIpAddr(HttpServletRequest request) {<br>        String ip = request.getHeader(“x-forwarded-for”);<br>        if (ip == null || ip.length() == 0 || “unknown”.equalsIgnoreCase(ip)) {<br>            ip = request.getHeader(“Proxy-Client-IP”);<br>        }<br>        if (ip == null || ip.length() == 0 || “unknown”.equalsIgnoreCase(ip)) {<br>            ip = request.getHeader(“WL-Proxy-Client-IP”);<br>        }<br>        if (ip == null || ip.length() == 0 || “unknown”.equalsIgnoreCase(ip)) {<br>            ip = request.getRemoteAddr();<br>        }<br>        return ip;<br>    }</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC学习笔记]]></title>
      <url>https://fudawei.github.io/2014/02/09/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>SpringMVC 使用@RequestMapping 注解为控制器指定可以处理哪些URL请求<br>在控制器的类定义及方法定义处都可标注<br>@RequestMapping<br>类定义处： 提供初步的请求映射信息，相对于WEB应用的根目录<br>方法处：提供进一步的细分映射信息。相对于类定义处的URL。若类定义处未标注@RequestMapping，则方法标记的URL相对于WEB应用的根目录<br>DispatcherServlet 截获请求后，就通过控制器上@RequestMapping 提供的映射信息确定请求所对应的处理方法</p>
<p>eg<br>    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"><br>        <property name="prefix" value="/WEB-INF/views/"></property><br>        <property name="suffix" value=".jsp"></property><br>    </bean></p>
<p><a href="springmvc/testRequestMapping">test requestMapping </a></p>
<p>// 类定义处标记的@RequestMapping限定了处理器可以处理所有URI为 /spring的请求，它相对于WEB容器部署的根路径<br>@RequestMapping(“/springmvc”)<br>@Controller<br>public class SpringMVCTest {<br>    private static final String SUCCESS = “success”;<br>    // 处理器类可以定义多个处理方法，处理来自 /springmvc的请求<br>    @RequestMapping(“/testRequestMapping”)<br>    public String testRequestMapping(){<br>        System.out.println(“testRequest…”);<br>        return SUCCESS;<br>    }<br>}</p>
<pre><code>&lt;a href=&quot;springmvc/testRequestMethod&quot;&gt;test requestMethod &lt;/a&gt;

&lt;br&gt;
&lt;a href=&quot;springmvc/testParamsAndHeaders?username=atguigu&amp;age=10&quot;&gt;test ParamsAndHeaders &lt;/a&gt;
&lt;br&gt;

&lt;a href=&quot;springmvc/test/mnxyv/abc&quot;&gt;test AntPath &lt;/a&gt;
&lt;br&gt;

&lt;a href=&quot;springmvc/testParamsAndHeaders?username=atguigu&amp;age=10&quot;&gt;test ParamsAndHeaders &lt;/a&gt;
&lt;br&gt;

&lt;form action=&quot;springmvc/testRequestMethod&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;br&gt;
&lt;a href=&quot;springmvc/testRequestMapping&quot;&gt;test requestMapping &lt;/a&gt;
&lt;br&gt;
&lt;a href=&quot;helloworld&quot;&gt;HelloWorld&lt;/a&gt;
</code></pre><p>@Controller<br>public class HelloWorld {<br>    /**</p>
<pre><code> * 1. 使用 @RequestMapping 注解来映射请求的url
 * 2. 返回值会通过视图解析器解析为实际的物理视图
 * 对于InternalResourceViewResolver视图解析器，做如下解析
 * prefix+returnVal+suffix 这样的方式得到实际的物理视图
 */
@RequestMapping(&quot;/helloworld&quot;)
public String hello() {
    System.out.println(&quot;hello world&quot;);
    return &quot;success&quot;;
}
</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>RequestMapping 除了可以使用请求URL映射请求外，还可以使用请求方法，请求参数及请求头映射请求<br>RequestMapping 的value,method,params及headers分别表示请求URL，请求方法、请求参数及请求头的映射条件，他们之间是与的关系，联合使用多个条件可以让请求映射更加精确<br>params和headers支持简单的表达式：<br>param1: 表示请求必须包含名为param1的请求参数<br>!param1: 表示请求不能包含名为param1的请求参数<br>param1!=value1: 表示请求必须包含名为param1的请求参数，值不能为value1<br>{“param1=value”,”param2”} : 表示必须包含param1和param2，且param1的参数值必须为value</p>
<p>@RequestMapping(“/springmvc”)<br>@Controller<br>public class SpringMVCTest {<br>    private static final String SUCCESS = “success”;<br>    // 指定接收POST的请求，页面可以设置为form表单<br>    @RequestMapping(value=”/testRequestMethod”,method=RequestMethod.POST)<br>    public String testRequestMethod(){<br>        System.out.println(“testRequestMethod…”);<br>        return SUCCESS;<br>    }<br>    // 必须包含username属性和age属性，且age不能为1，否则不予接收<br>    @RequestMapping(value=”testParamsAndHeaders”,params={“username”,”age!=1”})<br>    public String testParams(){<br>        System.out.println(“testParamsAndHeaders…”);<br>        return SUCCESS;<br>    }<br>    // 支持匹配符<br>    // ? 匹配文件名中的一个字符<br>    // <em> 匹配文件名中的任意字符<br>    // ** 匹配多层路径<br>    // 还支持Ant风格的URL<br>    @RequestMapping(“/test/</em>/abc”)<br>    public String testRequestMapping(){<br>        System.out.println(“testRequest…”);<br>        return SUCCESS;<br>    }<br>}</p>
<p>@PathVariable 映射URL绑定的占位符<br>带占位符的URL是SpringMVC向REST目标挺进发展具有里程碑的意义<br>通过@PathVariable 可以将URL中占位符参数绑定到控制器处理方法的入参中；URL 中的{xxx}占位符可以通过@PathVariable(“xxx”)绑定到操作方法的入参中<br>eg : <a href="springmvc/testPathVariable/1">test requestMapping </a></p>
<p>// @PathVariable 可以映射URL中的占位符到目标方法的参数中 - REST风格<br>    @RequestMapping(“/testPathVariable/{id}”)<br>    public String testPathVariable(@PathVariable(“id”) Integer id){<br>        System.out.println(“testPathVariable “+id);<br>        return SUCCESS;<br>    }</p>
<p>REST Representational State Transfer 资源表现层状态转化<br>具体的说就是HTTP协议里面，GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源</p>
<p>form表单只支持GET与POST请求，Spring 使用 HiddenHttpMethodFilter 把这些请求转换为标准的http方法，使得支持GET,POST,PUT 与DELETE请求<br>把 HiddenHttpMethodFilter 配置到web.xml中，可以把post请求转为delete或post请求</p>
<ol>
<li>配置HiddenHttpMethodFilter</li>
<li>发送post请求时，携带一个name=”_method”的隐藏域，值为delete或put</li>
</ol>
<p>Rest 风格</p>
<form action="springmvc/testRest/1" method="post"><br>    <input type="hidden" name="_method" value="PUT"><br>    <input type="submit" value="PUT"><br></form>

<p><br></p>
<form action="springmvc/testRest/1" method="post"><br>    <input type="hidden" name="_method" value="Delete"><br>    <input type="submit" value="test delete"><br></form><br><br><br><br>@RequestMapping(value=”/testRest/{id}”, method=RequestMethod.PUT)<br>    public String testRestPut(@PathVariable Integer id){<br>        System.out.println(“Put: “+id);<br>        return SUCCESS;<br>    }<br><br>    @RequestMapping(value=”/testRest/{id}”, method=RequestMethod.DELETE)<br>    public String testRestDelete(@PathVariable Integer id){<br>        System.out.println(“Delete: “+id);<br>        return SUCCESS;<br>    }<br><br>web.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">  	&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</div><div class="line">  	// 配置HiddenHttpMethodFilter 可以把POST请求转换为DELETE或POST请求</div><div class="line">  	&lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;</div><div class="line">  &lt;/filter&gt;</div><div class="line">  &lt;filter-mapping&gt;</div><div class="line">  	&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</div><div class="line">  	&lt;url-pattern&gt;&apos;/*&apos;&lt;/url-pattern&gt;</div><div class="line">  &lt;/filter-mapping&gt;</div><div class="line"></div><div class="line">  &lt;servlet&gt;</div><div class="line">    &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;</div><div class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">  &lt;/servlet&gt;</div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure><br><br>在springMVC中得到id,使用 @PathVariable 注解<br><br>Spring MVC 通过分析处理方法的签名，将HTTP请求信息绑定到处理方法的相应入参中。<br>必要时可以对方法及方法入参标注相应的注解(@PathVariable,@RequestParam,@RequestHeader 等)，Spring MVC 框架会将HTTP请求的信息绑定到相应的方法入参中，并根据方法的返回值类型做出相应的后续处理<br><br>eg:<br><a href="springmvc/testRequestParam?username=haha&age=10">Test RequestParam</a><br>/<em>*
 </em> [testRequestParam description]<br> <em> @RequestParam 映射请求参数
 </em>  value 值即请求参数的参数名<br> <em>  required 该参数是否必须，默认为true
 </em>   defaultValue 请求参数的默认值<br> */<br>@RequestMapping(value=”/testRequestParam”)<br>    public String testRequestParam(@RequestParam(value=”username”) String un,<br>            // (value=”age”, required=false, defaultValue=”0”) int age)<br>            @RequestParam(value=”age”, required=false) Integer age){   // 若某个值不是必须的，可以使用required=false注解<br>        System.out.println(“username =　“ + un + “; age = “+age);<br>        return SUCCESS;<br>    }<br>——————<br><a href="springmvc/testRequestHeader">Test RequestHeader</a><br><br>@RequestMapping(“/testRequestHeader”)<br>    public String testRequestHeader(@RequestHeader(value=”Accept-Language”) String al){<br>        System.out.println(“testRequestHeader,Accept-Language : “+al);<br>        return SUCCESS;<br>    }<br><br>———————-<br>使用 @CookieValue 取得Cookie值，映射一个Cookie值，属性同@RequestParam<br>@RequestMapping(“/testCookievalue”)<br>    public String testCookieValue(@CookieValue(“JSESSIONID”) String sessionId){<br>        System.out.println(“testCookieValue:sessionId “+sessionId);<br>        return SUCCESS;<br>    }<br><br>使用POJO对象绑定请求参数值<br>SpringMVC 会按请求参数名和POJO属性名进行自动匹配，自动为该对象填充属性值，支持级联属性，如dept.deptId, dept.address.tel 等<br><br><form action="springmvc/testPojo" method="post"><br>        username:<input type="text" name="username"><br>        <br><br>        password:<input type="password" name="password"><br>        <br><br>        email:<input type="text" name="email"><br>        <br><br>        age:<input type="text" name="age"><br>        <br><br>        city:<input type="text" name="address.city"><br>        <br><br>        province:<input type="text" name="address.province"><br>        <br><br><br>        <input type="submit" value="submit"><br>    </form>

<p>public class User {<br>    private String username;<br>    private String password;<br>    private String email;<br>    private int age;<br>    private Address address;<br>    getter…setter …<br>}<br>@RequestMapping(“/testPojo”)<br>    public String testPojo(User user){<br>        System.out.println(“testPojo “+user);<br>        return SUCCESS;<br>    }</p>
<p>MVC 的Handler方法可以接受哪些ServletAPI类型的参数<br>HttpServletRequest HttpServletResponse HttpSession java.security.Principal Locale InputStream OutputStream Reader Writer</p>
<p>Spring MVC 提供了一下几种途径输出模型数据：<br>ModelAndView：处理方法返回值类型为ModelAndView时，方法体即可通过该对象添加模型数据<br>Map 及 Model:入参为 org.springframework.ui.Model 、 org.springframework.ui.ModelMap 或 java.util.Map 时，处理方法返回时，Map 中的数据会自动添加到模型中<br>@SessionAttributes:将模型中的某个属性暂存到HttpSession中，以便多个请求之间可以共享这个属性<br>@ModelAttribute:方法入参标注该注解后，入参的对象就会放到数据模型中</p>
<p>控制器处理方法的返回值如果为ModelAndView，则其既包含视图信息，也包含模型数据信息<br>添加模型数据：<br>ModelAndView addObject(String attributeName,Object attributeValue)<br>ModelAndView addAllObject(Map<string,?> modelMap)<br>设置视图：<br>void setView(View view)<br>void setViewName(String viewName)</string,?></p>
<p>/**</p>
<ul>
<li>目标方法的返回值可以是ModelAndView类型</li>
<li>其中可以包含视图和模型信息</li>
<li>Spring MVC 会把ModelAndView的model中数据放入到request域对象中</li>
<li>@return [description]<br>*/<br>@RequestMapping(“/testModelAndView”)<br> public ModelAndView testModelAndView(){<pre><code>String viewName = SUCCESS;
ModelAndView modelAndView = new ModelAndView(viewName);
modelAndView.addObject(&quot;time&quot;,new Date());
return modelAndView;
</code></pre> }</li>
</ul>
<body><br>    <h4>Success Page</h4><br>    time: ${requestScope.time}<br></body>

<hr>
<p>@RequestMapping(“/testMap”)<br>    public String testMap(Map<string,object> map){<br>        map.put(“name”,Arrays.asList(“tom”,”jerry”,”Mike”));<br>        return SUCCESS;<br>    }</string,object></p>
<p>Name: ${requestScope.name } 取得map模型数据</p>
<hr>
<p>若希望在多个请求之间公用某个模型属性数据，可以在控制器上标注一个 @SessionAttributes，Spring MVC 将在模型中对应的属性暂存到 HttpSession 中的数据会自动添加到模型中<br>@SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外（使用value属性值），还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中（使用types属性值）。<strong> 注意：该注解只能放在类的上面不能放在方法上面 </strong><br>@SessionAttributes(type=User.class) 会将隐含模型中所有类型为User.class的属性添加到会话中<br>@SessionAttributes(value={“user1”,”user2”})<br>@SessionAttributes(types={User.class,Dept.class})<br>@SessionAttributes(value={“user1”,”user2”},types={Dept.class})</p>
<p>在已有基础上添加 @SessionAttributes({“user”})<br>@RequestMapping(“testSessionAttributes”)<br>    public String testSessionAttributes(Map<string,object> map){<br>        User user = new User(“Tom”, “123456”, “tom@gmail.com”, 16);<br>        map.put(“user”, user);<br>        return SUCCESS;<br>    }</string,object></p>
<p>requestUser : ${requestScope.user }<br>sessionUser:${sessionScope.user }</p>
<p>若注解改为  @SessionAttributes(value={“user”},types=String.class)  则<br>@RequestMapping(“testSessionAttributes”)<br>    public String testSessionAttributes(Map<string,object> map){<br>        User user = new User(“Tom”, “123456”, “tom@gmail.com”, 16);<br>        map.put(“user”, user);<br>        map.put(“school”,”atguigu”);<br>        return SUCCESS;<br>    }<br>    也会把school放入到request和session中</string,object></p>
<p>ModelAttribute<br>    &lt;!–</p>
<pre><code>    1. 原始数据  1,Tom,123456,tom@atguigu.com,12
    2. 密码不能修改
    3. 表单回显，模拟操作直接在表单填写对应的属性值
 --&gt;
&lt;form action=&quot;springmvc/testModelAttribute&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=1&gt;
    username:&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;Tom&quot;&gt;
    &lt;br&gt;
    email:&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;tom@atguigu.com&quot;&gt;
    &lt;br&gt;
    age:&lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;12&quot;&gt;
    &lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
&lt;/form&gt;

/*
 * 有 @ModelAttribute标记的方法，会在每个目标方法执行之前被SpringMVC调用
 */
@ModelAttribute
public void getUser(@RequestParam(value=&quot;id&quot;,required=false) Integer id,
        Map&lt;String,Object&gt; map){
    if(id!=null){
        User user = new User(1,&quot;Tom&quot;,&quot;1256&quot;,&quot;tom@atguigu.com&quot;,12);
        System.out.println(&quot; 从数据库获取一个对象 &quot;+user);
        map.put(&quot;user&quot;,user);
    }
}
/*
 * 1. 执行@ModelAttribute注解修饰的方法，从数据库中取出对象，把对象放入到了Map中，键为 user
 * 2. SpringMVC 从Map中取出User对象，并把表单的请求参数赋给该User对象的对应属性
 * 3. SpringMVC 把上述对象传入目标方法的参数
 * 注意： 在ModelAttribute修饰的方法中，放入到Map时的键需要和目标方法入参类型的第一个字母小写的字符串一致，即必须是 user
 */
@RequestMapping(&quot;/testModelAttribute&quot;)
public String testModelAttribute(User user){
    System.out.println(&quot;modify &quot;+user);
    return SUCCESS;
}
</code></pre><p>可以用@ModelAttribute 注释方法参数或方法。带有@ModelAttribute 注解的方法会将其要输入的或创建的参数对象添加到Model对象中（若方法没有显示添加）<br>SpringMVC 确定目标方法POJO类型入参的过程</p>
<ol>
<li>确定一个key<br>1)若目标方法的POJO类型的参数木有使用@ModelAttribute 作为修饰，则key为POJO类型第一个字母的小写<br>2)若使用了@ModelAttribute 来修饰，则key为@ModelAttribute 注解的value属性值</li>
<li>在implicitModel 中查找key对应的对象，若存在，则作为入参传入<br>若在@ModelAttribute 标记的方法中在Map中保存过，则key和1确定的key一致，则会获取到<br>3.若implicitModel中不存在key对应的对象，则检查当前的Handler是否使用@SessionAttribute 注解修饰，若使用了该注解，且@SessionAttributes 注解的value属性值中包含了key，则会从HttpSession中来获取key所对应的value值，若存在则直接传入到目标方法的入参中，若不存在则将抛异常</li>
<li>若Handler没有标记@SessionAttributes 注解或@SessionAttributes 注解的value值不包含key，则会通过反射来创建POJO类型的参数，传入为目标方法的参数</li>
<li>SpringMVC 会把key和POJO类型的对象保存在impliciModel中，进而会保存到request中</li>
</ol>
<p>SpringMVC 视图解析流程分析<br>请求处理方法完成后，最终赶回一个ModelAndView对象，对于那些返回String,View 或ModelMap等类型的处理方法，Spring MVC 也会在内部将他们装配成一个ModelAndView对象，包含了逻辑名和模型对象的视图<br>Spring MVC 借助视图解析器（ViewResolver）得到最终的视图对象，最终的视图可以是JSP，也可能是Excel、JFreeChart 等各种表现形式的视图<br>视图的作用是渲染模型数据，将模型的数据以某种形式呈现给客户<br>为了实现视图模型和具体实现技术的解耦，Spring 在org.springframework.web.servlet 包中定义了一个高度抽象的View接口<br>视图对象由视图解析器负责实例化，由于视图是无状态的，所有他们不会有线程安全的问题</p>
<p>InternalResourceViewResolver JSP 是最常见的视图技术，可以使用InternalResourceViewResolver作为视图解析器<br>若项目中使用了JSTL，则SpringMVC会自动把视图</p>
<p><mvc:view-controller path="/success" view-name="success"></mvc:view-controller></p>
<p><mvc:annotation-driven></mvc:annotation-driven></p>
<p>若希望使用Excel展示数据列表，仅需要扩展SpringMVC提供的AbstractExcelView或AbstractJExcel View 即可。实现buildExcelDocument()方法，在方法中使用模型数据构建Excel文档就可以了<br>视图对象需要配置IOC容器中的一个bean，使用BeanNameViewResolver作为视图解析器即可<br>若希望直接在浏览器中直接下载Excel文档，则可以设置响应头 Content-Disposition 的值为attachment;filename=xxx.xls</p>
<p>自定义视图<br>配置xml<br><!-- 扫描包 --><br>    <context:component-scan base-package="com.atguigu.springmvc"></context:component-scan></p>
<pre><code>&lt;!-- 配置视图解析器，如何把handler方法返回值解析为实际的物理视图 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 配置BeanNameViewResolver视图解析器;使用视图的名字来解析视图 --&gt;
&lt;!-- 通过order属性定义视图的优先级，order值越小视图解析器优先级越高。
InternalResourceViewResolver 优先级数值最大，所有优先级最低--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;&gt;
    &lt;property name=&quot;order&quot; value=&quot;100&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>@RequestMapping(“/testView”)<br>    public String testView(){<br>        System.out.println(“test view”);<br>        return “helloView”;<br>    }</p>
<p>@Component<br>public class HelloView implements View{</p>
<pre><code>@Override
public String getContentType() {
    return &quot;text/html&quot;;
}

@Override
public void render(Map&lt;String, ?&gt; arg0, HttpServletRequest request,
        HttpServletResponse response) throws Exception {
    response.getWriter().print(&quot;hello view time:&quot;+new Date());
}
</code></pre><p>}</p>
<p>重定向<br>@RequestMapping(“/testRedirect”)<br>    public String testRedirect(){<br>        System.out.println(“testRedirect”);<br>        return “redirect:/index.jsp”;  // 重定向到根目录的页面，<br>    }<br>重定向和Flash属性<br>转发比重定向快，因为重定向经过客户端，而转发没有。但是，有时采用重定向更好，若需要重定向到一个外部网站，则无法使用转发<br>使用重定向的一个不方便的地方是：无法轻松的传值给目标页面，而采用转发，则可以简单的将属性添加到model中。Spring 3 版本通过Flash属性提供了一种供重定向传值的方法<br>要使用Flash属性，必须在Spring MVC 配置文件中有一个<annotation-driver> 元素，然后还必须在方法参数里面添加一个新的参数u类型<br>org.springframework.web.servlet.mvc.support.RedirectAttributes<br>@RequestMapping(value=”product-save”,method=RequestMethod.POST)<br>public String saveProduct(ProductForm productForm, RedirectAttributes redirectAttributes){<br>    redirectAttributes.addFlashAttribute(“message”,”The product was successfully added”);<br>    return “redict:/product_view” + product.getId();<br>}</annotation-driver></p>
<h3 id="tomcat默认就是不允许PUT和DELETE的"><a href="#tomcat默认就是不允许PUT和DELETE的" class="headerlink" title="tomcat默认就是不允许PUT和DELETE的"></a>tomcat默认就是不允许PUT和DELETE的</h3><p>如何配置Tomcat支持HTTP Delete和Put 方法<br>在tomcat web.xml文件中配置org.apache.catalina.servlets.DefaultServlet的</p>
<p><init-param><br>    <param-name>readonly</param-name><br>    <param-value>false</param-value><br></init-param><br>readonly参数默认是true，即不允许delete和put操作，所以通过XMLHttpRequest对象的put或者delete方法访问就会报告http 403错误。为REST服务起见，应该设置该属性为false。</p>
<p>Jstl 学习<br>页面请求：　<a href="emps">List All Employees</a><br>Handler 处理<br>@RequestMapping(“/emps”)<br>    public String list(Map<string, object=""> map){<br>        // 把结果放入到employees这个map中，返回<br>        map.put(“employees”, employeeDao.getAll());<br>        return “list”;<br>    }<br>list.jsp<br><br> 我是分割线<br><br>    <c:if test="${empty requestScope.employees }"><br>        没有任何员工信息<br>    </c:if><br>    <c:if test="${!empty requestScope.employees }"><br>        <table border="1" cellpadding="10" cellspacing="1"><br>            <tr><br>                <th>ID</th><br>                <th>LastName</th><br>                <th>Email</th><br>                <th>Gender</th><br>                <th>Department</th><br>                <th>Edit</th><br>                <th>Delete</th><br>            </tr><br>            <c:foreach items="${requestScope.employees }" var="emp"><br>                <tr><br>                    <td>${emp.id }</td><br>                    <td>${emp.lastName }</td><br>                    <td>${emp.email }</td><br>                    <td>${emp.gender==0?’Female’ : ‘Male’ }</td><br>                    <td>${emp.department.departmentName }</td><br>                    <td><a href="">Edit</a></td><br>                    <td><a href="">Delete</a></td><br>                </tr><br>            </c:foreach><br>        </table><br>    </c:if></string,></p>
<p>可以在spring MVC 中配置 <mvc:default-servlet-handler> 可以解决静态资源文件找不到的问题</mvc:default-servlet-handler></p>
<p>xml配置文件可以通过一份主配置文件，其它文件导入</p>
<p>应用MVC，可以在Controller类中调用后端业务逻辑，通常，需要若干封装了后端复杂逻辑的Service类，在Service类中，可以实例化一个DAO类来访问数据库。在Spring MVC 中，Service 对象可以自动被注入到Controller对象中，而DAO对象可以自动被注入到Service对象中。<br>&lt;%@ taglib prefix=”form” uri=”<a href="http://www.springframework.org/tags/form" target="_blank" rel="external">http://www.springframework.org/tags/form</a>“ %&gt;<br>&lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core" target="_blank" rel="external">http://java.sun.com/jsp/jstl/core</a>“ %&gt;</p>
<p><c:if test="${requestScope.errors !=null}"><br>    <p id="errors"><br>    Errors(s)!<br>    <ul><br>    <c:foreach var="errors" items="${requestScope.errors}"><br>        <li>${error}</li><br>    </c:foreach><br>    </ul><br>    </p><br></c:if></p>
<p>一般的， @RequestMapping(“/custom”) 和 @RequestMapping(value=”/custom”) 一样，如果有超过一个属性时，必须写入value属性名称<br>method属性用来指示该方法处理哪些HTTP方法 eg: RequestMethod.PUT</p>
<p>import org.apache.commons.logging.Log ;<br>import org.apache.commons.logging.LogFactory;<br>private static final Log logger = LogFactory.getLog(Product.class)<br>logger.info(“save product”);</p>
<hr>
<h3 id="编写转换器-amp-amp-验证器"><a href="#编写转换器-amp-amp-验证器" class="headerlink" title="编写转换器 &amp;&amp; 验证器"></a>编写转换器 &amp;&amp; 验证器</h3><p>一. 转换器</p>
<ol>
<li>实现Converter<s,t> 接口，S 输入，T输出；<br> eg: 编写StringToDateConverter</s,t></li>
<li><p>注册转换器</p>
 <bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"><br>     <property name="converters"><br>         <list><br>             <bean class="com.yuchuan.controller.StringToDateConverter"><br>                 <constructor-arg type="java.lang.String" value="MM-dd-yyyy"></constructor-arg><br>             </bean><br>         </list><br>     </property><br> </bean>

 <mvc:annotation-driven conversion-service="conversionService"></mvc:annotation-driven></li>
<li>编写控制类调用<br> @RequestMapping(value=”employee_save”)<br> public String saveEmployee(@ModelAttribute Employee employee,<pre><code>    BindingResult bindingResult,Model model){
if(bindingResult.hasErrors()){
    FieldError fieldError = bindingResult.getFieldError();
    logger.info(&quot;Code:&quot;+fieldError.getCode()+&quot;,field:&quot;+fieldError.getField());
    return &quot;EmployeeForm&quot;;
}
logger.info(&quot;employeeDeatails&quot;);
model.addAttribute(&quot;employee&quot;,employee);
return &quot;EmployeeDetails&quot;;
</code></pre> }<br>每个需要校验的Bean后面紧跟一个BindingResult，SpringMVC框架会将校验结果保存在它里面，通过hasErrors方法可以<br>判断是否有校验错误；最后，当返回到原页面以后，SpringMVC框架还会将所有校验错误信息保存在上下文中，供页面上取得<br>校验错误，Spring提供了一套JSP自定义标签。</li>
</ol>
<p>注意引入css文件 <style type="text/css">@import url(“<c:url value="/css/main.css"/>“);</style><br>不经过springmvc默认拦截器<br>    <mvc:annotation-driven><br>    <mvc:resources mapping="/css/**" location="/css/"><br>    <mvc:resources mapping="/*.html" location="/"></mvc:resources></mvc:resources></mvc:annotation-driven></p>
<p>二、 验证器</p>
<ol>
<li>编写ProductValidator，实现Validator接口</li>
<li>xml文件 <bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"><br>     <property name="basename" value="/WEB-INF/resource/messages"></property><br> </bean></li>
<li>编写Controller<br>@RequestMapping(“/product_save”)<br> public String saveProduct(@ModelAttribute Product product,<pre><code>    BindingResult bindingResult,Model model){
ProductValidator productValidator = new ProductValidator();
productValidator.validate(product, bindingResult);
if(bindingResult.hasErrors()){
    FieldError fieldError = bindingResult.getFieldError();
    logger.info(&quot;Code:&quot;+fieldError.getCode()+&quot;,field:&quot;+fieldError.getField());
    return &quot;ProductForm&quot;;
}
model.addAttribute(&quot;product&quot;,product);
return &quot;ProductDetails&quot;;
</code></pre> }</li>
</ol>
<p>JSTL<br>遍历对象</p>
<p><c:foreach items="${books}" var="book"><br>    <tr><br>        <td>${book.category.name}</td><br>        <td>${book.title}</td><br>        <td>${book.isbn}</td><br>        <td>${book.author}</td><br>    </tr><br></c:foreach></p>
<p>遍历 HashMap<string,string></string,string></p>
<p><c:foreach items="${requestScope.capitals }" var="map"><br>        <tr><br>            <td>${map.key }</td><br>            <td>${map.value }</td><br>        </tr><br>    </c:foreach></p>
<p>遍历 HashMap<string,string[]></string,string[]></p>
<p><c:foreach items="${requestScope.bigCities}" var="mapItem"><br>    <tr><br>        <td>${mapItem.key}</td><br>        <td><br>            <c:foreach items="${mapItem.value}" var="city" varstatus="status"><br>                ${city}<c:if test="${!status.last}">,</c:if><br>            </c:foreach><br>        </td><br>    </tr><br>    </c:foreach></p>
<p>遍历以特殊符号分割的字符串<br>    <c:fortokens items="Ab,Ba,BC" delims="," var="item"><br>                <c:out value="${item}"></c:out><br>    </c:fortokens></p>
<p><fmt:formatnumber value="12" type="number"></fmt:formatnumber></p>
<p><fmt:formatnumber value="12" type="number" minintegerdigits="3"></fmt:formatnumber></p>
<p><fmt:formatnumber value="123434" pattern=".000"></fmt:formatnumber></p>
<p><fmt:formatnumber value="12" type="currency"></fmt:formatnumber></p>
<p><fmt:formatnumber value="0.12" type="percent"></fmt:formatnumber></p>
<p><fmt:formatnumber value="0.125" type="percent" minfractiondigits="2"></fmt:formatnumber></p>
<p>使用上传文件（使用commons-fileupload和commons-io）<br>@RequestMapping(value = “/product_save”)<br>    public String saveProduct(HttpServletRequest servletRequest,<br>            @ModelAttribute Product product, BindingResult bindingResult,<br>            Model model) {</p>
<pre><code>    List&lt;MultipartFile&gt; files = product.getImages();

    List&lt;String&gt; fileNames = new ArrayList&lt;String&gt;();
    File imageFile = null;
    if (null != files &amp;&amp; files.size() &gt; 0) {
        for (MultipartFile multipartFile : files) {

            String fileName = multipartFile.getOriginalFilename();
            fileNames.add(fileName);

            imageFile = new File(servletRequest.getServletContext()
                    .getRealPath(&quot;/image&quot;), fileName);
            logger.info(&quot;path is :&quot; + imageFile);
            try {
                multipartFile.transferTo(imageFile);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    // save product here
    model.addAttribute(&quot;product&quot;, product);
    model.addAttribute(&quot;path&quot;,imageFile);
    return &quot;ProductDetails&quot;;
}
</code></pre><p>JSP</p>
<p><c:foreach items="${product.images}" var="image"><br>            <li>${image.originalFilename}<br>            <img src="${path }"><br>            </li><br>        </c:foreach><br>配置</p>
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"><br>        <property name="maxUploadSize" value="2000000"><br>    </property></bean>


<p>Servlet 注意线程安全性。Servlet 实例会被一个应用程序中的所有用户共享，因此不建议使用类级变量，除非它们是只读的，或者是java.util.concurrent.atomic 包的成员<br>将项目打包成war文件复制放在Tomcat的webapps目录下，当开始启动Tomcat时，Tomcat 就会自动解压这个war文件，部署成war文件所有Servlet容器中都适用</p>
<p>ServletRequest 方法<br>public int getContentLength()<br>public String getContentType()<br>public Stirng getProtocol()<br>public String getParameter(Stirng name)<br>还可以使用getParameterNames/getParameterMap/getParameterValues 获取表单域名、值及查询字符串。</p>
<p>ServletResponse<br>在调用Servlet的Service方法前，Servlet 容器首先创建一个ServletResponse，并将它作为第二个参数传给Service方法。ServletResponse 隐藏了向浏览器发送响应的复杂过程 。在ServletResponse中定义的方法之一是getWritter方法，它返回了一个可以向客户端发送文本的PrintWriter.还有一个方法可以用来向浏览器发送输出，getOutputStream,但这个方法是用于发送二进制数据，因此大部分情况下使用的是getWriter,而不是getOutputStream.<br>ServletConfig<br>当Servlet容器初始化Servlet时，Servlet 容器会给Servlet的init方法传入一个ServletConfig.ServletConfig 封装可以通过@Webservlet 或者部署描述符（web.xml）传给Servlet配置信息。这样传入的每一个条信息就叫一个初始参数。一个初始参数有key和value两个元件。<br>为了从servlet内部获取到初始参数的值，要在Servlet容器传给Servlet的init方法的ServletConfig中调用getInitParameter方法。<br>String getInitParameter(String name) 此外，getInitParameterNames方法则是返回所有参数名称的一个Enumeration。<br>除了getInitParameter和getInitParameterNames，ServletConfig 还提供了 getServletContext 方法。<br>@WebServlet(name=”MyServlet”,<br>    urlPatterns={“/my”},<br>    initParams={<br>            @WebInitParam(name=”admin”,value=”Harry”),<br>            @WebInitParam(name=”email”,value=”admin@example.com”)<br>    })<br>public class MyServlet implements Servlet{<br>    public void service(ServletRequest request, ServletResponse response){<br>        String admin = servletConfig.getInitParameter(“admin”);<br>        String email = servletConfig.getInitParameter(“email”);<br>    }<br>}</p>
<p>ServletContext<br>可以共享从应用程序中的所有资料处访问到的信息 ，并且可以动态注册web对象，前者将对象保存在ServletContext中的一个内部Map中<br>Object getAttribute(String name)<br>java.util.Enumeration<stirng> getAttributeNames()<br>void setAttribute(String name,Object object)<br>void remove Attribute(String name)</stirng></p>
<p>GenericServlet<br>public void service(ServletRequest paramServletRequest, ServletResponse paramServletResponse)<br>            throws ServletException, IOException {<br>        ServletConfig servletConfig = getServletConfig();<br>        String admin = servletConfig.getInitParameter(“admin”);<br>        paramServletResponse.setContentType(“text/html”);<br>        PrintWriter writer = paramServletResponse.getWriter();<br>        writer.println(“<html><head></head>“<br>                +”<body>Hello From “ + admin<br>                +”</body></html>“);<br>    }</p>
<p>HttpServlet<br>查阅HttpServlet 中service方法源码，该方法会检验用来发送请求的HTTP方法（通过调用request.getMethod）并调用以下方法之一：doGet/doPost/doHead/doPut/doDelete/doTrace/doOptions。这七种方法每一种方法都表示一个HTTP方法<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-6-5/85130786.jpg" alt="javax.servlet主要类型"><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-6-5/57507735.jpg" alt="javax.servlet.http主要类型"></p>
<p>Servlet 上的WebServlet标注如果如果同时也在部署描述符中进行声明，那么它将不起作用。但是，在有部署描述符的应用程序中，却不在部署描述符中标注的Servlet时，则仍然有效。这意味着，可以标注Servlet，并在同一个应用程序的部署描述符中声明这些Servlet<br>Filter 配置eg:</p>
<p><filter><br>    <filter-name>Logging Filter</filter-name><br>    <filter-class>com.yuchuan.LoggingFilter</filter-class><br></filter></p>
<p><filter-mapping><br>    <filter-name>Logging Filter</filter-name><br>    <url-pattern>MyServlet</url-pattern><br></filter-mapping></p>
<p>Listener 用来注册一个监听器，子元素listener-class包含监听器类的全路径名</p>
<listener><br>    <listener-class>com.yuchuan.ApplicationListener</listener-class><br></listener>

<p>servlet-mapping<br>映射一个Servlet到/first</p>
<p><servlet><br>    <servlet-name>FirstServlet</servlet-name><br>    <servlet-class>com.yuchuan.FirstServlet</servlet-class><br></servlet></p>
<p><servlet-mapping><br>    <servlet-name>FirstServlet</servlet-name><br>    <url-pattern>/first</url-pattern><br></servlet-mapping></p>
<p>session-config 元素定义了javax.servlet.http.HttpSession 实例的参数，此元素可以包含session-timeout cookie-config或 tracking-mode<br>session-timeout 指定会话时间超时间隔（分钟），必须为整数。如果该值为零或负数，则会话永不超时<br>cookie-config 定义了跟踪会话创建的cookie的配置<br>tracking-mode  定义了跟踪会话模式，有效值是 Cookie URL 或 SSl<br>eg: 表示应用的HttpSession对象在不活动12min后失效。<br>     <session-config><br>          <session-timeout>12</session-timeout><br>     </session-config></p>
<p>xsi:schemaLocation 属性制定了模式文档的位置，以便可以进行验证。</p>
<p>@RequestMapping(value=”/url”)<br>public String myMethod(){<br>    session.addAttribute(key,value);<br>}<br>Spring MVC 中可以在请求处理方法中出现的参数类型包括：<br>javax.servlet.ServletRequest 或 javax.servlet.http.HttpServletRequest<br>javax.servlet.ServletResponse 或 javax.servlet.http.HttpServletResponse<br>javax.servlet.HttpSession<br>org.springframework.web.context.request.WebRequest<br>java.util.Locale<br>java.io.InputStream 或  java.io.Reader<br>java.io.OutputStream 或 java.io.Writer<br>java.security.Principal<br>HttpEntity&lt;?&gt;<br>java.util.Map / org.springframework.ui.Model<br>org.springframework.web.servlet.mvc.support.RedirectAttributes<br>org.springframework.validation.Errors<br>org.springframework.validation.BindingResult<br>org.springframework.web.bind.support.SessionStatus<br>org.springframework.web.util.UriComponentsBuilder<br>带@PathVariable, @MatrixVariable 注解的对象<br>@RequestParam @RequestHeader @RequestBody @RequestPart<br>注意： org.springframework.ui.Model 类型，这不是一个Servlet API 类型，而是一个包含Map的Spring MVC 类型。每次调用请求处理方法时，Spring MVC 都创建Model对象并将其Map注入到各种对象<br>请求处理方法可以返回如下类型的对象：<br>ModelAndView<br>Model<br>Map 包含模型的属性<br>View<br>代表逻辑视图名的String<br>提供对Servlet的访问，以响应Http头部和内容 HttpEntity 或 ResponseEntity 对象<br>Callable<br>DeferredResult<br>其他任意类型，Spring 将其视作输出给View的对象模型</p>
<p><mvc:annotation-driven></mvc:annotation-driven></p>
<p><mvc:resources mapping="/css/**" location="/css/"></mvc:resources></p>
<p><mvc:resources mapping="/*.html" location="/"></mvc:resources></p>
<p><annotation-driven> 元素做的事情包括注册用于支持基于注解的控制器的请求处理方法的bean对象。<resource> 元素则只是Spring MVC 哪些静态资源需要单独处理（不通过dispatcher servlet）<br>第一个确保在CSS目录下的所有文件可见，第二个允许显示所有的.html文件<br>注意： 如果没有 <annotation-driven> <resources>元素会阻止任意控制器被调用，若不需要使用resources,则不需要<annotation-driven>元素</annotation-driven></resources></annotation-driven></resource></annotation-driven></p>
<p>无论是否会使用Model，Spring MVC 都会在每一个请求处理方法被调用时创建一个Model实例，用于增加需要显示在视图中的属性。例如通过<br>model.addAttribute(“product”,product) 来添加实例 。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的阻塞队列]]></title>
      <url>https://fudawei.github.io/2013/10/23/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B9%9D%5D-Java%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h1><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<a id="more"></a>
<p>阻塞队列提供了四种处理方法:<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/Java阻塞队列/阻塞队列方法.png" alt="Java中阻塞队列方法"></p>
<ul>
<li><strong>抛出异常</strong>：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li>
<li><strong>返回特殊值</strong>：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null</li>
<li><strong>一直阻塞</strong>：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。</li>
<li><strong>超时退出</strong>：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</li>
</ul>
<h1 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h1><p>JDK7提供了7个阻塞队列。分别是</p>
<ol>
<li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
</ol>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ArrayBlockingQueue fairQueue = new  ArrayBlockingQueue(1000,true);</div></pre></td></tr></table></figure>
<p>访问者的公平性是使用可重入锁实现的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</div><div class="line">        if (capacity &lt;= 0)</div><div class="line">            throw new IllegalArgumentException();</div><div class="line">        this.items = new Object[capacity];</div><div class="line">        lock = new ReentrantLock(fair);</div><div class="line">        notEmpty = lock.newCondition();</div><div class="line">        notFull =  lock.newCondition();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为<code>Integer.MAX_VALUE</code>。此队列按照先进先出的原则对元素进行排序。</p>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>PriorityBlockingQueue是一个支持优先级的无界队列。默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。元素按照升序排列。</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue运用在以下应用场景：</p>
<ol>
<li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</li>
<li>定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。<br>队列中的Delayed必须实现compareTo来指定元素的顺序。比如让延时时间最长的放在队列的末尾。实现代码如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public int compareTo(Delayed other) &#123;</div><div class="line">           if (other == this) // compare zero ONLY if same object</div><div class="line">                return 0;</div><div class="line">            if (other instanceof ScheduledFutureTask) &#123;</div><div class="line">                ScheduledFutureTask x = (ScheduledFutureTask)other;</div><div class="line">                long diff = time - x.time;</div><div class="line">                if (diff &lt; 0)</div><div class="line">                    return -1;</div><div class="line">                else if (diff &gt; 0)</div><div class="line">                    return 1;</div><div class="line">       else if (sequenceNumber &lt; x.sequenceNumber)</div><div class="line">                    return -1;</div><div class="line">                else</div><div class="line">                    return 1;</div><div class="line">            &#125;</div><div class="line">            long d = (getDelay(TimeUnit.NANOSECONDS) -</div><div class="line">                      other.getDelay(TimeUnit.NANOSECONDS));</div><div class="line">            return (d == 0) ? 0 : ((d &lt; 0) ? -1 : 1);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h3 id="如何实现Delayed接口"><a href="#如何实现Delayed接口" class="headerlink" title="如何实现Delayed接口"></a>如何实现Delayed接口</h3><p>我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类。这个类实现了Delayed接口。首先：在对象创建的时候，使用time记录前对象什么时候可以使用，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ScheduledFutureTask(Runnable r, V result, long ns, long period) &#123;</div><div class="line">            super(r, result);</div><div class="line">            this.time = ns;</div><div class="line">            this.period = period;</div><div class="line">            this.sequenceNumber = sequencer.getAndIncrement();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后使用getDelay可以查询当前元素还需要延时多久，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public long getDelay(TimeUnit unit) &#123;</div><div class="line">            return unit.convert(time - now(), TimeUnit.NANOSECONDS);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>通过构造函数可以看出延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为getDelay时可以指定任意单位，一旦以纳秒作为单位，而延时的时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。</p>
<h4 id="如何实现延时队列"><a href="#如何实现延时队列" class="headerlink" title="如何实现延时队列"></a>如何实现延时队列</h4><p>延时队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">long delay = first.getDelay(TimeUnit.NANOSECONDS);</div><div class="line">                    if (delay &lt;= 0)</div><div class="line">                        return q.poll();</div><div class="line">                    else if (leader != null)</div><div class="line">                        available.await();</div></pre></td></tr></table></figure>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用，SynchronousQueue的吞吐量高于LinkedBlockingQueue 和 ArrayBlockingQueue。</p>
<h2 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h2><p>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p>
<h3 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h3><p>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。transfer方法的关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Node pred = tryAppend(s, haveData);</div><div class="line">return awaitMatch(s, pred, e, (how == TIMED), nanos);</div></pre></td></tr></table></figure>
<p>第一行代码是试图把存放当前元素的s节点作为tail节点。第二行代码是让CPU自旋等待消费者消费元素。因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其他线程。</p>
<h3 id="tryTransfer方法"><a href="#tryTransfer方法" class="headerlink" title="tryTransfer方法"></a>tryTransfer方法</h3><p>tryTransfer方法则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。</p>
<p>对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p>
<h2 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h2><p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast等方法，以First单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是Jdk的bug，使用时还是用带有First和Last后缀的方法更清楚。</p>
<p>在初始化LinkedBlockingDeque时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。</p>
<h1 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h1><p>如果队列是空的，消费者会一直等待，当生产者添加元素时候，消费者是如何知道当前队列有元素的呢？如果让你来设计阻塞队列你会如何设计，让生产者和消费者能够高效率的进行通讯呢？让我们先来看看JDK是如何实现的。</p>
<p>使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源码发现ArrayBlockingQueue使用了Condition来实现，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private final Condition notFull;</div><div class="line">private final Condition notEmpty;</div><div class="line"></div><div class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</div><div class="line">        //省略其他代码</div><div class="line">        notEmpty = lock.newCondition();</div><div class="line">        notFull =  lock.newCondition();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public void put(E e) throws InterruptedException &#123;</div><div class="line">        checkNotNull(e);</div><div class="line">        final ReentrantLock lock = this.lock;</div><div class="line">        lock.lockInterruptibly();</div><div class="line">        try &#123;</div><div class="line">            while (count == items.length)</div><div class="line">                notFull.await();</div><div class="line">            insert(e);</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public E take() throws InterruptedException &#123;</div><div class="line">        final ReentrantLock lock = this.lock;</div><div class="line">        lock.lockInterruptibly();</div><div class="line">        try &#123;</div><div class="line">            while (count == 0)</div><div class="line">                notEmpty.await();</div><div class="line">            return extract();</div><div class="line">  &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void insert(E x) &#123;</div><div class="line">        items[putIndex] = x;</div><div class="line">        putIndex = inc(putIndex);</div><div class="line">        ++count;</div><div class="line">        notEmpty.signal();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当我们往队列里插入一个元素时，如果队列不可用，阻塞生产者主要通过LockSupport.park(this)来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public final void await() throws InterruptedException &#123;</div><div class="line">            if (Thread.interrupted())</div><div class="line">                throw new InterruptedException();</div><div class="line">            Node node = addConditionWaiter();</div><div class="line">            int savedState = fullyRelease(node);</div><div class="line">            int interruptMode = 0;</div><div class="line">            while (!isOnSyncQueue(node)) &#123;</div><div class="line">                LockSupport.park(this);</div><div class="line">                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line">                interruptMode = REINTERRUPT;</div><div class="line">            if (node.nextWaiter != null) // clean up if cancelled</div><div class="line">                unlinkCancelledWaiters();</div><div class="line">            if (interruptMode != 0)</div><div class="line"></div><div class="line">reportInterruptAfterWait(interruptMode);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>继续进入源码，发现调用setBlocker先保存下将要阻塞的线程，然后调用unsafe.park阻塞当前线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static void park(Object blocker) &#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        setBlocker(t, blocker);</div><div class="line">        unsafe.park(false, 0L);</div><div class="line">        setBlocker(t, null);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>unsafe.park是个native方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public native void park(boolean isAbsolute, long time);</div></pre></td></tr></table></figure>
<p>park这个方法会阻塞当前线程，只有以下四种情况中的一种发生时，该方法才会返回。</p>
<ul>
<li>与park对应的unpark执行或已经执行时。注意：已经执行是指unpark先执行，然后再执行的park。</li>
<li>线程被中断时。</li>
<li>如果参数中的time不是零，等待了指定的毫秒数时。</li>
<li>发生异常现象时。这些异常事先无法确定。</li>
</ul>
<p>我们继续看一下JVM是如何实现park方法的，park在不同的操作系统使用不同的方式实现，在linux下是使用的是系统方法pthread_cond_wait实现。实现代码在JVM源码路径src/os/linux/vm/os_linux.cpp里的 os::PlatformEvent::park方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void os::PlatformEvent::park() &#123;      </div><div class="line">             int v ;</div><div class="line">         for (;;) &#123;</div><div class="line">        v = _Event ;</div><div class="line">         if (Atomic::cmpxchg (v-1, &amp;_Event, v) == v) break ;</div><div class="line">         &#125;</div><div class="line">         guarantee (v &gt;= 0, &quot;invariant&quot;) ;</div><div class="line">         if (v == 0) &#123;</div><div class="line">         // Do this the hard way by blocking ...</div><div class="line">         int status = pthread_mutex_lock(_mutex);</div><div class="line">         assert_status(status == 0, status, &quot;mutex_lock&quot;);</div><div class="line">         guarantee (_nParked == 0, &quot;invariant&quot;) ;</div><div class="line">         ++ _nParked ;</div><div class="line">         while (_Event &lt; 0) &#123;</div><div class="line">         status = pthread_cond_wait(_cond, _mutex);</div><div class="line">         // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...</div><div class="line">         // Treat this the same as if the wait was interrupted</div><div class="line">         if (status == ETIME) &#123; status = EINTR; &#125;</div><div class="line">         assert_status(status == 0 || status == EINTR, status, &quot;cond_wait&quot;);</div><div class="line">         &#125;</div><div class="line">         -- _nParked ;</div><div class="line">         </div><div class="line">         // In theory we could move the ST of 0 into _Event past the unlock(),</div><div class="line">         // but then we&apos;d need a MEMBAR after the ST.</div><div class="line">         _Event = 0 ;</div><div class="line">         status = pthread_mutex_unlock(_mutex);</div><div class="line">         assert_status(status == 0, status, &quot;mutex_unlock&quot;);</div><div class="line">         &#125;</div><div class="line">         guarantee (_Event &gt;= 0, &quot;invariant&quot;) ;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>pthread_cond_wait是一个多线程的条件变量函数，cond是condition的缩写，字面意思可以理解为线程在等待一个条件发生，这个条件是一个全局变量。这个方法接收两个参数，一个共享变量_cond，一个互斥量_mutex。而unpark方法在linux下是使用pthread_cond_signal实现的。park 在windows下则是使用WaitForSingleObject实现的。</p>
<p>当队列满时，生产者往阻塞队列里插入一个元素，生产者线程会进入WAITING (parking)状态。我们可以使用jstack dump阻塞的生产者线程看到这点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;main&quot; prio=5 tid=0x00007fc83c000000 nid=0x10164e000 waiting on condition [0x000000010164d000]</div><div class="line">   java.lang.Thread.State: WAITING (parking)</div><div class="line">        at sun.misc.Unsafe.park(Native Method)</div><div class="line">        - parking to wait for  &lt;0x0000000140559fe8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</div><div class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)</div><div class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)</div><div class="line">        at java.util.concurrent.ArrayBlockingQueue.put(ArrayBlockingQueue.java:324)</div><div class="line">        at blockingqueue.ArrayBlockingQueueTest.main(ArrayBlockingQueueTest.java:11)</div></pre></td></tr></table></figure>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文转载自：<a href="http://www.infoq.com/cn/articles/java-blocking-queue/" target="_blank" rel="external">http://www.infoq.com/cn/articles/java-blocking-queue/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IntelliJ远程调试教程]]></title>
      <url>https://fudawei.github.io/2013/09/18/IntelliJ%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>对于分布式系统的调试不知道大家有什么好的方法。对于我来说，在知道远程调试这个方法之前就是在代码中打各种log，然后重新部署，上线，调试，这样比较费时。今天咱们来了解了解Java远程调试这个牛逼的功能，本文以Intellij IDEA为例讲解怎么使用远程调试。以<a href="http://fudawei.github.io/2015/09/11/Thrift%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">Thrift入门教程</a>这篇文章中使用的程序作为例子。这个程序由Thrift服务端和客户端组成。描述一下远程调试需要解决的问题：</p>
<a id="more"></a>
<blockquote>
<p>服务端程序运行在一台远程服务器上，我们可以在本地服务端的代码（前提是本地的代码必须和远程服务器运行的代码一致）中设置断点，每当有请求到远程服务器时时能够在本地知道远程服务端的此时的内部状态。</p>
</blockquote>
<p>下面按照步骤介绍怎么远程debug。</p>
<h1 id="使用特定JVM参数运行服务端代码"><a href="#使用特定JVM参数运行服务端代码" class="headerlink" title="使用特定JVM参数运行服务端代码"></a>使用特定JVM参数运行服务端代码</h1><p>要让远程服务器运行的代码支持远程调试，则启动的时候必须加上特定的JVM参数，这些参数是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Xdebug -Xrunjdwp:transport=dt_socket,suspend=n,server=y,address=$&#123;debug_port&#125;</div></pre></td></tr></table></figure>
<p>其中的${debug_port}是用户自定义的，为debug端口，本例以5555端口为例。</p>
<h1 id="本地连接远程服务器debug端口"><a href="#本地连接远程服务器debug端口" class="headerlink" title="本地连接远程服务器debug端口"></a>本地连接远程服务器debug端口</h1><p>打开Intellij IDEA，在顶部靠右的地方选择”Edit Configurations…”，进去之后点击+号，选择”Remote”，按照下图的只是填写红框内的内容，其中host为远程代码运行的机器的ip/hostname，port为上一步指定的debug_port，本例是5555<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/IntelliJ远程调试教程/create_remote.png" alt=""><br>然后点击Apply，最后点击OK即可</p>
<h1 id="启动debug模式"><a href="#启动debug模式" class="headerlink" title="启动debug模式"></a>启动debug模式</h1><p> 现在在上一步选择”Edit Configurations…”的下拉框的位置选择上一步创建的remote的名字，然后点击右边的debug按钮(长的像臭虫那个)，看控制台日志，如果出现类似<strong>“Connected to the target VM, address: ‘xx.xx.xx.xx:5555’, transport: ‘socket’”</strong>的字样，就表示连接成功过了。<br> <img src="http://7xlune.com1.z0.glb.clouddn.com/images/IntelliJ远程调试教程/start_remote.png" alt=""></p>
<h1 id="设置断点，开始调试"><a href="#设置断点，开始调试" class="headerlink" title="设置断点，开始调试"></a>设置断点，开始调试</h1><p>远程debug模式已经开启，现在可以在需要调试的代码中打断点了，比如：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/IntelliJ远程调试教程/create_debug_point.png" alt=""><br>如图中所示，如果断点内有√，则表示选取的断点正确。</p>
<p>现在在本地发送一个到远程服务器的请求，看本地控制台的bug界面，划到debugger这个标签，可以看到当前远程服务的内部状态（各种变量）已经全部显示出来了，并且在刚才设置了断点的地方，也显示了该行的变量值。<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/IntelliJ远程调试教程/show_debug_result1.png" alt=""><br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/IntelliJ远程调试教程/show_debug_result2.png" alt=""></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>本文为作者原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/09/18/IntelliJ远程调试教程">http://fudawei.github.io/2015/09/18/IntelliJ远程调试教程</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Java并发包学习七]解密ThreadLocal]]></title>
      <url>https://fudawei.github.io/2013/09/02/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83%5D%E8%A7%A3%E5%AF%86ThreadLocal/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>相信读者在网上也看了很多关于ThreadLocal的资料，很多博客都这样说：ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；ThreadLocal的目的是为了解决多线程访问资源时的共享问题。如果你也这样认为的，那现在给你10秒钟，清空之前对ThreadLocal的<strong>错误</strong>的认知！<br><a id="more"></a><br>看看JDK中的源码是怎么写的：</p>
<blockquote>
<p>This class provides thread-local variables.  These variables differ from<br> their normal counterparts in that each thread that accesses one (via its<br> {@code get} or {@code set} method) has its own, independently initialized<br> copy of the variable.  {@code ThreadLocal} instances are typically private<br> static fields in classes that wish to associate state with a thread (e.g.,<br> a user ID or Transaction ID).</p>
</blockquote>
<p>翻译过来大概是这样的(英文不好，如有更好的翻译，请留言说明)：  </p>
<blockquote>
<p>ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是<code>private static</code>类型的，用于关联线程和线程的上下文。</p>
</blockquote>
<p>可以总结为一句话：<strong>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</strong><br>举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，我要完成这两个函数都需要同一个东西：公交卡（北京公交和地铁都使用公交卡），那么我为了不向这两个函数都传递公交卡这个变量（相当于不是一直带着公交卡上路），我可以这么做：将公交卡事先交给一个机构，当我需要刷卡的时候再向这个机构要公交卡（当然每次拿的都是同一张公交卡）。这样就能达到只要是我(同一个线程)需要公交卡，何时何地都能向这个机构要的目的。</p>
<p>有人要说了：<em>你可以将公交卡设置为全局变量啊，这样不是也能何时何地都能取公交卡吗？</em>但是如果有很多个人（很多个线程）呢？大家可不能都使用同一张公交卡吧(我们假设公交卡是实名认证的)，这样不就乱套了嘛。现在明白了吧？这就是ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</p>
<h1 id="ThreadLocal基本操作"><a href="#ThreadLocal基本操作" class="headerlink" title="ThreadLocal基本操作"></a>ThreadLocal基本操作</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>ThreadLocal的构造函数签名是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Creates a thread local variable.</div><div class="line"> * @see #withInitial(java.util.function.Supplier)</div><div class="line"> */</div><div class="line">public ThreadLocal() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部啥也没做。</p>
<h2 id="initialValue函数"><a href="#initialValue函数" class="headerlink" title="initialValue函数"></a>initialValue函数</h2><p>initialValue函数用来设置ThreadLocal的初始值，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected T initialValue() &#123;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数在调用<code>get</code>函数的时候会第一次调用，但是如果一开始就调用了<code>set</code>函数，则该函数不会被调用。通常该函数只会被调用一次，除非手动调用了<code>remove</code>函数之后又调用<code>get</code>函数，这种情况下，<code>get</code>函数中还是会调用<code>initialValue</code>函数。该函数是protected类型的，很显然是建议在子类重载该函数的，所以通常该函数都会以匿名内部类的形式被重载，以指定初始值，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package com.winwill.test;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/9/2 00:05</div><div class="line"> */</div><div class="line">public class TestThreadLocal &#123;</div><div class="line">    private static final ThreadLocal&lt;Integer&gt; value = new ThreadLocal&lt;Integer&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        protected Integer initialValue() &#123;</div><div class="line">            return Integer.valueOf(1);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h2><p>该函数用来获取与当前线程关联的ThreadLocal的值，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public T get()</div></pre></td></tr></table></figure>
<p>如果当前线程没有该ThreadLocal的值，则调用<code>initialValue</code>函数获取初始值返回。</p>
<h2 id="set函数"><a href="#set函数" class="headerlink" title="set函数"></a>set函数</h2><p>set函数用来设置当前线程的该ThreadLocal的值，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void set(T value)</div></pre></td></tr></table></figure>
<p>设置当前线程的ThreadLocal的值为value。</p>
<h2 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h2><p>remove函数用来将当前线程的ThreadLocal绑定的值删除，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void remove()</div></pre></td></tr></table></figure>
<p>在某些情况下需要手动调用该函数，防止内存泄露。</p>
<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><p>学习了最基本的操作之后，我们用一段代码来演示ThreadLocal的用法，该例子实现下面这个场景：</p>
<blockquote>
<p>有5个线程，这5个线程都有一个值value，初始值为0，线程运行时用一个循环往value值相加数字。</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package com.winwill.test;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/9/2 00:05</div><div class="line"> */</div><div class="line">public class TestThreadLocal &#123;</div><div class="line">    private static final ThreadLocal&lt;Integer&gt; value = new ThreadLocal&lt;Integer&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        protected Integer initialValue() &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            new Thread(new MyThread(i)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class MyThread implements Runnable &#123;</div><div class="line">        private int index;</div><div class="line"></div><div class="line">        public MyThread(int index) &#123;</div><div class="line">            this.index = index;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            System.out.println(&quot;线程&quot; + index + &quot;的初始value:&quot; + value.get());</div><div class="line">            for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                value.set(value.get() + i);</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;线程&quot; + index + &quot;的累加value:&quot; + value.get());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<blockquote>
<p>线程0的初始value:0<br>线程3的初始value:0<br>线程2的初始value:0<br>线程2的累加value:45<br>线程1的初始value:0<br>线程3的累加value:45<br>线程0的累加value:45<br>线程1的累加value:45<br>线程4的初始value:0<br>线程4的累加value:45  </p>
</blockquote>
<p>可以看到，各个线程的value值是相互独立的，本线程的累加操作不会影响到其他线程的值，真正达到了线程内部隔离的效果。</p>
<h1 id="如何实现的"><a href="#如何实现的" class="headerlink" title="如何实现的"></a>如何实现的</h1><p>看了基本介绍，也看了最简单的效果演示之后，我们更应该好好研究下ThreadLocal内部的实现原理。如果给你设计，你会怎么设计？相信大部分人会有这样的想法：  </p>
<blockquote>
<p>每个ThreadLocal类创建一个Map，然后用线程的ID作为Map的key，实例对象作为Map的value，这样就能达到各个线程的值隔离的效果。</p>
</blockquote>
<p>没错，这是最简单的设计方案，JDK最早期的ThreadLocal就是这样设计的。JDK1.3（不确定是否是1.3）之后ThreadLocal的设计换了一种方式。</p>
<p>我们先看看JDK8的ThreadLocal的<code>get</code>方法的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public T get() &#123;</div><div class="line">      Thread t = Thread.currentThread();</div><div class="line">      ThreadLocalMap map = getMap(t);</div><div class="line">      if (map != null) &#123;</div><div class="line">          ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">          if (e != null) &#123;</div><div class="line">              @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">              T result = (T)e.value;</div><div class="line">              return result;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      return setInitialValue();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>其中getMap的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ThreadLocalMap getMap(Thread t) &#123;</div><div class="line">    return t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>setInitialValue函数的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private T setInitialValue() &#123;</div><div class="line">    T value = initialValue();</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value);</div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">    return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>createMap函数的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void createMap(Thread t, T firstValue) &#123;</div><div class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单解析一下，get方法的流程是这样的：  </p>
<ol>
<li>首先获取当前线程</li>
<li>根据当前线程获取一个Map</li>
<li>如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的value e，否则转到5</li>
<li>如果e不为null，则返回e.value，否则转到5</li>
<li>Map为空或者e为空，则通过<code>initialValue</code>函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map</li>
</ol>
<p>然后需要注意的是Thread类中包含一个成员变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</div></pre></td></tr></table></figure>
<p>所以，可以总结一下ThreadLocal的设计思路：<br><strong>每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例本身，value是真正需要存储的Object。</strong><br>这个方案刚好与我们开始说的简单的设计方案相反。查阅了一下资料，这样设计的主要有以下几点优势：  </p>
<ul>
<li>这样设计之后每个Map的Entry数量变小了：之前是Thread的数量，现在是ThreadLocal的数量，能提高性能，据说性能的提升不是一点两点(没有亲测)</li>
<li>当Thread销毁之后对应的ThreadLocalMap也就随之销毁了，能减少内存使用量。</li>
</ul>
<h1 id="再深入一点"><a href="#再深入一点" class="headerlink" title="再深入一点"></a>再深入一点</h1><p>先交代一个事实：<strong>ThreadLocalMap是使用ThreadLocal的弱引用作为Key的</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static class ThreadLocalMap &#123;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * The entries in this hash map extend WeakReference, using</div><div class="line">         * its main ref field as the key (which is always a</div><div class="line">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</div><div class="line">         * == null) mean that the key is no longer referenced, so the</div><div class="line">         * entry can be expunged from table.  Such entries are referred to</div><div class="line">         * as &quot;stale entries&quot; in the code that follows.</div><div class="line">         */</div><div class="line">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</div><div class="line">            /** The value associated with this ThreadLocal. */</div><div class="line">            Object value;</div><div class="line"></div><div class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">                super(k);</div><div class="line">                value = v;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：<br><img src="http://7xlune.com1.z0.glb.clouddn.com/images/解密ThreadLocal/ThreadLocal.png" alt=""></p>
<p>然后网上就传言，ThreadLocal会引发内存泄露，他们的理由是这样的：</p>
<blockquote>
<p>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<br><strong>ThreadLocal Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</strong><br>永远无法回收，造成内存泄露。</p>
</blockquote>
<p>我们来看看到底会不会出现这种情况。<br>其实，在JDK的ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施，下面是ThreadLocalMap的<code>getEntry</code>方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</div><div class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</div><div class="line">    Entry e = table[i];</div><div class="line">    if (e != null &amp;&amp; e.get() == key)</div><div class="line">        return e;</div><div class="line">    else</div><div class="line">        return getEntryAfterMiss(key, i, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getEntryAfterMiss</code>函数的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</div><div class="line">     Entry[] tab = table;</div><div class="line">     int len = tab.length;</div><div class="line"></div><div class="line">     while (e != null) &#123;</div><div class="line">         ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">         if (k == key)</div><div class="line">             return e;</div><div class="line">         if (k == null)</div><div class="line">             expungeStaleEntry(i);</div><div class="line">         else</div><div class="line">             i = nextIndex(i, len);</div><div class="line">         e = tab[i];</div><div class="line">     &#125;</div><div class="line">     return null;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><code>expungeStaleEntry</code>函数的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">private int expungeStaleEntry(int staleSlot) &#123;</div><div class="line">           Entry[] tab = table;</div><div class="line">           int len = tab.length;</div><div class="line"></div><div class="line">           // expunge entry at staleSlot</div><div class="line">           tab[staleSlot].value = null;</div><div class="line">           tab[staleSlot] = null;</div><div class="line">           size--;</div><div class="line"></div><div class="line">           // Rehash until we encounter null</div><div class="line">           Entry e;</div><div class="line">           int i;</div><div class="line">           for (i = nextIndex(staleSlot, len);</div><div class="line">                (e = tab[i]) != null;</div><div class="line">                i = nextIndex(i, len)) &#123;</div><div class="line">               ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">               if (k == null) &#123;</div><div class="line">                   e.value = null;</div><div class="line">                   tab[i] = null;</div><div class="line">                   size--;</div><div class="line">               &#125; else &#123;</div><div class="line">                   int h = k.threadLocalHashCode &amp; (len - 1);</div><div class="line">                   if (h != i) &#123;</div><div class="line">                       tab[i] = null;</div><div class="line"></div><div class="line">                       // Unlike Knuth 6.4 Algorithm R, we must scan until</div><div class="line">                       // null because multiple entries could have been stale.</div><div class="line">                       while (tab[h] != null)</div><div class="line">                           h = nextIndex(h, len);</div><div class="line">                       tab[h] = e;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           return i;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>整理一下ThreadLocalMap的<code>getEntry</code>函数的流程：</p>
<ol>
<li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；</li>
<li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询</li>
</ol>
<p>在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，<code>set</code>操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。<br>但是光这样还是不够的，上面的设计思路依赖一个前提条件：<strong>要调用ThreadLocalMap的<code>genEntry</code>函数或者<code>set</code>函数。</strong>这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的<code>remove</code>函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成<code>private static</code>的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文为作者自己的个人见解，如理解有误，请留言相告，谢谢。<br><strong>转载请注明出处：</strong><br><a href="http://fudawei.github.io/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/">http://fudawei.github.io/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[A记录和CNAME记录介绍]]></title>
      <url>https://fudawei.github.io/2013/08/31/A%E8%AE%B0%E5%BD%95%E4%B8%8ECNAME%E8%AE%B0%E5%BD%95%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>在互联网上访问网站的时候我们通常都是输入网址，比如<a href="http://fudawei.github.io">http://fudawei.github.io</a>，通过这个网址怎么知道需要访问的资源是在哪里呢？答案就是域名解析，将一个网址映射到一个特定的IP地址的过程就叫做<strong>域名解析</strong>。域名的解析工作由DNS服务器完成。<br><a id="more"></a></p>
<h1 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h1><p>A记录即Address记录，字面意思就是地址记录，就是将一个域名或主机名解析成一个具体的IP地址。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。</p>
<h1 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h1><p>CNAME记录即别名记录。这种记录允许您将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。这两个别名的全称就 <a href="http://www.mydomain.com/和“mail.mydomain.com”。实际上他们都指向" target="_blank" rel="external">http://www.mydomain.com/和“mail.mydomain.com”。实际上他们都指向</a> “host.mydomain.com”。</p>
<h1 id="A记录和CNAME记录的比较"><a href="#A记录和CNAME记录的比较" class="headerlink" title="A记录和CNAME记录的比较"></a>A记录和CNAME记录的比较</h1><p>A记录就是把一个域名解析到一个IP地址（Address，特制数字IP地址），而CNAME记录就是把域名解析到另外一个域名。其功能是差不多，CNAME将几个主机名指向一个别名，其实跟指向IP地址是一样的，因为这个别名也要做一个A记录的。但是使用CNAME记录可以很方便地变更IP地址。如果一台服务器有100个网站，他们都做了别名，该台服务器变更IP时，只需要变更别名的A记录就可以了。</p>
<h1 id="使用哪种方式更好"><a href="#使用哪种方式更好" class="headerlink" title="使用哪种方式更好"></a>使用哪种方式更好</h1><p>域名解析CNAME记录A记录哪一种比较好？如果论对网站的影响，就没有多大区别。但是：CNAME有一个好处就是稳定，就好像一个IP与一个域名的区别。服务商从方便维护的角度，一般也建议用户使用CNAME记录绑定域名的。如果主机使用了双线IP，显然使用CNAME也要方便一些。<br>A记录也有一些好处，例如可以在输入域名时不用输入WWW.来访问网站哦！从SEO优化角度来看，一些搜索引擎如alex或一些搜索查询工具网站等等则默认是自动去掉WWW.来辨别网站，CNAME记录是必须有如：WWW(别名)前缀的域名，有时候会遇到这样的麻烦，前缀去掉了默认网站无法访问。<br>有人认为，在SEO优化网站的时候，由于搜索引擎找不到去掉WWW.的域名时，对网站权重也会有些影响。因为有些网民客户也是不喜欢多写三个W来访问网站的，网站无法访问有少量网民客户会放弃继续尝试加WWW.访问域名了，因此网站访问浏览量也会减少一些。<br>也有人认为同一个域名加WWW.和不加WWW.访问网站也会使网站权重分散，这也是个问题。但是可以使用301跳转把不加WWW.跳转到加WWW.的域名，问题就解决了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://blog.xieyc.com/differences-between-a-record-and-cname-record/" target="_blank" rel="external">http://blog.xieyc.com/differences-between-a-record-and-cname-record/</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Java并发包学习六]Semaphore介绍]]></title>
      <url>https://fudawei.github.io/2013/08/26/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E5%85%AD%5DSemaphore%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>emaphore字面意思是信号量。他主要用于控制有限的资源的访问数量。我们看一个生活中常常出现的场景：<br><a id="more"></a></p>
<blockquote>
<p>一个厕所只有3个坑位，但是有10个人来上厕所，那怎么办？假设10的人的编号分别为1-10，并且1号先到厕所，10号最后到厕所。那么1-3号来的时候必然有可用坑位，顺利如厕，4号来的时候需要看看前面3人是否有人出来了，如果有人出来，进去，否则等待。同样的道理，4-10号也需要等待正在上厕所的人出来后才能进去，并且谁先进去这得看等待的人是否有素质，是否能遵守先来先上的规则。</p>
</blockquote>
<p>在这种场景下，Semaphore便派上了用场。</p>
<h1 id="基本函数介绍"><a href="#基本函数介绍" class="headerlink" title="基本函数介绍"></a>基本函数介绍</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数使用一个初始非零整数初始化Semaphore，表示最开始的时候的可用资源（上例中的厕所坑位）数量。有两种类型的构造函数，函数签名分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public Semaphore(int permits)</div><div class="line">public Semaphore(int permits, boolean fair)</div></pre></td></tr></table></figure>
<p>其中permits参数表示初始的可用资源数量，fair参数表示是否使用公平策略（是否按照先来线上的顺序）选择正在等候的使用者（上例中的上厕所的人），fair为<strong>true</strong>表示公平策略，采用先来先用的算法，为<strong>false</strong>表示非公平策略，完全随机，默认使用非公平策略。</p>
<h2 id="acquire函数"><a href="#acquire函数" class="headerlink" title="acquire函数"></a>acquire函数</h2><p>acquire函数用来申请资源，有两种不同的函数，签名分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void acquire() throws InterruptedException </div><div class="line">public void acquire(int permits) throws InterruptedException</div></pre></td></tr></table></figure>
<p>第一个函数用来申请一个资源，第二个函数用来申请permits个资源，当没有需要申请的数量这么多个资源时，申请线程会被阻塞，直到有可用资源或者申请线程被打断，如果申请线程被打断，则抛出InterruptedException异常。</p>
<h2 id="acquireUninterruptibly函数"><a href="#acquireUninterruptibly函数" class="headerlink" title="acquireUninterruptibly函数"></a>acquireUninterruptibly函数</h2><p>翻译过来就是不可能被打断的申请，对，该函数用来申请可用资源，并且不会被打断，也有两种类型，函数签名分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void acquireUninterruptibly()</div><div class="line">public void acquireUninterruptibly(int permits)</div></pre></td></tr></table></figure>
<p>第一个函数用来申请一个资源，第二个函数用来申请permits个资源。就算线程在申请资源过程中被打断，依然会继续申请，只不过获取资源的时间可能会有所变化。</p>
<h2 id="tryAcquire函数"><a href="#tryAcquire函数" class="headerlink" title="tryAcquire函数"></a>tryAcquire函数</h2><p>tryAcquire函数用来获取可用资源，但是这类函数能够有时间的限制，如果超时，立即返回，有几种类型的函数，签名分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public boolean tryAcquire()</div><div class="line">public boolean tryAcquire(long timeout, TimeUnit unit)</div><div class="line">        throws InterruptedException</div><div class="line">public boolean tryAcquire(int permits)</div><div class="line">public boolean tryAcquire(int permits, long timeout, TimeUnit unit)</div><div class="line">        throws InterruptedException</div></pre></td></tr></table></figure>
<ol>
<li>第一个函数用来申请一个资源，如果当前有可用资源，立即返回true，否则立即返回false；</li>
<li>第二个函数用来申请一个资源，指定一个超时时间，如果当前可以资源数量足够，立即返回true，否则最多等待给定的时间，如果时间到还是未能获取资源，则返回false；如果等待过程中线程被打断，抛出InterruptedException异常；</li>
<li>和1一样，只是申请permits个资源；</li>
<li>和2一样，只是申请permits个资源。</li>
</ol>
<h2 id="release函数"><a href="#release函数" class="headerlink" title="release函数"></a>release函数</h2><p>release函数用来释放资源，就好比说蹲厕所的人出来了，让出了坑位。有两种类型，函数签名分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void release()</div><div class="line">public void release(int permits)</div></pre></td></tr></table></figure>
<p>第一个函数释放一个资源，第二个函数释放permits个资源。</p>
<h2 id="availablePermits函数"><a href="#availablePermits函数" class="headerlink" title="availablePermits函数"></a>availablePermits函数</h2><p>availablePermits函数用来获取当前可用的资源数量，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public int availablePermits()</div></pre></td></tr></table></figure>
<h2 id="drainPermits函数"><a href="#drainPermits函数" class="headerlink" title="drainPermits函数"></a>drainPermits函数</h2><p>drainPermits函数用来申请当前所有可用的资源，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public int drainPermits()</div></pre></td></tr></table></figure>
<p>函数返回申请到的资源的个数。</p>
<h2 id="reducePermits函数"><a href="#reducePermits函数" class="headerlink" title="reducePermits函数"></a>reducePermits函数</h2><p>reducePermits函数用来禁止某些资源不可用，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void reducePermits(int reduction)</div></pre></td></tr></table></figure>
<p>reduction表示禁止的数量，比如由于厕所马桶坏了，有一个坑位不能用，此时就可以调用该函数禁止一个资源不可用。如果reduction小于零，则抛出IllegalArgumentException异常。</p>
<h2 id="isFair函数"><a href="#isFair函数" class="headerlink" title="isFair函数"></a>isFair函数</h2><p>isFair函数用来判断当前的信号量是采用什么类型的策略，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public boolean isFair()</div></pre></td></tr></table></figure>
<p>函数返回<strong>true</strong>表示采用的是公平策略，返回<strong>false</strong>表示采用非公平策略。</p>
<h2 id="hasQueuedThreads函数"><a href="#hasQueuedThreads函数" class="headerlink" title="hasQueuedThreads函数"></a>hasQueuedThreads函数</h2><p>hasQueuedThreads函数用来判断是否有现成正在等待申请资源，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final boolean hasQueuedThreads()</div></pre></td></tr></table></figure>
<p>返回<strong>true</strong>表示有现成正在等待申请资源，<strong>false</strong>表示没有，需要注意的是：<strong>因为申请过程是可以取消的，函数返回true并不表示肯定会申请资源，该函数设计的初衷是用来做系统监控的。</strong></p>
<h2 id="getQueueLength函数"><a href="#getQueueLength函数" class="headerlink" title="getQueueLength函数"></a>getQueueLength函数</h2><p>getQueueLength函数用来返回正在等待申请资源的线程的数量，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final int getQueueLength()</div></pre></td></tr></table></figure>
<p>返回当前正在等待申请资源的线程数。</p>
<h2 id="getQueuedThreads函数"><a href="#getQueuedThreads函数" class="headerlink" title="getQueuedThreads函数"></a>getQueuedThreads函数</h2><p>getQueuedThreads函数返回当前正在等待申请资源的线程集合，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected Collection&lt;Thread&gt; getQueuedThreads()</div></pre></td></tr></table></figure>
<h1 id="模拟实验"><a href="#模拟实验" class="headerlink" title="模拟实验"></a>模拟实验</h1><p>下面用代码来模拟如下场景：</p>
<blockquote>
<p>一个厕所只有3个坑位，有6个人（编号1-6）先后来上厕所，采用先来先上的策略。</p>
</blockquote>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">package com.winwill.test;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line">import java.util.concurrent.Semaphore;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/8/25 23:23</div><div class="line"> */</div><div class="line">public class TestSemaphore &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        Semaphore wc = new Semaphore(3, true); // 3个坑位</div><div class="line">        for (int i = 1; i &lt;= 6; i++) &#123;</div><div class="line">            Thread t = new Thread(new Person(&quot;第&quot; + i + &quot;个人&quot;, wc));</div><div class="line">            t.start();</div><div class="line">            Thread.sleep(new Random().nextInt(300));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class Person implements Runnable &#123;</div><div class="line">        private String name;</div><div class="line">        private Semaphore wc;</div><div class="line"></div><div class="line">        public Person(String name, Semaphore wc) &#123;</div><div class="line">            this.name = name;</div><div class="line">            this.wc = wc;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            System.out.print(name + &quot;：憋死老子了!&quot;);</div><div class="line">            if (wc.availablePermits() &gt; 0) &#123;</div><div class="line">                System.out.println(&quot;天助我也，有坑位！&quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                System.out.println(&quot;卧槽，没坑位了，等会儿吧...&quot;);</div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                wc.acquire(); //申请坑位</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(name + &quot;：终于轮到我了，拉屎就是爽！&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(new Random().nextInt(1000)); // 模拟上厕所时间。</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(name + &quot;：拉完了，好臭!&quot;);</div><div class="line">            wc.release();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>第1个人：憋死老子了!天助我也，有坑位！<br>第1个人：终于轮到我了，拉屎就是爽！<br>第2个人：憋死老子了!天助我也，有坑位！<br>第2个人：终于轮到我了，拉屎就是爽！<br>第3个人：憋死老子了!天助我也，有坑位！<br>第3个人：终于轮到我了，拉屎就是爽！<br>第3个人：拉完了，好臭!<br>第4个人：憋死老子了!天助我也，有坑位！<br>第4个人：终于轮到我了，拉屎就是爽！<br>第5个人：憋死老子了!卧槽，没坑位了，等会儿吧…<br>第6个人：憋死老子了!卧槽，没坑位了，等会儿吧…<br>第2个人：拉完了，好臭!<br>第5个人：终于轮到我了，拉屎就是爽！<br>第4个人：拉完了，好臭!<br>第6个人：终于轮到我了，拉屎就是爽！<br>第1个人：拉完了，好臭!<br>第6个人：拉完了，好臭!<br>第5个人：拉完了，好臭!  </p>
</blockquote>
<p>可以看到，任何时候在用坑位的人数都控制在3人之内，并且开始蹲坑的顺序一定是按编号从小到大来的（公平策略）。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>release函数和acquire并没有要求一定是同一个线程都调用，可以A线程申请资源，B线程释放资源；</li>
<li>调用release函数之前并没有要求一定要先调用acquire函数。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Java并发包学习五]CountDownLatch和CyclicBarrier介绍]]></title>
      <url>https://fudawei.github.io/2013/08/25/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%BA%94%5DCountDownLatch%E5%92%8CCyclicBarrier%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JDK中提供了一些用于线程之间协同等待的工具类，CountDownLatch和CyclicBarrier就是最典型的两个线程同步辅助类。下面分别详细介绍这两个类，以及他们之间的异同点。<br><a id="more"></a></p>
<h1 id="CountDownLatch类"><a href="#CountDownLatch类" class="headerlink" title="CountDownLatch类"></a>CountDownLatch类</h1><p>CountDownLatch顾名思义：<strong>倒计数锁存器</strong>。没错，他就是一个计数器，并且是倒着计数的。他的应用场景如下：</p>
<blockquote>
<p>一个任务A，他需要等待其他的一些任务都执行完毕之后它才能执行。就比如说赛跑的时候，发令员需要等待所有运动员都准备好了才能发令，否则不被K才怪嘞！</p>
</blockquote>
<p>此时CountDownLatch就可以大展身手了。</p>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>本节介绍CountDownLatch的基本操作函数。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public CountDownLatch(int count)</div></pre></td></tr></table></figure>
<p>用一个给定的数值初始化CountDownLatch，之后计数器就从这个值开始倒计数，直到计数值达到零。</p>
<h3 id="await函数"><a href="#await函数" class="headerlink" title="await函数"></a>await函数</h3><p>await函数用两种形式，签名分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void await() throws InterruptedException</div><div class="line">public boolean await(long timeout, TimeUnit unit)</div></pre></td></tr></table></figure>
<p>这两个函数的作用都是让线程阻塞等待其他线程，直到CountDownLatch的计数值变为0才继续执行之后的操作。区别在于第一个函数没有等待时间限制，可以等到天荒地老，海枯石烂，第二个函数给定一个等待超时时间，超过该时间就直接放弃了，并且第二个函数具有返回值，超时时间之内CountDownLatch的值达到0就返回<strong>true</strong>,等待时间结束计数值都还没达到0就返回<strong>false</strong>。这两个操作在等待过程中如果等待的线程被中断，则会抛出InterruptedException异常。</p>
<h3 id="countDown函数"><a href="#countDown函数" class="headerlink" title="countDown函数"></a>countDown函数</h3><p>这个函数用来将CountDownLatch的计数值减一，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void countDown()</div></pre></td></tr></table></figure>
<p>需要说明的是，如果调用这个函数的时候CountDownLatch的计数值已经为0，那么这个函数什么也不会做。</p>
<h3 id="getCount函数"><a href="#getCount函数" class="headerlink" title="getCount函数"></a>getCount函数</h3><p>该函数用来获取当前CountDownLatch的计数值，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void countDown()</div></pre></td></tr></table></figure>
<h2 id="模拟实验"><a href="#模拟实验" class="headerlink" title="模拟实验"></a>模拟实验</h2><p>理论知识讲完了，需要真枪实战地来演示一下这个类的作用，我们就以下面这个场景为例子，用CountDownLatch来实现这个需求：</p>
<blockquote>
<p>有5个运动员赛跑，开跑之前，裁判需要等待5个运动员都准备好才能发令，并且5个运动员准备好之后也都需要等待裁判发令才能开跑。</p>
</blockquote>
<p>首先分析一下依赖关系：</p>
<blockquote>
<p>裁判发令 -&gt; 5个运动员都准备好；<br>5个运动员开跑 -&gt; 裁判发令。</p>
</blockquote>
<p>好，依赖关系已经出来了，代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">package com.winwill.test;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line">import java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/8/24 23:35</div><div class="line"> */</div><div class="line">public class TestCountDownLatch &#123;</div><div class="line">    private static final int RUNNER_NUMBER = 5; // 运动员个数</div><div class="line">    private static final Random RANDOM = new Random();</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 用于判断发令之前运动员是否已经完全进入准备状态，需要等待5个运动员，所以参数为5</div><div class="line">        CountDownLatch readyLatch = new CountDownLatch(RUNNER_NUMBER);</div><div class="line">        // 用于判断裁判是否已经发令，只需要等待一个裁判，所以参数为1</div><div class="line">        CountDownLatch startLatch = new CountDownLatch(1);</div><div class="line">        for (int i = 0; i &lt; RUNNER_NUMBER; i++) &#123;</div><div class="line">            Thread t = new Thread(new Runner((i + 1) + &quot;号运动员&quot;, readyLatch, startLatch));</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            readyLatch.await();</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        startLatch.countDown();</div><div class="line">        System.out.println(&quot;裁判：所有运动员准备完毕，开始...&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class Runner implements Runnable &#123;</div><div class="line">        private CountDownLatch readyLatch;</div><div class="line">        private CountDownLatch startLatch;</div><div class="line">        private String name;</div><div class="line"></div><div class="line">        public Runner(String name, CountDownLatch readyLatch, CountDownLatch startLatch) &#123;</div><div class="line">            this.name = name;</div><div class="line">            this.readyLatch = readyLatch;</div><div class="line">            this.startLatch = startLatch;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            int readyTime = RANDOM.nextInt(1000);</div><div class="line">            System.out.println(name + &quot;：我需要&quot; + readyTime + &quot;秒时间准备.&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(readyTime);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(name + &quot;：我已经准备完毕.&quot;);</div><div class="line">            readyLatch.countDown();</div><div class="line">            try &#123;</div><div class="line">                startLatch.await();  // 等待裁判发开始命令</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(name + &quot;：开跑...&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<blockquote>
<p>1号运动员：我需要389秒时间准备.<br>2号运动员：我需要449秒时间准备.<br>3号运动员：我需要160秒时间准备.<br>4号运动员：我需要325秒时间准备.<br>5号运动员：我需要978秒时间准备.<br>3号运动员：我已经准备完毕.<br>4号运动员：我已经准备完毕.<br>1号运动员：我已经准备完毕.<br>2号运动员：我已经准备完毕.<br>5号运动员：我已经准备完毕.<br>裁判：所有运动员准备完毕，开始…<br>1号运动员：开跑…<br>5号运动员：开跑…<br>2号运动员：开跑…<br>4号运动员：开跑…<br>3号运动员：开跑…  </p>
</blockquote>
<p>可以看到，一切都是如此地完美，运动员准备好了之后裁判才发令，裁判发令之后运动员才开跑。</p>
<h1 id="CyclicBarrier类"><a href="#CyclicBarrier类" class="headerlink" title="CyclicBarrier类"></a>CyclicBarrier类</h1><p>CyclicBarrier翻译过来就是：循环的屏障。什么是循环？可以重复利用呗，对这个类就是一个可以重复利用的屏障类。CyclicBarrier主要用于一组固定大小的线程之间，各个线程之间相互等待，当所有线程都完成某项任务之后，才能执行之后的任务。<br>如下场景：</p>
<blockquote>
<p>有若干个线程都需要向一个数据库写数据，但是必须要所有的线程都讲数据写入完毕他们才能继续做之后的事情。</p>
</blockquote>
<p>分析一下这个场景的特征： </p>
<ul>
<li>各个线程都必须完成某项任务(写数据)才能继续做后续的任务；  </li>
<li>各个线程需要相互等待，不能独善其身。</li>
</ul>
<p>这种场景便可以利用CyclicBarrier来完美解决。</p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>本节介绍CyclicBarrier的基本操作函数。</p>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>有两种类型的构造函数，函数签名分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public CyclicBarrier(int parties, Runnable barrierAction)</div><div class="line">public CyclicBarrier(int parties)</div></pre></td></tr></table></figure>
<p>参数parties表示一共有多少线程参与这次“活动”，参数barrierAction是可选的，用来指定当所有线程都完成这些必须的“神秘任务”之后需要干的事情，所以barrierAction这里的动作在一个相互等待的循环内只会执行一次。</p>
<h3 id="getParties函数"><a href="#getParties函数" class="headerlink" title="getParties函数"></a>getParties函数</h3><p>getParties用来获取当前的CyclicBarrier一共有多少线程参数与，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public int getParties()</div></pre></td></tr></table></figure>
<p>返回参与“活动”的线程个数。</p>
<h3 id="await函数-1"><a href="#await函数-1" class="headerlink" title="await函数"></a>await函数</h3><p>await函数用来执行等待操作，有两种类型的函数签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public int await() throws InterruptedException, BrokenBarrierException</div><div class="line">public int await(long timeout, TimeUnit unit)</div><div class="line">        throws InterruptedException,</div><div class="line">               BrokenBarrierException,</div><div class="line">               TimeoutException</div></pre></td></tr></table></figure>
<p>第一个函数是一个无参函数，第二个函数可以指定等待的超时时间。它们的作用是：一直等待知道所有参与“活动”的线程都调用过await函数，如果当前线程不是即将调用await函数的的最后一个线程，当前线程将会被挂起，直到下列某一种情况发生：</p>
<ul>
<li>最后一个线程调用了await函数；</li>
<li>某个线程打断了当前线程；</li>
<li>某个线程打断了其他某个正在等待的线程；</li>
<li>其他某个线程等待时间超过给定的超时时间；</li>
<li>其他某个线程调用了reset函数。</li>
</ul>
<p>如果等待过程中线程被打断了，则会抛出InterruptedException异常；<br>如果等待过程中出现下列情况中的某一种情况，则会抛出BrokenBarrierException异常：</p>
<ul>
<li>其他线程被打断了；</li>
<li>当前线程等待超时了；</li>
<li>当前CyclicBarrier被reset了；</li>
<li>等待过程中CyclicBarrier损坏了；</li>
<li>构造函数中指定的barrierAction在执行过程中发生了异常。</li>
</ul>
<p>如果等待时间超过给定的最大等待时间，则会抛出TimeoutException异常，并且这个时候其他已经嗲用过await函数的线程将会继续后续的动作。</p>
<p>返回值：返回当前线程在调用过await函数的所以线程中的编号，编号为<strong>parties-1</strong>的表示第一个调用await函数，编号为0表示是最后一个调用await函数。</p>
<h3 id="isBroken函数"><a href="#isBroken函数" class="headerlink" title="isBroken函数"></a>isBroken函数</h3><p>给函数用来判断barrier是否已经损坏，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public boolean isBroken()</div></pre></td></tr></table></figure>
<p>如果因为任何原因被损坏返回<strong>true</strong>，否则返回<strong>false</strong>。</p>
<h3 id="reset函数"><a href="#reset函数" class="headerlink" title="reset函数"></a>reset函数</h3><p>顾名思义，这个函数用来重置barrier，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void reset()</div></pre></td></tr></table></figure>
<p>如果调用了该函数，则在等待的线程将会抛出BrokenBarrierException异常。</p>
<h3 id="getNumberWaiting函数"><a href="#getNumberWaiting函数" class="headerlink" title="getNumberWaiting函数"></a>getNumberWaiting函数</h3><p>该函数用来获取当前正在等待该barrier的线程数，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public int getNumberWaiting()</div></pre></td></tr></table></figure>
<h2 id="模拟实验-1"><a href="#模拟实验-1" class="headerlink" title="模拟实验"></a>模拟实验</h2><p>下面用代码实现下面的场景：</p>
<blockquote>
<p>有5个线程都需要向一个数据库写数据，但是必须要所有的线程都讲数据写入完毕他们才能继续做之后的事情。</p>
</blockquote>
<h3 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h3><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">package com.winwill.test;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line">import java.util.concurrent.BrokenBarrierException;</div><div class="line">import java.util.concurrent.CyclicBarrier;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/8/25 00:34</div><div class="line"> */</div><div class="line">public class TestCyclicBarrier &#123;</div><div class="line">    private static final int THREAD_NUMBER = 5;</div><div class="line">    private static final Random RANDOM = new Random();</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        CyclicBarrier barrier = new CyclicBarrier(THREAD_NUMBER, new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                System.out.println(Thread.currentThread().getId() + &quot;：我宣布，所有小伙伴写入数据完毕&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        for (int i = 0; i &lt; THREAD_NUMBER; i++) &#123;</div><div class="line">            Thread t = new Thread(new Worker(barrier));</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class Worker implements Runnable &#123;</div><div class="line">        private CyclicBarrier barrier;</div><div class="line"></div><div class="line">        public Worker(CyclicBarrier barrier) &#123;</div><div class="line">            this.barrier = barrier;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            int time = RANDOM.nextInt(1000);</div><div class="line">            System.out.println(Thread.currentThread().getId() + &quot;：我需要&quot; + time + &quot;毫秒时间写入数据.&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(time);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getId() + &quot;：写入数据完毕，等待其他小伙伴...&quot;);</div><div class="line">            try &#123;</div><div class="line">                barrier.await(); // 等待所有线程都调用过此函数才能进行后续动作</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (BrokenBarrierException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getId() + &quot;：所有线程都写入数据完毕，继续干活...&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<blockquote>
<p>10：我需要16毫秒时间写入数据.<br>11：我需要353毫秒时间写入数据.<br>12：我需要101毫秒时间写入数据.<br>13：我需要744毫秒时间写入数据.<br>14：我需要51毫秒时间写入数据.<br>10：写入数据完毕，等待其他小伙伴…<br>14：写入数据完毕，等待其他小伙伴…<br>12：写入数据完毕，等待其他小伙伴…<br>11：写入数据完毕，等待其他小伙伴…<br>13：写入数据完毕，等待其他小伙伴…<br>13：我宣布，所有小伙伴写入数据完毕<br>13：所有线程都写入数据完毕，继续干活…<br>10：所有线程都写入数据完毕，继续干活…<br>12：所有线程都写入数据完毕，继续干活…<br>14：所有线程都写入数据完毕，继续干活…<br>11：所有线程都写入数据完毕，继续干活…   </p>
</blockquote>
<p>可以看到，线程小伙伴们非常团结，写完自己的数据之后都在等待其他小伙伴，所有小伙伴都完成之后才继续后续的动作。</p>
<h3 id="重复使用"><a href="#重复使用" class="headerlink" title="重复使用"></a>重复使用</h3><p>上面的例子并没有体现CyclicBarrier可以循环使用的特点，所以有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">package com.winwill.test;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line">import java.util.concurrent.BrokenBarrierException;</div><div class="line">import java.util.concurrent.CyclicBarrier;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/8/25 00:34</div><div class="line"> */</div><div class="line">public class TestCyclicBarrier &#123;</div><div class="line">    private static final int THREAD_NUMBER = 5;</div><div class="line">    private static final Random RANDOM = new Random();</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        CyclicBarrier barrier = new CyclicBarrier(THREAD_NUMBER, new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                System.out.println(Thread.currentThread().getId() + &quot;：我宣布，所有小伙伴写入数据完毕&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        for (int i = 0; i &lt; THREAD_NUMBER; i++) &#123;</div><div class="line">            Thread t = new Thread(new Worker(barrier));</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line">        Thread.sleep(10000);</div><div class="line">        System.out.println(&quot;================barrier重用==========================&quot;);</div><div class="line">        for (int i = 0; i &lt; THREAD_NUMBER; i++) &#123;</div><div class="line">            Thread t = new Thread(new Worker(barrier));</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class Worker implements Runnable &#123;</div><div class="line">        private CyclicBarrier barrier;</div><div class="line"></div><div class="line">        public Worker(CyclicBarrier barrier) &#123;</div><div class="line">            this.barrier = barrier;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            int time = RANDOM.nextInt(1000);</div><div class="line">            System.out.println(Thread.currentThread().getId() + &quot;：我需要&quot; + time + &quot;毫秒时间写入数据.&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(time);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getId() + &quot;：写入数据完毕，等待其他小伙伴...&quot;);</div><div class="line">            try &#123;</div><div class="line">                barrier.await(); // 等待所有线程都调用过此函数才能进行后续动作</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (BrokenBarrierException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getId() + &quot;：所有线程都写入数据完毕，继续干活...&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>10：我需要228毫秒时间写入数据.<br>11：我需要312毫秒时间写入数据.<br>12：我需要521毫秒时间写入数据.<br>13：我需要720毫秒时间写入数据.<br>14：我需要377毫秒时间写入数据.<br>10：写入数据完毕，等待其他小伙伴…<br>11：写入数据完毕，等待其他小伙伴…<br>14：写入数据完毕，等待其他小伙伴…<br>12：写入数据完毕，等待其他小伙伴…<br>13：写入数据完毕，等待其他小伙伴…<br>13：我宣布，所有小伙伴写入数据完毕<br>13：所有线程都写入数据完毕，继续干活…<br>10：所有线程都写入数据完毕，继续干活…<br>11：所有线程都写入数据完毕，继续干活…<br>14：所有线程都写入数据完毕，继续干活…<br>12：所有线程都写入数据完毕，继续干活…<br>================barrier重用==========================<br>15：我需要212毫秒时间写入数据.<br>16：我需要691毫秒时间写入数据.<br>17：我需要530毫秒时间写入数据.<br>18：我需要758毫秒时间写入数据.<br>19：我需要604毫秒时间写入数据.<br>15：写入数据完毕，等待其他小伙伴…<br>17：写入数据完毕，等待其他小伙伴…<br>19：写入数据完毕，等待其他小伙伴…<br>16：写入数据完毕，等待其他小伙伴…<br>18：写入数据完毕，等待其他小伙伴…<br>18：我宣布，所有小伙伴写入数据完毕<br>18：所有线程都写入数据完毕，继续干活…<br>15：所有线程都写入数据完毕，继续干活…<br>19：所有线程都写入数据完毕，继续干活…<br>16：所有线程都写入数据完毕，继续干活…<br>17：所有线程都写入数据完毕，继续干活…  </p>
</blockquote>
<p>可以看到，barrier的确是重用了。</p>
<h3 id="等待超时"><a href="#等待超时" class="headerlink" title="等待超时"></a>等待超时</h3><p>如果await的时候设置了一个最长等待时间，并且等待超时，则会怎么样呢？下面的例子故意让一个线程延迟一段时间才开始写数据，这样就会出现先等待的线程等待最后一个线程抛出等待超时异常的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">package com.winwill.test;</div><div class="line"></div><div class="line">import java.util.Random;</div><div class="line">import java.util.concurrent.BrokenBarrierException;</div><div class="line">import java.util.concurrent.CyclicBarrier;</div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line">import java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/8/25 00:34</div><div class="line"> */</div><div class="line">public class TestCyclicBarrier &#123;</div><div class="line">    private static final int THREAD_NUMBER = 5;</div><div class="line">    private static final Random RANDOM = new Random();</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        CyclicBarrier barrier = new CyclicBarrier(THREAD_NUMBER, new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                System.out.println(Thread.currentThread().getId() + &quot;：我宣布，所有小伙伴写入数据完毕&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        for (int i = 0; i &lt; THREAD_NUMBER; i++) &#123;</div><div class="line">            if (i &lt; THREAD_NUMBER - 1) &#123;</div><div class="line">                Thread t = new Thread(new Worker(barrier));</div><div class="line">                t.start();</div><div class="line">            &#125; else &#123;  //最后一个线程故意延迟3s创建。</div><div class="line">                Thread.sleep(3000);</div><div class="line">                Thread t = new Thread(new Worker(barrier));</div><div class="line">                t.start();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class Worker implements Runnable &#123;</div><div class="line">        private CyclicBarrier barrier;</div><div class="line"></div><div class="line">        public Worker(CyclicBarrier barrier) &#123;</div><div class="line">            this.barrier = barrier;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            int time = RANDOM.nextInt(1000);</div><div class="line">            System.out.println(Thread.currentThread().getId() + &quot;：我需要&quot; + time + &quot;毫秒时间写入数据.&quot;);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(time);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getId() + &quot;：写入数据完毕，等待其他小伙伴...&quot;);</div><div class="line">            try &#123;</div><div class="line">                barrier.await(2000, TimeUnit.MILLISECONDS); // 只等待2s，必然会等待最后一个线程超时</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (BrokenBarrierException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (TimeoutException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getId() + &quot;：所有线程都写入数据完毕，继续干活...&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>10：我需要820毫秒时间写入数据.<br>11：我需要140毫秒时间写入数据.<br>12：我需要640毫秒时间写入数据.<br>13：我需要460毫秒时间写入数据.<br>11：写入数据完毕，等待其他小伙伴…<br>13：写入数据完毕，等待其他小伙伴…<br>12：写入数据完毕，等待其他小伙伴…<br>10：写入数据完毕，等待其他小伙伴…<br>java.util.concurrent.BrokenBarrierException<br>12：所有线程都写入数据完毕，继续干活…<br>    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)<br>    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)<br>13：所有线程都写入数据完毕，继续干活…<br>11：所有线程都写入数据完毕，继续干活…<br>10：所有线程都写入数据完毕，继续干活…<br>    at com.winwill.test.TestCyclicBarrier$Worker.run(TestCyclicBarrier.java:52)<br>    at java.lang.Thread.run(Thread.java:744)<br>java.util.concurrent.BrokenBarrierException<br>    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)<br>    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)<br>    at com.winwill.test.TestCyclicBarrier$Worker.run(TestCyclicBarrier.java:52)<br>    at java.lang.Thread.run(Thread.java:744)<br>java.util.concurrent.TimeoutException<br>    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:257)<br>    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)<br>    at com.winwill.test.TestCyclicBarrier$Worker.run(TestCyclicBarrier.java:52)<br>    at java.lang.Thread.run(Thread.java:744)<br>java.util.concurrent.BrokenBarrierException<br>    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)<br>    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)<br>    at com.winwill.test.TestCyclicBarrier$Worker.run(TestCyclicBarrier.java:52)<br>    at java.lang.Thread.run(Thread.java:744)<br>14：我需要850毫秒时间写入数据.<br>java.util.concurrent.BrokenBarrierException<br>14：写入数据完毕，等待其他小伙伴…<br>14：所有线程都写入数据完毕，继续干活…<br>    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)<br>    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)<br>    at com.winwill.test.TestCyclicBarrier$Worker.run(TestCyclicBarrier.java:52)<br>    at java.lang.Thread.run(Thread.java:744)  </p>
</blockquote>
<p>可以看到，前面四个线程等待最后一个线程超时了，这个时候他们不再等待最后这个小伙伴了，而是抛出异常并都继续后续的动作。最后这个线程屁颠屁颠地完成写入数据操作之后也继续了后续的动作。需要说明的是，发生了超时异常时候，还没有完成“神秘任务”的线程在完成任务之后不会做任何等待，而是会直接执行后续的操作。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：</p>
<ul>
<li>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</li>
<li>CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</li>
<li>CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</li>
</ul>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>转载请注明出处：<a href="http://fudawei.github.io/2015/08/25/[Java并发包学习五]CountDownLatch和CyclicBarrier介绍">http://fudawei.github.io/2015/08/25/[Java并发包学习五]CountDownLatch和CyclicBarrier介绍</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Java并发包学习四]Future和FutureTask]]></title>
      <url>https://fudawei.github.io/2013/08/21/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E5%9B%9B%5DFuture%E5%92%8CFutureTask/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Future主要用来表示线程异步执行的结果，他提供了检查异步执行的程序是否已经执行完毕、是否已经被取消，并且获取执行结果的方法。它是一个接口，接口的定义如下：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface Future&lt;V&gt; &#123;</div><div class="line">    boolean cancel(boolean mayInterruptIfRunning);</div><div class="line">    boolean isCancelled();</div><div class="line">    boolean isDone();</div><div class="line">    V get() throws InterruptedException, ExecutionException;</div><div class="line">    V get(long timeout, TimeUnit unit)</div><div class="line">        throws InterruptedException, ExecutionException, TimeoutException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>JDK中的FutureTask类是这个接口的最基本的实现。</p>
<h1 id="成员函数介绍"><a href="#成员函数介绍" class="headerlink" title="成员函数介绍"></a>成员函数介绍</h1><h2 id="cancel函数"><a href="#cancel函数" class="headerlink" title="cancel函数"></a>cancel函数</h2><p>cancel函数用来取消一个正在异步执行的任务，如果任务还没有开始，则该任务将不会再被执行，如果任务已经在执行，则可以通过mayInterruptIfRunning参数来决定是否需要尝试取消正在执行的任务，如果mayInterruptIfRunning参数为<strong>true</strong>则将取消正在运行的任务，为<strong>false</strong>则不会打断，该任务能正常结束。    </p>
<h2 id="isCanceled函数"><a href="#isCanceled函数" class="headerlink" title="isCanceled函数"></a>isCanceled函数</h2><p>isCanceled函数用来判断一个任务是否已经被取消，如果一个任务在正常执行结束之前被取消，则该函数返回<strong>true</strong>，否则返回<strong>false</strong>。</p>
<h2 id="isDone函数"><a href="#isDone函数" class="headerlink" title="isDone函数"></a>isDone函数</h2><p>isDone函数用来检测一个任务是否已经结束，结束的原因可以分为以下几种情况：  </p>
<ul>
<li>正常完成； </li>
<li>抛出异常而退出；</li>
<li>被cancel函数取消；</li>
</ul>
<p>以上这三种情况，该函数都会返回<strong>true</strong>，否则返回<strong>false</strong>。</p>
<h2 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h2><p>get函数用来获取异步执行的结果，需要说明的是，对于没有参数的get函数，如果任务没有执行完毕，该函数会一直阻塞，直到任务结束，然后再返回执行的结果；而有timeout和unit两个参数的get函数能提供一个最长等待时间，如果过了给定的时间，任务仍然没有完毕，则抛出TimeoutException，否则返回任务执行结果。</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>下面的例子演示怎么使用Future来获取异步执行的结果，假设这样一个场景：</p>
<blockquote>
<p>我们现在正在家里打dota(笔者是个dota爱好者^_^)，突然口渴了，想喝点白开水，于是我们需要烧开水，烧开水是一个比较耗时的事情，所以热水器(烧水线程)在烧开水的时候我们（主线程）不应该在一旁干等着，而是可以继续玩dota。等到被干死了之后或者上了别人高地之后再去检查开水是否已经烧好了。</p>
</blockquote>
<p>在这个场景中，我就好比是程序的主线程，而热水器就是我创建的副线程，它的主要任务就是烧水。副线程在进行比较耗时的时候主线程可以去干它自己喜欢的事情，等到空闲的时候再去检查副线程任务是否完成，然后获取任务执行结果。</p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>下面的代码演示上述场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">package com.winwill.test;</div><div class="line"></div><div class="line">import java.util.concurrent.Callable;</div><div class="line">import java.util.concurrent.FutureTask;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/8/21 11:29</div><div class="line"> */</div><div class="line">public class TestFuture &#123;</div><div class="line">    static class BoilWater implements Callable&lt;String&gt; &#123;</div><div class="line">        public String call() throws Exception &#123;</div><div class="line">            Thread.sleep(5000);            // 模拟一个耗时操作</div><div class="line">            return System.currentTimeMillis() + &quot; | 热水器：主人，水烧开了&quot;;   //烧水完成</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        //创建一个线程池，相当于找到一个热水器</div><div class="line">        FutureTask futureTask = new FutureTask(new BoilWater());</div><div class="line">        // 开始烧水</div><div class="line">        // Executors.newCachedThreadPool().submit(futureTask); 这样使用线程池的形式，</div><div class="line">        // 结果是一样的</div><div class="line">        new Thread(futureTask).start();</div><div class="line">        System.out.println(System.currentTimeMillis() + &quot; | 我：小热，你可以开始烧水了...&quot;);</div><div class="line"></div><div class="line">        // 继续打Dota</div><div class="line">        System.out.println(System.currentTimeMillis() + &quot; | 我：继续开心地玩Dota...&quot;);</div><div class="line">        Thread.sleep(4000);</div><div class="line">        System.out.println(System.currentTimeMillis() + &quot; | 我：Oh，我死了...&quot;);</div><div class="line"></div><div class="line">        // 被干了或者上对面高地了，有时间来检查水是否烧好了。</div><div class="line">        System.out.println(System.currentTimeMillis() + &quot; | 我：看看水烧好没...&quot;);</div><div class="line">        while (!futureTask.isDone()) &#123;</div><div class="line">            System.out.println(System.currentTimeMillis() + &quot; | 我：水还没烧开，小热，你快点烧，我再给你一秒钟...&quot;);</div><div class="line">            Thread.sleep(1000);</div><div class="line">        &#125;</div><div class="line">        // 使用get函数来获取烧水结果</div><div class="line">        System.out.println((String) futureTask.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<blockquote>
<p>1440129236549 | 我：小热，你可以开始烧水了…<br>1440129236549 | 我：继续开心地玩Dota…<br>1440129240554 | 我：Oh，我死了…<br>1440129240554 | 我：看看水烧好没…<br>1440129240554 | 我：水还没烧开，小热，你快点烧，我再给你一秒钟…<br>1440129241553 | 热水器：主人，水烧开了   </p>
</blockquote>
<p>可以看到，我和小热分工明确，我玩dota，他烧水，<strong>他烧水的时候我并没有傻傻地等着!</strong></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Java并发包学习三]ThreadFactory介绍]]></title>
      <url>https://fudawei.github.io/2013/08/13/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%89%5DThreadFactory%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ThreadFactory翻译过来是线程工厂，顾名思义，就是用来创建线程的，它用到了工厂模式的思想。它通常和线程池一起使用，主要用来控制创建新线程时的一些行为，比如设置线程的优先级，名字等等。它是一个接口，接口中只有一个方法:<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Constructs a new &#123;@code Thread&#125;.  Implementations may also initialize</div><div class="line"> * priority, name, daemon status, &#123;@code ThreadGroup&#125;, etc.</div><div class="line"> *</div><div class="line"> * @param r a runnable to be executed by new thread instance</div><div class="line"> * @return constructed thread, or &#123;@code null&#125; if the request to</div><div class="line"> *         create a thread is rejected</div><div class="line"> */</div><div class="line">Thread newThread(Runnable r);</div></pre></td></tr></table></figure></p>
<p>子类实现此方法并在其中完成自定义的行为。  </p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>下面我们通过一个简单的实验来解释ThreadFactory的作用，下面的代码首先创建一个类MyThreadFactoryTest，实现了ThreadFactory，newThread()方法中做了一些简单的行为：  </p>
<ul>
<li>创建新线程时，为线程设置一个名字；  </li>
<li>创建新线程时，在控制台打印一条提示信息，并附上新线程的名字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">package com.winwill.thread;</div><div class="line"></div><div class="line">import java.util.concurrent.ExecutorService;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line">import java.util.concurrent.ThreadFactory;</div><div class="line">import java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/8/11 20:28</div><div class="line"> */</div><div class="line">public class MyThreadFactoryTest implements ThreadFactory &#123;</div><div class="line">    private final AtomicInteger count = new AtomicInteger(0);</div><div class="line"></div><div class="line">    public Thread newThread(Runnable r) &#123;</div><div class="line">        int c = count.incrementAndGet();</div><div class="line">        Thread t = new Thread(r);</div><div class="line">        t.setName(&quot;test_thread_no.&quot; + c);</div><div class="line">        System.out.println(&quot;Create new thread, thread name: &quot; + t.getName());</div><div class="line">        return t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        ExecutorService service = Executors.newFixedThreadPool(5, new MyThreadFactoryTest());</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            service.submit(new Runnable() &#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    System.out.println(&quot;Start execute...&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行这段程序会得到如下的结果：</p>
<blockquote>
<p>Create new thread, thread name: test_thread_no.1<br>Create new thread, thread name: test_thread_no.2<br>Start execute…<br>Start execute…<br>Create new thread, thread name: test_thread_no.3<br>Start execute…<br>Create new thread, thread name: test_thread_no.4<br>Start execute…<br>Create new thread, thread name: test_thread_no.5<br>Start execute…</p>
</blockquote>
<p>可以看到，运行结果符合我们的预期。</p>
<h1 id="JDK中默认的ThreadFactory"><a href="#JDK中默认的ThreadFactory" class="headerlink" title="JDK中默认的ThreadFactory"></a>JDK中默认的ThreadFactory</h1><p>在JDK的Executors类中有一个DefaultThreadFactory类，它实现了ThreadFactory，它是JDK中默认的线程工厂类，从源码可以看到这个线程工厂类为线程池中新创建的线程设置的名字为：</p>
<blockquote>
<p>pool-[线程池编号]-thread-[该线程池的线程编号]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * The default thread factory</div><div class="line">    */</div><div class="line">   static class DefaultThreadFactory implements ThreadFactory &#123;</div><div class="line">       private static final AtomicInteger poolNumber = new AtomicInteger(1);</div><div class="line">       private final ThreadGroup group;</div><div class="line">       private final AtomicInteger threadNumber = new AtomicInteger(1);</div><div class="line">       private final String namePrefix;</div><div class="line"></div><div class="line">       DefaultThreadFactory() &#123;</div><div class="line">           SecurityManager s = System.getSecurityManager();</div><div class="line">           group = (s != null) ? s.getThreadGroup() :</div><div class="line">                                 Thread.currentThread().getThreadGroup();</div><div class="line">           namePrefix = &quot;pool-&quot; +</div><div class="line">                         poolNumber.getAndIncrement() +</div><div class="line">                        &quot;-thread-&quot;;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       public Thread newThread(Runnable r) &#123;</div><div class="line">           Thread t = new Thread(group, r,</div><div class="line">                                 namePrefix + threadNumber.getAndIncrement(),</div><div class="line">                                 0);</div><div class="line">           if (t.isDaemon())</div><div class="line">               t.setDaemon(false);</div><div class="line">           if (t.getPriority() != Thread.NORM_PRIORITY)</div><div class="line">               t.setPriority(Thread.NORM_PRIORITY);</div><div class="line">           return t;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Java并发包学习二]Executors介绍]]></title>
      <url>https://fudawei.github.io/2013/08/12/%5BJava%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%BA%8C%5DExecutors%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Executors类是JDK 1.5开始自带的一个非常强大的主要用于创建各类线程池的工具类。<br><a id="more"></a></p>
<h1 id="常用方法介绍"><a href="#常用方法介绍" class="headerlink" title="常用方法介绍"></a>常用方法介绍</h1><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><p>newFixedThreadPool方法有两种函数签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads)  </div><div class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</div></pre></td></tr></table></figure>
<p>这两个函数用于创建一个最大线程数目固定的线程池，该线程池用一个共享的无界队列来存储提交的任务。参数nThreads指定线程池的最大线程数，参数<a href="http://飞鸟.com/2015/08/11/JDK8-%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0-ThreadFactory%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="external">threadFactory</a>是线程工厂类，主要用于自定义线程池中创建新线程时的行为。需要说明的是，创建线程池时，如果线程池没有接收到任何任务，则线程池中不会创建新线程，在线程池中线程数目少于最大线程数时，每来一个新任务就创建一个新线程，当线程数达到最大线程数时，不再创建新线程，新来的任务存储在队列中，之后线程数目不再变化！</p>
<h2 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h2><p>newWorkStealingPool方法有两种函数签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newWorkStealingPool(int parallelism)</div><div class="line">public static ExecutorService newWorkStealingPool()</div></pre></td></tr></table></figure>
<p>这两个方法用于创建ForkJoin框架中用到的ForkJoinPool线程池，第一个函数中的参数用于指定并行数，第二个函数没有参数，它默认使用当前机器可用的CPU个数作为并行数。</p>
<h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><p>newSingleThreadExecutor用于创建只有一个线程的线程池，有两种函数签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newSingleThreadExecutor()</div><div class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)</div></pre></td></tr></table></figure>
<p>线程池中的任务使用无界队列存储，第二个函数可以指定threadFactory，自定义创建线程时的行为。</p>
<h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><p>newCachedThreadPoolf方法用于创建线程数数目可以随着实际情况自动调节的线程池，也有两种类型的函数签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newCachedThreadPool()</div><div class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)</div></pre></td></tr></table></figure>
<p>这种线程池的最大线程数只受到操作系统可以创建的最大线程数数目限制，当线程池有很多任务需要处理时，会不断地创建新线程，当任务处理完毕之后，如果某个线程空闲时间大于60s，则该线程将会被销毁。因为这种线程池能够自动调节线程数量，所以比较适合执行大量的短期的小任务。</p>
<h2 id="newSingleThreadScheduledExecutor"><a href="#newSingleThreadScheduledExecutor" class="headerlink" title="newSingleThreadScheduledExecutor"></a>newSingleThreadScheduledExecutor</h2><p>newSingleThreadScheduledExecutor该方法用于创建只有一个线程的线程池，并且该线程定时周期性地执行给定的任务，有两种类型的函数签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor()</div><div class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)</div></pre></td></tr></table></figure>
<p>需要注意的是: <strong>线程在周期性地执行任务时如果遇到Exception，则以后将不再周期性地执行任务。</strong></p>
<h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><p>newScheduledThreadPool用于创建一个线程池，线程池中得线程能够周期性地执行给定的任务，有两种函数签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</div><div class="line">public static ScheduledExecutorService newScheduledThreadPool(</div><div class="line">            int corePoolSize, ThreadFactory threadFactory)</div></pre></td></tr></table></figure>
<h2 id="unconfigurableExecutorService"><a href="#unconfigurableExecutorService" class="headerlink" title="unconfigurableExecutorService"></a>unconfigurableExecutorService</h2><p>unconfigurableExecutorService主要用于包装现有的线程池，包装之后的线程池不能修改，相当于final的，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService unconfigurableExecutorService(ExecutorService executor)</div></pre></td></tr></table></figure>
<h2 id="unconfigurableScheduledExecutorService"><a href="#unconfigurableScheduledExecutorService" class="headerlink" title="unconfigurableScheduledExecutorService"></a>unconfigurableScheduledExecutorService</h2><p>unconfigurableScheduledExecutorService用于包装可以周期性执行任务的线程池，包装之后的线程池不能修改，相当于final，函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)</div></pre></td></tr></table></figure>
<h2 id="defaultThreadFactory"><a href="#defaultThreadFactory" class="headerlink" title="defaultThreadFactory"></a>defaultThreadFactory</h2><p>defaultThreadFactory方法返回默认的工厂方法类，默认的工厂方法为线程池中新创建的线程命名为：</p>
<blockquote>
<p>pool-[虚拟机中线程池编号]-thread-[线程编号]</p>
</blockquote>
<p>函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static ThreadFactory defaultThreadFactory()</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java注解]]></title>
      <url>https://fudawei.github.io/2013/08/07/Java%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><ul>
<li><p>注解对于开发人员来讲既熟悉又陌生，熟悉是因为只要你是做开发，都会用到注解（常见的@Override）；陌生是因为即使不使用注解也照常能够进行开发；注解不是必须的，但了解注解有助于我们深入理解某些第三方框架（比如Android Support Annotations、JUnit、xUtils、ActiveAndroid等），提高工作效率</p>
</li>
<li><p>ava注解又称为标注，是Java从1.5开始支持加入源码的特殊语法元数据；Java中的类、方法、变量、参数、包都可以被注解。这里提到的元数据是描述数据的数据，结合实例来说明：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"app_name"</span>&gt;</span>AnnotionDemo<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>这里的”app_name”就是描述数据”AnnotionDemo”的数据，这是在配置文件中写的，注解是在源码中写的，如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main_layout);</div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            setTextInOtherThread();</div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>在上面的代码中，在MainActivity.java中复写了父类Activity.java的onCreate方法，使用到了@Override注解。但即使不加上@Override注解标记代码，程序也能够正常运行。那这里的@Override注解有什么用呢？使用它有什么好处？事实上，@Override是告诉编译器这个方法是一个重写方法，如果父类中不存在该方法，编译器会报错，提示该方法不是父类中的方法。如果不小心拼写错误，将onCreate写成了onCreat，而且没有使用@Override注解，程序依然能够编译通过，但运行结果和期望的大不相同。从示例可以看出，注解有助于阅读代码</p>
</li>
<li><p>使用注解很简单，根据注解类的@Target所修饰的对象范围，可以在类、方法、变量、参数、包中使用“@+注解类名+[属性值]”的方式使用注解。比如：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@UiThread</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setTextInOtherThread</span><span class="params">(@StringRes <span class="keyword">int</span> resId)</span></span>&#123;</div><div class="line">    TextView threadTxtView = (TextView)MainActivity.<span class="keyword">this</span>.findViewById(R.id.threadTxtViewId);</div><div class="line">    threadTxtView.setText(resId);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="特别说明："><a href="#特别说明：" class="headerlink" title="特别说明："></a><strong>特别说明：</strong></h4><ul>
<li><p>注解仅仅是元数据，和业务逻辑无关，所以当你查看注解类时，发现里面没有任何逻辑处理；</p>
</li>
<li><p>javadoc中的@author、@version、@param、@return、@deprecated、@hide、@throws、@exception、@see是标记，并不是注解；</p>
</li>
</ul>
<a id="more"></a>
<h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><ul>
<li><p><strong>格式检查：</strong>告诉编译器信息，比如被@Override标记的方法如果不是父类的某个方法，IDE会报错；</p>
</li>
<li><p><strong>减少配置：</strong>运行时动态处理，得到注解信息，实现代替配置文件的功能；</p>
</li>
<li><p><strong>减少重复工作：</strong>比如第三方框架xUtils，通过注解@ViewInject减少对findViewById的调用，类似的还有（JUnit、ActiveAndroid等）；</p>
</li>
</ul>
<h3 id="注解是如何工作的？"><a href="#注解是如何工作的？" class="headerlink" title="注解是如何工作的？"></a>注解是如何工作的？</h3><ul>
<li>注解仅仅是元数据，和业务逻辑无关，所以当你查看注解类时，发现里面没有任何逻辑处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ViewInject &#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/* parent view id */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parentId</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果注解不包含业务逻辑处理，必然有人来实现这些逻辑。注解的逻辑实现是元数据的用户来处理的，注解仅仅提供它定义的属性（类/方法/变量/参数/包）的信息，注解的用户来读取这些信息并实现必要的逻辑。当使用java中的注解时（比如@Override、@Deprecated、@SuppressWarnings）JVM就是用户，它在字节码层面工作。如果是自定义的注解，比如第三方框架ActiveAndroid，它的用户是每个使用注解的类，所有使用注解的类都需要继承Model.java，在Model.java的构造方法中通过反射来获取注解类中的每个属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TableInfo</span><span class="params">(Class&lt;? extends Model&gt; type)</span> </span>&#123;</div><div class="line">    mType = type;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Table tableAnnotation = type.getAnnotation(Table.class);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (tableAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">        mTableName = tableAnnotation.name();</div><div class="line">        mIdName = tableAnnotation.id();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        mTableName = type.getSimpleName();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Manually add the id column since it is not declared like the other columns.</span></div><div class="line">    Field idField = getIdField(type);</div><div class="line">    mColumnNames.put(idField, mIdName);</div><div class="line"></div><div class="line">    List&lt;Field&gt; fields = <span class="keyword">new</span> LinkedList&lt;Field&gt;(ReflectionUtils.getDeclaredColumnFields(type));</div><div class="line">    Collections.reverse(fields);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</div><div class="line">        <span class="keyword">if</span> (field.isAnnotationPresent(Column.class)) &#123;</div><div class="line">            <span class="keyword">final</span> Column columnAnnotation = field.getAnnotation(Column.class);</div><div class="line">            String columnName = columnAnnotation.name();</div><div class="line">            <span class="keyword">if</span> (TextUtils.isEmpty(columnName)) &#123;</div><div class="line">                columnName = field.getName();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mColumnNames.put(field, columnName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="注解和配置文件的区别"><a href="#注解和配置文件的区别" class="headerlink" title="注解和配置文件的区别"></a>注解和配置文件的区别</h3><ul>
<li>通过上面的描述可以发现，其实注解干的很多事情，通过配置文件也可以干，比如为类设置配置属性；但注解和配置文件是有很多区别的，在实际编程过程中，注解和配置文件配合使用在工作效率、低耦合、可拓展性方面才会达到权衡</li>
</ul>
<hr>
<h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a><strong>配置文件：</strong></h4><p><strong>使用场合：</strong></p>
<ul>
<li><p>外部依赖的配置，比如build.gradle中的依赖配置；</p>
</li>
<li><p>同一项目团队内部达成一致的时候；</p>
</li>
<li><p>非代码类的资源文件（比如图片、布局、数据、签名文件等）；</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><p>降低耦合，配置集中，容易扩展，比如Android应用多语言支持；</p>
</li>
<li><p>对象之间的关系一目了然，比如strings.xml；</p>
</li>
<li><p>xml配置文件比注解功能齐全，支持的类型更多，比如drawable、style等；</p>
</li>
</ul>
<p><strong> 缺点：</strong></p>
<ul>
<li><p>繁琐；</p>
</li>
<li><p>类型不安全，比如R.java中的都是资源ID，用TextView的setText方法时传入int值时无法检测出该值是否为资源ID，但@StringRes可以；</p>
</li>
</ul>
<hr>
<h4 id="注解："><a href="#注解：" class="headerlink" title="注解："></a><strong>注解：</strong></h4><p><strong>使用场合：</strong></p>
<ul>
<li><p>动态配置信息；</p>
</li>
<li><p>代为实现程序逻辑（比如xUtils中的@ViewInject代为实现findViewById）；</p>
</li>
<li><p>代码格式检查，比如Override、Deprecated、NonNull、StringRes等，便于IDE能够检查出代码错误</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><p>在class文件中，提高程序的内聚性；</p>
</li>
<li><p>减少重复工作，提高开发效率，比如findViewById</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>如果对annotation进行修改，需要重新编译整个工程；</p>
</li>
<li><p>业务类之间的关系不如XML配置那样一目了然；</p>
</li>
<li><p>程序中过多的annotation，对于代码的简洁度有一定影响；</p>
</li>
<li><p>扩展性较差；</p>
</li>
</ul>
<hr>
<h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a><strong>API</strong></h4><p>Android开发过程中使用到的注解主要来自如下几个地方：</p>
<ul>
<li><p>Android SDK：在包android.annotation下；</p>
</li>
<li><p>Android Annotation Support包：在包android.support.annotation下；</p>
</li>
<li><p>JDK：在包java.lang下；</p>
</li>
<li><p>第三方框架中的自定义注解；</p>
</li>
</ul>
<h4 id="最常见注解"><a href="#最常见注解" class="headerlink" title="最常见注解"></a><strong>最常见注解</strong></h4><ul>
<li><strong>@Override</strong></li>
</ul>
<p>属于标记注解，不需要设置属性值；只能添加在方法的前面，用于标记该方法是复写的父类中的某个方法，如果在父类没有的方法前面加上@Override注解，编译器会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>@Deprecated</strong></li>
</ul>
<p>属于标记注解，不需要设置属性值；可以对构造方法、变量、方法、包、参数标记，告知用户和编译器被标记的内容已不建议被使用，如果被使用，编译器会报警告，但不会报错，程序也能正常运行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.PACKAGE, ElementType.PARAMETER, ElementType.TYPE&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>@SuppressWarnings</strong></li>
</ul>
<p>可以对构造方法、变量、方法、包、参数标记，用于告知编译器忽略指定的警告，不用再编译完成后出现警告信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</div><div class="line">    String[] value();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>@TargetApi</strong></li>
</ul>
<p>可以对接口、方法、构造方法标记，如果在应用中指定minSdkVersion为8，但有地方需要使用API 11中的方法，为了避免编译器报错，在调用API11中方法的接口、方法或者构造方法前面加上@Target(11)，这样该方法就可以使用&lt;=11的API接口了。虽然这样能够避免编译器报错，但在运行时需要注意，不能在API低于11的设备中使用该方法，否则会crash（可以获取程序运行设备的API版本来判断是否调用该方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;TYPE, METHOD, CONSTRUCTOR&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TargetApi &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This sets the target api level for the type..</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>@SuppressLint</strong></li>
</ul>
<p>和@Target的功能差不多，但使用范围更广，主要用于避免在lint检查时报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressLint &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The set of warnings (identified by the lint issue id) that should be</div><div class="line">     * ignored by lint. It is not an error to specify an unrecognized name.</div><div class="line">     */</div><div class="line">    String[] value();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Android-Annotation-Support包中的注解介绍："><a href="#Android-Annotation-Support包中的注解介绍：" class="headerlink" title="Android Annotation Support包中的注解介绍："></a>Android Annotation Support包中的注解介绍：</h3><p>Android support library从19.1版本开始引入了一个新的注解库，它包含很多有用的元注解，你能用它们修饰你的代码，帮助你发现bug。Support library自己本身也用到了这些注解，所以作为support library的用户，Android Studio已经基于这些注解校验了你的代码并且标注其中潜在的问题</p>
<p>这些注解是作为一个support包提供给开发者使用，要使用他们，需要在build.gradle中添加对android support-annotations的依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'com.android.support:support-annotations:22.2.0'</span></div></pre></td></tr></table></figure>
<p>support包中的注解分为如下几大类：</p>
<h4 id="Nullness注解："><a href="#Nullness注解：" class="headerlink" title="Nullness注解："></a><strong>Nullness注解：</strong></h4><ul>
<li><p><strong>@Nullable:</strong>用于标记方法参数或者返回值可以为空；</p>
</li>
<li><p><strong>@NonNull:</strong>用于标记方法参数或者返回值不能为空，如果为空编译器会报警告；</p>
</li>
</ul>
<h4 id="资源类型注解："><a href="#资源类型注解：" class="headerlink" title="资源类型注解："></a><strong>资源类型注解：</strong></h4><ul>
<li>这类注解主要用于标记方法的参数必须要是指定的资源类型，如果不是，IDE就会报错；因为资源文件都是静态的，所以在编写代码时IDE就知道传值是否错误，可以避免传的资源id错误导致运行时异常。资源类型注解包括@AnimatorRes、@AnimRes、@AnyRes、@ArrayRes、@BoolRes、@ColorRes、@DimenRes、@DrawableRes、@FractionRes、@IdRes、@IntgerRes、@InterpolatorRes、@LayoutRes、@MenuRes、@PluralsRes、@RawRes、@StringRes、@StyleableRes、@StyleRes、@TransitionRes、@XmlRes</li>
</ul>
<h4 id="类型定义注解："><a href="#类型定义注解：" class="headerlink" title="类型定义注解："></a><strong>类型定义注解：</strong></h4><ul>
<li>这类注解用于检查“魔幻数”，很多时候，我们使用整型常量代替枚举类型（性能考虑），例如我们有一个IceCreamFlavourManager类，它具有三种模式的操作：VANILLA，CHOCOLATE和STRAWBERRY。我们可以定义一个名为@Flavour的新注解，并使用@IntDef指定它可以接受的值类型：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCreamFlavourManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flavour;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VANILLA = <span class="number">0</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHOCOLATE = <span class="number">1</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRAWBERRY = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="meta">@IntDef</span>(&#123;VANILLA, CHOCOLATE, STRAWBERRY&#125;)</div><div class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> Flavour &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Flavour</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFlavour</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> flavour;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlavour</span><span class="params">(@Flavour <span class="keyword">int</span> flavour)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.flavour = flavour;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这时如果我们使用错误的整型值调用IceCreamFlavourManager.setFlavour时，IDE将报错如下：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A32.jpg" alt=""></center>

<ul>
<li>IDE甚至会提示我们可以使用的有效的取值：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A31.jpg" alt=""></center>

<ul>
<li>我们也可以指定整型值作为标志位，也就是说这些整型值可以使用’｜’或者’&amp;’进行与或等操作。如果我们把@Flavour定义为如下标志位：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IntDef</span>(flag = <span class="keyword">true</span>, value = &#123;VANILLA, CHOCOLATE, STRAWBERRY&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Flavour &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>那么可以如下调用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.setFlavour(IceCreamFlavourManager.VANILLA &amp; IceCreamFlavourManager.CHOCOLATE);</div></pre></td></tr></table></figure>
<h4 id="线程注解："><a href="#线程注解：" class="headerlink" title="线程注解："></a><strong>线程注解：</strong></h4><ul>
<li>用于标记指定的方法、类（如果一个类中的所有方法都有相同的线程需求，就可以对这个类进行注解，比如View.java就被@UIThread所标记）只能在指定的线程类中被调用，包括：@UiThread、@MainThread、@WorkerThread、@BinderThread；以@UIThread为例，说明这类注解的使用方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main_layout);</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                setTextInOtherThread(R.string.app_name);</div><div class="line">             <span class="comment">// setTextInOtherThread2(R.string.app_name);</span></div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@UiThread</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setTextInOtherThread</span><span class="params">(@StringRes <span class="keyword">int</span> resId)</span></span>&#123;</div><div class="line">        TextView threadTxtView = (TextView)MainActivity.<span class="keyword">this</span>.findViewById(R.id.threadTxtViewId);</div><div class="line">        threadTxtView.setText(resId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setTextInOtherThread2</span><span class="params">(@StringRes <span class="keyword">final</span> <span class="keyword">int</span> resId)</span></span>&#123;</div><div class="line">        MainActivity.<span class="keyword">this</span>.runOnUiThread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                TextView threadTxtView = (TextView)MainActivity.<span class="keyword">this</span>.findViewById(R.id.threadTxtViewId);</div><div class="line">                threadTxtView.setText(resId);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>@UIThread和@MainThread的区别：</strong>在进程里只有一个主线程。这个就是@MainThread。同时这个线程也是一个@UiThread。比如activity的主要窗口就运行在这个线程上。然而它也有能力为应用创建其他线程。这很少见，一般具备这样功能的都是系统进程。通常是把和生命周期有关的用@MainThread标注，和View层级结构相关的用@UiThread标注。但是由于@MainThread本质上是一个@UiThread，而大部分情况下@UiThread又是一个@MainThread，所以工具(lint ,Android Studio,等等)可以把他们互换，所以你能在一个可以调用@MainThread方法的地方也能调用@UiThread方法，反之亦然</li>
</ul>
<h4 id="GRB颜色值注解："><a href="#GRB颜色值注解：" class="headerlink" title="GRB颜色值注解："></a><strong>GRB颜色值注解：</strong></h4><ul>
<li>用于标记传递的颜色值必须是整型值，并且不能是color资源ID；当你的API期望一个颜色资源的时候，可以用@ColorRes标注，但是当你有一个相反的使用场景时，这种用法就不可用了，因为你并不是期望一个颜色资源id，而是一个真实的RGB或者ARGB的颜色值。在这种情况下，你可以使用@ColorInt注解，表示你期望的是一个代表颜色的整数值：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTextColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>有了这个，当你传递一个颜色id而不是颜色值的时候，lint就会标记出这段不正确的代码：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A34.jpg" alt=""></center>

<h4 id="值约束注解："><a href="#值约束注解：" class="headerlink" title="值约束注解："></a><strong>值约束注解：</strong></h4><ul>
<li>用于标记参数必须是指定类型的值，并且值的范围必须在约束的范围内，包括@Size、@IntRange、@FloatRange。如果你的参数是一个float或者double类型，并且一定要在某个范围内，你可以使用@FloatRange注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(@FloatRange(from=<span class="number">0.0</span>, to=<span class="number">1.0</span>)</span> <span class="keyword">float</span> alpha)</span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果有人使用该API的时候传递一个0-255的值，比如尝试调用setAlpha(128)，那么工具就会捕获这一问题：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A36.jpg" alt=""></center>

<ul>
<li><p>把这些注解应用到参数上是非常有用的，因为用户很有可能会提供错误范围的参数，比如上面的setAlpha例子，有的API是采用0-255的方式，而有的是采用0-1的float值的方式</p>
</li>
<li><p>对于数据、集合以及字符串，你可以用@Size注解参数来限定集合的大小(当参数是字符串的时候，可以限定字符串的长度)。举几个例子:</p>
<ol>
<li><p>集合不能为空: @Size(min=1)；</p>
</li>
<li><p>字符串最大只能有23个字符: @Size(max=23)；</p>
</li>
<li><p>数组只能有2个元素: @Size(2)；</p>
</li>
<li><p>数组的大小必须是2的倍数 (例如图形API中获取位置的x/y坐标数组: @Size(multiple=2)</p>
</li>
</ol>
</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A37.jpg" alt=""></center>

<h4 id="权限注解："><a href="#权限注解：" class="headerlink" title="权限注解："></a><strong>权限注解：</strong></h4><ul>
<li>如果你的方法需要调用者有特定的权限，你可以使用@RequiresPermission注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequiresPermission</span>(Manifest.permission.SET_WALLPAPER)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setWallpaper</span><span class="params">(Bitmap bitmap)</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure>
<ul>
<li>如果你至少需要权限集合中的一个，你可以使用anyOf属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequiresPermission</span>(anyOf = &#123;</div><div class="line">    Manifest.permission.ACCESS_COARSE_LOCATION,</div><div class="line">    Manifest.permission.ACCESS_FINE_LOCATION&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Location <span class="title">getLastKnownLocation</span><span class="params">(String provider)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>如果你同时需要多个权限，你可以用allOf属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequiresPermission</span>(allOf = &#123;</div><div class="line">    Manifest.permission.READ_HISTORY_BOOKMARKS, </div><div class="line">    Manifest.permission.WRITE_HISTORY_BOOKMARKS&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateVisitedHistory</span><span class="params">(ContentResolver cr, String url, <span class="keyword">boolean</span> real)</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>对于intents的权限，可以直接在定义的intent常量字符串字段上标注权限需求(他们通常都已经被@SdkConstant注解标注过了):</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequiresPermission</span>(android.Manifest.permission.BLUETOOTH)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTION_REQUEST_DISCOVERABLE =</div><div class="line">            <span class="string">"android.bluetooth.adapter.action.REQUEST_DISCOVERABLE"</span>;</div></pre></td></tr></table></figure>
<ul>
<li>对于content providers的权限，你可能需要单独的标注读和写的权限访问，所以可以用@Read或者@Write标注每一个权限需求：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequiresPermission</span>.Read(<span class="meta">@RequiresPermission</span>(READ_HISTORY_BOOKMARKS))</div><div class="line"><span class="meta">@RequiresPermission</span>.Write(<span class="meta">@RequiresPermission</span>(WRITE_HISTORY_BOOKMARKS))</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri BOOKMARKS_URI = Uri.parse(<span class="string">"content://browser/bookmarks"</span>);</div></pre></td></tr></table></figure>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A38.jpg" alt=""></center>


<h4 id="复写方法注解："><a href="#复写方法注解：" class="headerlink" title="复写方法注解："></a><strong>复写方法注解：</strong></h4><ul>
<li>如果你的API允许使用者重写你的方法，但你又需要你自己的方法(父方法)在重写的时候也被调用，这时候你可以使用@CallSuper标注：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallSuper</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>用了这个后，当重写的方法没有调用父方法时，工具就会给予警告提示：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A39.jpg" alt=""></center>

<h4 id="返回值注解："><a href="#返回值注解：" class="headerlink" title="返回值注解："></a><strong>返回值注解：</strong></h4><ul>
<li><p>如果你的方法有返回值，你期望调用者用这个值做些事情，那么你可以使用@CheckResult注解标注这个方法</p>
</li>
<li><p>你并不需要为每个非空方法都进行标注。它主要的目的是帮助哪些容易被混淆，难以被理解的API的使用者</p>
</li>
<li><p>比如，可能很多开发者都对String.trim()一知半解，认为调用了这个方法，就可以让字符串改变以去掉空白字符。如果这个方法被@CheckResult标注，工具就会对那些没有使用trim()返回结果的调用者发出警告</p>
</li>
<li><p>Android中，Context#checkPermission这个方法已经被@CheckResult标注了：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CheckResult</span>(suggest=<span class="string">"#enforcePermission(String,int,int,String)"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">checkPermission</span><span class="params">(@NonNull String permission, <span class="keyword">int</span> pid, <span class="keyword">int</span> uid)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>这是非常重要的，因为有些使用context.checkPermission的开发者认为他们已经执行了一个权限 —-但其实这个方法仅仅只做了检查并且反馈一个是否成功的值而已。如果开发者使用了这个方法，但是又不用其返回值，那么这个开发者真正想调用的可能是这个Context#enforcePermission方法，而不是checkPermission</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A310.jpg" alt=""></center>

<h4 id="测试可见注解："><a href="#测试可见注解：" class="headerlink" title="测试可见注解："></a><strong>测试可见注解：</strong></h4><ul>
<li>你可以把这个注解标注到类、方法或者字段上，以便你在测试的时候可以使用他们</li>
</ul>
<hr>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>通过阅读注解类的源码可以发现，任何一个注解类都有如下特征：</p>
<ul>
<li><p>注解类会被@interface标记；</p>
</li>
<li><p>注解类的顶部会被@Documented、@Retention、@Target、@Inherited这四个注解标记（@Documented、@Inherited可选，@Retention、@Target必须要有）；</p>
</li>
</ul>
<p><strong>@UiThread源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(CLASS)</div><div class="line"><span class="meta">@Target</span>(&#123;METHOD,CONSTRUCTOR,TYPE&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UiThread &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>上文提到的四个注解：@Documented、@Retention、@Target、@Inherited就是元注解，它们的作用是负责注解其它注解，主要是描述注解的一些属性，任何注解都离不开元注解（包括元注解自身，通过元注解可以自定义注解），元注解的用户是JDK，JDK已经帮助我们实现了这四个注解的逻辑。这四个注解在JDK的java.lang.annotation包中。对每个元注解的详细说明如下：</p>
<h4 id="Target："><a href="#Target：" class="headerlink" title="@Target："></a><strong>@Target：</strong></h4><ul>
<li><p><strong>作用：</strong>用于描述注解的使用范围，即被描述的注解可以用在什么地方；</p>
</li>
<li><p><strong>取值：</strong></p>
</li>
</ul>
<ol>
<li><p>CONSTRUCTOR:构造器；</p>
</li>
<li><p>FIELD:实例；</p>
</li>
<li><p>LOCAL_VARIABLE:局部变量；</p>
</li>
<li><p>METHOD:方法；</p>
</li>
<li><p>PACKAGE:包；</p>
</li>
<li><p>PARAMETER:参数;</p>
</li>
<li><p>TYPE:类、接口(包括注解类型) 或enum声明</p>
</li>
</ol>
<ul>
<li><strong>示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/***</span></div><div class="line"> *</div><div class="line"> * 实体注解接口</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(value = &#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Entity &#123;</div><div class="line">    <span class="comment">/***</span></div><div class="line">     * 实体默认firstLevelCache属性为false</div><div class="line">     * <span class="doctag">@return</span> boolean</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">firstLevelCache</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</div><div class="line">    <span class="comment">/***</span></div><div class="line">     * 实体默认secondLevelCache属性为false</div><div class="line">     * <span class="doctag">@return</span> boolean</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">secondLevelCache</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</div><div class="line">    <span class="comment">/***</span></div><div class="line">     * 表名默认为空</div><div class="line">     * <span class="doctag">@return</span> String</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">tableName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">    <span class="comment">/***</span></div><div class="line">     * 默认以""分割注解</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">split</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Retention："><a href="#Retention：" class="headerlink" title="@Retention："></a><strong>@Retention：</strong></h4><ul>
<li><p><strong>作用：</strong>表示需要在什么级别保存该注解信息，用于描述注解的生命周期，即被描述的注解在什么范围内有效；</p>
</li>
<li><p><strong>取值：</strong></p>
</li>
</ul>
<ol>
<li><p>SOURCE:在源文件中有效，即源文件保留；</p>
</li>
<li><p>CLASS:在class文件中有效，即class保留；</p>
</li>
<li><p>RUNTIME:在运行时有效，即运行时保留；</p>
</li>
</ol>
<ul>
<li><strong>示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/***</span></div><div class="line"> * 字段注解接口</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(value = &#123;ElementType.FIELD&#125;)<span class="comment">//注解可以被添加在实例上</span></div><div class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)<span class="comment">//注解保存在JVM运行时刻,能够在运行时刻通过反射API来获取到注解的信息</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;<span class="comment">//注解的name属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Documented："><a href="#Documented：" class="headerlink" title="@Documented："></a><strong>@Documented：</strong></h4><ul>
<li><p><strong>作用：</strong>用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化</p>
</li>
<li><p><strong>取值：</strong>它属于标记注解，没有成员；</p>
</li>
<li><p><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(CLASS)</div><div class="line"><span class="meta">@Target</span>(&#123;METHOD,CONSTRUCTOR,TYPE&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UiThread &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Inherited："><a href="#Inherited：" class="headerlink" title="@Inherited："></a><strong>@Inherited：</strong></h4><ul>
<li><p><strong>作用：</strong>用于描述某个被标注的类型是可被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类</p>
</li>
<li><p><strong>取值：</strong>它属于标记注解，没有成员；</p>
</li>
<li><p><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**  </span></div><div class="line"> * <span class="doctag">@author</span> wangsheng </div><div class="line"> **/  </div><div class="line"><span class="meta">@Inherited</span>  </div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Greeting &#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> FontColor&#123; BULE,RED,GREEN&#125;;  </div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">FontColor <span class="title">fontColor</span><span class="params">()</span> <span class="keyword">default</span> FontColor.GREEN</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h3><p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。</p>
<ul>
<li><strong>自定义注解格式：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">元注解</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名&#123;</div><div class="line">    定义体；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>注解参数可支持的数据类型：</strong></li>
</ul>
<ol>
<li><p>所有基本数据类型（int,float,boolean,byte,double,char,long,short)；</p>
</li>
<li><p>String类型；</p>
</li>
<li><p>Class类型；</p>
</li>
<li><p>enum类型；</p>
</li>
<li><p>Annotation类型；</p>
</li>
<li><p>以上所有类型的数组</p>
</li>
</ol>
<hr>
<p><strong>特别说明：</strong></p>
<ul>
<li>注解类中的方法只能用public或者默认这两个访问权修饰，不写public就是默认，eg：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitColor &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Color&#123; BULE,RED,GREEN&#125;;</div><div class="line">    <span class="function">Color <span class="title">fruitColor</span><span class="params">()</span> <span class="keyword">default</span> Color.GREEN</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>如果注解类中只有一个成员，最好把方法名设置为”value”，比如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitName &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法</li>
</ul>
<hr>
<h4 id="实例演示："><a href="#实例演示：" class="headerlink" title="实例演示："></a><strong>实例演示：</strong></h4><ul>
<li><strong>ToDo.java：</strong>注解类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.METHOD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@interface</span> Todo &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;LOW, MEDIUM, HIGH&#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Status &#123;STARTED, NOT_STARTED&#125;    </div><div class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span> <span class="keyword">default</span> "Yash"</span>;</div><div class="line">    <span class="function">Priority <span class="title">priority</span><span class="params">()</span> <span class="keyword">default</span> Priority.LOW</span>;</div><div class="line">    <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">default</span> Status.NOT_STARTED</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>BusinessLogic:</strong>使用注解的类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessLogic</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessLogic</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compltedMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"This method is complete"</span>);</div><div class="line">    &#125;    </div><div class="line"></div><div class="line">    <span class="meta">@Todo</span>(priority = Todo.Priority.HIGH)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notYetStartedMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// No Code Written yet</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Todo</span>(priority = Todo.Priority.MEDIUM, author = <span class="string">"Uday"</span>, status = Todo.Status.STARTED)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incompleteMethod1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//Some business logic is written</span></div><div class="line">        <span class="comment">//But its not complete yet</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Todo</span>(priority = Todo.Priority.LOW, status = Todo.Status.STARTED )</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incompleteMethod2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//Some business logic is written</span></div><div class="line">        <span class="comment">//But its not complete yet</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>TodoReport.java：</strong>解析注解信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoReport</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TodoReport</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        getTodoReportForBusinessLogic();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 解析使用注解的类，获取通过注解设置的属性</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTodoReportForBusinessLogic</span><span class="params">()</span> </span>&#123;</div><div class="line">        Class businessLogicClass = BusinessLogic.class;</div><div class="line">        <span class="keyword">for</span>(Method method : businessLogicClass.getMethods()) &#123;</div><div class="line">            Todo todoAnnotation = (Todo)method.getAnnotation(Todo.class);</div><div class="line">            <span class="keyword">if</span>(todoAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">                System.out.println(<span class="string">" Method Name : "</span> + method.getName());</div><div class="line">                System.out.println(<span class="string">" Author : "</span> + todoAnnotation.author());</div><div class="line">                System.out.println(<span class="string">" Priority : "</span> + todoAnnotation.priority());</div><div class="line">                System.out.println(<span class="string">" Status : "</span> + todoAnnotation.status());</div><div class="line">                System.out.println(<span class="string">" --------------------------- "</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行结果如下图所示：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A311.jpg" alt=""></center>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/21410338?f3fb8ead20=ede8379d6b659f7594e37ed09c7c0b50" target="_blank" rel="external">深入浅出Java注解</a></p>
</li>
<li><p><a href="http://www.in-droid.com/2016/06/02/Java%E6%B3%A8%E8%A7%A3/" target="_blank" rel="external">Java注解</a></p>
</li>
<li><p><a href="http://josh-persistence.iteye.com/blog/2226493" target="_blank" rel="external">深入浅出Java Annotation(元注解和自定义注解）</a></p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[finalize-方法对垃圾回收的影响]]></title>
      <url>https://fudawei.github.io/2013/08/06/finalize-%E6%96%B9%E6%B3%95%E5%AF%B9%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>Java中提供了一个类似C++析构函数的机制: finalize()方法，该函数允许子类重载，用于在对象被回收是释放资源。</p>
</blockquote>
<p>但是一般情况下，尽量不要使用finalize函数进行资源的释放，原因主要有一下几点:<br><a id="more"></a></p>
<ul>
<li>finalize函数调用时，有可能导致对象复活。</li>
<li>finalize函数执行的时间没有保障，他完全由GC线程决定，正常情况下，若不发生gc，则finalize一直都没有机会被执行。</li>
<li>一个糟糕的finalize函数会严重影响gc的性能。</li>
</ul>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>下面通过一个实验来看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package com.winwill.jvm;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15-5-29 下午8:24</div><div class="line"> */</div><div class="line">public class TestFinalizer &#123;</div><div class="line">    public static class LY &#123;</div><div class="line">        private byte[] content = new byte[512];</div><div class="line"></div><div class="line">        @Override</div><div class="line">        protected void finalize() &#123;</div><div class="line">            try &#123;</div><div class="line">                System.out.println(&quot;回收线程:&quot; + Thread.currentThread().getId());</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        long tsStart = System.currentTimeMillis();</div><div class="line">        for (int i = 0; i &lt; 50000; i++) &#123;</div><div class="line">            LY ly = new LY();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;耗时:&quot; + (System.currentTimeMillis() - tsStart));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个例子创建了一个内部类TestFinalizer$LY，这个类有一个成员变量，只占用512字节，还重载了finalize函数，其中的sleep操作模拟一个比较耗时的动作。然后主函数中通过一个循环不断地创建LY对象，因为循环中创建的对象没有被其他对象引用，所以创建之后就应该被回收。</p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>我们使用如下参数运行该程序：</p>
<blockquote>
<p>-Xmx10m  -Xms10m  -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/qifuguang/dump.bin</p>
</blockquote>
<p>也就是将虚拟机的初始和最大堆内存都设置为10m，并且如果发生OOM，则将内存信息dump出来。按照前文所说，每个对象创建之后都应该立马被回收，所以10m空间创建这么多对象应该是没有问题的，只不过会多发生几次gc而已，但是运行的结果却是这样的：</p>
<blockquote>
<p>回收线程:3<br>java.lang.OutOfMemoryError: Java heap space<br>Dumping heap to /home/qifuguang/dump.bin …<br>Heap dump file created [11569716 bytes in 0.046 secs]<br>Exception in thread “main”<br>Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread “main”</p>
</blockquote>
<p>发生了内存溢出！！！</p>
<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>为什么会出现上面的结果呢？我们找到dump出来的文件，然后使用eclipse的MAT插件打开这个文件之后可以看到内存中存在大量的java.lang.ref.Finalizer对象。<br><img src="http://img.blog.csdn.net/20150529205328228" alt="这里写图片描述"></p>
<p>这会是什么原因呢？原来finalize函数是由FinalizerThread线程处理的，每一个即将回收的并且包含finalize函数的对象都会在正式回收前加入FinalizerThread的执行队列，该队列为java.lang.ref.ReferenceQueue引用队列，内部实现为链表结构，队列中的每一项为java.lang.ref.Finalizer引用对象，它本质为一个引用，在该例中这些引用就指向了LF对象。由于LF对象被加入了引用队列，并且被“强引用”，所以就阻止了对象的正常回收，并且引用队列中的对象排队执行finalize函数，处理得比较慢，回收速度比不上创建对象的速度，所以就出现了OOM(Out Of Memory)错误。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>但是话又说回来了，虽然finalize函数不推荐使用，但是在某些场合，使用finalize函数可以起到双保险为作用，比如在Mysql的JDBC驱动中，com.mysql.jdbc.ConnectionImpl就实现了finalize函数，在函数中执行了连接的关闭操作，这样如果开发人员开发过程中忘记关闭不需要的连接，在对象回收时也会被强制关闭，确保数据库没有连接泄露。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Java]四种引用类型]]></title>
      <url>https://fudawei.github.io/2013/08/01/%5BJava%5D%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>一般程序中通过new创建的对象的引用都是强引用，强引用只有在从根节点不可达的情况下才会被垃圾回收器回收，所以可能产生内存溢出。<br><a id="more"></a></p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>使用SoftReference创建，弱于强引用，在内存紧张的时候会被回收，不会产生内存溢出。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>使用WeakReference创建，弱于软引用，在系统gc时只要发现弱引用直接回收，不会产生内存溢出。</p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>使用PhantomReference创建，最弱的引用类型，随时都可以被垃圾回收器回收，配合引用队列使用可以跟踪对象的回收，因此可以将一些资源的释放放在虚引用中执行和记录。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">package com.winwill.reference;</div><div class="line"></div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">import java.lang.ref.PhantomReference;</div><div class="line">import java.lang.ref.ReferenceQueue;</div><div class="line">import java.lang.ref.SoftReference;</div><div class="line">import java.lang.ref.WeakReference;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15-5-27 下午4:45</div><div class="line"> */</div><div class="line">public class TestReference &#123;</div><div class="line">    public static class User &#123;</div><div class="line">        private String name;</div><div class="line">        private int id;</div><div class="line"></div><div class="line">        public User(String name, int id) &#123;</div><div class="line">            this.name = name;</div><div class="line">            this.id = id;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public String toString() &#123;</div><div class="line">            return id + &quot;:&quot; + name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testReference() throws Exception &#123;</div><div class="line">        /** 创建强引用对象*/</div><div class="line">        User u = new User(&quot;winwill&quot;, 1);</div><div class="line"></div><div class="line">        /**使用强引用对象创建软引用对象*/</div><div class="line">        SoftReference&lt;User&gt; userSoftReference = new SoftReference&lt;User&gt;(u);</div><div class="line">        /**使用强引用对象创建弱引用对象*/</div><div class="line">        WeakReference&lt;User&gt; userWeakReference = new WeakReference&lt;User&gt;(u);</div><div class="line"></div><div class="line">        /**使用强引用对象创建虚引用对象*/</div><div class="line">        ReferenceQueue&lt;User&gt; referenceQueue = new ReferenceQueue&lt;User&gt;();</div><div class="line">        PhantomReference&lt;User&gt; userPhantomReference = new PhantomReference&lt;User&gt;(u, referenceQueue);</div><div class="line">        /**删除强引用*/</div><div class="line">        u = null;</div><div class="line"></div><div class="line">        /**通过软引用获取*/</div><div class="line">        System.out.println(userSoftReference.get());</div><div class="line">        /**通过虚引用获取*/</div><div class="line">        System.out.println(userWeakReference.get());</div><div class="line">        /**通过虚引用获取*/</div><div class="line">        System.out.println(userPhantomReference.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码输出结果如下：<br><img src="http://img.blog.csdn.net/20150527172210655" alt="这里写图片描述"></p>
<p>可以看到，<strong>无法使用虚引用获取它引用的对象</strong>，再者，虚引用配合引用队列可以跟踪对象的回收时间，因此，可以将一些资源的释放操作放置在虚引用中执行和记录.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用虚拟机参数]]></title>
      <url>https://fudawei.github.io/2013/08/01/%E5%B8%B8%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0/</url>
      <content type="html"><![CDATA[<ul>
<li>-XX:+PrintGC   启动java虚拟机后，只要遇到gc，就打印日志。</li>
<li>-XX:+PrintGCDetails  gc发生时，打印更详细的日志。</li>
<li>-XX:+PrintHeapAtGC  gc发生时，打印更详细的堆信息。<a id="more"></a></li>
<li>-XX:+PrintGCTimeStamps gc发生时，额外打印gc时间，该时间为虚拟机启动到现在的时间偏移量。</li>
<li>-XX:+PrintGCApplicationConcurrentTime gc时打印应用程序执行的时间。</li>
<li>-XX:+PrintGCApplicationStoppedTime gc时打印应用程序由于gc产生停顿的时间。</li>
<li>-XX:+PrintReferenceGC  跟踪系统内的软引用，若引用，虚引用和Finallize队列。</li>
<li>-Xloggc 指定gc日志的保存路径。</li>
<li>-XX:+TraceClassLoading  跟踪类加载。</li>
<li>-XX:+TraceClassUnloading 跟踪类卸载。</li>
<li>-XX:+PrintVMOptions 程序运行时，打印虚拟机接收到的命令行显示参数。</li>
<li>-XX:+PrintCommandLineFlags 打印传递给虚拟机的显式和隐式参数。</li>
<li>-XX:+PrintFlagsFinal 打印所有系统参数的值。</li>
<li>-Xms 指定初始堆空间的大小，例如-Xms20m</li>
<li>-Xmx 指定最大堆空间的大小，例如-Xmx100m</li>
<li>-Xmn 指定新生代的大小，例如-Xmn1m</li>
<li>-XX:MaxHeapSize 指定最大内存。</li>
<li>-XX:SurvivorRatio 指定新生代中eden区和from/to区的比例关系。</li>
<li>-XX:NewRatio 设置新生代和老生带的比例，注意：这个值的含义是 老生带/新生代。</li>
<li>-XX:+HeapDumpOnOutOfMemoryError 内存溢出时，导出整个堆的信息，和下一个参数配合使用。</li>
<li>-XX:HeapDumpPath 导出的堆信息的保存路径，和上一个参数配合使用。</li>
<li>-XX:OnOutOfMemoryError 内存溢出发生错误时执行一个脚本文件。</li>
<li>-XX:PermSize 配置初始永久区的大小(JDK8中永久区已经被彻底移除，使用了新的元数据区存放类的元数据)。</li>
<li>-XX:MaxPermSize 配置最大永久区的大小(JDK8中永久区已经被彻底移除，使用了新的元数据区存放类的元数据)。</li>
<li>-XX:MaxMetaspaceSize 指定永久区最大可用值。</li>
<li>-Xss 指定线程的栈大小。</li>
<li>-XX:MaxDirectMemorySize 指定最大可用直接内存值。</li>
<li>-server 指定虚拟机在server模式下工作。</li>
<li>-client 指定虚拟机在client模式下工作。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ToStringBuilder介绍]]></title>
      <url>https://fudawei.github.io/2013/06/01/ToStringBuilder%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h3 id="ToStringBuilder简单介绍"><a href="#ToStringBuilder简单介绍" class="headerlink" title="ToStringBuilder简单介绍"></a>ToStringBuilder简单介绍</h3><p>ToStringBuilder是用于构建一个类的toString字符串的工具类，提供了多种不同的格式，同时还能自定义打印哪些变量。</p>
<h3 id="ToStringBuilder主要方法"><a href="#ToStringBuilder主要方法" class="headerlink" title="ToStringBuilder主要方法"></a>ToStringBuilder主要方法</h3><ul>
<li>append()方法： 该方法用于自定义添加需要打印哪些变量，只有使用append添加的变量才会在toString函数中打印。</li>
<li>reflectionToString()方法： 该方法使用反射机制打印一个类中的所有变量，该函数还提供一个变量style，用于指定使用什么样的格式打印变量，几种不的style将在下面介绍。<a id="more"></a>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3>下面的代码使用了ToStringBuilder的append方法将index变量添加进去</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.xiaomi.test;</div><div class="line"></div><div class="line">import org.apache.commons.lang.builder.ToStringBuilder;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/5/10 22:39</div><div class="line"> */</div><div class="line">public class Subject &#123;</div><div class="line">    private int index;</div><div class="line">    private String name;</div><div class="line"></div><div class="line">    public Subject(int index, String name) &#123;</div><div class="line">        this.index = index;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return new ToStringBuilder(this).append(&quot;index&quot;, index).toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(new Subject(1, &quot;subject1&quot;).toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="http://img.blog.csdn.net/20150510230514295" alt="这里写图片描述"><br>可以看到toString仅仅打印了index，但是并没有打印name，所以只有append添加的变量才会被打印。</p>
<p>下面的代码使用了ToStringBuilder的静态方法reflectionToString打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.xiaomi.test;</div><div class="line"></div><div class="line">import org.apache.commons.lang.builder.ToStringBuilder;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author qifuguang</div><div class="line"> * @date 15/5/10 22:39</div><div class="line"> */</div><div class="line">public class Subject &#123;</div><div class="line">    private int index;</div><div class="line">    private String name;</div><div class="line"></div><div class="line">    public Subject(int index, String name) &#123;</div><div class="line">        this.index = index;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return ToStringBuilder.reflectionToString(this, ToStringStyle.DEFAULT_STYLE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(new Subject(1, &quot;subject1&quot;).toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="http://img.blog.csdn.net/20150510230428412" alt="这里写图片描述"><br>由此可见reflectionToString这个函数默认打印所有变量，上面的示例使用的是默认的style，也就是ToStringStyle.DEFAULT_STYLE；<br>如果将style换成ToStringStyle.NO_FIELD_NAMES_STYLE，则打印结果如下：<br><img src="http://img.blog.csdn.net/20150510230651452" alt="这里写图片描述"><br>可以看到并没有打印变量的名字，仅仅打印了变量的值；<br>如果换成ToStringStyle.MULTI_LINE_STYLE，则打印结果如下：<br><img src="http://img.blog.csdn.net/20150510230607254" alt="这里写图片描述"><br>可以看到每个变量打印一行；<br>如果换成ToStringStyle.SHORT_PREFIX_STYLE，则打印结果如下：<br><img src="http://img.blog.csdn.net/20150510230839248" alt="这里写图片描述"><br>可以看到类前面没有了包名；<br>如果换成ToStringStyle.SIMPLE_STYLE，则打印结果如下：<br><img src="http://img.blog.csdn.net/20150510230738499" alt="这里写图片描述"><br>可以看到，这次直接没有了类名，直接只一次打印了变量的值。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在自定义类的时候往往需要重写toString方法，ToStringBuilder工具类提供了很好支持，如果能够使用该类重写toString，那想必是极好的了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java习惯用法]]></title>
      <url>https://fudawei.github.io/2013/02/08/Java%E4%B9%A0%E6%83%AF%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="java习惯用法"><a href="#java习惯用法" class="headerlink" title="java习惯用法"></a>java习惯用法</h2><h3 id="实现equals"><a href="#实现equals" class="headerlink" title="实现equals()"></a>实现equals()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">  String name;</div><div class="line">  int birthYear;</div><div class="line">  byte[] raw;</div><div class="line">  public boolean equals(Object obj) &#123;</div><div class="line"></div><div class="line">    if (!obj instanceof Person)</div><div class="line">      return false;</div><div class="line">    Person other = (Person)obj;</div><div class="line">    return name.equals(other.name)</div><div class="line">        &amp;&amp; birthYear == other.birthYear</div><div class="line">        &amp;&amp; Arrays.equals(raw, other.raw);</div><div class="line">  &#125;</div><div class="line">  public int hashCode() &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数必须是Object类型，不能是外围类。</p>
<p>foo.equals(null) 必须返回false，不能抛NullPointerException。（注意，null instanceof 任意类 总是返回false，<br>因此上面的代码可以运行。）</p>
<p>基本类型域（比如，int）的比较使用 == ，基本类型数组域的比较使用Arrays.equals()。</p>
<p>覆盖equals()时，记得要相应地覆盖 hashCode()，与 equals() 保持一致。</p>
<h3 id="实现hashCode"><a href="#实现hashCode" class="headerlink" title="实现hashCode()"></a>实现hashCode()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">  String a;</div><div class="line">  Object b;</div><div class="line">  byte c;</div><div class="line">  int[] d;</div><div class="line"></div><div class="line">  public int hashCode() &#123;</div><div class="line">    return a.hashCode() + b.hashCode() + c + Arrays.hashCode(d);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public boolean equals(Object o) &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当x和y两个对象具有x.equals(y) == true ，你必须要确保x.hashCode() == y.hashCode()。<br>根据逆反命题，如果x.hashCode() != y.hashCode()，那么x.equals(y) == false 必定成立。<br>你不需要保证，当x.equals(y) == false时，x.hashCode() != y.hashCode()。但是，如果你可以尽可能地使它成立的话，这会提高哈希表的性能。</p>
<h3 id="实现compareTo"><a href="#实现compareTo" class="headerlink" title="实现compareTo()"></a>实现compareTo()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Person implements Comparable&lt;Person&gt; &#123;</div><div class="line">  String firstName;</div><div class="line">  String lastName;</div><div class="line">  int birthdate;</div><div class="line"></div><div class="line">  // Compare by firstName, break ties by lastName, finally break ties by birthdate</div><div class="line">  public int compareTo(Person other) &#123;</div><div class="line">    if (firstName.compareTo(other.firstName) != 0)</div><div class="line">      return firstName.compareTo(other.firstName);</div><div class="line">    else if (lastName.compareTo(other.lastName) != 0)</div><div class="line">      return lastName.compareTo(other.lastName);</div><div class="line">    else if (birthdate &lt; other.birthdate)</div><div class="line">      return -1;</div><div class="line">    else if (birthdate &gt; other.birthdate)</div><div class="line">      return 1;</div><div class="line">    else</div><div class="line">      return 0;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实现clone"><a href="#实现clone" class="headerlink" title="实现clone()"></a>实现clone()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Values implements Cloneable &#123;</div><div class="line">  String abc;</div><div class="line">  double foo;</div><div class="line">  int[] bars;</div><div class="line">  Date hired;</div><div class="line"></div><div class="line">  public Values clone() &#123;</div><div class="line">    try &#123;</div><div class="line">      Values result = (Values)super.clone();</div><div class="line">      result.bars = result.bars.clone();</div><div class="line">      result.hired = result.hired.clone();</div><div class="line">      return result;</div><div class="line">    &#125; catch (CloneNotSupportedException e) &#123;  // Impossible</div><div class="line">      throw new AssertionError(e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 super.clone() 让Object类负责创建新的对象。<br>基本类型域都已经被正确地复制了。同样，我们不需要去克隆String和BigInteger等不可变类型。<br>手动对所有的非基本类型域（对象和数组）进行深度复制（deep copy）。<br>实现了Cloneable的类，clone()方法永远不要抛CloneNotSupportedException。因此，<br>需要捕获这个异常并忽略它，或者使用不受检异常（unchecked exception）包装它。</p>
<h3 id="使用StringBuilder或StringBuffer"><a href="#使用StringBuilder或StringBuffer" class="headerlink" title="使用StringBuilder或StringBuffer"></a>使用StringBuilder或StringBuffer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) -&gt; &quot;a and b and c&quot;</div><div class="line">String join(List&lt;String&gt; strs) &#123;</div><div class="line">  StringBuilder sb = new StringBuilder();</div><div class="line">  boolean first = true;</div><div class="line">  for (String s : strs) &#123;</div><div class="line">    if (first) </div><div class="line">    	first = false;</div><div class="line">    else </div><div class="line">    	sb.append(&quot; and &quot;);</div><div class="line">    sb.append(s);</div><div class="line">  &#125;</div><div class="line">  return sb.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不要像这样使用重复的字符串连接：s += item ，因为它的时间效率是O(n^2)。<br>使用StringBuilder或者StringBuffer时，可以使用append()方法添加文本和使用toString()方法去获取连接起来的整个文本。<br>优先使用StringBuilder，因为它更快。StringBuffer的所有方法都是同步的，而你通常不需要同步的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Random rand = new Random();</div><div class="line">System.out.println(rand.nextInt(6)+1);</div></pre></td></tr></table></figure>
<h3 id="使用Iterator-remove"><a href="#使用Iterator-remove" class="headerlink" title="使用Iterator.remove()"></a>使用Iterator.remove()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void filter(List&lt;String&gt; list) &#123;</div><div class="line">  for (Iterator&lt;String&gt; iter = list.iterator(); iter.hasNext(); ) &#123;</div><div class="line">    String item = iter.next();</div><div class="line">    if (...)</div><div class="line">      iter.remove();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串反转-逆序"><a href="#字符串反转-逆序" class="headerlink" title="字符串反转(逆序)"></a>字符串反转(逆序)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static String reverse(String s)&#123;</div><div class="line">		return new StringBuilder(s).reverse().toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>1)继承Thread类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class MyThread extends Thread&#123;</div><div class="line">	public void run()&#123;   ...   &#125;</div><div class="line">&#125;</div><div class="line">new MyThread.start();</div><div class="line">2) 实现Runnable接口</div><div class="line">class MyRunnable implements Runnable&#123;</div><div class="line">	public void run()&#123;   ...   &#125;</div><div class="line">&#125;</div><div class="line">new Thread(new MyRunnable()).start()</div></pre></td></tr></table></figure>
<p>不要直接调用run()方法。总是调用Thread.start()方法，这个方法会创建一条新的线程并使新建的线程调用run()。</p>
<p>如果try之前的语句运行失败并且抛出异常，那么finally语句块就不会执行<br>如果try语句块里面的语句抛出异常，那么程序的运行就会跳到finally语句块里执行尽可能多的语句，然后跳出这个方法（</p>
<h3 id="从输入流里读取字节数据"><a href="#从输入流里读取字节数据" class="headerlink" title="从输入流里读取字节数据"></a>从输入流里读取字节数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">InputStream in = (...);</div><div class="line">try &#123;</div><div class="line">  while (true) &#123;</div><div class="line">    int b = in.read();</div><div class="line">    if (b == -1)</div><div class="line">      break;</div><div class="line">    (... process b ...)</div><div class="line">  &#125;</div><div class="line">&#125; finally &#123;</div><div class="line">  in.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>read()方法要么返回下一次从流里读取的字节数（0到255，包括0和255），要么在达到流的末端时返回-1。</p>
<h3 id="从输入流里读取块数据"><a href="#从输入流里读取块数据" class="headerlink" title="从输入流里读取块数据"></a>从输入流里读取块数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">InputStream in = (...);</div><div class="line">try &#123;</div><div class="line">  byte[] buf = new byte[100];</div><div class="line">  while (true) &#123;</div><div class="line">    int n = in.read(buf);</div><div class="line">    if (n == -1)</div><div class="line">      break;</div><div class="line">    (... process buf with offset=0 and length=n ...)</div><div class="line">  &#125;</div><div class="line">&#125; finally &#123;</div><div class="line">  in.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要记住的是，read()方法不一定会填满整个buf，所以你必须在处理逻辑中考虑返回的长度。</p>
<h3 id="从文件里读取文本"><a href="#从文件里读取文本" class="headerlink" title="从文件里读取文本"></a>从文件里读取文本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BufferedReader in = new BufferedReader(</div><div class="line">    new InputStreamReader(new FileInputStream(...), &quot;UTF-8&quot;));</div><div class="line">try &#123;</div><div class="line">  while (true) &#123;</div><div class="line">    String line = in.readLine();</div><div class="line">    if (line == null)</div><div class="line">      break;</div><div class="line">    (... process line ...)</div><div class="line">  &#125;</div><div class="line">&#125; finally &#123;</div><div class="line">  in.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BufferedReader对象的创建显得很冗长。这是因为Java把字节和字符当成两个不同的概念来看待（这与C语言不同）。<br>你可以使用任何类型的InputStream来代替FileInputStream，比如socket。<br>当达到流的末端时，BufferedReader.readLine()会返回null。<br>要一次读取一个字符，使用Reader.read()方法。<br>你可以使用其他的字符编码而不使用UTF-8，但最好不要这样做。</p>
<h3 id="向文件里写文本"><a href="#向文件里写文本" class="headerlink" title="向文件里写文本"></a>向文件里写文本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PrintWriter out = new PrintWriter(</div><div class="line">    new OutputStreamWriter(new FileOutputStream(...), &quot;UTF-8&quot;));</div><div class="line">try &#123;</div><div class="line">  out.print(&quot;Hello &quot;);</div><div class="line">  out.print(42);</div><div class="line">  out.println(&quot; world!&quot;);</div><div class="line">&#125; finally &#123;</div><div class="line">  out.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Printwriter对象的创建显得很冗长。这是因为Java把字节和字符当成两个不同的概念来看待（这与C语言不同）。<br>就像System.out，你可以使用print()和println()打印多种类型的值。<br>你可以使用其他的字符编码而不使用UTF-8，但最好不要这样做。</p>
<h3 id="预防性检测（Defensive-checking）数值"><a href="#预防性检测（Defensive-checking）数值" class="headerlink" title="预防性检测（Defensive checking）数值"></a>预防性检测（Defensive checking）数值</h3><p>预防性检测对象<br>预防性检测数组索引<br>预防性检测数组区间</p>
<h3 id="填充数组元素"><a href="#填充数组元素" class="headerlink" title="填充数组元素"></a>填充数组元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">byte[] a =new byte[10];</div><div class="line">		Arrays.fill(a,(byte)123);</div><div class="line">		for (byte b : a) &#123;</div><div class="line">			System.out.println(b);</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h3 id="把4个字节包装（packing）成一个int"><a href="#把4个字节包装（packing）成一个int" class="headerlink" title="把4个字节包装（packing）成一个int"></a>把4个字节包装（packing）成一个int</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int packBigEndian(byte[] b) &#123;</div><div class="line">  return (b[0] &amp; 0xFF) &lt;&lt; 24</div><div class="line">       | (b[1] &amp; 0xFF) &lt;&lt; 16</div><div class="line">       | (b[2] &amp; 0xFF) &lt;&lt;  8</div><div class="line">       | (b[3] &amp; 0xFF) &lt;&lt;  0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int packLittleEndian(byte[] b) &#123;</div><div class="line">  return (b[0] &amp; 0xFF) &lt;&lt;  0</div><div class="line">       | (b[1] &amp; 0xFF) &lt;&lt;  8</div><div class="line">       | (b[2] &amp; 0xFF) &lt;&lt; 16</div><div class="line">       | (b[3] &amp; 0xFF) &lt;&lt; 24;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="把int分解（Unpacking）成4个字节"><a href="#把int分解（Unpacking）成4个字节" class="headerlink" title="把int分解（Unpacking）成4个字节"></a>把int分解（Unpacking）成4个字节</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">byte[] unpackBigEndian(int x) &#123;</div><div class="line">  return new byte[] &#123;</div><div class="line">    (byte)(x &gt;&gt;&gt; 24),</div><div class="line">    (byte)(x &gt;&gt;&gt; 16),</div><div class="line">    (byte)(x &gt;&gt;&gt;  8),</div><div class="line">    (byte)(x &gt;&gt;&gt;  0)</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">byte[] unpackLittleEndian(int x) &#123;</div><div class="line">  return new byte[] &#123;</div><div class="line">    (byte)(x &gt;&gt;&gt;  0),</div><div class="line">    (byte)(x &gt;&gt;&gt;  8),</div><div class="line">    (byte)(x &gt;&gt;&gt; 16),</div><div class="line">    (byte)(x &gt;&gt;&gt; 24)</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总是使用无符号右移操作符（&gt;&gt;&gt;）对位进行包装（packing），不要使用算术右移操作符（&gt;&gt;）。</p>
<p>eg<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class RightDef&#123;</div><div class="line">  int num1 = num2+2;</div><div class="line">  static int num2 = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>static 修饰的变量属于类，类变量会随着类初始化得到初始化，因此num2的初始化时机总是处于num1的初始化时机之前</p>
<p>使用 static 修饰的变量是类变量，没有使用 static 修饰的是实例变量<br>在同一个JVM中，每个类只对应一个Class对象，但每个类可以创建多个Java对象<br>同一个JVM内的类变量只需一块内存空间，但是该类每创建一次实例，就需要为实例变量分配内存空间<br>每个类初始化完成之后，系统都会为该类创建一个对应的Class实例，程序可以通过反射来获取某个类对应的Class实例。<br>eg: 要获取person类的Class实例。通过 Person.class 或者 Class.forName(“Person”);</p>
<p>通过实例来访问某个类变量的时候，底层依然会转换为通过类访问类变量。</p>
<h3 id="实例变量的初始化时机："><a href="#实例变量的初始化时机：" class="headerlink" title="实例变量的初始化时机："></a>实例变量的初始化时机：</h3><p>1）定义实例变量时指定初始值<br>2）非静态初始化块中对实例变量指定初始值<br>3）构造器中对实例变量指定初始值<br>1和2先于3执行，1,2的顺序与他们在源程序中的排列顺序相同<br>eg:</p>
<p>public Cat(String name,int age){ … }<br>{weight=2.0}<br>double weight = 2.3</p>
<p>每次执行之后weight都是 2.3，因为非静态代码块在前面，先执行</p>
<h3 id="类变量的初始化时机："><a href="#类变量的初始化时机：" class="headerlink" title="类变量的初始化时机："></a>类变量的初始化时机：</h3><p>1）定义类变量时指定初始值<br>2）静态初始化块中对类变量指定初始值<br>这两种方式的执行顺序与他们在源程序中的排列顺序相同</p>
<p>final 可修饰变量，被final修饰的变量被赋值后不能重新赋值<br>final 可修饰方法，被final修饰的方法不能被重写<br>final 可修饰类  ，被final修饰的类不能派生子类</p>
<h3 id="Java-Eclipse无法查看源代码"><a href="#Java-Eclipse无法查看源代码" class="headerlink" title="Java Eclipse无法查看源代码"></a>Java Eclipse无法查看源代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.点 “window“-&gt; “Preferences”-&gt; “Java” -&gt; “Installed JRES”</div><div class="line">2.此时&quot;Installed JRES&quot;右边是列表窗格，列出了系统中的JRE 环境，选择你的JRE，然后点边上的“Edit...“</div><div class="line">3.选中rt.jar文件的这一项：“C:\Java\jdk1.5.0_04\jre\lib\rt.jar” 点 左边的“+”号展开它（JDK实际安装路径以你的为准）</div><div class="line">4.展开后，可以看到“Source Attachment:(none)”，点这一项，点右边的按钮“Source Attachment...“，选择你的JDK目录下的 “src.zip”文件</div><div class="line">5.一路点“ok”结束。</div></pre></td></tr></table></figure>
<p>sublime text3<br>多处选择相同的词：Ctrl+D，回退选择Ctrl+U默认设置<br>逐词移动：Ctrl+左右键默认设置<br>显示类和方法提纲：Ctrl+R默认设置，可以很容易知道一个类中都有哪些方法。<br>显示n个窗口：alt+shift+1，或者2,3…显示n个窗口<br>格式化代码：alt+shift+f自己设置的，选择代码后按此快捷键可以格式化代码。修改 reindent<br>折叠代码：ctrl+shift+[自己设置的，可以折叠方法里面的代码  修改fold_by_level</p>
<p>（1）：“在Java里面参数传递都是按值传递”这句话的意思是：按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递。<br>（2）：在Java里面只有基本类型和按照下面这种定义方式的String是按值传递，其它的都是按引用传递。就是直接使用双引号定义字符串方式：String str = “Java私塾”;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[wait,notify,notifyAll详细介绍]]></title>
      <url>https://fudawei.github.io/2012/10/23/wait-notify-notifyAll%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>wait，notify和notifyAll方法是Object类的成员函数，所以Java的任何一个对象都能够调用这三个方法。这三个方法主要是用于线程间通信，协调多个线程的运行。</p>
<a id="more"></a>
<h1 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h1><p>调用线程的sleep，yield方法时，线程并不会让出对象锁，wait却不同。</p>
<p><strong>wait函数必须在同步代码块中调用(也就是当前线程必须持有对象的锁)</strong>，他的功能是这样的：</p>
<blockquote>
<p>我累了，休息一会儿，对象的锁你们拿去用吧，CPU也给你们。</p>
</blockquote>
<p>调用了wait函数的线程会一直等待，直到有其他线程调用了同一个对象的notify或者notifyAll方法才能被唤醒，需要注意的是：被唤醒并不代表立即获得对象的锁。也就是说，一个线程调用了对象的wait方法后，他需要等待两件事情的发生：</p>
<ol>
<li>有其他线程调用同一个对象的notify或者notifyAll方法（调用notify/notifyAll方法之前）</li>
<li>被唤醒之后重新获得对象的锁(调用notify/notifyAll方法之后)</li>
</ol>
<p>才能继续往下执行后续动作。</p>
<p>如果一个线程调用了某个对象的wait方法，但是后续并没有其他线程调用该对象的notify或者notifyAll方法，则该线程将会永远等下去…</p>
<h1 id="notify和notifyAll方法"><a href="#notify和notifyAll方法" class="headerlink" title="notify和notifyAll方法"></a>notify和notifyAll方法</h1><p><strong>notofy/notifyAll方法也必须在同步代码块中调用(也就是调用线程必须持有对象的锁)</strong>，他们的功能是这样的：</p>
<blockquote>
<p>女士们，先生们请注意，锁的对象我即将用完，请大家醒醒，准备一下，马上你们就能使用锁了。</p>
</blockquote>
<p>不同的是，notify方法只会唤醒一个正在等待的线程(至于唤醒谁，不确定！)，而notifyAll方法会唤醒所有正在等待的线程。还有一点需要特别强调：<strong>调用notify和notifyAll方法后，当前线程并不会立即放弃锁的持有权，而必须要等待当前同步代码块执行完才会让出锁。</strong></p>
<p>如果一个对象之前没有调用wait方法，那么调用notify方法是没有任何影响的。</p>
<h1 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h1><p>下面我们举例子来巩固上面讲到的理论知识,下面的代码创建了两个线程，Thread1在同步代码块中调用wait，Thread2在同步代码块中调用notify：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">package com.winwill.test;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author 飞鸟</div><div class="line"> * @date 15/8/14 16:37</div><div class="line"> */</div><div class="line">public class Test &#123;</div><div class="line">    private static final Object lock = new Object();</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new Thread(new Thread1()).start();</div><div class="line">        new Thread(new Thread2()).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class Thread1 implements Runnable &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            System.out.println(&quot;Thread1 start...&quot;);</div><div class="line">            synchronized (lock) &#123;</div><div class="line">                try &#123;</div><div class="line">                    lock.wait();</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;Thread1 stop...&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class Thread2 implements Runnable &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            System.out.println(&quot;Thread2 start...&quot;);</div><div class="line">            synchronized (lock) &#123;</div><div class="line">                lock.notify();</div><div class="line">                System.out.println(&quot;Thread2 stop...&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<blockquote>
<p>Thread1 start…<br>Thread2 start…<br>Thread2 stop…<br>Thread1 stop…  </p>
</blockquote>
<p>从上面的例子可以证实上面说到的一个结论：<strong>线程调用notify方法后并不会让出锁，而必须等待同步代码块执行完毕之后再让出</strong>，可以看到执行结果中Thread2的开始和结束是成对挨着出现的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这三个函数的相互通信可以做很多事情，比如常见的生产者-消费者模式，生产者要往队列里面生产东西，就必须等待队列有空间，同样的，消费者要同队列里面消费东西，就必须等待队列里有东西。使用wait,notify,notifyAll方法可以协调生产者和消费者之间的行为。在JDK1.4之后出现了一个Condition类，这个类也能够实现相同的功能，并且一般建议使用Condition替代wait,notify,notifyAll家族，实现更安全的线程间通信功能，比如ArrayBlockingQueue就是使用Condition实现阻塞队列的。</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文为作者原创，转载请注明出处，本文链接：<a href="http://fudawei.github.io/2015/10/23/wait-notify-notifyAll%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/">http://fudawei.github.io/2015/10/23/wait-notify-notifyAll%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sql笔记]]></title>
      <url>https://fudawei.github.io/2012/09/05/sql%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="sql学习"><a href="#sql学习" class="headerlink" title="sql学习"></a>sql学习</h2><h3 id="sql学习-1"><a href="#sql学习-1" class="headerlink" title="sql学习"></a>sql学习</h3><h4 id="查询每个月倒数第2天入职的员工的信息"><a href="#查询每个月倒数第2天入职的员工的信息" class="headerlink" title="查询每个月倒数第2天入职的员工的信息"></a>查询每个月倒数第2天入职的员工的信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT last_name,hire_date </div><div class="line">FROM employees </div><div class="line">WHERE hire_date = LAST_DAY(hire_date) -1</div></pre></td></tr></table></figure>
<h4 id="查询隔行数据"><a href="#查询隔行数据" class="headerlink" title="查询隔行数据"></a>查询隔行数据</h4><figure class="highlight plain"><figcaption><span>row_number() over(order by sno) n wher n % 2 =1```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 将空值转换为有效值 </div><div class="line"></div><div class="line">```select sno,bookname,author,isnull(book,&apos;无&apos;) as book from tb_space</div></pre></td></tr></table></figure>
<h4 id="第N行数据"><a href="#第N行数据" class="headerlink" title="第N行数据"></a>第N行数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from (select top n from tb_space )aa</div><div class="line">where not exist (select * from (select top n-1 from tb_space)bb </div><div class="line">where aa.sno = bb.sno )</div></pre></td></tr></table></figure>
<h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><p>right(xh,len(xh)-1) 从右边开始取指定个数的字符<br>left(xh,len(xh)-1) 从左边开始去指定个数的字符<br>substring(expresion,start,length) 子串<br>select * from tb_space order by 2,3 按照第2列，第3列排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">case...when</div><div class="line">select(</div><div class="line">case job</div><div class="line">when &apos;会计&apos; then salary*1.5;</div><div class="line">when &apos;秘书&apos; then salary*2.0;</div><div class="line">end as new_salary</div><div class="line">) order by new_salary</div></pre></td></tr></table></figure></p>
<h4 id="对重复的内容不作统计"><a href="#对重复的内容不作统计" class="headerlink" title="对重复的内容不作统计"></a>对重复的内容不作统计</h4><p>select count(distinct duty) as duty<br>不包括最大最小值计算平均值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">select avg(salary)</div><div class="line">from tb_space where salary not in (</div><div class="line">	(select min(salary) as minSalary from tb_treatment)</div><div class="line">	union </div><div class="line">	(selct max(salary) as maxSalary from tb_treatment)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h3 id="语法特点："><a href="#语法特点：" class="headerlink" title="语法特点："></a>语法特点：</h3><p>1.没有“ ”，字符串使用‘ ’包含<br>2.没有逻辑相等，赋值和逻辑相等都是=<br>3.类型不再是最严格的。任何数据都可以包含在‘ ’以内<br>4.没有bool值的概念，但是在视图中可以输入true/false<br>5.它也有关系运算符：&gt; &lt; &gt;= &lt;= = &lt;&gt; != ,它返回一个bool值<br>6.它也有逻辑运算符： ！(not) &amp;&amp;(and) ||(or)<br>7.它不区别大小写<br>数据库完整性（Database Integrity）是指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。</p>
<h3 id="事务的四个特点ACID"><a href="#事务的四个特点ACID" class="headerlink" title="事务的四个特点ACID:"></a>事务的四个特点ACID:</h3><p>A:原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。它是一个整体，不能再拆分<br>C：一致性：事务在完成时，必须使所有的数据都保持一致状态。。某种程度的一致<br>I:隔离性：事务中隔离，每一个事务是单独的请求将单独的处理，与其它事务没有关系，互不影响<br>D：持久性：如果事务一旦提交，就对数据的修改永久保留</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>存储过程为标准SQL增加了如下功能：<br>条件执行、循环控制结构、命名变量、命名过程、语句块（调用存储过程让DBMS执行一系列SQL语句）</p>
<h3 id="存储过程的优点"><a href="#存储过程的优点" class="headerlink" title="存储过程的优点"></a>存储过程的优点</h3><p>1）封装  只需要了解过程调用的输入输出就可以安全的使用数据库，防止用户跳过完整性检查<br>2）改善性能  调用存储过程时，DBMS可快速的执行存储过程中的语句，可直接转到语句的执行，无需分析，确认，优化和生成执行计划，这些步骤实现已经完成<br>3）减少网络流量<br>4）减少工作量 编译存储过程之后，许多用户和应用程序都可执行相同的语句序列，而不必重新输入和重新向DBMS提交，当执行需要许多SQL语句或是复杂逻辑的语句时，执行已经调试并测试通过的SQL语句批处理，减少了引入程序错误的风险<br>5）安全性 系统管理员可向单独的用户授予对数据库对象的最小访问权限</p>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>SELECT CONCAT(Cname,Tnum) FROM course WHERE Cnum=03</p>
<h4 id="left-截取指定字符串的指定个数字符"><a href="#left-截取指定字符串的指定个数字符" class="headerlink" title="left 截取指定字符串的指定个数字符"></a>left 截取指定字符串的指定个数字符</h4><p>SELECT LEFT(Cname,5) FROM course WHERE Cnum=01<br>SELECT RIGHT(Cname,5) FROM course WHERE Cnum=01</p>
<h4 id="charIndex"><a href="#charIndex" class="headerlink" title="charIndex()"></a>charIndex()</h4><p>SELECT LOCATE(‘ne’,cname) FROM course WHERE cnum=01<br>SELECT SUBSTRING(Cname,1,3) FROM course</p>
<h3 id="delete-和-truncate"><a href="#delete-和-truncate" class="headerlink" title="delete 和 truncate"></a>delete 和 truncate</h3><p>delete from Teacher where Age&lt;20<br>–特点:<br>–1.删除是一条一条进行删除的<br>–2.每一条记录的删除都需要将操作写入到日志文件中<br>–3.标识列不会从种子值重新计算,以从上次最后一条标识列值往下计算<br>–4.这种删除可以触发delete触发器</p>
<p>–truncate table 表名 –没有条件，它是一次性删除所有数据<br>–特点：<br>–1.一次性删除所有数据，没有条件，那么日志文件只以最小化的数据写入<br>–2.它可以使用标识列从种子值重新计算<br>–3.它不能触发delete触发器<br>truncate table teacher</p>
<p>update Teacher set Salary=Salary+500 where ClassId=4 and Age&gt;20<br>–sign:正数==1  负数 ==-1  0=0<br>select SIGN(-100)</p>
<p>mysql不存在top关键词，使用limit<br>SELECT <em> FROM course WHERE cnum=(SELECT  cnum FROM sc ORDER BY cnum DESC LIMIT 0,1)<br>–使用top分页<br>select top 5 </em> from Student where StudentNo not in(select top 5 studentno from Student)</p>
<p>视图就是一张虚拟表，可以像使用子查询做为结果集一样使用视图<br>触发器:执行一个可以改变表数据的操作（增加删除和修改），会自动触发另外一系列（类似于存储过程中的模块）的操作。</p>
<p>SQL语法顺序是：<br>SELECT[DISTINCT]<br>FROM<br>WHERE<br>GROUP BY<br>HAVING<br>UNION<br>ORDER BY<br>执行顺序为：<br>FROM<br>WHERE<br>GROUP BY<br>HAVING<br>SELECT<br>DISTINCT<br>UNION<br>ORDER BY<br>The first thing that happens is loading data from the disk into memory, in order to operate on such data.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">WITH a AS (</div><div class="line">  SELECT first_name, last_name, current_date - date_of_birth age</div><div class="line">  FROM author</div><div class="line">)</div><div class="line">SELECT *</div><div class="line">FROM a</div><div class="line">WHERE age &gt; 10000</div></pre></td></tr></table></figure></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>SELECT 语句有很多特殊的规则，至少你应该熟悉以下几条<br>你仅能够使用那些能通过表引用而得来的字段<br>如果你有 GROUP BY 语句，你只能够使用 GROUP BY 语句后面的字段或者聚合函数<br>当你的语句中没有 GROUP BY 的时候，可以使用开窗函数代替聚合函数<br>当你的语句中没有 GROUP BY 的时候，你不能同时使用聚合函数和其它函数<br>有一些方法可以将普通函数封装在聚合函数中</p>
<h3 id="sybase常用SQL"><a href="#sybase常用SQL" class="headerlink" title="sybase常用SQL"></a>sybase常用SQL</h3><p>FROM后的子查询，要定义别名才可使用<br>IQ中若采用 FULL JOIN 连接则不能使用 WHERE 条件，否则FULL JOIN将失效，要筛选条件则用子查询先过滤记录后再FULL JOIN<br>根据SELECT 语句建立[临时]表的方法（ORACLE的CREATE TABLE）为 SELECT ..[*] INTO [‘#’]table_name FROM ..<br>其中如果在table_name加前缀’#’，则为会话级临时表，否则为实体表；<br>存储过程隐式游标语法：<br>FOR A AS B CURSOR FOR SELECT … FROM …<br>DO….<br>END FOR;<br>需要注意的时，这边的A 和 B 在 过程语句中都不能引用，所以为避免过程语句其他字段名与FOR SELECT 语句的字段名称重复，<br>FOR SELECT 语句的字段最好都定义别名区分<br>因Sybase为列存储模式，在执行上INSERT语句会比UPDATE语句慢，尤其表数据越多INSERT效率就越慢；所以在ETL时建议多用UPDATE而不是INSERT<br>空字符串’’在Sybase中也是个字符而不是null值，这点要注意</p>
<h3 id="转换函数："><a href="#转换函数：" class="headerlink" title="转换函数："></a>转换函数：</h3><p>CONVERT(datetype,exp[,format-style])<br>CAST(exp AS data-type)</p>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>DAY(date_exp):返回日期天值，DAYS(date_exp,int):返回日期date_exp加int后的日期；MONTH与MONTHS、YEAR与YEARS同理；<br>DATE(exp):将表达式转换为日期，并删除任何小时、分钟或秒；兼容性：IQ<br>DATEPART(date-part,date-exp): 返回日期分量的对应值(整数)<br>GETDATE():返回系统时间<br>DATENAME(datepart,date_expr):以字符串形式返回date_expr指定部分的值,转换成合适的名字<br>DATEDIFF(datepart,date_expr1,date_expr2):返回date_expr2-date_expr1,通过指定的datepart度量<br>DATEADD（date-part,num-exp,date-exp）:返回按指定date-part分量加num-exp值后生成的date-exp值；</p>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>CEIL(num-exp)：返回大于或等于指定表达式的最小整数；兼容性：IQ&amp;ASE<br>FLOOR(numeric_expr):返回小于或等于指定值的最大整数<br>ABS(num-exp):返回数值表达式的绝对值；兼容性：IQ&amp;ASE<br>TRUNCNUM(1231.1251,2)：截取数值；不四舍五入<br>ROUND(numeric_expr,int_expr)：把数值表达式圆整到int_expr指定的精度<br>RAND([int_expr])：返回0-1之间的随机浮点数，可指定基值<br>SIGN(int_expr)：返回正+1，零0或负-1<br>SQRT(float_expr)：返回指定值的平方根<br>PI()：返回常数3.1415926<br>POWER(numeric_expr,power)：返回numeric_expr的值给power的幂<br>EXP(float_expr)：给出指定值的指数值</p>
<h3 id="常用DDL语句"><a href="#常用DDL语句" class="headerlink" title="常用DDL语句"></a>常用DDL语句</h3><p>1.删除列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE table_name DELETE column_name</div></pre></td></tr></table></figure></p>
<p>2.增加列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE table_name ADD (column_name DATA_TYPE [NOT] NULL)</div></pre></td></tr></table></figure></p>
<p>3.修改列的空与非空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE table_name MODIFY column_name [NOT] NULL</div></pre></td></tr></table></figure></p>
<p>4.修改列名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE table_name RENAME old_column_name TO new_column_name</div></pre></td></tr></table></figure></p>
<p>5.快速建立临时表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * INTO [#]table_name FROM .....</div></pre></td></tr></table></figure></p>
<p>6、修改表名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE old_table_name RENAME new_table_name</div></pre></td></tr></table></figure></p>
<p>7.增加主键约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE tb_name ADD CONSTRAINT pk_name PRIMARY KEY(col_name,..)</div></pre></td></tr></table></figure></p>
<p>8.删除主键约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE tb_name DROP CONSTRAINT pk_name</div></pre></td></tr></table></figure></p>
<p>9.建立自增长字段，与Oracle的SEQUENCE类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE TMP_001 (RES_ID INTEGER IDENTITY NOT NULL)</div></pre></td></tr></table></figure></p>
<p>10.添加表注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COMMENT ON TABLE table_name IS &apos;....&apos;</div></pre></td></tr></table></figure></p>
<p>11.创建索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE INDEX index_name ON table_name(column_name)</div></pre></td></tr></table></figure></p>
<h3 id="mysql笔记"><a href="#mysql笔记" class="headerlink" title="mysql笔记"></a>mysql笔记</h3><p>USE test<br>CREATE TABLE users(id int(4) primary key,name varchar(15),password varchar(15))<br>ALTER TABLE users ADD email VARCHAR(20) ,MODIFY NAME VARCHAR(15)usersusers<br>重命名 RENAME TABLE USERS TO USER<br>DROP TABLE USERS</p>
<p>select[distinct][concat(col 1,”:”,col 2) as col] selection_list<br>from 表名<br>group by grouping_columns<br>order by sorting_columns<br>having secondary_constraint<br>limit count </p>
<h4 id="等同连接"><a href="#等同连接" class="headerlink" title="等同连接"></a>等同连接</h4><p>SELECT tb_mrbook.id,tb_mrbook.bookname,author,price<br>FROM tb_mrbook,tb_bookinfo<br>WHERE tb_mrbook.bookname = tb_bookinfo.bookname<br>AND tb_bookinfo.bookname=”mysql”</p>
<p>SELECT * FROM tb_bookinfo WHERE bookname LIKE ‘%m%’</p>
<p>SELECT * FROM tb_mrbook ORDER BY id DESC LIMIT 3</p>
<h4 id="聚合函数（NULL值被忽略）"><a href="#聚合函数（NULL值被忽略）" class="headerlink" title="聚合函数（NULL值被忽略）"></a>聚合函数（NULL值被忽略）</h4><p>SELECT COUNT(*) FROM tb_bookinfo<br>select sum(price) from tb_bookinfo where price &lt;30.0<br>select AVG(price) from tb_bookinfo<br>select MAX(price) from tb_bookinfo</p>
<h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>SELECT section,tb_login.user,books FROM tb_login LEFT JOIN tb_books ON tb_login.user=tb_books.user<br>右外连接<br>RIGHT JOIN<br>内连接</p>
<h4 id="子查询："><a href="#子查询：" class="headerlink" title="子查询："></a>子查询：</h4><p>IN 关键字<br>SELECT * FROM tb_login WHERE USER IN(SELECT USER FROM tb_books)   对应 NOT IN<br>带比较运算符的子运算符<br>SELECT id,books,ROW FROM tb_books WHERE ROW&gt;=(SELECT ROW FROM tb_row WHERE id=1)<br>ANY<br>select books,row from tb_books where row<any(select row="" from="" tb_row)="" all="" select="" books,row="" tb_book="" where="">=ALL(select row from tb_row)</any(select></p>
<p>合并查询结果 UNION 合并查询结果并去除重复结果，UNION ALL 不会去除重复<br>SELECT USER FROM tb_login<br>UNION<br>SELECT USER FROM tb_books</p>
<p>SELECT * FROM tb_login tt WHERE tt.id=1  起别名<br>SELECT  section AS sss,NAME AS nnn FROM tb_login  为字段取别名</p>
<h4 id="使用正则表达式查询"><a href="#使用正则表达式查询" class="headerlink" title="使用正则表达式查询"></a>使用正则表达式查询</h4><p> SELECT <em> FROM tb_books WHERE USER REGEXP ‘[m|l]’<br>SELECT </em> FROM tb_books WHERE USER REGEXP ‘a<em>c’   ===&gt; Aric  Eric  Jack  Lucy  abc12   </em>表示出现0,1，多次<br>SELECT <em> FROM tb_books WHERE USER REGEXP ‘a</em>c’   ===&gt; Jack    + 表示出现1次，多次</p>
<h4 id="MYSQL函数"><a href="#MYSQL函数" class="headerlink" title="MYSQL函数"></a>MYSQL函数</h4><p>1)数学函数<br>2)字符串函数<br>3)日期和时间函数<br>4)条件判断函数<br>5)系统信息函数<br>6)加密函数<br>7)格式化函数和锁函数</p>
<h4 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h4><p>当用户通过索引查询数据库中的数据时，不需要遍历所有数据库中的所有数据，大幅度提<br>高了查询效率<br>一次编写多次调用–MySQL存储过程<br>名称不区分大小写</p>
<h3 id="web安全"><a href="#web安全" class="headerlink" title="web安全"></a>web安全</h3><p>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串<br>最终达到欺骗服务器执行恶意的SQL命令。<br>将（恶意）的SQL命令注入到后台数据库引擎执行，<br>它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库<br>主要原因是 程序没有细致的过滤用户输入的数据，使得非法数据侵入系统</p>
<p>SQL注入分为平台层注入和代码层注入，前者由于不安全的数据库配置所致，后者由于程序员对输入为进行细致的过滤，执行了非法的数据查询<br>在某些表单中，用户输入的内容直接用来构造动态sql命令，或者作为存储过程的输入参数，这些表单特别容易受到sql注入的攻击</p>
<h4 id="防止sql注入："><a href="#防止sql注入：" class="headerlink" title="防止sql注入："></a>防止sql注入：</h4><p>对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双-进行转换等<br>不使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取<br>不要使用管理员的权限数据库连接，为每个应用使用单独的权限有限的数据库连接<br>不要把机密信息比如密码明文存放，加密或者hash掉密码和敏感信息<br>异常信息给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装<br>使用专业检测sql注入漏洞的工具平台扫描检测</p>
<p>强制产生错误 使用特殊字符来进行sql注入<br>通过正则表达校验用户输入<br>通过参数化存储过程进行数据查询存取<br>参数化SQL语句 数值以参数化的形式提供<br>XMLHttpRequest能够产生异步后台请求<br>同源策略，它是由Netscape提出的一个著名的安全策略。<br>现在所有支持JavaScript 的浏览器都会使用这个策略。<br>所谓同源是指，域名，协议，端口相同。<br>当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。</p>
<p>同源策略防止javascript读取不相关的域中的内容，当它并没有限制javascript创建指向其他域的元素的能力，能够从src或href属性自动获取<br>内容的任何元素都有利于黑客攻击。</p>
<p>专业核弹头翻新,改装,潜艇抛光,喷漆.回收二手航母,大修核反应堆,拆洗导弹发动机、清洗航母油槽、航天飞机保养换三滤.高空作业擦洗卫星表面除尘.星球设计，全球海洋保养及维护，南极冰川修复,地球形状改造及时空改变颠倒业务，并批发歼10，F22 F35 B2轰炸机，各类氢/核弹头。量大从优！有正规发票</p>
<h2 id="sql学习-2"><a href="#sql学习-2" class="headerlink" title="sql学习"></a>sql学习</h2><h3 id="基本sql"><a href="#基本sql" class="headerlink" title="基本sql"></a>基本sql</h3><h4 id="查询每个月倒数第2天入职的员工的信息-1"><a href="#查询每个月倒数第2天入职的员工的信息-1" class="headerlink" title="查询每个月倒数第2天入职的员工的信息"></a>查询每个月倒数第2天入职的员工的信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT last_name,hire_date </div><div class="line">FROM employees </div><div class="line">WHERE hire_date = LAST_DAY(hire_date) -1</div></pre></td></tr></table></figure>
<h4 id="查询隔行数据-1"><a href="#查询隔行数据-1" class="headerlink" title="查询隔行数据"></a>查询隔行数据</h4><figure class="highlight plain"><figcaption><span>row_number() over(order by sno) n wher n % 2 =1```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 将空值转换为有效值 </div><div class="line"></div><div class="line">```select sno,bookname,author,isnull(book,&apos;无&apos;) as book from tb_space</div></pre></td></tr></table></figure>
<h4 id="第N行数据-1"><a href="#第N行数据-1" class="headerlink" title="第N行数据"></a>第N行数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from (select top n from tb_space )aa</div><div class="line">where not exist (select * from (select top n-1 from tb_space)bb </div><div class="line">where aa.sno = bb.sno )</div></pre></td></tr></table></figure>
<h4 id="字符函数-1"><a href="#字符函数-1" class="headerlink" title="字符函数"></a>字符函数</h4><p>right(xh,len(xh)-1) 从右边开始取指定个数的字符<br>left(xh,len(xh)-1) 从左边开始去指定个数的字符<br>substring(expresion,start,length) 子串<br>select * from tb_space order by 2,3 按照第2列，第3列排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">case...when</div><div class="line">select(</div><div class="line">case job</div><div class="line">when &apos;会计&apos; then salary*1.5;</div><div class="line">when &apos;秘书&apos; then salary*2.0;</div><div class="line">end as new_salary</div><div class="line">) order by new_salary</div></pre></td></tr></table></figure></p>
<h4 id="对重复的内容不作统计-1"><a href="#对重复的内容不作统计-1" class="headerlink" title="对重复的内容不作统计"></a>对重复的内容不作统计</h4><p>select count(distinct duty) as duty<br>不包括最大最小值计算平均值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">select avg(salary)</div><div class="line">from tb_space where salary not in (</div><div class="line">    (select min(salary) as minSalary from tb_treatment)</div><div class="line">    union </div><div class="line">    (selct max(salary) as maxSalary from tb_treatment)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h3 id="多列子查询"><a href="#多列子查询" class="headerlink" title="多列子查询"></a>多列子查询</h3><h4 id="成对比较的多列子查询"><a href="#成对比较的多列子查询" class="headerlink" title="成对比较的多列子查询"></a>成对比较的多列子查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SELECT NAME,salary ,department </div><div class="line">FROM employee </div><div class="line">WHERE (salary,department) IN (</div><div class="line">     SELECT MAX(salary),department</div><div class="line">     FROM employee</div><div class="line">     GROUP BY department</div><div class="line">)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SELECT NAME,salary ,department </div><div class="line">FROM employee </div><div class="line">WHERE salary IN (</div><div class="line">     SELECT MAX(salary)</div><div class="line">     FROM employee</div><div class="line">     GROUP BY department</div><div class="line">) AND department IN (</div><div class="line">SELECT DISTINCT department </div><div class="line">    FROM employee</div><div class="line">)</div></pre></td></tr></table></figure>
<p>接口是 实体把自己提供给外界的一种抽象化说明，用以由内部操作分离出外部沟通方法，使其能被修改内部而不影响外界其他<br>实体与其交互的方式</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>则对于任意的序号为i的结点有：(1)如i=1，则序号为i的结点是根结点，无双亲结点，如i&gt;1，则序号为i的结点的双亲结点序号<br>为i/2;（2）如2<em>i&gt;n,则序号为i的结点无左孩子，如2</em>i&lt;=n,则序号为i的结点的左孩子结点序号为2<em>i；(3)如2</em>i+1&gt;n，则序号为<br>i的结点无右孩子，如2<em>i+1&lt;=n,则序号为i的结点的右孩子结点序号为2</em>i+1;<br>二叉树含有n个节点，则二叉链表含有2n个指针域，分支数比节点数少1 ，所以 2n-(n-1) = n+1 个空的链域</p>
<p>spring IOC控制反转，控制权交出去，使用容器创建并维护对象<br>AOP面向切面编程<br>DI(dependency injection) 依赖注入  –》 设值注入  构造注入</p>
<p>java在处理基本数据类型（例如int ,char,double）时，都是采用按值传递的方式执行，除此之外的其它类型都是按引用传递的方式执行。<br>对象除了在函数调用时时引用传递，在使用“=”赋值时也是采用引用传递。</p>
<h4 id="webservice小记"><a href="#webservice小记" class="headerlink" title="webservice小记"></a>webservice小记</h4><p>WebService是一种跨编程语言和跨操作系统平台的远程调用技术。<br>Object方法：<br>getClass() hashCode()  equals(Object)  clone()  toString()  notify()   notifyAll()<br>wait(long) wait(long,int) wait()  finalize()<br>通过使用Web Service,我们可以将应用程序转换为网络应用程序，从而使本地的应用程序可以向全世界发布信息或提供某种服务</p>
<p>1.高内聚，低耦合，模块和程序的高度独立性<br>2.所有的设备都可以像文件一样地操作<br>3.“命令的相互支持性”，命令们通过一个管道或是重定向，可以互相联系在一起</p>
<p>抽象类和接口的区别<br>值类型和引用类型的区别<br>存储过程和函数的区别</p>
<p>表中有A B C三列,用SQL语句实现：当A列大于B列时选择A列否则选择B列，当B列大于C列时选择B列否则选择C列。<br>select (case when a&gt;b then a else b end ),<br>(case when b&gt;c then b esle c end)<br>from table_name</p>
<h4 id="一个日期判断的sql语句？"><a href="#一个日期判断的sql语句？" class="headerlink" title="一个日期判断的sql语句？"></a>一个日期判断的sql语句？</h4><p>请取出tb_send表中日期(SendTime字段)为当天的所有记录?<br>select * from tb where datediff(dd,SendTime,getdate())=0</p>
<h4 id="case…when"><a href="#case…when" class="headerlink" title="case…when"></a>case…when</h4><p>大于或等于80表示优秀，大于或等于60表示及格，小于60分表示不及格。<br>select<br>(case when 语文&gt;=80 then ‘优秀’<br>        when 语文&gt;=60 then ‘及格’<br>else ‘不及格’) as 语文,<br>(case when 数学&gt;=80 then ‘优秀’<br>        when 数学&gt;=60 then ‘及格’<br>else ‘不及格’) as 数学,<br>(case when 英语&gt;=80 then ‘优秀’<br>        when 英语&gt;=60 then ‘及格’<br>else ‘不及格’) as 英语,<br>from table</p>
<p>查询中用到的关键词主要包含六个，并且他们的顺序依次为<br>select–from–where–group by–having–order by -&gt;distinct -&gt;top </p>
<p>1.not and or一起出现时候，not &gt; and &gt; or 优先级顺序</p>
<ol>
<li>使用表达式生成新列<br>eg:<br>SELECT 10 AS NAME<br>UNION ALL<br>SELECT 20<br>UNION ALL<br>SELECT  30<br>UNION ALL<br>SELECT 40</li>
</ol>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><h2 id="Java可以通过JNI调用本地的C-C-代码，本地的C-C-的代码也可以调用java代码。JNI-是本地编程接口，Java和C-C-互相通过的接口。Java通过C-C-使用本地的代码的一个关键性原因在于C-C-代码的高效性。"><a href="#Java可以通过JNI调用本地的C-C-代码，本地的C-C-的代码也可以调用java代码。JNI-是本地编程接口，Java和C-C-互相通过的接口。Java通过C-C-使用本地的代码的一个关键性原因在于C-C-代码的高效性。" class="headerlink" title="Java可以通过JNI调用本地的C/C++代码，本地的C/C++的代码也可以调用java代码。JNI 是本地编程接口，Java和C/C++互相通过的接口。Java通过C/C++使用本地的代码的一个关键性原因在于C/C++代码的高效性。"></a>Java可以通过JNI调用本地的C/C++代码，本地的C/C++的代码也可以调用java代码。JNI 是本地编程接口，Java和C/C++互相通过的接口。Java通过C/C++使用本地的代码的一个关键性原因在于C/C++代码的高效性。</h2><h4 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h4><p>public bool IsAdult(int age)<br>{<br>    var isAdult = age &gt; 18;<br>    return isAdult;</p>
<h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>参数过多<br>public void RegisterUser(string userName, string password, string email, string phone)<br>{ … }<br>重构后<br>public void RegisterUser(User user)</p>
<h2 id="…"><a href="#…" class="headerlink" title="{ … }"></a>{ … }</h2><p>public void RegisterUser(User user, bool sendEmail)<br>{ … }<br>布尔参数在告诉方法不止做一件事，违反了Do one thing<br>重构后：<br>public void RegisterUser(User user)<br>{ … }<br>public void SendEmail(User user)</p>
<h2 id="…-1"><a href="#…-1" class="headerlink" title="{ … }"></a>{ … }</h2><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>String s1 = “Hello”;<br>String s2 = “Hello”; S1=S2=S3<br>String s3 = “Hel” + “lo”;  S1=S3 S3虽然是拼接的，但拼接的都是已知的字符串，编译器优化<br>String s4 = “Hel” + new String(“lo”);  S1!=S3<br>String s5 = new String(“Hello”);   S1和S5是否相等<br>String s6 = s5.intern(); S1=S6 intern()将字符串添加到常量池中<br>String s7 = “H”;<br>String s8 = “ello”;<br>String s9 = s7 + s8; S1!=S9 S7和S8拼接之后在堆中，被S9引用，地址和S1不一样</p>
<h4 id="异或运算及应用"><a href="#异或运算及应用" class="headerlink" title="异或运算及应用"></a>异或运算及应用</h4><p>0^a=a<br>a^a=0<br>a^b^c=a^c^b<br>找出数组中只出现了一次的数（除了一个数只出现一次外，其他数都是出现两次）<br>升级版：数组中只出现1次的两个数字(百度面试题)。</p>
]]></content>
    </entry>
    
  
  
</search>
