
<!doctype html>
<html class="theme-next use-motion theme-next-mala">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="我们整天忙忙碌碌，像一群群没有灵魂的苍蝇，喧闹着，躁动着，听不到灵魂深处的声音。时光流逝，童年远去，我们渐渐长大，岁月带走了许许多多的回忆，也消蚀了心底曾经拥有的那份童稚的纯真，我们不顾心灵桎梏，沉溺于人世浮华，专注于利益法则，我们把自己弄丢了。" />



  <meta name="keywords" content="Linux,Shell," />



  <link rel="alternate" href="/atom.xml" title="冰鸟" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="概述awk是一种很棒的语言。awk 适合于文本处理和报表生成，它还有许多精心设计的特性，允许进行需要特殊技巧程序设计。与某些语言不同，awk 的语法较为常见。它借鉴了某些语言的一些精华部分，如 C 语言、Python 和 bash（虽然在技术上，awk 比 python 和 bash 早创建）。awk 是那种一旦学会了就会成为您战略编码库的主要部分的语言。
一. 第一个 awk让我们继续，开始使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Shell--Awk">
<meta property="og:url" content="https://fudawei.github.io/2017/01/22/Shell学习之Awk/index.html">
<meta property="og:site_name" content="冰鸟">
<meta property="og:description" content="概述awk是一种很棒的语言。awk 适合于文本处理和报表生成，它还有许多精心设计的特性，允许进行需要特殊技巧程序设计。与某些语言不同，awk 的语法较为常见。它借鉴了某些语言的一些精华部分，如 C 语言、Python 和 bash（虽然在技术上，awk 比 python 和 bash 早创建）。awk 是那种一旦学会了就会成为您战略编码库的主要部分的语言。
一. 第一个 awk让我们继续，开始使用">
<meta property="og:updated_time" content="2017-02-12T01:59:36.348Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shell--Awk">
<meta name="twitter:description" content="概述awk是一种很棒的语言。awk 适合于文本处理和报表生成，它还有许多精心设计的特性，允许进行需要特殊技巧程序设计。与某些语言不同，awk 的语法较为常见。它借鉴了某些语言的一些精华部分，如 C 语言、Python 和 bash（虽然在技术上，awk 比 python 和 bash 早创建）。awk 是那种一旦学会了就会成为您战略编码库的主要部分的语言。
一. 第一个 awk让我们继续，开始使用">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mala',
    sidebar: 'post'
  };
</script>

  <title> Shell--Awk | 冰鸟 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">冰鸟-博客</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            <i class="menu-item-icon icon-next-commonweal"></i> <br />
            公益404
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    
      

      
        <style type="text/css">

    .circle {
        width: 40px;
        height: 40px;
        background: #555 no-repeat;
        cursor: move;
    }

    .assist-btn {
        position: fixed;
        top: 50％;
        left: 10px;
        -moz-border-radius: 50px;
        -webkit-border-radius: 50px;
        border-radius: 50px;
        outline: none;
        border: none;
        color: #87daff;
    }

</style>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript">
    // 浮动圆点展开与收缩
    /*
    $(function () {
        var assist_box = $('.assist-box');
        $('#assist_btn').hover(function () {
            assist_box.stop().show(300);
        }, function () {
            assist_box.stop().hide(150);
        })
    });
    */  
    //浮动圆点拖动
    $(function () {
        var box = document.getElementById('assist_btn');
        box.onmousedown = function (event) {
            var e = event || window.event,
                t = e.target || e.srcElement,
                // 鼠标按下时的坐标x1,y1
                x1 = e.clientX,
                y1 = e.clientY,
                //鼠标按下时的左右偏移量
                dragLeft = this.offsetLeft,
                dragTop = this.offsetTop;

            document.onmousemove = function (event) {
                var e = event || window.event,
                    t = e.target || e.srcElement,
                    // 鼠标移动时的动态坐标
                    x2 = e.clientX,
                    y2 = e.clientY,
                    // 鼠标移动时的坐标的变化量
                    x = x2 - x1,
                    y = y2 - y1;
                box.style.left = (dragLeft + x) + 'px';
                box.style.top = (dragTop + y) + 'px';
            }

            document.onmouseup = function () {
                this.onmousemove = null;
            }
        }
    });

/*
    $whitesmoke   = #f5f5f5
    $gainsboro    = #eee
    $gray-lighter = #ddd
    $grey-light   = #ccc
    $grey         = #bbb
    $grey-dark    = #999
    $grey-dim     = #666
    $black-light  = #555
    $black-deep   = #222
    $red          = #ff2a2a
    $blue-bright  = #87daff
    $blue         = #0684bd
    $blue-deep    = #262a30
*/
    // white theme
    var body = {color: "#555", background: "white"};
    var a_tag = {color: "#222"};
    var header = { background: "#f5f5f5"};
    var logo_line_i = {background: "#222"};
    // var post_code = {background: "#eee", color: "#222"};

    function switch_theme() {
        $("body").css(body);
        $("a:not('.links-of-author-item a, .site-state-item a, .site-state-posts a, .feed-link a, .motion-element a, .post-tags a, .show-commit-cls a, #donate_board a')").css(a_tag);
        $(".header, .footer").css(header);
        $(".logo-line-before i, .logo-line-after i").css(logo_line_i);
        //$(".post code").css(post_code);
        $("#idhyt-surprise-ball #idhyt-surprise-ball-animation .drag").css(a_tag);
        $(".post-title-link, .posts-expand .post-meta, .post-comments-count, .disqus-comment-count, .post-category a, .post-nav-next a, .post-nav-item a").css(a_tag);
        
        // $("code").css({color: '#c5c8c6', background: '#1d1f21'});
        $("#assist_btn").hide(1500);
    }

    $(function () {
        $("#assist_btn").dblclick(function() {
            switch_theme();
        });
    });

</script>

<div>

    <button class="assist-btn circle" id="assist_btn" title="双击切换">
        亮
    </button>

</div>









      

    

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              Shell--Awk
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-01-22T10:30:02+08:00" content="2017-01-22">
            2017-01-22
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Linux/" itemprop="url" rel="index">
                  <span itemprop="name">Linux</span>
                </a>
              </span>

              
              
                ， 
              

            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Linux/Shell/" itemprop="url" rel="index">
                  <span itemprop="name">Shell</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <!--
              <a href="/2017/01/22/Shell学习之Awk/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/22/Shell学习之Awk/" itemprop="commentsCount"></span>
              </a>
              -->
              <a href="/2017/01/22/Shell学习之Awk/#comments" itemprop="discussionUrl">
                <span>评论</span>
              </a>
            </span>
          
        




&nbsp; | &nbsp;
<span id="/2017/01/22/Shell学习之Awk/"class="leancloud_visitors" data-flag-title="Shell--Awk">
         &nbsp;阅读次数
        </span>


	
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>awk是一种很棒的语言。awk 适合于文本处理和报表生成，它还有许多精心设计的特性，允许进行需要特殊技巧程序设计。与某些语言不同，awk 的语法较为常见。它借鉴了某些语言的一些精华部分，如 C 语言、Python 和 bash（虽然在技术上，awk 比 python 和 bash 早创建）。awk 是那种一旦学会了就会成为您战略编码库的主要部分的语言。</p>
<h3 id="一-第一个-awk"><a href="#一-第一个-awk" class="headerlink" title="一. 第一个 awk"></a>一. 第一个 awk</h3><p>让我们继续，开始使用 awk，以了解其工作原理。在命令行中输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; print &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>你将会见到 /etc/passwd 文件的内容出现在眼前。现在，解释 awk 做了些什么。调用 awk 时，我们指定 /etc/passwd 作为输入文件。执行 awk 时，它依次对 /etc/passwd 中的每一行执行 print 命令。所有输出都发送到 stdout，所得到的结果与与执行catting /etc/passwd完全相同。</p>
<p>现在，解释 { print } 代码块。在 awk 中，花括号用于将几块代码组合到一起，这一点类似于 C 语言。在代码块中只有一条 print 命令。在 awk 中，如果只出现 print 命令，那么将打印当前行的全部内容。</p>
<p>这里是另一个 awk 示例，它的作用与上例完全相同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; print $0 &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure></p>
<p>在 awk 中， $0 变量表示整个当前行，所以 print 和 print $0 的作用完全一样。</p>
<p>如果你愿意，可以创建一个 awk 程序，让它输出与输入数据完全无关的数据。以下是一个示例：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; print &quot;&quot; &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>只要将 “” 字符串传递给 print 命令，它就会打印空白行。如果测试该脚本，将会发现对于 /etc/passwd 文件中的每一行，awk 都输出一个空白行。再次说明， awk 对输入文件中的每一行都执行这个脚本。以下是另一个示例：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; print &quot;hiya&quot; &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>运行这个脚本将在您的屏幕上写满 hiya。</p>
<h3 id="二-多个字段"><a href="#二-多个字段" class="headerlink" title="二. 多个字段"></a>二. 多个字段</h3><p>awk 非常善于处理分成多个逻辑字段的文本，而且让您可以毫不费力地引用 awk 脚本中每个独立的字段。以下脚本将打印出您的系统上所有用户帐户的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F&quot;:&quot; &apos;&#123; print $1 &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>　<br>上例中，在调用 awk 时，使用 -F 选项来指定 “:” 作为字段分隔符。awk 处理 print $1 命令时，它会打印出在输入文件中每一行中出现的第一个字段。以下是另一个示例： 　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F&quot;:&quot; &apos;&#123; print $1 $3 &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>以下是该脚本输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">halt7</div><div class="line">operator11</div><div class="line">root0</div><div class="line">shutdown6</div><div class="line">sync5</div><div class="line">bin1</div><div class="line">....etc.</div></pre></td></tr></table></figure>
<p>如您所见，awk 打印出 /etc/passwd 文件的第一和第三个字段，它们正好分别是用户名和用户标识字段。现在，当脚本运行时，它并不理想 – 在两个输出字段之间没有空格！如果习惯于使用 bash 或 python 进行编程，那么您会指望 print $1 $3 命令在两个字段之间插入空格。然而，当两个字符串在 awk 程序中彼此相邻时，awk 会连接它们但不在它们之间添加空格。以下命令会在这两个字段中插入空格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F&quot;:&quot; &apos;&#123; print $1 &quot; &quot; $3 &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>以这种方式调用 print 时，它将连接 $1 、” “ 和 $3 ，创建可读的输出。当然，如果需要的话，我们还可以插入一些文本标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F&quot;:&quot; &apos;&#123; print &quot;username: &quot; $1 &quot;/t/tuid:&quot; $3&quot; &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>这将产生以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">username: halt uid:7</div><div class="line">username: operator uid:11</div><div class="line">username: root uid:0</div><div class="line">username: shutdown uid:6</div><div class="line">username: sync uid:5</div><div class="line">username: bin uid:1</div><div class="line">....etc.</div></pre></td></tr></table></figure>
<h3 id="三-外部脚本"><a href="#三-外部脚本" class="headerlink" title="三. 外部脚本"></a>三. 外部脚本</h3><p>将脚本作为命令行自变量传递给 awk 对于小的单行程序来说是非常简单的，而对于多行程序，它就比较复杂。您肯定想要在外部文件中撰写脚本。然后可以向 awk 传递 -f 选项，以向它提供此脚本文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -f myscript.awk myfile.in</div></pre></td></tr></table></figure>
<p>将脚本放入文本文件还可以让您使用附加 awk 功能。例如，这个多行脚本与前面的单行脚本的作用相同，它们都打印出 /etc/passwd 中每一行的第一个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">FS=&quot;:&quot;</div><div class="line">&#125;</div><div class="line">&#123; print $1 &#125;</div></pre></td></tr></table></figure>
<p>这两个方法的差别在于如何设置字段分隔符。在这个脚本中，字段分隔符在代码自身中指定（通过设置 FS 变量），而在前一个示例中，通过在命令行上向 awk 传递 -F”:” 选项来设置 FS。通常，最好在脚本自身中设置字段分隔符，只是因为这表示您可以少输入一个命令行自变量。我们将在本文的后面详细讨论 FS 变量。</p>
<h3 id="四-BEGIN-和-END-块"><a href="#四-BEGIN-和-END-块" class="headerlink" title="四. BEGIN 和 END 块"></a>四. BEGIN 和 END 块</h3><p>通常，对于每个输入行，awk 都会执行每个脚本代码块一次。然而，在许多编程情况中，可能需要在 awk 开始处理输入文件中的文本之 前 执行初始化代码。对于这种情况，awk 允许您定义一个 BEGIN 块。我们在前一个示例中使用了 BEGIN 块。因为 awk 在开始处理输入文件之前会执行 BEGIN 块，因此它是初始化 FS（字段分隔符）变量、打印页眉或初始化其它在程序中以后会引用的全局变量的极佳位置。</p>
<p>awk 还提供了另一个特殊块，叫作 END 块。awk 在处理了输入文件中的所有行之后执行这个块。通常，END 块用于执行最终计算或打印应该出现在输出流结尾的摘要信息。</p>
<h3 id="五-规则表达式和块"><a href="#五-规则表达式和块" class="headerlink" title="五. 规则表达式和块"></a>五. 规则表达式和块</h3><p>awk 允许使用规则表达式，根据规则表达式是否匹配当前行来选择执行独立代码块。以下示例脚本只输出包含字符序列 foo 的那些行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/foo/ &#123; print &#125;</div></pre></td></tr></table></figure>
<p>当然，可以使用更复杂的规则表达式。以下脚本将只打印包含浮点数的行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/[0-9]+/.[0-9]*/ &#123; print &#125;</div></pre></td></tr></table></figure>
<h3 id="六-表达式和块"><a href="#六-表达式和块" class="headerlink" title="六. 表达式和块"></a>六. 表达式和块</h3><p>有许多其它方法可以选择执行代码块。我们可以将任意一种布尔表达式放在一个代码块之前，以控制何时执行某特定块。仅当对前面的布尔表达式求值为真时，awk 才执行代码块。以下示例脚本输出将输出其第一个字段等于 fred 的所有行中的第三个字段。如果当前行的第一个字段不等于 fred ，awk 将继续处理文件而不对当前行执行 print 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$1 == &quot;fred&quot; &#123; print $3 &#125;</div></pre></td></tr></table></figure>
<p>awk 提供了完整的比较运算符集合，包括 “==”、”&lt;”、”&gt;”、”&lt;=”、”&gt;=” 和 “!=”。另外，awk 还提供了 “~” 和 “!~” 运算符，它们分别表示“匹配”和“不匹配”。它们的用法是在运算符左边指定变量，在右边指定规则表达式。如果某一行的第五个字段包含字符序列 root ，那么以下示例将只打印这一行中的第三个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$5 ~ /root/ &#123; print $3 &#125;</div></pre></td></tr></table></figure>
<h3 id="七-条件语句"><a href="#七-条件语句" class="headerlink" title="七. 条件语句"></a>七. 条件语句</h3><p>awk 还提供了非常好的类似于 C 语言的 if 语句。如果您愿意，可以使用 if 语句重写前一个脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">if ( $5 ~ /root/ ) &#123; </div><div class="line">  print $3 </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个脚本的功能完全一样。第一个示例中，布尔表达式放在代码块外面。而在第二个示例中，将对每一个输入行执行代码块，而且我们使用 if 语句来选择执行 print 命令。这两个方法都可以使用，可以选择最适合脚本其它部分的一种方法。</p>
<p>以下是更复杂的 awk if 语句示例。可以看到，尽管使用了复杂、嵌套的条件语句， if 语句看上去仍与相应的 C 语言 if 语句一样：<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">  if ( $1 == &quot;foo&quot; ) &#123;</div><div class="line">    if ( $2 == &quot;foo&quot; ) &#123;</div><div class="line">      print &quot;uno&quot;</div><div class="line">    &#125; </div><div class="line">   else &#123;</div><div class="line">      print &quot;one&quot;</div><div class="line">    &#125;</div><div class="line">  &#125; </div><div class="line">  else if ($1 == &quot;bar&quot; ) &#123;</div><div class="line">    print &quot;two&quot;</div><div class="line">  &#125; </div><div class="line">  else &#123;</div><div class="line">   print &quot;three&quot; </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 if 语句还可以将代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">! /matchme/ &#123; print $1 $3 $4 &#125;</div><div class="line"></div><div class="line">转换成：</div><div class="line"></div><div class="line">&#123; </div><div class="line">  if ( $0 !~ /matchme/ ) &#123;</div><div class="line">  print $1 $3 $4</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个脚本都只输出 不 包含 matchme 字符序列的那些行。此外，还可以选择最适合您的代码的方法。它们的功能完全相同。</p>
<p>awk 还允许使用布尔运算符 “||”（逻辑与）和 “&amp;&amp;”（逻辑或），以便创建更复杂的布尔表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( $1 == &quot;foo&quot; ) &amp;&amp; ( $2 == &quot;bar&quot; ) &#123; print &#125;</div></pre></td></tr></table></figure>
<p>这个示例只打印第一个字段等于 foo 且 第二个字段等于 bar 的那些行。</p>
<h3 id="八-数值变量！"><a href="#八-数值变量！" class="headerlink" title="八. 数值变量！"></a>八. 数值变量！</h3><p>至今，我们不是打印字符串、整行就是特定字段。然而，awk 还允许我们执行整数和浮点运算。通过使用数学表达式，可以很方便地编写计算文件中空白行数量的脚本。以下就是这样一个脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123; x=0 &#125;</div><div class="line">  /^$/ &#123; x=x+1 &#125;</div><div class="line">END &#123; print &quot;I found &quot; x &quot; blank lines. :)&quot; &#125;</div></pre></td></tr></table></figure>
<p>在 BEGIN 块中，将整数变量 x 初始化成零。然后，awk 每次遇到空白行时，awk 将执行 x=x+1 语句，递增 x 。处理完所有行之后，执行 END 块，awk 将打印出最终摘要，指出它找到的空白行数量。</p>
<h3 id="九-字符串化变量"><a href="#九-字符串化变量" class="headerlink" title="九. 字符串化变量"></a>九. 字符串化变量</h3><p>awk 的优点之一就是“简单和字符串化”。我认为 awk 变量“字符串化”是因为所有 awk 变量在内部都是按字符串形式存储的。同时，awk 变量是“简单的”，因为可以对它执行数学操作，且只要变量包含有效数字字符串，awk 会自动处理字符串到数字的转换步骤。要理解我的观点，请研究以下这个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x=&quot;1.01&quot;</div><div class="line"># We just set x to contain the *string* &quot;1.01&quot;</div><div class="line">x=x+1</div><div class="line"># We just added one to a *string*</div><div class="line">print x</div><div class="line"># Incidentally, these are comments :)</div></pre></td></tr></table></figure>
<p>awk 将输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.01</div></pre></td></tr></table></figure>
<p>有趣吧！虽然将字符串值 1.01 赋值给变量 x ，我们仍然可以对它加一。但在 bash 和 python 中却不能这样做。首先，bash 不支持浮点运算。而且，如果 bash 有“字符串化”变量，它们并不“简单”；要执行任何数学操作，bash 要求我们将数字放到丑陋的 $( ) ) 结构中。如果使用 python，则必须在对 1.01 字符串执行任何数学运算之前，将它转换成浮点值。虽然这并不困难，但它仍是附加的步骤。如果使用 awk，它是全自动的，而那会使我们的代码又好又整洁。如果想要对每个输入行的第一个字段乘方并加一，可以使用以下脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; print ($1^2)+1 &#125;</div></pre></td></tr></table></figure>
<p>如果做一个小实验，就可以发现如果某个特定变量不包含有效数字，awk 在对数学表达式求值时会将该变量当作数字零处理。</p>
<h3 id="十-众多运算符"><a href="#十-众多运算符" class="headerlink" title="十. 众多运算符"></a>十. 众多运算符</h3><p>awk 的另一个优点是它有完整的数学运算符集合。除了标准的加、减、乘、除，awk 还允许使用前面演示过的指数运算符 “^”、模（余数）运算符 “%” 和其它许多从 C 语言中借入的易于使用的赋值操作符。</p>
<p>这些运算符包括前后加减（ i++ 、 –foo ）、加／减／乘／除赋值运算符（ a+=3 、 b*=2 、 c/=2.2 、 d-=6.2 ）。不仅如此 – 我们还有易于使用的模／指数赋值运算符（ a^=2 、 b%=4 ）。</p>
<h3 id="十一-字段分隔符"><a href="#十一-字段分隔符" class="headerlink" title="十一. 字段分隔符"></a>十一. 字段分隔符</h3><p>awk 有它自己的特殊变量集合。其中一些允许调整 awk 的运行方式，而其它变量可以被读取以收集关于输入的有用信息。我们已经接触过这些特殊变量中的一个，FS。前面已经提到过，这个变量让您可以设置 awk 要查找的字段之间的字符序列。我们使用 /etc/passwd 作为输入时，将 FS 设置成 “:”。当这样做有问题时，我们还可以更灵活地使用 FS。</p>
<p>FS 值并没有被限制为单一字符；可以通过指定任意长度的字符模式，将它设置成规则表达式。如果正在处理由一个或多个 tab 分隔的字段，您可能希望按以下方式设置 FS：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FS=&quot;/t+&quot;</div></pre></td></tr></table></figure></p>
<p>以上示例中，我们使用特殊 “+” 规则表达式字符，它表示“一个或多个前一字符”。<br>如果字段由空格分隔（一个或多个空格或 tab），您可能想要将 FS 设置成以下规则表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FS=&quot;[[:space:]+]&quot;</div></pre></td></tr></table></figure></p>
<p>这个赋值表达式也有问题，它并非必要。为什么？因为缺省情况下，FS 设置成单一空格字符，awk 将这解释成表示“一个或多个空格或 tab”。在这个特殊示例中，缺省 FS 设置恰恰是您最想要的！<br>复杂的规则表达式也不成问题。即使您的记录由单词 “foo” 分隔，后面跟着三个数字，以下规则表达式仍允许对数据进行正确的分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FS=&quot;foo[0-9][0-9][0-9]&quot;</div></pre></td></tr></table></figure></p>
<h3 id="十二-字段数量"><a href="#十二-字段数量" class="headerlink" title="十二. 字段数量"></a>十二. 字段数量</h3><p>接着我们要讨论的两个变量通常并不是需要赋值的，而是用来读取以获取关于输入的有用信息。第一个是 NF 变量，也叫做“字段数量”变量。awk 会自动将该变量设置成当前记录中的字段数量。可以使用 NF 变量来只显示某些输入行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NF == 3 &#123; print &quot;this particular record has three fields: &quot; $0 &#125;</div></pre></td></tr></table></figure>
<p>当然，也可以在条件语句中使用 NF 变量，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">  if ( NF &gt; 2 ) &#123;</div><div class="line">    print $1 &quot; &quot; $2 &quot;:&quot; $3 </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="十三-记录号"><a href="#十三-记录号" class="headerlink" title="十三. 记录号"></a>十三. 记录号</h3><p>记录号 (NR) 是另一个方便的变量。它始终包含当前记录的编号（awk 将第一个记录算作记录号 1）。迄今为止，我们已经处理了每一行包含一个记录的输入文件。对于这些情况，NR 还会告诉您当前行号。然而，当我们在本系列以后部分中开始处理多行记录时，就不会再有这种情况，所以要注意！可以象使用 NF 变量一样使用 NR 来只打印某些输入行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(NR &lt; 10 ) || (NR &gt; 100) &#123; print &quot;We are on record number 1-9 or 101+&quot; &#125;</div></pre></td></tr></table></figure>
<p>另一个示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  if ( NR &gt; 10 ) &#123;</div><div class="line">    print &quot;ok, now for the real information!&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>awk 提供了适合各种用途的附加变量。我们将在以后的文章中讨论这些变量。</p>
<h3 id="十四-多行记录"><a href="#十四-多行记录" class="headerlink" title="十四. 多行记录"></a>十四. 多行记录</h3><p>awk 是一种用于读取和处理结构化数据（如系统的 /etc/passwd 文件）的极佳工具。/etc/passwd 是 UNIX 用户数据库，并且是用冒号定界的文本文件，它包含许多重要信息，包括所有现有用户帐户和用户标识，以及其它信息。在我的 前一篇文章 中，我演示了 awk 如何轻松地分析这个文件。我们只须将 FS（字段分隔符）变量设置成 “:”。</p>
<p>正确设置了 FS 变量之后，就可以将 awk 配置成分析几乎任何类型的结构化数据，只要这些数据是每行一个记录。然而，如果要分析占据多行的记录，仅仅依靠设置 FS 是不够的。在这些情况下，我们还需要修改 RS 记录分隔符变量。RS 变量告诉 awk 当前记录什么时候结束，新记录什么时候开始。</p>
<p>譬如，让我们讨论一下如何完成处理“联邦证人保护计划”所涉及人员的地址列表的任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> Jimmy the Weasel</div><div class="line">100 Pleasant Drive</div><div class="line">San Francisco, CA 12345</div><div class="line"></div><div class="line">Big Tony</div><div class="line">200 Incognito Ave.</div><div class="line">Suburbia, WA 67890</div></pre></td></tr></table></figure>
<p>理论上，我们希望 awk 将每 3 行看作是一个独立的记录，而不是三个独立的记录。如果 awk 将地址的第一行看作是第一个字段 ($1)，街道地址看作是第二个字段 ($2)，城市、州和邮政编码看作是第三个字段 $3，那么这个代码就会变得很简单。以下就是我们想要得到的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">FS=&quot;/n&quot;</div><div class="line">RS=&quot;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面这段代码中，将 FS 设置成 “/n” 告诉 awk 每个字段都占据一行。通过将 RS 设置成 “”，还会告诉 awk 每个地址记录都由空白行分隔。一旦 awk 知道是如何格式化输入的，它就可以为我们执行所有分析工作，脚本的其余部分很简单。让我们研究一个完整的脚本，它将分析这个地址列表，并将每个记录打印在一行上，用逗号分隔每个字段。</p>
<p>address.awk<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">  FS=&quot;/n&quot;</div><div class="line">  RS=&quot;&quot;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  print $1 &quot;, &quot; $2 &quot;, &quot; $3</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果这个脚本保存为 address.awk，地址数据存储在文件 address.txt 中，可以通过输入 “awk -f address.awk address.txt” 来执行这个脚本。此代码将产生以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Jimmy the Weasel, 100 Pleasant Drive, San Francisco, CA 12345</div><div class="line">Big Tony, 200 Incognito Ave., Suburbia, WA 67890</div></pre></td></tr></table></figure></p>
<h3 id="十五-OFS-和-ORS"><a href="#十五-OFS-和-ORS" class="headerlink" title="十五. OFS 和 ORS"></a>十五. OFS 和 ORS</h3><p>在 address.awk 的 print 语句中，可以看到 awk 会连接（合并）一行中彼此相邻的字符串。我们使用此功能在同一行上的三个字段之间插入一个逗号和空格 (“, “)。这个方法虽然有用，但比较难看。与其在字段间插入 “, “ 字符串，倒不如让通过设置一个特殊 awk 变量 OFS，让 awk 完成这件事。请参考下面这个代码片断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print &quot;Hello&quot;, &quot;there&quot;, &quot;Jim!&quot;</div></pre></td></tr></table></figure>
<p>这行代码中的逗号并不是实际文字字符串的一部分。事实上，它们告诉 awk “Hello”、”there” 和 “Jim!” 是单独的字段，并且应该在每个字符串之间打印 OFS 变量。缺省情况下，awk 产生以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello there Jim!</div></pre></td></tr></table></figure>
<p>这是缺省情况下的输出结果，OFS 被设置成 “ “，单个空格。不过，我们可以方便地重新定义 OFS，这样 awk 将插入我们中意的字段分隔符。以下是原始 address.awk 程序的修订版，它使用 OFS 来输出那些中间的 “, “ 字符串：</p>
<p>address.awk 的修订版 　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line"> FS=&quot;/n&quot;</div><div class="line"> RS=&quot;&quot;</div><div class="line"> OFS=&quot;, &quot;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line"> print $1, $2, $3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>awk 还有一个特殊变量 ORS，全称是“输出记录分隔符”。通过设置缺省为换行 (“/n”) 的 OFS，我们可以控制在 print 语句结尾自动打印的字符。缺省 ORS 值会使 awk 在新行中输出每个新的 print 语句。如果想使输出的间隔翻倍，可以将 ORS 设置成 “/n/n”。或者，如果想要用单个空格分隔记录（而不换行），将 ORS 设置成 “”。</p>
<p>将多行转换成用 tab 分隔的格式</p>
<p>假设我们编写了一个脚本，它将地址列表转换成每个记录一行，且用 tab 定界的格式，以便导入电子表格。使用稍加修改的 address.awk 之后，就可以清楚地看到这个程序只适合于三行的地址。如果 awk 遇到以下地址，将丢掉第四行，并且不打印该行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cousin Vinnie</div><div class="line">Vinnie&apos;s Auto Shop</div><div class="line">300 City Alley</div><div class="line">Sosueme, OR 76543</div></pre></td></tr></table></figure>
<p>要处理这种情况，代码最好考虑每个字段的记录数量，并依次打印每个记录。现在，代码只打印地址的前三个字段。以下就是我们想要的一些代码：</p>
<p>适合具有任意多字段的地址的 address.awk 版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">  FS=&quot;/n&quot;</div><div class="line">  RS=&quot;&quot;</div><div class="line">  ORS=&quot;&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">  x=1</div><div class="line">  while ( x&lt;NF ) &#123;</div><div class="line">   print $x &quot;/t&quot;</div><div class="line">   x++</div><div class="line">  &#125;</div><div class="line">  print $NF &quot;/n&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先，将字段分隔符 FS 设置成 “/n”，将记录分隔符 RS 设置成 “”，这样 awk 可以象以前一样正确分析多行地址。然后，将输出记录分隔符 ORS 设置成 “”，它将使 print 语句在每个调用结尾 不 输出新行。这意味着如果希望任何文本从新的一行开始，那么需要明确写入 print “/n” 。</p>
<p>在主代码块中，创建了一个变量 x 来存储正在处理的当前字段的编号。起初，它被设置成 1。然后，我们使用 while 循环（一种 awk 循环结构，等同于 C 语言中的 while 循环），对于所有记录（最后一个记录除外）重复打印记录和 tab 字符。最后，打印最后一个记录和换行；此外，由于将 ORS 设置成 “”，print 将不输出换行。程序输出如下，这正是我们所期望的：</p>
<p>我们想要的输出。不算漂亮，但用 tab 定界，以便于导入电子表格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Jimmy the Weasel 100 Pleasant Drive San Francisco, CA 12345 </div><div class="line">Big Tony 200 Incognito Ave. Suburbia, WA 67890</div><div class="line">Cousin Vinnie Vinnie Auto Shop 300 City Alley Sosueme, OR 76543</div></pre></td></tr></table></figure>
<h3 id="十六-循环结构"><a href="#十六-循环结构" class="headerlink" title="十六. 循环结构"></a>十六. 循环结构</h3><p>我们已经看到了 awk 的 while 循环结构，它等同于相应的 C 语言 while 循环。awk 还有 “do…while” 循环，它在代码块结尾处对条件求值，而不象标准 while 循环那样在开始处求值。它类似于其它语言中的 “repeat…until” 循环。以下是一个示例：</p>
<p>do…while 示例<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  count=1</div><div class="line">  do &#123;</div><div class="line">  print &quot;I get printed at least once no matter what&quot; </div><div class="line">  &#125; while ( count != 1 )</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与一般的 while 循环不同，由于在代码块之后对条件求值，”do…while” 循环永远都至少执行一次。换句话说，当第一次遇到普通 while 循环时，如果条件为假，将永远不执行该循环。</p>
<p>for 循环</p>
<p>awk 允许创建 for 循环，它就象 while 循环，也等同于 C 语言的 for 循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for ( initial assignment; comparison; increment ) &#123;</div><div class="line">code block</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是一个简短示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for ( x = 1; x &lt;= 4; x++ ) &#123;</div><div class="line">  print &quot;iteration&quot;,x</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此段代码将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iteration 1</div><div class="line">iteration 2</div><div class="line">iteration 3</div><div class="line">iteration 4</div></pre></td></tr></table></figure>
<p>十七. break 和 continue<br>此外，如同 C 语言一样，awk 提供了 break 和 continue 语句。使用这些语句可以更好地控制 awk 的循环结构。以下是迫切需要 break 语句的代码片断：</p>
<p>while 死循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (1) &#123;</div><div class="line">print &quot;forever and ever...&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>while 死循环 1 永远代表是真，这个 while 循环将永远运行下去。以下是一个只执行十次的循环：</p>
<p>break 语句示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x=1</div><div class="line">while(1) &#123;</div><div class="line">  print &quot;iteration&quot;,x</div><div class="line">  if ( x == 10 ) &#123;</div><div class="line">  break</div><div class="line">  &#125;</div><div class="line">  x++</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里，break 语句用于“逃出”最深层的循环。”break” 使循环立即终止，并继续执行循环代码块后面的语句。<br>continue 语句补充了 break，其作用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">x=1</div><div class="line">while (1) &#123;</div><div class="line">   if ( x == 4 ) &#123;</div><div class="line">   x++</div><div class="line">   continue</div><div class="line">   &#125;</div><div class="line">   print &quot;iteration&quot;,x</div><div class="line">   if ( x &gt; 20 ) &#123;</div><div class="line">   break</div><div class="line">   &#125;</div><div class="line">   x++</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码打印 “iteration 1” 到 “iteration 21”，”iteration 4” 除外。如果迭代等于 4，则增加 x 并调用 continue 语句，该语句立即使 awk 开始执行下一个循环迭代，而不执行代码块的其余部分。如同 break 一样，continue 语句适合各种 awk 迭代循环。在 for 循环主体中使用时，continue 将使循环控制变量自动增加。以下是一个等价循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for ( x=1; x&lt;=21; x++ ) &#123;</div><div class="line">  if ( x == 4 ) &#123;</div><div class="line">  continue</div><div class="line">  &#125;</div><div class="line">  print &quot;iteration&quot;,x&#125;</div></pre></td></tr></table></figure>
<p>在 while 循环中时，在调用 continue 之前没有必要增加 x ，因为 for 循环会自动增加 x 。</p>
<h3 id="十八-数组"><a href="#十八-数组" class="headerlink" title="十八. 数组"></a>十八. 数组</h3><p>如果您知道 awk 可以使用数组，您一定会感到高兴。然而，在 awk 中，数组下标通常从 1 开始，而不是 0：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myarray[1]=&quot;jim&quot;</div><div class="line">myarray[2]=456</div></pre></td></tr></table></figure>
<p>awk 遇到第一个赋值语句时，它将创建 myarray ，并将元素 myarray[1] 设置成 “jim”。执行了第二个赋值语句后，数组就有两个元素了。</p>
<ol>
<li>数组迭代</li>
</ol>
<p>定义之后，awk 有一个便利的机制来迭代数组元素，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">for ( x in myarray ) &#123;</div><div class="line">print myarray[x]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码将打印数组 myarray 中的每一个元素。当对于 for 使用这种特殊的 “in” 形式时，awk 将 myarray 的每个现有下标依次赋值给 x （循环控制变量），每次赋值以后都循环一次循环代码。虽然这是一个非常方便的 awk 功能，但它有一个缺点 – 当 awk 在数组下标之间轮转时，它不会依照任何特定的顺序。那就意味着我们不能知道以上代码的输出是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jim</div><div class="line">456</div></pre></td></tr></table></figure>
<p>还是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">456</div><div class="line">jim</div></pre></td></tr></table></figure>
<p>套用 Forrest Gump 的话来说，迭代数组内容就像一盒巧克力 – 您永远不知道将会得到什么。因此有必要使 awk 数组“字符串化”，我们现在就来研究这个问题。</p>
<ol>
<li>数组下标字符串化</li>
</ol>
<p>在我的前一篇文章 中，我演示了 awk 实际上以字符串格式来存储数字值。虽然 awk 要执行必要的转换来完成这项工作，但它却可以使用某些看起来很奇怪的代码：<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a=&quot;1&quot;</div><div class="line">b=&quot;2&quot;</div><div class="line">c=a+b+3</div></pre></td></tr></table></figure></p>
<p>执行了这段代码后， c 等于 6 。由于 awk 是“字符串化”的，添加字符串 “1” 和 “2” 在功能上并不比添加数字 1 和 2 难。这两种情况下，awk 都可以成功执行运算。awk 的“字符串化”性质非常可爱 – 您可能想要知道如果使用数组的字符串下标会发生什么情况。例如，使用以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">myarr[&quot;1&quot;]=&quot;Mr. Whipple&quot;</div><div class="line">print myarr[&quot;1&quot;]</div></pre></td></tr></table></figure></p>
<p>可以预料，这段代码将打印 “Mr. Whipple”。但如果去掉第二个 “1” 下标中的引号，情况又会怎样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myarr[&quot;1&quot;]=&quot;Mr. Whipple&quot;</div><div class="line">print myarr[1]</div></pre></td></tr></table></figure>
<p>猜想这个代码片断的结果比较难。awk 将 myarr[“1”] 和 myarr[1] 看作数组的两个独立元素，还是它们是指同一个元素？答案是它们指的是同一个元素，awk 将打印 “Mr. Whipple”，如同第一个代码片断一样。虽然看上去可能有点怪，但 awk 在幕后却一直使用数组的字符串下标！</p>
<p>了解了这个奇怪的真相之后，我们中的一些人可能想要执行类似于以下的古怪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myarr[&quot;name&quot;]=&quot;Mr. Whipple&quot;</div><div class="line">print myarr[&quot;name&quot;]</div></pre></td></tr></table></figure>
<p>这段代码不仅不会产生错误，而且它的功能与前面的示例完全相同，也将打印 “Mr. Whipple”！可以看到，awk 并没有限制我们使用纯整数下标；如果我们愿意，可以使用字符串下标，而且不会产生任何问题。只要我们使用非整数数组下标，如 myarr[“name”] ，那么我们就在使用 关联数组 。从技术上讲，如果我们使用字符串下标，awk 的后台操作并没有什么不同（因为即便使用“整数”下标，awk 还是会将它看作是字符串）。但是，应该将它们称作 关联数组 – 它听起来很酷，而且会给您的上司留下印象。字符串化下标是我们的小秘密。;)</p>
<ol>
<li>数组工具</li>
</ol>
<p>谈到数组时，awk 给予我们许多灵活性。可以使用字符串下标，而且不需要连续的数字序列下标（例如，可以定义 myarr[1] 和 myarr[1000] ，但不定义其它所有元素）。虽然这些都很有用，但在某些情况下，会产生混淆。幸好，awk 提供了一些实用功能有助于使数组变得更易于管理。</p>
<p>首先，可以删除数组元素。如果想要删除数组 fooarray 的元素 1 ，输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete fooarray[1]</div></pre></td></tr></table></figure>
<p>而且，如果想要查看是否存在某个特定数组元素，可以使用特殊的 “in” 布尔运算符，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ( 1 in fooarray ) &#123;</div><div class="line">print &quot;Ayep! It&apos;s there.&quot;</div><div class="line">&#125; else &#123;</div><div class="line">print &quot;Nope! Can&apos;t find it.&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="十九-格式化输出"><a href="#十九-格式化输出" class="headerlink" title="十九. 格式化输出"></a>十九. 格式化输出</h3><p>在这篇 awk 系列的总结中，Daniel 向您介绍 awk 重要的字符串函数，以及演示了如何从头开始编写完整的支票簿结算程序。在这个过程中，您将学习如何编写自己的函数，并使用 awk 的多维数组。学完本文之后，您将掌握更多 awk 经验，可以让您创建功能更强大的脚本。</p>
<p>虽然大多数情况下 awk 的 print 语句可以完成任务，但有时我们还需要更多。在那些情况下，awk 提供了两个我们熟知的老朋友 printf() 和 sprintf()。是的，如同其它许多 awk 部件一样，这些函数等同于相应的 C 语言函数。printf() 会将格式化字符串打印到 stdout，而 sprintf() 则返回可以赋值给变量的格式化字符串。如果不熟悉 printf() 和 sprintf()，介绍 C 语言的文章可以让您迅速了解这两个基本打印函数。在 Linux 系统上，可以输入 “man 3 printf” 来查看 printf() 帮助页面。</p>
<p>以下是一些 awk sprintf() 和 printf() 的样本代码。可以看到，它们几乎与 C 语言完全相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x=1</div><div class="line">b=&quot;foo&quot;</div><div class="line">printf(&quot;%s got a %d on the last test/n&quot;,&quot;Jim&quot;,83)</div><div class="line">myout=(&quot;%s-%d&quot;,b,x)</div><div class="line">print myout</div></pre></td></tr></table></figure>
<p>此代码将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Jim got a 83 on the last test</div><div class="line">foo-1</div></pre></td></tr></table></figure>
<h3 id="二十-字符串函数"><a href="#二十-字符串函数" class="headerlink" title="二十. 字符串函数"></a>二十. 字符串函数</h3><p>awk 有许多字符串函数，这是件好事。在 awk 中，确实需要字符串函数，因为不能象在其它语言（如 C、C++ 和 Python）中那样将字符串看作是字符数组。例如，如果执行以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mystring=&quot;How are you doing today?&quot;</div><div class="line">print mystring[3]</div></pre></td></tr></table></figure>
<p>将会接收到一个错误，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk: string.gawk:59: fatal: attempt to use scalar as array</div></pre></td></tr></table></figure>
<p>噢，好吧。虽然不象 Python 的序列类型那样方便，但 awk 的字符串函数还是可以完成任务。让我们来看一下。<br>首先，有一个基本 length() 函数，它返回字符串的长度。以下是它的使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print length(mystring)</div></pre></td></tr></table></figure></p>
<p>此代码将打印值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">24</div></pre></td></tr></table></figure>
<p>好，继续。下一个字符串函数叫作 index，它将返回子字符串在另一个字符串中出现的位置，如果没有找到该字符串则返回 0。使用 mystring，可以按以下方法调用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print index(mystring,&quot;you&quot;)</div></pre></td></tr></table></figure>
<p>awk 会打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">9</div></pre></td></tr></table></figure>
<p>让我们继续讨论另外两个简单的函数，tolower() 和 toupper()。与您猜想的一样，这两个函数将返回字符串并且将所有字符分别转换成小写或大写。请注意，tolower() 和 toupper() 返回新的字符串，不会修改原来的字符串。这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print tolower(mystring)</div><div class="line">print toupper(mystring)</div><div class="line">print mystring</div></pre></td></tr></table></figure>
<p>……将产生以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">how are you doing today?</div><div class="line">HOW ARE YOU DOING TODAY?</div><div class="line">How are you doing today?</div></pre></td></tr></table></figure>
<p>到现在为止一切不错，但我们究竟如何从字符串中选择子串，甚至单个字符？那就是使用 substr() 的原因。以下是 substr() 的调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysub=substr(mystring,startpos,maxlen)</div></pre></td></tr></table></figure>
<p>mystring 应该是要从中抽取子串的字符串变量或文字字符串。startpos 应该设置成起始字符位置，maxlen 应该包含要抽取的字符串的最大长度。请注意，我说的是 最大长度 ；如果 length(mystring) 比 startpos+maxlen 短，那么得到的结果就会被截断。substr() 不会修改原始字符串，而是返回子串。以下是一个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print substr(mystring,9,3)</div></pre></td></tr></table></figure>
<p>awk 将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">you</div></pre></td></tr></table></figure>
<p>如果您通常用于编程的语言使用数组下标访问部分字符串（以及不使用这种语言的人），请记住 substr() 是 awk 代替方法。需要使用它来抽取单个字符和子串；因为 awk 是基于字符串的语言，所以会经常用到它。</p>
<p>现在，我们讨论一些更耐人寻味的函数，首先是 match()。match() 与 index() 非常相似，它与 index() 的区别在于它并不搜索子串，它搜索的是规则表达式。match() 函数将返回匹配的起始位置，如果没有找到匹配，则返回 0。此外，match() 还将设置两个变量，叫作 RSTART 和 RLENGTH。RSTART 包含返回值（第一个匹配的位置），RLENGTH 指定它占据的字符跨度（如果没有找到匹配，则返回 -1）。通过使用 RSTART、RLENGTH、substr() 和一个小循环，可以轻松地迭代字符串中的每个匹配。以下是一个 match() 调用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print match(mystring,/you/), RSTART, RLENGTH</div></pre></td></tr></table></figure>
<p>awk 将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">9 9 3</div></pre></td></tr></table></figure>
<p>字符串替换</p>
<p>现在，我们将研究两个字符串替换函数，sub() 和 gsub()。这些函数与目前已经讨论过的函数略有不同，因为它们 确实修改原始字符串 。以下是一个模板，显示了如何调用 sub()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub(regexp,replstring,mystring)</div></pre></td></tr></table></figure>
<p>调用 sub() 时，它将在 mystring 中匹配 regexp 的第一个字符序列，并且用 replstring 替换该序列。sub() 和 gsub() 用相同的自变量；唯一的区别是 sub() 将替换第一个 regexp 匹配（如果有的话），gsub() 将执行全局替换，换出字符串中的所有匹配。以下是一个 sub() 和 gsub() 调用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub(/o/,&quot;O&quot;,mystring)</div><div class="line">print mystring</div><div class="line">mystring=&quot;How are you doing today?&quot;</div><div class="line">gsub(/o/,&quot;O&quot;,mystring)</div><div class="line">print mystring</div></pre></td></tr></table></figure>
<p>必须将 mystring 复位成其初始值，因为第一个 sub() 调用直接修改了 mystring。在执行时，此代码将使 awk 输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HOw are you doing today?</div><div class="line">HOw are yOu dOing tOday?</div></pre></td></tr></table></figure>
<p>当然，也可以是更复杂的规则表达式。我把测试一些复杂规则表达式的任务留给您来完成。</p>
<p>通过介绍函数 split()，我们来汇总一下已讨论过的函数。split() 的任务是“切开”字符串，并将各部分放到使用整数下标的数组中。以下是一个 split() 调用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numelements=split(&quot;Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec&quot;,mymonths,&quot;,&quot;)</div></pre></td></tr></table></figure>
<p>调用 split() 时，第一个自变量包含要切开文字字符串或字符串变量。在第二个自变量中，应该指定 split() 将填入片段部分的数组名称。在第三个元素中，指定用于切开字符串的分隔符。split() 返回时，它将返回分割的字符串元素的数量。split() 将每一个片段赋值给下标从 1 开始的数组，因此以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print mymonths[1],mymonths[numelements]</div></pre></td></tr></table></figure>
<p>……将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Jan Dec</div></pre></td></tr></table></figure>
<p>特殊字符串形式</p>
<p>简短注释 – 调用 length()、sub() 或 gsub() 时，可以去掉最后一个自变量，这样 awk 将对 $0（整个当前行）应用函数调用。要打印文件中每一行的长度，使用以下 awk 脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">print length()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二十一-财务上的趣事"><a href="#二十一-财务上的趣事" class="headerlink" title="二十一. 财务上的趣事"></a>二十一. 财务上的趣事</h3><p>几星期前，我决定用 awk 编写自己的支票簿结算程序。我决定使用简单的 tab 定界文本文件，以便于输入最近的存款和提款记录。其思路是将这个数据交给 awk 脚本，该脚本会自动合计所有金额，并告诉我余额。以下是我决定如何将所有交易记录到 “ASCII checkbook” 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">23 Aug 2000 food - - Y Jimmy&apos;s Buffet 30.25</div></pre></td></tr></table></figure>
<p>此文件中的每个字段都由一个或多个 tab 分隔。在日期（字段 1，$1）之后，有两个字段叫做“费用分类帐”和“收入分类帐”。以上面这行为例，输入费用时，我在费用字段中放入四个字母的别名，在收入字段中放入 “-“（空白项）。这表示这一特定项是“食品费用”。:) 以下是存款的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">23 Aug 2000 - inco - Y Boss Man 2001.00</div></pre></td></tr></table></figure>
<p>在这个实例中，我在费用分类帐中放入 “-“（空白），在收入分类帐中放入 “inco”。”inco” 是一般（薪水之类）收入的别名。使用分类帐别名让我可以按类别生成收入和费用的明细分类帐。至于记录的其余部分，其它所有字段都是不需加以说明的。“是否付清？”字段（”Y” 或 “N”）记录了交易是否已过帐到我的帐户；除此之外，还有一个交易描述，和一个正的美元金额。</p>
<p>用于计算当前余额的算法不太难。awk 只需要依次读取每一行。如果列出了费用分类帐，但没有收入分类帐（为 “-“），那么这一项就是借方。如果列出了收入分类帐，但没有费用分类帐（为 “-“），那么这一项就是贷方。而且，如果同时列出了费用和收入分类帐，那么这个金额就是“分类帐转帐”；即，从费用分类帐减去美元金额，并将此金额添加到收入分类帐。此外，所有这些分类帐都是虚拟的，但对于跟踪收入和支出以及预算却非常有用。</p>
<p>代码</p>
<p>现在该研究代码了。我们将从第一行（BEGIN 块和函数定义）开始：</p>
<p>balance，第 1 部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env awk -f</div><div class="line">BEGIN &#123; </div><div class="line">FS=&quot;/t+&quot;</div><div class="line">months=&quot;Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&quot;</div><div class="line">&#125;</div><div class="line">function monthdigit(mymonth) &#123;</div><div class="line">return (index(months,mymonth)+3)/4</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先执行 “chmod +x myscript” 命令，那么将第一行 “#!…” 添加到任何 awk 脚本将使它可以直接从 shell 中执行。其余行定义了 BEGIN 块，在 awk 开始处理支票簿文件之前将执行这个代码块。我们将 FS（字段分隔符）设置成 “/t+”，它会告诉 awk 字段由一个或多个 tab 分隔。另外，我们定义了字符串 months，下面将出现的 monthdigit() 函数将使用它。</p>
<p>最后三行显示了如何定义自己的 awk 。格式很简单 – 输入 “function”，再输入名称，然后在括号中输入由逗号分隔的参数。在此之后，”{ }” 代码块包含了您希望这个函数执行的代码。所有函数都可以访问全局变量（如 months 变量）。另外，awk 提供了 “return” 语句，它允许函数返回一个值，并执行类似于 C 和其它语言中 “return” 的操作。这个特定函数将以 3 个字母字符串格式表示的月份名称转换成等价的数值。例如，以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print monthdigit(&quot;Mar&quot;)</div></pre></td></tr></table></figure>
<p>……将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3</div></pre></td></tr></table></figure>
<p>现在，让我们讨论其它一些函数。</p>
<p>财务函数</p>
<p>以下是其它三个执行簿记的函数。我们即将见到的主代码块将调用这些函数之一，按顺序处理支票簿文件的每一行，从而将相应交易记录到 awk 数组中。有三种基本交易，贷方 (doincome)、借方 (doexpense) 和转帐 (dotransfer)。您会发现这三个函数全都接受一个自变量，叫作 mybalance。mybalance 是二维数组的一个占位符，我们将它作为自变量进行传递。目前，我们还没有处理过二维数组；但是，在下面可以看到，语法非常简单。只须用逗号分隔每一维就行了。</p>
<p>我们将按以下方式将信息记录到 “mybalance” 中。数组的第一维从 0 到 12，用于指定月份，0 代表全年。第二维是四个字母的分类帐，如 “food” 或 “inco”；这是我们处理的真实分类帐。因此，要查找全年食品分类帐的余额，应查看 mybalance[0,”food”]。要查找 6 月的收入，应查看 mybalance[6,”inco”]。</p>
<p>balance，第 2 部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function doincome(mybalance) &#123;</div><div class="line">mybalance[curmonth,$3] += amount</div><div class="line">mybalance[0,$3] += amount</div><div class="line">&#125;</div><div class="line">function doexpense(mybalance) &#123;</div><div class="line">mybalance[curmonth,$2] -= amount</div><div class="line">mybalance[0,$2] -= amount</div><div class="line">&#125;</div><div class="line">function dotransfer(mybalance) &#123;</div><div class="line">mybalance[0,$2] -= amount</div><div class="line">mybalance[curmonth,$2] -= amount</div><div class="line">mybalance[0,$3] += amount</div><div class="line">mybalance[curmonth,$3] += amount</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 doincome() 或任何其它函数时，我们将交易记录到两个位置 – mybalance[0,category] 和 mybalance[curmonth, category]，它们分别表示全年的分类帐余额和当月的分类帐余额。这让我们稍后可以轻松地生成年度或月度收入／支出明细分类帐。</p>
<p>如果研究这些函数，将发现在我的引用中传递了 mybalance 引用的数组。另外，我们还引用了几个全局变量：curmonth，它保存了当前记录所属的月份的数值，$2（费用分类帐），$3（收入分类帐）和金额（$7，美元金额）。调用 doincome() 和其它函数时，已经为要处理的当前记录（行）正确设置了所有这些变量。</p>
<p>主块</p>
<p>以下是主代码块，它包含了分析每一行输入数据的代码。请记住，由于正确设置了 FS，可以用 $ 1 引用第一个字段，用 $2 引用第二个字段，依次类推。调用 doincome() 和其它函数时，这些函数可以从函数内部访问 curmonth、$2、$3 和金额的当前值。请先研究代码，在代码之后可以见到我的说明。</p>
<p>balance，第 3 部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">curmonth=monthdigit(substr($1,4,3))</div><div class="line">amount=$7</div><div class="line"></div><div class="line">#record all the categories encountered</div><div class="line">if ( $2 != &quot;-&quot; ) globcat[$2]=&quot;yes&quot;</div><div class="line">if ( $3 != &quot;-&quot; ) globcat[$3]=&quot;yes&quot;</div><div class="line">#tally up the transaction properly</div><div class="line">if ( $2 == &quot;-&quot; ) &#123;</div><div class="line">  if ( $3 == &quot;-&quot; ) &#123;</div><div class="line">  print &quot;Error: inc and exp fields are both blank!&quot;</div><div class="line">  exit 1</div><div class="line">  &#125; else &#123;</div><div class="line">  #this is income</div><div class="line">  doincome(balance)</div><div class="line">  if ( $5 == &quot;Y&quot; )   doincome(balance2)</div><div class="line">  &#125;</div><div class="line">&#125; </div><div class="line">else if ( $3 == &quot;-&quot; ) &#123;</div><div class="line">  #this is an expense </div><div class="line">  doexpense(balance)</div><div class="line">  if ( $5 == &quot;Y&quot; )   doexpense(balance2)</div><div class="line">  &#125; else &#123;</div><div class="line">  #this is a transfer</div><div class="line">  dotransfer(balance)</div><div class="line">  if ( $5 == &quot;Y&quot; )   dotransfer(balance2)</div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在主块中，前两行将 curmonth 设置成 1 到 12 之间的整数，并将金额设置成字段 7（使代码易于理解）。然后，是四行有趣的代码，它们将值写到数组 globcat 中。globcat，或称作全局分类帐数组，用于记录在文件中遇到的所有分类帐 – “inco”、”misc”、”food”、”util” 等。例如，如果 $2 == “inco”，则将 globcat[“inco”] 设置成 “yes”。稍后，我们可以使用简单的 “for (x in globcat)” 循环来迭代分类帐列表。</p>
<p>在接着的大约二十行中，我们分析字段 $2 和 $3，并适当记录交易。如果 $2==”-“ 且 $3!=”-“，表示我们有收入，因此调用 doincome()。如果是相反的情况，则调用 doexpense()；如果 $2 和 $3 都包含分类帐，则调用 dotransfer()。每次我们都将 “balance” 数组传递给这些函数，从而在这些函数中记录适当的数据。</p>
<p>您还会发现几行代码说“if ( $5 == “Y” )，那么将同一个交易记录到 balance2 中”。我们在这里究竟做了些什么？您将回忆起 $5 包含 “Y” 或 “N”，并记录交易是否已经过帐到帐户。由于仅当过帐了交易时我们才将交易记录到 balance2，因此 balance2 包含了真实的帐户余额，而 “balance” 包含了所有交易，不管是否已经过帐。可以使用 balance2 来验证数据项（因为它应该与当前银行帐户余额匹配），可以使用 “balance” 来确保没有透支帐户（因为它会考虑您开出的尚未兑现的所有支票）。</p>
<p>生成报表</p>
<p>主块重复处理了每一行记录之后，现在我们有了关于比较全面的、按分类帐和按月份划分的借方和贷方记录。现在，在这种情况下最合适的做法是只须定义生成报表的 END 块：</p>
<p>balance，第 4 部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">END &#123;</div><div class="line">bal=0</div><div class="line">bal2=0</div><div class="line">for (x in globcat) &#123;</div><div class="line">bal=bal+balance[0,x]</div><div class="line">bal2=bal2+balance2[0,x]</div><div class="line">&#125;</div><div class="line">printf(&quot;Your available funds: %10.2f/n&quot;, bal)</div><div class="line">printf(&quot;Your account balance: %10.2f/n&quot;, bal2)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个报表将打印出汇总，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Your available funds:1174.22</div><div class="line">Your account balance:2399.33</div></pre></td></tr></table></figure>
<p>在 END 块中，我们使用 “for (x in globcat)” 结构来迭代每一个分类帐，根据记录在案的交易结算主要余额。实际上，我们结算两个余额，一个是可用资金，另一个是帐户余额。要执行程序并处理您在文件 “mycheckbook.txt” 中输入的财务数据，将以上所有代码放入文本文件 “balance”，执行 “chmod +x balance”，然后输入 “./balance mycheckbook.txt”。然后 balance 脚本将合计所有交易，打印出两行余额汇总。</p>
<p>升级</p>
<p>我使用这个程序的更高级版本来管理我的个人和企业财务。我的版本（由于篇幅限制不能在此涵盖）会打印出收入和费用的月度明细分类帐，包括年度总合、净收入和其它许多内容。它甚至以 HTML 格式输出数据，因此我可以在 Web 浏览器中查看它。:) 如果您认为这个程序有用，我建议您将这些特性添加到这个脚本中。不必将它配置成要 记录 任何附加信息；所需的全部信息已经在 balance 和 balance2 里面了。只要升级 END 块就万事具备了！</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag">#Linux</a>
          
            <a href="/tags/Shell/" rel="tag">#Shell</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/01/23/Shell学习之Sed/" rel="prev">Shell--Sed</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/29/Spring源码：核心容器/" rel="next">Spring源码：核心容器</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div>
      
        <style type="text/css">

    .donate_bar {
        text-align: center;
        margin-top : 5%;
    }

    .donate_bar.hidden {
        display:none;
    }
/*
    .donate_bar a.btn_donate {
        display: inline-block;
        width: 82px;
        height: 82px;
        margin-left:auto;
        margin-right:auto;

        background: url("http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif") no-repeat;
        _background: url("http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif") no-repeat; 

        -webkit-transition: background 0s;
        -moz-transition: background 0s;
        -o-transition: background 0s;
        -ms-transition: background 0s;
        transition: background 0s;
    }
*/
    .donate_bar a.btn_donate:hover { 
        // background-position: 0px -82px;
        color: #87daff
    }

    .donate_bar .donate_txt {
        display: block;
        color: #9d9d9d;
        font: 14px/2 "Microsoft Yahei";
    }

    .bold { 
        font-weight: bold; 
    }

    .post-donate a {
        border-bottom: 0px;
    }

    #donate_guide table {
        border: none;
    }

    #donate_guide td {
        border-bottom: none;
        border-right: none;
        background: #333333;
        valign: top;
    }

</style>



    

    <div class ="post-donate">
        <div id="donate_board" class="donate_bar center">
              <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏">赏</a>
              <span id="donate_txt" class="donate_txt">
                   
                        仅仅是一个功能
                   
              </span>
            <br>
        </div>  
  
        <div id="donate_guide" class="donate_bar center hidden">
            <!--
            
                <a href="http://o7keinrz4.bkt.clouddn.com/alipay.jpg" title="支付宝打赏" class="fancybox" rel="article0" 
                    style="float:left;margin-left:25%;margin-right:10px;">
                    <img src="http://o7keinrz4.bkt.clouddn.com/alipay.jpg" title="" height="164px" width="164px">
                </a> 
              

            
                <a href="http://a1.qpic.cn/psb?/V14YOoud1BGVTo/jixVOczWkObdtwZ3pmS3REM285bhwg3q*z0ZzUGUjWc!/c/dAgBAAAAAAAA&ek=1&kp=1&pt=0&bo=rgGuAQAAAAABACc!&sce=60-2-2&rf=0-0" title="微信打赏" class="fancybox" rel="article0"
                    style="margin-right:30%">
                    <img src="http://a1.qpic.cn/psb?/V14YOoud1BGVTo/jixVOczWkObdtwZ3pmS3REM285bhwg3q*z0ZzUGUjWc!/c/dAgBAAAAAAAA&ek=1&kp=1&pt=0&bo=rgGuAQAAAAABACc!&sce=60-2-2&rf=0-0" title="" height="164px" width="164px">
                </a>
            
            -->
            <table>
                <tr>
                    <td>
                        
                            <a href="http://o7keinrz4.bkt.clouddn.com/alipay.jpg" title="支付宝打赏" class="fancybox" rel="article0" 
                                style="float:left;margin-left:25%;margin-right:10px;">
                                <img src="http://o7keinrz4.bkt.clouddn.com/alipay.jpg" title="" height="164px" width="164px">
                            </a> 
                         
                    </td>
                    <td>
                        
                            <a href="http://a1.qpic.cn/psb?/V14YOoud1BGVTo/jixVOczWkObdtwZ3pmS3REM285bhwg3q*z0ZzUGUjWc!/c/dAgBAAAAAAAA&ek=1&kp=1&pt=0&bo=rgGuAQAAAAABACc!&sce=60-2-2&rf=0-0" title="微信打赏" class="fancybox" rel="article0"
                                style="margin-right:30%">
                                <img src="http://a1.qpic.cn/psb?/V14YOoud1BGVTo/jixVOczWkObdtwZ3pmS3REM285bhwg3q*z0ZzUGUjWc!/c/dAgBAAAAAAAA&ek=1&kp=1&pt=0&bo=rgGuAQAAAAABACc!&sce=60-2-2&rf=0-0" title="" height="164px" width="164px">
                            </a>
                        
                    </td>
                </tr>
            </table>

        </div>

        <script type="text/javascript">
            document.getElementById('btn_donate').onclick = function() {
                $('#donate_board').addClass('hidden');
                // $('#donate_guide').removeClass('hidden');
                $('#donate_guide').show(2000);
            }

        </script>
    </div>

    


      
    </div>

    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>

 </div>

        
            <!-- 多说热评文章-->
            <p>热评文章</p>
            <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>
        

        
          <div class="comments" id="comments">
            
              <div class="ds-thread" data-thread-key="2017/01/22/Shell学习之Awk/"
                   data-title="Shell--Awk" data-url="https://fudawei.github.io/2017/01/22/Shell学习之Awk/">
              </div>
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="冰鸟" itemprop="image"/>
          <p class="site-author-name" itemprop="name">冰鸟</p>
        </div>
        <p class="site-description motion-element" itemprop="description">我们整天忙忙碌碌，像一群群没有灵魂的苍蝇，喧闹着，躁动着，听不到灵魂深处的声音。时光流逝，童年远去，我们渐渐长大，岁月带走了许许多多的回忆，也消蚀了心底曾经拥有的那份童稚的纯真，我们不顾心灵桎梏，沉溺于人世浮华，专注于利益法则，我们把自己弄丢了。</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">140</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">40</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">74</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fudw1987" target="_blank">GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/fu-da-wei-70" target="_blank">知乎</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://t.qq.com/fudw764923019" target="_blank">微博</a>
              </span>
            
          
        </div>

        <div class="links-of-friendly motion-element">
          
        </div>

        
        

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一-第一个-awk"><span class="nav-number">2.</span> <span class="nav-text">一. 第一个 awk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-多个字段"><span class="nav-number">3.</span> <span class="nav-text">二. 多个字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-外部脚本"><span class="nav-number">4.</span> <span class="nav-text">三. 外部脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-BEGIN-和-END-块"><span class="nav-number">5.</span> <span class="nav-text">四. BEGIN 和 END 块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五-规则表达式和块"><span class="nav-number">6.</span> <span class="nav-text">五. 规则表达式和块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六-表达式和块"><span class="nav-number">7.</span> <span class="nav-text">六. 表达式和块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七-条件语句"><span class="nav-number">8.</span> <span class="nav-text">七. 条件语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八-数值变量！"><span class="nav-number">9.</span> <span class="nav-text">八. 数值变量！</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九-字符串化变量"><span class="nav-number">10.</span> <span class="nav-text">九. 字符串化变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十-众多运算符"><span class="nav-number">11.</span> <span class="nav-text">十. 众多运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十一-字段分隔符"><span class="nav-number">12.</span> <span class="nav-text">十一. 字段分隔符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十二-字段数量"><span class="nav-number">13.</span> <span class="nav-text">十二. 字段数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十三-记录号"><span class="nav-number">14.</span> <span class="nav-text">十三. 记录号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十四-多行记录"><span class="nav-number">15.</span> <span class="nav-text">十四. 多行记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十五-OFS-和-ORS"><span class="nav-number">16.</span> <span class="nav-text">十五. OFS 和 ORS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十六-循环结构"><span class="nav-number">17.</span> <span class="nav-text">十六. 循环结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十八-数组"><span class="nav-number">18.</span> <span class="nav-text">十八. 数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十九-格式化输出"><span class="nav-number">19.</span> <span class="nav-text">十九. 格式化输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二十-字符串函数"><span class="nav-number">20.</span> <span class="nav-text">二十. 字符串函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二十一-财务上的趣事"><span class="nav-number">21.</span> <span class="nav-text">二十一. 财务上的趣事</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2017
  </span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冰鸟
  </span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme by <a class="theme-link" href="https://github.com/fudawei">fudawei</a>
</div>
 &nbsp; |  &nbsp; 

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
  &nbsp; |  &nbsp; 
<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>

<!-- busuanzi -->



 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"fudawei"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>

<!-- custom analytics part create by xiamo -->
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("SbuO6UqesUpwpVQpFOF85w4b-gzGzoHsz", "nU6WMv6iTcTpjLHKtOIoovuO");</script>
<script>
function showTime(Counter) {
	var query = new AV.Query(Counter);
	$(".leancloud_visitors").each(function() {
		var url = $(this).attr("id").trim();
		query.equalTo("url", url);
		query.find({
			success: function(results) {
				if (results.length == 0) {
					var content = '0 ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
					return;
				}
				for (var i = 0; i < results.length; i++) {
					var object = results[i];
					var content = object.get('time') + ' ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
				}
			},
			error: function(object, error) {
				console.log("Error: " + error.code + " " + error.message);
			}
		});

	});
}

function addCount(Counter) {
	var Counter = AV.Object.extend("Counter");
	url = $(".leancloud_visitors").attr('id').trim();
	title = $(".leancloud_visitors").attr('data-flag-title').trim();
	var query = new AV.Query(Counter);
	query.equalTo("url", url);
	query.find({
		success: function(results) {
			if (results.length > 0) {
				var counter = results[0];
				counter.fetchWhenSave(true);
				counter.increment("time");
				counter.save(null, {
					success: function(counter) {
						var content =  counter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(counter, error) {
						console.log('Failed to save Visitor num, with error message: ' + error.message);
					}
				});
			} else {
				var newcounter = new Counter();
				newcounter.set("title", title);
				newcounter.set("url", url);
				newcounter.set("time", 1);
				newcounter.save(null, {
					success: function(newcounter) {
					    console.log("newcounter.get('time')="+newcounter.get('time'));
						var content = newcounter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(newcounter, error) {
						console.log('Failed to create');
					}
				});
			}
		},
		error: function(error) {
			console.log('Error:' + error.code + " " + error.message);
		}
	});
}
$(function() {
	var Counter = AV.Object.extend("Counter");
	if ($('.leancloud_visitors').length == 1) {
		addCount(Counter);
	} else if ($('.post-title-link').length > 1) {
		showTime(Counter);
	}
}); 
</script>


</body>
</html>
