<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冰鸟</title>
  <subtitle>冰鸟-博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fudawei.github.io/"/>
  <updated>2017-02-08T06:30:38.569Z</updated>
  <id>https://fudawei.github.io/</id>
  
  <author>
    <name>冰鸟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Synchronized实现原理以及底层优化</title>
    <link href="https://fudawei.github.io/2017/02/07/Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96/"/>
    <id>https://fudawei.github.io/2017/02/07/Synchronized实现原理以及底层优化/</id>
    <published>2017-02-07T02:30:02.000Z</published>
    <updated>2017-02-08T06:30:38.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Synchronized的基本使用和原理"><a href="#Synchronized的基本使用和原理" class="headerlink" title="Synchronized的基本使用和原理"></a>Synchronized的基本使用和原理</h2><h3 id="一、synchronized的使用"><a href="#一、synchronized的使用" class="headerlink" title="一、synchronized的使用"></a>一、synchronized的使用</h3><ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<h3 id="二、Synchronized-原理"><a href="#二、Synchronized-原理" class="headerlink" title="二、Synchronized 原理"></a>二、Synchronized 原理</h3><p>我们先从一个实例来看一下Synchronized原理，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedDemo &#123;</div><div class="line">     public void method() &#123;</div><div class="line">         synchronized (this) &#123;</div><div class="line">             System.out.println(&quot;Method 1 start&quot;);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们先通过反编译下面的代码来看看Synchronized是如何实现对代码块进行同步的：<br><img src="/img/synchronized/synchronized-1.png" alt=""></p>
<p>关于这两条指令的作用，我们直接参考JVM规范中描述：<br>monitorenter ：</p>
<blockquote>
<pre><code>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:

• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.

• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.

• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor&apos;s entry count is zero, then tries again to gain ownership.
</code></pre></blockquote>
<p>这段话的大概意思为：</p>
<p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<ul>
<li><p>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>
</li>
<li><p>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p>
</li>
<li><p>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
</li>
</ul>
<p>monitorexit：</p>
<blockquote>
<p>  The thread that executes monitorexit must be the owner of the monitor associated    &gt;   with the instance referenced by objectref.<br>  The thread decrements the entry count of the monitor associated with objectref. If<br>  as a result the value of the entry count is zero, the thread exits the monitor and<br>  is no longer its owner. Other threads that are blocking to enter the monitor are<br>  allowed to attempt to do so.</p>
</blockquote>
<p>这段话的大概意思为：</p>
<p>执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p>
<p>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p>
<p>　　通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p>
<p>　　我们再来看一下同步方法的反编译结果：</p>
<p>源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedMethod &#123;</div><div class="line">    public synchronized void method() &#123;</div><div class="line">        System.out.println(&quot;Hello World!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>反编译结果：<br><img src="/img/synchronized/synchronized-2.png" alt=""><br>　从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</p>
<h3 id="三、运行结果解释"><a href="#三、运行结果解释" class="headerlink" title="三、运行结果解释"></a>三、运行结果解释</h3><p>　　有了对Synchronized原理的认识，再来看上面的程序就可以迎刃而解了。</p>
<p>1、代码段一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> public class SynchronizedTest &#123;</div><div class="line"></div><div class="line">     public synchronized void method1()&#123;</div><div class="line">         System.out.println(&quot;Method 1 start&quot;);</div><div class="line">         try &#123;</div><div class="line">             System.out.println(&quot;Method 1 execute&quot;);</div><div class="line">             Thread.sleep(3000);</div><div class="line">         &#125; catch (InterruptedException e) &#123;</div><div class="line">             e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">         System.out.println(&quot;Method 1 end&quot;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     public synchronized void method2()&#123;</div><div class="line">         System.out.println(&quot;Method 2 start&quot;);</div><div class="line">         try &#123;</div><div class="line">             System.out.println(&quot;Method 2 execute&quot;);</div><div class="line">             Thread.sleep(1000);</div><div class="line">         &#125; catch (InterruptedException e) &#123;</div><div class="line">             e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">         System.out.println(&quot;Method 2 end&quot;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     public static void main(String[] args) &#123;</div><div class="line">         final SynchronizedTest test = new SynchronizedTest();</div><div class="line">         new Thread(new Runnable() &#123;</div><div class="line">             @Override</div><div class="line">             public void run() &#123;</div><div class="line">                 test.method1();</div><div class="line">             &#125;</div><div class="line">         &#125;).start();</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                test.method2();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　虽然method1和method2是不同的方法，但是这两个方法都进行了同步，并且是通过同一个对象去调用的，所以调用之前都需要先去竞争同一个对象上的锁（monitor），也就只能互斥的获取到锁，因此，method1和method2只能顺序的执行。</p>
<p>2、代码段2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedTest &#123;</div><div class="line"></div><div class="line">     public static synchronized void method1()&#123;</div><div class="line">         System.out.println(&quot;Method 1 start&quot;);</div><div class="line">         try &#123;</div><div class="line">             System.out.println(&quot;Method 1 execute&quot;);</div><div class="line">             Thread.sleep(3000);</div><div class="line">         &#125; catch (InterruptedException e) &#123;</div><div class="line">             e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">         System.out.println(&quot;Method 1 end&quot;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     public static synchronized void method2()&#123;</div><div class="line">         System.out.println(&quot;Method 2 start&quot;);</div><div class="line">         try &#123;</div><div class="line">             System.out.println(&quot;Method 2 execute&quot;);</div><div class="line">             Thread.sleep(1000);</div><div class="line">         &#125; catch (InterruptedException e) &#123;</div><div class="line">             e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">         System.out.println(&quot;Method 2 end&quot;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     public static void main(String[] args) &#123;</div><div class="line">         final SynchronizedTest test = new SynchronizedTest();</div><div class="line">         final SynchronizedTest test2 = new SynchronizedTest();</div><div class="line"></div><div class="line">         new Thread(new Runnable() &#123;</div><div class="line">             @Override</div><div class="line">             public void run() &#123;</div><div class="line">                 test.method1();</div><div class="line">             &#125;</div><div class="line">         &#125;).start();</div><div class="line"></div><div class="line">         new Thread(new Runnable() &#123;</div><div class="line">             @Override</div><div class="line">             public void run() &#123;</div><div class="line">                 test2.method2();</div><div class="line">             &#125;</div><div class="line">         &#125;).start();</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　虽然test和test2属于不同对象，但是test和test2属于同一个类的不同实例，由于method1和method2都属于静态同步方法，所以调用的时候需要获取同一个类上monitor（每个类只对应一个class对象），所以也只能顺序的执行。</p>
<p>3、代码段3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedTest &#123;</div><div class="line">    public void method1()&#123;</div><div class="line">        System.out.println(&quot;Method 1 start&quot;);</div><div class="line">        try &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                System.out.println(&quot;Method 1 execute&quot;);</div><div class="line">                Thread.sleep(3000);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;Method 1 end&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void method2()&#123;</div><div class="line">        System.out.println(&quot;Method 2 start&quot;);</div><div class="line">        try &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                System.out.println(&quot;Method 2 execute&quot;);</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;Method 2 end&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final SynchronizedTest test = new SynchronizedTest();</div><div class="line"></div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                test.method1();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                test.method2();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　对于代码块的同步实质上需要获取Synchronized关键字后面括号中对象的monitor，由于这段代码中括号的内容都是this，而method1和method2又是通过同一的对象去调用的，所以进入同步块之前需要去竞争同一个对象上的锁，因此只能顺序执行同步块。</p>
<h3 id="四-小结"><a href="#四-小结" class="headerlink" title="四 小结"></a>四 小结</h3><p>　　Synchronized是Java并发编程中最常用的用于保证线程安全的方式，其使用相对也比较简单。但是如果能够深入了解其原理，对监视器锁等底层知识有所了解，一方面可以帮助我们正确的使用Synchronized关键字，另一方面也能够帮助我们更好的理解并发编程机制，有助我们在不同的情况下选择更优的并发策略来完成任务。对平时遇到的各种并发问题，也能够从容的应对</p>
<h2 id="Synchronized的底层优化"><a href="#Synchronized的底层优化" class="headerlink" title="Synchronized的底层优化"></a>Synchronized的底层优化</h2><h3 id="一、重量级锁"><a href="#一、重量级锁" class="headerlink" title="一、重量级锁"></a>一、重量级锁</h3><p>　　上篇文章中向大家介绍了Synchronized的用法及其实现的原理。现在我们应该知道，Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p>
<h3 id="二、轻量级锁"><a href="#二、轻量级锁" class="headerlink" title="二、轻量级锁"></a>二、轻量级锁</h3><p>　　锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking来禁用偏向锁。锁的状态保存在对象的头文件中，以32位的JDK为例：<br><img src="/img/synchronized/synchronized-3.png" alt=""><br>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p>
<p>1、轻量级锁的加锁过程</p>
<p>　　（1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如图2.1所示。</p>
<p>　　（2）拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>　　（3）拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）。</p>
<p>　　（4）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图2.2所示。</p>
<p>　　（5）如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。<br>  <img src="/img/synchronized/synchronized-4.png" alt=""><br>  图2.1 轻量级锁CAS操作之前堆栈与对象的状态<br>  <img src="/img/synchronized/synchronized-5.png" alt=""><br>  图2.2 轻量级锁CAS操作之后堆栈与对象的状态</p>
<p>2、轻量级锁的解锁过程：</p>
<p>　　（1）通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。</p>
<p>　　（2）如果替换成功，整个同步过程就完成了。</p>
<p>　　（3）如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。</p>
<h3 id="三、偏向锁"><a href="#三、偏向锁" class="headerlink" title="三、偏向锁"></a>三、偏向锁</h3><p>　　引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
<p>1、偏向锁获取过程：</p>
<p>　　（1）访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。</p>
<p>　　（2）如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。</p>
<p>　　（3）如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。</p>
<p>　　（4）如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</p>
<p>　　（5）执行同步代码。</p>
<p>2、偏向锁的释放：</p>
<p>　　偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>3、重量级锁、轻量级锁和偏向锁之间转换<br>  <img src="/img/synchronized/synchronized-6.png" alt=""></p>
<h3 id="四、其他优化"><a href="#四、其他优化" class="headerlink" title="四、其他优化"></a>四、其他优化</h3><p>1、适应性自旋（Adaptive Spinning）：从轻量级锁获取的流程中我们知道，当线程在获取轻量级锁的过程中执行CAS操作失败时，是要通过自旋来获取重量级锁的。问题在于，自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p>
<p>2、锁粗化（Lock Coarsening）：锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class StringBufferTest &#123;</div><div class="line">    StringBuffer stringBuffer = new StringBuffer();</div><div class="line"></div><div class="line">     public void append()&#123;</div><div class="line">         stringBuffer.append(&quot;a&quot;);</div><div class="line">         stringBuffer.append(&quot;b&quot;);</div><div class="line">         stringBuffer.append(&quot;c&quot;);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这里每次调用stringBuffer.append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p>
<p>3、锁消除（Lock Elimination）：锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。看下面这段程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedTest02 &#123;</div><div class="line"></div><div class="line">     public static void main(String[] args) &#123;</div><div class="line">        SynchronizedTest02 test02 = new SynchronizedTest02();</div><div class="line">        //启动预热</div><div class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        long start = System.currentTimeMillis();</div><div class="line">        for (int i = 0; i &lt; 100000000; i++) &#123;</div><div class="line">            test02.append(&quot;abc&quot;, &quot;def&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;Time=&quot; + (System.currentTimeMillis() - start));</div><div class="line">    &#125;</div><div class="line">    public void append(String str1, String str2) &#123;</div><div class="line">        StringBuffer sb = new StringBuffer();</div><div class="line">        sb.append(str1).append(str2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然StringBuffer的append是一个同步方法，但是这段程序中的StringBuffer属于一个局部变量，并且不会从该方法中逃逸出去，所以其实这过程是线程安全的，可以将锁消除。下面是我本地执行的结果：<br>  <img src="/img/synchronized/synchronized-7.png" alt=""><br>为了尽量减少其他因素的影响，这里禁用了偏向锁（-XX:-UseBiasedLocking）。通过上面程序，可以看出消除锁以后性能还是有比较大提升的。</p>
<p>　　注：可能JDK各个版本之间执行的结果不尽相同，我这里采用的JDK版本为1.6。</p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>　　本文重点介绍了JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，事，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程，这个时候就需要通过-XX:-UseBiasedLocking来禁用偏向锁。下面是这几种锁的对比：<br>  <img src="/img/synchronized/synchronized-8.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Synchronized的基本使用和原理&quot;&gt;&lt;a href=&quot;#Synchronized的基本使用和原理&quot; class=&quot;headerlink&quot; title=&quot;Synchronized的基本使用和原理&quot;&gt;&lt;/a&gt;Synchronized的基本使用和原理&lt;/h2&gt;&lt;
    
    </summary>
    
      <category term="Java" scheme="https://fudawei.github.io/categories/Java/"/>
    
      <category term="多线程" scheme="https://fudawei.github.io/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="内置锁" scheme="https://fudawei.github.io/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%86%85%E7%BD%AE%E9%94%81/"/>
    
    
      <category term="多线程" scheme="https://fudawei.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="https://fudawei.github.io/tags/java/"/>
    
      <category term="内置锁" scheme="https://fudawei.github.io/tags/%E5%86%85%E7%BD%AE%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程：核心理论</title>
    <link href="https://fudawei.github.io/2017/02/05/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%A0%B8%E5%BF%83%E7%90%86%E8%AE%BA/"/>
    <id>https://fudawei.github.io/2017/02/05/Java 并发编程：核心理论/</id>
    <published>2017-02-05T07:14:22.000Z</published>
    <updated>2017-02-08T06:35:40.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、共享性"><a href="#一、共享性" class="headerlink" title="一、共享性"></a>一、共享性</h3><p>　　数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。最典型的场景是数据库中的数据，为了保证数据的一致性，我们通常需要共享同一个数据库中数据，即使是在主从的情况下，访问的也同一份数据，主从只是为了访问的效率和数据安全，而对同一份数据做的副本。我们现在，通过一个简单的示例来演示多线程下共享数据导致的问题：</p>
<p>代码段一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class ShareData &#123;</div><div class="line">    public static int count = 0;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final ShareData data = new ShareData();</div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            new Thread(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    try &#123;</div><div class="line">                        //进入的时候暂停1毫秒，增加并发问题出现的几率</div><div class="line">                        Thread.sleep(1);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    for (int j = 0; j &lt; 100; j++) &#123;</div><div class="line">                        data.addCount();</div><div class="line">                    &#125;</div><div class="line">                    System.out.print(count + &quot; &quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            //主程序暂停3秒，以保证上面的程序执行完成</div><div class="line">            Thread.sleep(3000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;count=&quot; + count);</div><div class="line">    &#125;</div><div class="line">    public void addCount() &#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码的目的是对count进行加一操作，执行1000次，不过这里是通过10个线程来实现的，每个线程执行100次，正常情况下，应该输出1000。不过，如果你运行上面的程序，你会发现结果却不是这样。</p>
<h3 id="二、互斥性"><a href="#二、互斥性" class="headerlink" title="二、互斥性"></a>二、互斥性</h3><p>　　资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。所以我们通常将锁分为共享锁和排它锁，也叫做读锁和写锁。如果资源不具有互斥性，即使是共享资源，我们也不需要担心线程安全。例如，对于不可变的数据共享，所有线程都只能对其进行读操作，所以不用考虑线程安全问题。但是对共享数据的写操作，一般就需要保证互斥性，上述例子中就是因为没有保证互斥性才导致数据的修改产生问题。Java 中提供多种机制来保证互斥性，最简单的方式是使用Synchronized。现在我们在上面程序中加上Synchronized再执行：</p>
<p>代码段二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class ShareData &#123;</div><div class="line"></div><div class="line">    public static int count = 0;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final ShareData data = new ShareData();</div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            new Thread(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    try &#123;</div><div class="line">                        //进入的时候暂停1毫秒，增加并发问题出现的几率</div><div class="line">                        Thread.sleep(1);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    for (int j = 0; j &lt; 100; j++) &#123;</div><div class="line">                        data.addCount();</div><div class="line">                    &#125;</div><div class="line">                    System.out.print(count + &quot; &quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            //主程序暂停3秒，以保证上面的程序执行完成</div><div class="line">            Thread.sleep(3000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;count=&quot; + count);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 增加 synchronized 关键字</div><div class="line">     */</div><div class="line">    public synchronized void addCount() &#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在再执行上述代码，会发现无论执行多少次，返回的最终结果都是1000。</p>
<h3 id="三、原子性"><a href="#三、原子性" class="headerlink" title="三、原子性"></a>三、原子性</h3><p>　　原子性就是指对数据的操作是一个独立的、不可分割的整体。换句话说，就是一次操作，是一个连续不可中断的过程，数据不会执行的一半的时候被其他线程所修改。保证原子性的最简单方式是操作系统指令，就是说如果一次操作对应一条操作系统指令，这样肯定可以能保证原子性。但是很多操作不能通过一条指令就完成。例如，对long类型的运算，很多系统就需要分成多条指令分别对高位和低位进行操作才能完成。还比如，我们经常使用的整数 i++ 的操作，其实需要分成三个步骤：（1）读取整数 i 的值；（2）对 i 进行加一操作；（3）将结果写回内存。这个过程在多线程下就可能出现如下现象：<br><img src="/img/concurrent/concurrent-1.png" alt=""><br>这也是代码段一执行的结果为什么不正确的原因。对于这种组合操作，要保证原子性，最常见的方式是加锁，如Java中的Synchronized或Lock都可以实现，代码段二就是通过Synchronized实现的。除了锁以外，还有一种方式就是CAS（Compare And Swap），即修改数据之前先比较与之前读取到的值是否一致，如果一致，则进行修改，如果不一致则重新执行，这也是乐观锁的实现原理。不过CAS在某些场景下不一定有效，比如另一线程先修改了某个值，然后再改回原来值，这种情况下，CAS是无法判断的。</p>
<h3 id="四、可见性"><a href="#四、可见性" class="headerlink" title="四、可见性"></a>四、可见性</h3><p>要理解可见性，需要先对JVM的内存模型有一定的了解，JVM的内存模型与操作系统类似，如图所示：<br><img src="/img/concurrent/concurrent-2.png" alt=""><br>从这个图中我们可以看出，每个线程都有一个自己的工作内存（相当于CPU高级缓冲区，这么做的目的还是在于进一步缩小存储系统与CPU之间速度的差异，提高性能），对于共享变量，线程每次读取的是工作内存中共享变量的副本，写入的时候也直接修改工作内存中副本的值，然后在某个时间点上再将工作内存与主内存中的值进行同步。这样导致的问题是，如果线程1对某个变量进行了修改，线程2却有可能看不到线程1对共享变量所做的修改。通过下面这段程序我们可以演示一下不可见的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class VisibilityTest &#123;</div><div class="line">    private static boolean ready;</div><div class="line">    private static int number;</div><div class="line"> </div><div class="line">    private static class ReaderThread extends Thread &#123;</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(10);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            if (!ready) &#123;</div><div class="line">                System.out.println(ready);</div><div class="line">            &#125;</div><div class="line">            System.out.println(number);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    private static class WriterThread extends Thread &#123;</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(10);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            number = 100;</div><div class="line">            ready = true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new WriterThread().start();</div><div class="line">        new ReaderThread().start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从直观上理解，这段程序应该只会输出100，ready的值是不会打印出来的。实际上，如果多次执行上面代码的话，可能会出现多种不同的结果</p>
<p>当然，这个结果也只能说是有可能是可见性造成的，当写线程（WriterThread）设置ready=true后，读线程（ReaderThread）看不到修改后的结果，所以会打印false，对于第二个结果，也就是执行if (!ready)时还没有读取到写线程的结果，但执行System.out.println(ready)时读取到了写线程执行的结果。不过，这个结果也有可能是线程的交替执行所造成的。Java 中可通过Synchronized或Volatile来保证可见性，具体细节会在后续的文章中分析。</p>
<h3 id="五、有序性"><a href="#五、有序性" class="headerlink" title="五、有序性"></a>五、有序性</h3><p>　　为了提高性能，编译器和处理器可能会对指令做重排序。重排序可以分为三种：</p>
<p>　　（1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
<p>　　（2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<br>　　（3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
<p>　　我们可以直接参考一下JSR 133 中对重排序问题的描述<br><img src="/img/concurrent/concurrent-3.png" alt=""><br>先看上图中的（1）源码部分，从源码来看，要么指令 1 先执行要么指令 3先执行。如果指令 1 先执行，r2不应该能看到指令 4 中写入的值。如果指令 3 先执行，r1不应该能看到指令 2 写的值。但是运行结果却可能出现r2==2，r1==1的情况，这就是“重排序”导致的结果。上图（2）即是一种可能出现的合法的编译结果，编译后，指令1和指令2的顺序可能就互换了。因此，才会出现r2==2，r1==1的结果。Java 中也可通过Synchronized或Volatile来保证顺序性。</p>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h3><p>　　本文对Java 并发编程中的理论基础进行了讲解，有些东西在后续的分析中还会做更详细的讨论，如可见性、顺序性等。后续的文章都会以本章内容作为理论基础来讨论。如果大家能够很好的理解上述内容，相信无论是去理解其他并发编程的文章还是在平时的并发编程的工作中，都能够对大家有很好的帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、共享性&quot;&gt;&lt;a href=&quot;#一、共享性&quot; class=&quot;headerlink&quot; title=&quot;一、共享性&quot;&gt;&lt;/a&gt;一、共享性&lt;/h3&gt;&lt;p&gt;　　数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的
    
    </summary>
    
      <category term="Java" scheme="https://fudawei.github.io/categories/Java/"/>
    
      <category term="多线程" scheme="https://fudawei.github.io/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://fudawei.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Shell--Expect</title>
    <link href="https://fudawei.github.io/2017/01/24/Shell%E5%AD%A6%E4%B9%A0%E4%B9%8BExpect/"/>
    <id>https://fudawei.github.io/2017/01/24/Shell学习之Expect/</id>
    <published>2017-01-24T02:30:02.000Z</published>
    <updated>2017-02-08T03:39:19.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>   我们通过Shell可以实现简单的控制流功能，如：循环、判断等。但是对于需要交互的场合则必须通过人工来干预，有时候我们可能会需要实现和交互程序如telnet服务器等进行交互的功能。而expect就使用来实现这种功能的工具。</p>
<p>   expect是一个免费的编程工具语言，用来实现自动和交互式任务进行通信，而无需人的干预。expect是不断发展的，随着时间的流逝，其功能越来越强大，已经成为系统管理员的的一个强大助手。expect需要Tcl编程语言的支持，要在系统上运行expect必须首先安装Tcl。</p>
<h3 id="二、expect的安装"><a href="#二、expect的安装" class="headerlink" title="二、expect的安装"></a>二、expect的安装</h3><p>expect是在Tcl基础上创建起来的，所以在安装expect前我们应该先安装Tcl。</p>
<p>（一）Tcl 安装<br>主页: <a href="http://www.tcl.tk" target="_blank" rel="external">http://www.tcl.tk</a><br>下载地址: <a href="http://www.tcl.tk/software/tcltk/downloadnow84.tml" target="_blank" rel="external">http://www.tcl.tk/software/tcltk/downloadnow84.tml</a><br>1.下载源码包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://nchc.dl.sourceforge.net/sourceforge/tcl/tcl8.4.11-src.tar.gz</div></pre></td></tr></table></figure>
<p>2.解压缩源码包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar xfvz tcl8.4.11-src.tar.gz</div></pre></td></tr></table></figure>
<p>3.安装配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd tcl8.4.11/unix</div><div class="line">./configure --prefix=/usr/tcl --enable-shared</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>注意：<br>1、安装完毕以后，进入tcl源代码的根目录，把子目录unix下面的tclUnixPort.h copy到子目录generic中。</p>
<p>2、暂时不要删除tcl源代码，因为expect的安装过程还需要用。</p>
<p>（二）expect 安装 (需Tcl的库)</p>
<p>主页: <a href="http://expect.nist.gov/" target="_blank" rel="external">http://expect.nist.gov/</a></p>
<p>1.下载源码包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://sourceforge.net/projects/expect/files/Expect/5.45/expect5.45.tar.gz/download</div></pre></td></tr></table></figure>
<p>2.解压缩源码包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar xzvf expect5.45.tar.gz</div></pre></td></tr></table></figure>
<p>3.安装配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd expect5.45</div><div class="line">./configure --prefix=/usr/expect --with-tcl=/usr/tcl/lib --with-tclinclude=../tcl8.4.11/generic</div><div class="line">make</div><div class="line">make install</div><div class="line">ln -s /usr/tcl/bin/expect /usr/expect/bin/expect</div></pre></td></tr></table></figure>
<h3 id="三、Expect工作原理"><a href="#三、Expect工作原理" class="headerlink" title="三、Expect工作原理"></a>三、Expect工作原理</h3><p>   从最简单的层次来说，Expect的工作方式象一个通用化的Chat脚本工具。Chat脚本最早用于UUCP网络内，以用来实现计算机之间需要建立连接时进行特定的登录会话的自动化。</p>
<p>   Chat脚本由一系列expect-send对组成：expect等待输出中输出特定的字符，通常是一个提示符，然后发送特定的响应。例如下面的 Chat脚本实现等待标准输出出现Login:字符串，然后发送somebody作为用户名；然后等待Password:提示符，并发出响应 sillyme。</p>
<p>引用：</p>
<p>Login: somebody Password: sillyme<br>Expect最简单的脚本操作模式本质上和Chat脚本工作模式是一样的。</p>
<h3 id="四、实例详解"><a href="#四、实例详解" class="headerlink" title="四、实例详解"></a>四、实例详解</h3><ol>
<li>expect 是基于tcl 演变而来的，所以很多语法和tcl 类似，基本的语法如下<br>所示：<br>1.1 首行加上/usr/bin/expect<br>1.2 spawn: 后面加上需要执行的shell 命令，比如说spawn sudo touch testfile<br>1.3 expect: 只有spawn 执行的命令结果才会被expect 捕捉到，因为spawn 会启<br>动一个进程，只有这个进程的相关信息才会被捕捉到，主要包括：标准输入的提<br>示信息，eof 和timeout。<br>1.4 send 和send_user：send 会将expect 脚本中需要的信息发送给spawn 启动<br>的那个进程，而send_user 只是回显用户发出的信息，类似于shell 中的echo 而<br>已。</li>
</ol>
<ol>
<li>一个小例子，用于linux 下账户的建立：<br>filename: account.sh，可以使用./account.sh newaccout 来执行；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/expect</div><div class="line"></div><div class="line">set passwd &quot;mypasswd&quot;</div><div class="line">set timeout 60</div><div class="line">if &#123;$argc != 1&#125; &#123;</div><div class="line">  send &quot;usage ./account.sh \$newaccount\n&quot;</div><div class="line">  exit</div><div class="line">&#125;</div><div class="line"></div><div class="line">set user [lindex $argv [expr $argc-1]]</div><div class="line">spawn sudo useradd -s /bin/bash -g mygroup -m $user</div><div class="line">expect &#123;</div><div class="line">  &quot;assword&quot; &#123;</div><div class="line">    send_user &quot;sudo now\n&quot;</div><div class="line">    send &quot;$passwd\n&quot;</div><div class="line">    exp_continue</div><div class="line">  &#125;</div><div class="line">  eof&#123;</div><div class="line">    send_user &quot;eof\n&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">spawn sudo passwd $user</div><div class="line">expect &#123;</div><div class="line"> &quot;assword&quot; &#123;</div><div class="line">    send &quot;$passwd\n&quot;</div><div class="line">     exp_continue</div><div class="line"> &#125;</div><div class="line"> eof &#123;</div><div class="line">      send_user &quot;eof&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">spawn sudo smbpasswd -a $user</div><div class="line">expect &#123;</div><div class="line">         &quot;assword&quot; &#123;</div><div class="line">         send &quot;$passwd\n&quot;</div><div class="line">         exp_continue</div><div class="line">      &#125;</div><div class="line"></div><div class="line">     eof &#123;</div><div class="line">        send_user &quot;eof&quot;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>注意点：</li>
</ol>
<p>第3 行： 对变量赋值的方法；<br>第4 行： 默认情况下，timeout 是10 秒；<br>第6 行： 参数的数目可以用$argc 得到；<br>第11 行：参数存在$argv 当中，比如取第一个参数就是[lindex $argv 0]；并且<br>如果需要计算的话必须用expr，如计算2-1，则必须用[expr 2-1]；<br>第13 行：用spawn 来执行一条shell 命令，shell 命令根据具体情况可自行调整；<br>有文章说sudo 要加-S，经过实际测试，无需加-S 亦可；<br>第15 行：一般情况下，如果连续做两个expect，那么实际上是串行执行的，用。expect 与“{ ”之间直接必须有空格或则TAB间隔，否则会出麻烦，会报错invalid command name “expect{“<br>例子中的结构则是并行执行的，主要是看匹配到了哪一个；在这个例子中，如果<br>你写成串行的话，即<br>expect “assword”<br>send “$passwd\n”<br>expect eof<br>send_user “eof”<br>那么第一次将会正确运行，因为第一次sudo 时需要密码；但是第二次运行时由于<br>密码已经输过（默认情况下sudo 密码再次输入时间为5 分钟），则不会提示用户<br>去输入，所以第一个expect 将无法匹配到assword，而且必须注意的是如果是<br>spawn 命令出现交互式提问的但是expect 匹配不上的话，那么程序会按照timeout<br>的设置进行等待；可是如果spawn 直接发出了eof 也就是本例的情况，那么expect<br>“assword”将不会等待，而直接去执行expect eof。<br>这时就会报expect: spawn id exp6 not open，因为没有spawn 在执行，后面的<br>expect 脚本也将会因为这个原因而不再执行；所以对于类似sudo 这种命令分支<br>不定的情况，最好是使用并行的方式进行处理；<br>第17 行：仅仅是一个用户提示而已，可以删除；<br>第18 行：向spawn 进程发送password；<br>第19 行：使得spawn 进程在匹配到一个后再去匹配接下来的交互提示；<br>第21 行：eof 是必须去匹配的，在spawn 进程结束后会向expect 发送eof；如果<br>不去匹配，有时也能运行，比如sleep 多少秒后再去spawn 下一个命令，但是不<br>要依赖这种行为，很有可能今天还可以，明天就不能用了；</p>
<ol>
<li>其他<br>下面这个例子比较特殊，在整个过程中就不能expect eof 了：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/expect</div><div class="line">set timeout 30</div><div class="line">spawn ssh 10.192.224.224</div><div class="line">expect &quot;password:&quot;</div><div class="line">send &quot;mypassword\n&quot;</div><div class="line">expect &quot;*$&quot;</div><div class="line">send &quot;mkdir tmpdir\n&quot; #远程执行命令用send发送，不用spawn</div><div class="line">expect &quot;*$&quot; #注意这个地方，要与操作系统上环境变量PS1相匹配，尤其是有PS1有空格的情况下，一定在expct &quot;*$ &quot; 把空格加上，加不上你就完蛋了。我试过。</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个例子实际上是通过ssh 去登录远程机器，并且在远程机器上创佳一个目录，<br>我们看到在我们输入密码后并没有去expect eof，这是因为ssh 这个spawn 并没<br>有结束，而且手动操作时ssh 实际上也不会自己结束除非你exit；所以你只能<br>expect bash 的提示符，当然也可以是机器名等，这样才可以在远程创建一个目<br>录。<br>注意，请不要用spawn mkdir tmpdir，这样会使得上一个spawn 即ssh 结束，那<br>么你的tmpdir 将在本机建立。<br>当然实际情况下可能会要你确认ssh key，可以通过并行的expect 进行处理，不<br>多赘述。</p>
<p>6 实例：下面这个脚本是完成对单个服务器scp任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/expect</div><div class="line"></div><div class="line">set timeout 10</div><div class="line">set host [lindex $argv 0]</div><div class="line">set username [lindex $argv 1]</div><div class="line">set password [lindex $argv 2]</div><div class="line">set src_file [lindex $argv 3]</div><div class="line">set dest_file [lindex $argv 4]</div><div class="line"></div><div class="line">spawn scp  $src_file $username@$host:$dest_file</div><div class="line">expect &#123;</div><div class="line">     &quot;(yes/no)?&quot;</div><div class="line">        &#123;</div><div class="line">            send &quot;yes\n&quot;</div><div class="line">            expect &quot;*assword:&quot; &#123; send &quot;$password\n&quot;&#125;</div><div class="line">        &#125;</div><div class="line">    &quot;*assword:&quot;</div><div class="line">        &#123;</div><div class="line">            send &quot;$password\n&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">expect &quot;100%&quot;</div><div class="line">expect eof</div></pre></td></tr></table></figure></p>
<p>意代码刚开始的第一行，指定了expect的路径，与shell脚本相同，这一句指定了程序在执行时到哪里去寻找相应的启动程序。代码刚开始还设定了timeout的时间为10秒，如果在执行scp任务时遇到了代码中没有指定的异常，则在等待10秒后该脚本的执行会自动终止。<br>spawn代表在本地终端执行的语句，在该语句开始执行后，expect开始捕获终端的输出信息，然后做出对应的操作。expect代码中的捕获的(yes/no)内容用于完成第一次访问目标主机时保存密钥的操作。有了这一句，scp的任务减少了中断的情况。代码结尾的expect eof与spawn对应，表示捕获终端输出信息的终止。</p>
<p>有了这段expect的代码，还只能完成对单个远程主机的scp任务。如果需要实现批量scp的任务，则需要再写一个shell脚本来调用这个expect脚本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line"></div><div class="line">list_file=$1</div><div class="line">src_file=$2</div><div class="line">dest_file=$3</div><div class="line"></div><div class="line">cat $list_file | while    read line</div><div class="line"> do</div><div class="line">     host_ip=`echo $line | awk &apos;&#123;print $1&#125;&apos;`</div><div class="line">     username=`echo $line | awk &apos;&#123;print $2&#125;&apos;`</div><div class="line">     password=`echo $line | awk &apos;&#123;print $3&#125;&apos;`</div><div class="line">     echo &quot;$host_ip&quot;</div><div class="line">     ./expect_scp $host_ip $username $password $src_file $dest_file</div><div class="line"> done</div></pre></td></tr></table></figure></p>
<p>很简单的代码，指定了3个参数：列表文件的位置、本地源文件路径、远程主机目标文件路径。需要说明的是其中的列表文件指定了远程主机ip、用户名、密码，这些信息需要写成以下的格式：<br>IP username password<br>中间用空格或tab键来分隔，多台主机的信息需要写多行内容。<br>这样就指定了两台远程主机的信息。注意，如果远程主机密码中有“$”、“#”这类特殊字符的话，在编写列表文件时就需要在这些特殊字符前加上转义字符，否则expect在执行时会输入错误的密码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h3&gt;&lt;p&gt;   我们通过Shell可以实现简单的控制流功能，如：循环、判断等。但是对于需要交互的场合则必须通过人工来干预，有时候我们可
    
    </summary>
    
      <category term="linux shell" scheme="https://fudawei.github.io/categories/linux-shell/"/>
    
    
      <category term="linux shell" scheme="https://fudawei.github.io/tags/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell--Sed</title>
    <link href="https://fudawei.github.io/2017/01/23/Shell%E5%AD%A6%E4%B9%A0%E4%B9%8BSed/"/>
    <id>https://fudawei.github.io/2017/01/23/Shell学习之Sed/</id>
    <published>2017-01-23T08:07:02.000Z</published>
    <updated>2017-02-08T03:39:19.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是sed？"><a href="#一、什么是sed？" class="headerlink" title="一、什么是sed？"></a>一、什么是sed？</h2><pre><code>sed 是一种在线编辑器，它一次处理一行内容。sed是非交互式的编辑器。它不会修改文件，除非使用shell重定向来保存结果。默认情况下，所有的输出行都被打印到屏幕上。
</code></pre><h2 id="二、sed的处理过程"><a href="#二、sed的处理过程" class="headerlink" title="二、sed的处理过程"></a>二、sed的处理过程</h2><p>   sed编辑器逐行处理文件（或输入），并将结果发送到屏幕。具体过程如下：首先sed把当前正在处理的行保存在一个临时缓存区中（也称为模式空间），然后处理临时缓冲区中的行，完成后把该行发送到屏幕上。sed每处理完一行就将其从临时缓冲区删除，然后将下一行读入，进行处理和显示。处理完输入文件的最后一行后，sed便结束运行。</p>
<p>   前面说到sed不会修改文件，那么现在我们可以知道是为什么了？是因为sed把每一行都存在临时缓冲区中，对这个副本进行编辑，所以不会修改原文件。</p>
<p>补充知识：</p>
<pre><code>在使用sed的过程中，我们经常会听到“定址”，那么什么是“定址”呢？

定址用于决定对哪些行进行编辑。地址的形式可以是数字、正则表达式、或二者的结合。如果没有指定地址，sed将处理输入文件的所有行。
</code></pre><p>1、地址是一个数字，则表示行号；是“$”符号，则表示最后一行。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;3p&apos; datafile   #只打印第三行</div></pre></td></tr></table></figure>
<p>2、只显示指定行范围的文件内容</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;100,200p&apos; mysql_slow_query.log  # 只查看文件的第100行到第200行</div></pre></td></tr></table></figure></p>
<p>3、地址是逗号分隔的，那么需要处理的地址是这两行之间的范围（包括这两行在内）。范围可以用数字、正则表达式、或二者的组合表示。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sed &apos;2,5d&apos; datafile</div><div class="line">#删除第二到第五行</div><div class="line">sed &apos;/My/,/You/d&apos; datafile</div><div class="line">#删除包含&quot;My&quot;的行到包含&quot;You&quot;的行之间的行</div><div class="line">sed &apos;/My/,10d&apos; datafile</div><div class="line">#删除包含&quot;My&quot;的行到第十行的内容</div></pre></td></tr></table></figure>
<p>三、sed命令和选项<br>sed命令告诉sed如何处理由地址指定的各输入行，如果没有指定地址则处理所有的输入行。</p>
<p>1、sed命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>a\</td>
<td>在当前行后添加一行或多行。多行时除最后一行外，每行末尾需用“\”续行</td>
</tr>
<tr>
<td>c\</td>
<td>用此符号后的新文本替换当前行中的文本。多行时除最后一行外，每行末尾需用”\”续行</td>
</tr>
<tr>
<td>i\</td>
<td>在当前行之前插入文本。多行时除最后一行外，每行末尾需用”\”续行</td>
</tr>
<tr>
<td>d</td>
<td>删除行</td>
</tr>
<tr>
<td>h</td>
<td>把模式空间里的内容复制到暂存缓冲区</td>
</tr>
<tr>
<td>H</td>
<td>把模式空间里的内容追加到暂存缓冲区</td>
</tr>
<tr>
<td>g</td>
<td>把暂存缓冲区里的内容复制到模式空间，覆盖原有的内容</td>
</tr>
<tr>
<td>G</td>
<td>把暂存缓冲区的内容追加到模式空间里，追加在原有内容的后面</td>
</tr>
<tr>
<td>l</td>
<td>列出非打印字符</td>
</tr>
<tr>
<td>p</td>
<td>打印行</td>
<td></td>
</tr>
<tr>
<td>n</td>
<td>读入下一输入行，并从下一条命令而不是第一条命令开始对其的处理</td>
</tr>
<tr>
<td>q</td>
<td>结束或退出sed</td>
</tr>
<tr>
<td>r</td>
<td>从文件中读取输入行</td>
</tr>
<tr>
<td>!</td>
<td>对所选行以外的所有行应用命令</td>
</tr>
<tr>
<td>s</td>
<td>用一个字符串替换另一个</td>
</tr>
<tr>
<td>g</td>
<td>在行内进行全局替换</td>
</tr>
<tr>
<td>w</td>
<td>将所选的行写入文件</td>
</tr>
<tr>
<td>x</td>
<td>交换暂存缓冲区与模式空间的内容</td>
</tr>
<tr>
<td>y</td>
<td>将字符替换为另一字符（不能对正则表达式使用y命令）</td>
</tr>
</tbody>
</table>
<p>2、sed选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td>进行多项编辑，即对输入行应用多条sed命令时使用</td>
</tr>
<tr>
<td>-n</td>
<td>取消默认的输出</td>
</tr>
<tr>
<td>-f</td>
<td>指定sed脚本的文件名</td>
</tr>
</tbody>
</table>
<h2 id="四、正则表达式元字符"><a href="#四、正则表达式元字符" class="headerlink" title="四、正则表达式元字符"></a>四、正则表达式元字符</h2><p>   与grep一样，sed也支持特殊元字符，来进行模式查找、替换。不同的是，sed使用的正则表达式是括在斜杠线”/“之间的模式。</p>
<p>   如果要把正则表达式分隔符”/“改为另一个字符，比如o，只要在这个字符前加一个反斜线，在字符后跟上正则表达式，再跟上这个字符即可。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;\o^Myop&apos; datafile</div></pre></td></tr></table></figure>
<p>常用的正则表达式如下：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>功能描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>行首定位符</td>
<td>/^my/ 匹配所有以my开头的行</td>
</tr>
<tr>
<td>$</td>
<td>行尾定位符</td>
<td></td>
<td>/my$/ 匹配所有以my结尾的行</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符以外的单个字符</td>
<td>/m..y/ 匹配包含字母m，后跟两个任意字符，再跟字母y的行</td>
</tr>
<tr>
<td>*</td>
<td>匹配零个或多个前导字符</td>
<td>/my*/ 匹配包含字母m,后跟零个或多个y字母的行</td>
</tr>
<tr>
<td>[]</td>
<td>匹配指定字符组内的任一字符</td>
<td>/[Mm]y/ 匹配包含My或my的行</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不在指定字符组内的任一字符</td>
<td>/[^Mm]y/ 匹配包含y，但y之前的那个字符不是M或m的行</td>
</tr>
<tr>
<td>..</td>
<td>保存已匹配的字符</td>
<td>1,20s/youself/\1r/ 标记元字符之间的模式，并将其保存为标签1，之后可以使用\1来引用它。最多可以定义9个标签，从左边开始编号，最左边的是第一个。此例中，对第1到第20行进行处理，you被保存为标签1，如果发现youself，则替换为your。</td>
</tr>
<tr>
<td>&amp;</td>
<td>保存查找串以便在替换串中引用</td>
<td>s/my/<strong>&amp;</strong>/  符号&amp;代表查找串。my将被替换为<strong>my</strong></td>
</tr>
<tr>
<td>\&lt;</td>
<td>词首定位符</td>
<td>/\&lt;my/ 匹配包含以my开头的单词的行</td>
</tr>
<tr>
<td>></td>
<td>词尾定位符</td>
<td>/my>/ 匹配包含以my结尾的单词的行</td>
</tr>
<tr>
<td>x{m}</td>
<td>连续m个x</td>
<td>/9{5}/匹配包含连续5个9的行</td>
</tr>
<tr>
<td>x{m,}</td>
<td>至少m个x</td>
<td>/9{5,}/ 匹配包含至少连续5个9的行</td>
</tr>
<tr>
<td>x{m,n}</td>
<td>至少m个，但不超过n个x</td>
<td>/9{5,7}/ 匹配包含连续5到7个9的行</td>
</tr>
</tbody>
</table>
<h2 id="五、sed的退出状态"><a href="#五、sed的退出状态" class="headerlink" title="五、sed的退出状态"></a>五、sed的退出状态</h2><p>   sed不向grep一样，不管是否找到指定的模式，它的退出状态都是0。只有当命令存在语法错误时，sed的退出状态才不是0。</p>
<h2 id="六、常用范例"><a href="#六、常用范例" class="headerlink" title="六、常用范例"></a>六、常用范例</h2><p>1、p命令</p>
<p>   命令p用于显示模式空间的内容。默认情况下，sed把输入行打印在屏幕上，选项-n用于取消默认的打印操作。当选项-n和命令p同时出现时,sed可打印选定的内容。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">（1）sed &apos;/my/p&apos; datafile</div><div class="line">#默认情况下，sed把所有输入行都打印在标准输出上。如果某行匹配模式my，p命令将把该行另外打印一遍。</div><div class="line"></div><div class="line">（2）sed -n &apos;/my/p&apos; datafile</div><div class="line">#选项-n取消sed默认的打印，p命令把匹配模式my的行打印一遍。</div></pre></td></tr></table></figure>
<p>2、d命令</p>
<p>   命令d用于删除输入行。sed先将输入行从文件复制到模式空间里，然后对该行执行sed命令，最后将模式空间里的内容显示在屏幕上。如果发出的是命令d，当前模式空间里的输入行会被删除，不被显示。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">（1）sed &apos;$d&apos; datafile</div><div class="line">#删除最后一行，其余的都被显示</div><div class="line"></div><div class="line">（2）sed &apos;/my/d&apos; datafile</div><div class="line">#删除包含my的行，其余的都被显示</div></pre></td></tr></table></figure>
<p>3、s命令</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">（1）sed &apos;s/^My/You/g&apos; datafile</div><div class="line">#命令末端的g表示在行内进行全局替换，也就是说如果某行出现多个My，所有的My都被替换为You。</div><div class="line"></div><div class="line">（2）sed -n &apos;1,20s/My$/You/gp&apos; datafile</div><div class="line">#取消默认输出，处理1到20行里匹配以My结尾的行，把行内所有的My替换为You，并打印到屏幕上。</div><div class="line"></div><div class="line">（3）sed &apos;s#My#Your#g&apos; datafile</div><div class="line">#紧跟在s命令后的字符就是查找串和替换串之间的分隔符。分隔符默认为正斜杠，但可以改变。无论什么字符（换行符、反斜线除外），只要紧跟s命令，就成了新的串分隔符。</div></pre></td></tr></table></figure>
<p>4、e选项</p>
<p>   -e是编辑命令，用于sed执行多个编辑任务的情况下。在下一行开始编辑前，所有的编辑动作将应用到模式缓冲区中的行上。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;1,10d&apos; -e &apos;s/My/Your/g&apos; datafile</div><div class="line">#选项-e用于进行多重编辑。第一重编辑删除第1-3行。第二重编辑将出现的所有My替换为Your。因为是逐行进行这两项编辑（即这两个命令都在模式空间的当前行上执行），所以编辑命令的顺序会影响结果。</div></pre></td></tr></table></figure>
<p>5、r命令</p>
<p>r命令是读命令。sed使用该命令将一个文本文件中的内容加到当前文件的特定位置上。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed &apos;/My/r introduce.txt&apos; datafile</div><div class="line">#如果在文件datafile的某一行匹配到模式My，就在该行后读入文件introduce.txt的内容。如果出现My的行不止一行，则在出现My的各行后都读入introduce.txt文件的内容。</div></pre></td></tr></table></figure>
<p>6、w命令</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;/hrwang/w me.txt&apos; datafile</div></pre></td></tr></table></figure>
<p>7、a\ 命令</p>
<p>   a\ 命令是追加命令，追加将添加新文本到文件中当前行（即读入模式缓冲区中的行）的后面。所追加的文本行位于sed命令的下方另起一行。如果要追加的内容超过一行，则每一行都必须以反斜线结束，最后一行除外。最后一行将以引号和文件名结束。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sed &apos;/^hrwang/a\</div><div class="line">&gt;hrwang and mjfan are husband\</div><div class="line">&gt;and wife&apos; datafile</div><div class="line">#如果在datafile文件中发现匹配以hrwang开头的行，则在该行下面追加hrwang and mjfan are husband and wife</div></pre></td></tr></table></figure>
<p>8、i\ 命令</p>
<p>i\ 命令是在当前行的前面插入新的文本。</p>
<p>9、c\ 命令</p>
<p>sed使用该命令将已有文本修改成新的文本。</p>
<p>10、n命令</p>
<p>sed使用该命令获取输入文件的下一行，并将其读入到模式缓冲区中，任何sed命令都将应用到匹配行紧接着的下一行上。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;/hrwang/&#123;n;s/My/Your/;&#125;&apos; datafile</div></pre></td></tr></table></figure>
<p>注：如果需要使用多条命令，或者需要在某个地址范围内嵌套地址，就必须用花括号将命令括起来，每行只写一条命令，或这用分号分割同一行中的多条命令。</p>
<p>11、y命令</p>
<p>该命令与UNIX/Linux中的tr命令类似，字符按照一对一的方式从左到右进行转换。例如，y/abc/ABC/将把所有小写的a转换成A，小写的b转换成B，小写的c转换成C。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed &apos;1,20y/hrwang12/HRWANG^$/&apos; datafile</div><div class="line">#将1到20行内，所有的小写hrwang转换成大写，将1转换成^,将2转换成$。</div><div class="line">#正则表达式元字符对y命令不起作用。与s命令的分隔符一样，斜线可以被替换成其它的字符。</div></pre></td></tr></table></figure>
<p>12、q命令</p>
<p> q命令将导致sed程序退出，不再进行其它的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;/hrwang/&#123;s/hrwang/HRWANG/;q;&#125;&apos; datafile</div></pre></td></tr></table></figure>
<p>13、h命令和g命令</p>
<p>为了更好说明这两个命令，我们先创建如下的文本文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#cat datafile</div><div class="line">My name is hrwang.</div><div class="line">Your name is mjfan.</div><div class="line">hrwang is mjfan&apos;s husband.</div><div class="line">mjfan is hrwang&apos;s wife.</div><div class="line"></div><div class="line">sed -e &apos;/hrwang/h&apos; -e &apos;$G&apos; datafile</div><div class="line">sed -e &apos;/hrwang/H&apos; -e &apos;$G&apos; datafile</div><div class="line">#通过上面两条命令，你会发现h会把原来暂存缓冲区的内容清除，只保存最近一次执行h时保存进去的模式空间的内容。而H命令则把每次匹配hrwnag的行都追加保存在暂存缓冲区。</div><div class="line"></div><div class="line">sed -e &apos;/hrwang/H&apos; -e &apos;$g&apos; datafile</div><div class="line">sed -e &apos;/hrwang/H&apos; -e &apos;$G&apos; datafile</div><div class="line">#通过上面两条命令，你会发现g把暂存缓冲区中的内容替换掉了模式空间中当前行的内容，此处即替换了最后一行。而G命令则把暂存缓冲区的内容追加到了模式空间的当前行后。此处即追加到了末尾。</div></pre></td></tr></table></figure>
<p>补充知识点：sed特殊用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;/root/w a.txt&apos;    #将匹配行输出到文件</div><div class="line"></div><div class="line">sed &apos;/root/r abc.txt&apos; /etc/passwd #把abc.txt的文件内容读入到root匹配行后</div><div class="line"></div><div class="line">sed -n &apos;/root/w a.txt&apos;</div><div class="line"></div><div class="line">sed -n &apos;/root/&#123;=;p&#125;&apos; /etc/passwd #打印行号和匹配root的行</div><div class="line"></div><div class="line">sed -n &apos;/root/&#123;n;d&#125;&apos; /etc/passwd #将匹配root行的下一行删除</div><div class="line"></div><div class="line">sed -n &apos;/root/&#123;N;d&#125;&apos; /etc/passwd #将匹配root行和下一行都删除</div><div class="line"></div><div class="line">sed &apos;22&#123;h;d&#125;;23,33&#123;H;d&#125;;44G&apos; pass</div></pre></td></tr></table></figure>
<h2 id="七、sed脚本编写方法"><a href="#七、sed脚本编写方法" class="headerlink" title="七、sed脚本编写方法"></a>七、sed脚本编写方法</h2><p>1、从文件读入命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -f sed.sh</div></pre></td></tr></table></figure>
<p>sed.sh文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s/root/yerik/p</div><div class="line">s/bash/csh/p</div></pre></td></tr></table></figure>
<p>2、直接运行脚本 ./sed.sh /etc/passwd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bib/sed -f</div><div class="line">s/root/yerik/p</div><div class="line">s/bash/csh/p</div></pre></td></tr></table></figure>
<h2 id="八、小技巧"><a href="#八、小技巧" class="headerlink" title="八、小技巧"></a>八、小技巧</h2><p>1、用sed 输出自己的IP 地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig eth0 |sed &apos;2p&apos; |sed &apos;s/^.*addr:/ /g&apos; |sed &apos;s/B.*$ / /g&apos;</div></pre></td></tr></table></figure>
<p>2、在sed的命令行中引用shell变量时要使用双引号，而不是通常所用的单引号。下面是一个根据name变量的内容来删除named.conf文件中zone段的脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name=&apos;zone\ &quot;localhost&quot;&apos;</div><div class="line"></div><div class="line">sed &quot;/$name/,/&#125;;/d&quot; named.conf</div></pre></td></tr></table></figure>
<p>3、保持和获取：h命令和G命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e &apos;/test/h&apos; -e &apos;$G example</div></pre></td></tr></table></figure>
<p> 在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。</p>
<p>4、保持和互换：h命令和x命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e &apos;/test/h&apos; -e &apos;/check/x&apos; example</div></pre></td></tr></table></figure>
<p>互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。</p>
<h2 id="九、练习"><a href="#九、练习" class="headerlink" title="九、练习"></a>九、练习</h2><p>1，删除文件每行的第一个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;s/^.//gp&apos; /etc/passwd</div><div class="line">sed -nr &apos;s/(.)(.*)/\2/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>2，删除文件每行的第二个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/(.)(.)(.*)/\1\3/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>3，删除文件每行的最后一个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/.$//p&apos; /etc/passwd</div><div class="line">sed -nr &apos;s/(.*)(.)/\1/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>4，删除文件每行的倒数第二个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/(.*)(.)(.)/\1\3/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>5，删除文件每行的第二个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/([^a-Z]*)([a-Z]+)([^a-Z]+)([a-Z]+)(.*)/\1\2\3\5/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>6，删除文件每行的倒数第二个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/(.*)([^a-Z]+)([a-Z]+)([^a-Z]+)([a-Z]+)([^a-Z]*)/\1\2\4\5\6/p&apos; /etc/samba/smb.conf</div></pre></td></tr></table></figure>
<p>7，删除文件每行的最后一个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/(.*)([^a-Z]+)([a-Z]+)([^a-Z]*)/\1\2\4/p&apos; /etc/samba/smb.conf</div></pre></td></tr></table></figure>
<p>8，交换每行的第一个字符和第二个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/(.)(.)(.*)/\2\1\3/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>9，交换每行的第一个单词和第二个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/([^a-Z]*)([a-Z]+)([^a-Z]+)([a-Z]+)(.*)/\1\4\3\2\5/p&apos; /etc/samba/smb.conf</div></pre></td></tr></table></figure>
<p>10，交换每行的第一个单词和最后一个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/([^a-Z]*)([a-Z]+)([^a-Z]+)([a-Z]+)(.*)/\1\4\3\2\5/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>11，删除一个文件中所有的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;s/[0-9]*//g&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>12，删除每行开头的所有空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;s/^\ *//p&apos; /etc/samba/smb.conf</div><div class="line">sed -nr &apos;s/( *)(.*)/\2/p&apos; testp</div></pre></td></tr></table></figure>
<p>13，用制表符替换文件中出现的所有空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;s/\ /\t/gp&apos; pass</div></pre></td></tr></table></figure>
<p>14，把所有大写字母用括号（）括起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/([A-Z])/(&amp;)/gp&apos; testp</div><div class="line">sed -n &apos;s/[A-Z]/(&amp;)/gp&apos; testp</div></pre></td></tr></table></figure>
<p>15，打印每行3次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;p;p&apos; pass</div></pre></td></tr></table></figure>
<p>16，隔行删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n &apos;1~2p&apos; pass</div></pre></td></tr></table></figure>
<p>17，把文件从第22行到第33行复制到第44行后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;1,21h;22h;23,33H;44G&apos; pass</div></pre></td></tr></table></figure>
<p>18，把文件从第22行到第33行移动到第44行后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;22&#123;h;d&#125;;23,33&#123;H;d&#125;;44G&apos; pass</div></pre></td></tr></table></figure>
<p>19，只显示每行的第一个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/([^a-Z]*)([a-Z]+)([^a-Z]+)(.*)/\2/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>20，打印每行的第一个单词和第三个单词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -nr &apos;s/([^a-Z]*)([a-Z]+)([^a-Z]+)([a-Z]+)([^a-Z]+)([a-Z]+)(.*)/\2--\4/p&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>21，将格式为    mm/yy/dd    的日期格式换成   mm；yy；dd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">date +%m/%Y/%d |sed -n &apos;s#/#;#gp&apos;</div></pre></td></tr></table></figure>
<p>22, 逆向输出<br>sed ‘1!G;h;$!d’ b<br>cat a.txt<br>ABC<br>DEF<br>XYZ<br>输出样式变成<br>XYZ<br>DEF<br>ABC</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是sed？&quot;&gt;&lt;a href=&quot;#一、什么是sed？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是sed？&quot;&gt;&lt;/a&gt;一、什么是sed？&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;sed 是一种在线编辑器，它一次处理一行内容。sed是非交互式的编辑
    
    </summary>
    
      <category term="linux shell" scheme="https://fudawei.github.io/categories/linux-shell/"/>
    
    
      <category term="linux shell" scheme="https://fudawei.github.io/tags/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell--Awk</title>
    <link href="https://fudawei.github.io/2017/01/22/Shell%E5%AD%A6%E4%B9%A0%E4%B9%8BAwk/"/>
    <id>https://fudawei.github.io/2017/01/22/Shell学习之Awk/</id>
    <published>2017-01-22T02:30:02.000Z</published>
    <updated>2017-02-08T03:39:19.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>awk是一种很棒的语言。awk 适合于文本处理和报表生成，它还有许多精心设计的特性，允许进行需要特殊技巧程序设计。与某些语言不同，awk 的语法较为常见。它借鉴了某些语言的一些精华部分，如 C 语言、Python 和 bash（虽然在技术上，awk 比 python 和 bash 早创建）。awk 是那种一旦学会了就会成为您战略编码库的主要部分的语言。</p>
<h3 id="一-第一个-awk"><a href="#一-第一个-awk" class="headerlink" title="一. 第一个 awk"></a>一. 第一个 awk</h3><p>让我们继续，开始使用 awk，以了解其工作原理。在命令行中输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; print &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>你将会见到 /etc/passwd 文件的内容出现在眼前。现在，解释 awk 做了些什么。调用 awk 时，我们指定 /etc/passwd 作为输入文件。执行 awk 时，它依次对 /etc/passwd 中的每一行执行 print 命令。所有输出都发送到 stdout，所得到的结果与与执行catting /etc/passwd完全相同。</p>
<p>现在，解释 { print } 代码块。在 awk 中，花括号用于将几块代码组合到一起，这一点类似于 C 语言。在代码块中只有一条 print 命令。在 awk 中，如果只出现 print 命令，那么将打印当前行的全部内容。</p>
<p>这里是另一个 awk 示例，它的作用与上例完全相同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; print $0 &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure></p>
<p>在 awk 中， $0 变量表示整个当前行，所以 print 和 print $0 的作用完全一样。</p>
<p>如果你愿意，可以创建一个 awk 程序，让它输出与输入数据完全无关的数据。以下是一个示例：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; print &quot;&quot; &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>只要将 “” 字符串传递给 print 命令，它就会打印空白行。如果测试该脚本，将会发现对于 /etc/passwd 文件中的每一行，awk 都输出一个空白行。再次说明， awk 对输入文件中的每一行都执行这个脚本。以下是另一个示例：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123; print &quot;hiya&quot; &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>运行这个脚本将在您的屏幕上写满 hiya。</p>
<h3 id="二-多个字段"><a href="#二-多个字段" class="headerlink" title="二. 多个字段"></a>二. 多个字段</h3><p>awk 非常善于处理分成多个逻辑字段的文本，而且让您可以毫不费力地引用 awk 脚本中每个独立的字段。以下脚本将打印出您的系统上所有用户帐户的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F&quot;:&quot; &apos;&#123; print $1 &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>　<br>上例中，在调用 awk 时，使用 -F 选项来指定 “:” 作为字段分隔符。awk 处理 print $1 命令时，它会打印出在输入文件中每一行中出现的第一个字段。以下是另一个示例： 　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F&quot;:&quot; &apos;&#123; print $1 $3 &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>以下是该脚本输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">halt7</div><div class="line">operator11</div><div class="line">root0</div><div class="line">shutdown6</div><div class="line">sync5</div><div class="line">bin1</div><div class="line">....etc.</div></pre></td></tr></table></figure>
<p>如您所见，awk 打印出 /etc/passwd 文件的第一和第三个字段，它们正好分别是用户名和用户标识字段。现在，当脚本运行时，它并不理想 – 在两个输出字段之间没有空格！如果习惯于使用 bash 或 python 进行编程，那么您会指望 print $1 $3 命令在两个字段之间插入空格。然而，当两个字符串在 awk 程序中彼此相邻时，awk 会连接它们但不在它们之间添加空格。以下命令会在这两个字段中插入空格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F&quot;:&quot; &apos;&#123; print $1 &quot; &quot; $3 &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>以这种方式调用 print 时，它将连接 $1 、” “ 和 $3 ，创建可读的输出。当然，如果需要的话，我们还可以插入一些文本标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F&quot;:&quot; &apos;&#123; print &quot;username: &quot; $1 &quot;/t/tuid:&quot; $3&quot; &#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<p>这将产生以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">username: halt uid:7</div><div class="line">username: operator uid:11</div><div class="line">username: root uid:0</div><div class="line">username: shutdown uid:6</div><div class="line">username: sync uid:5</div><div class="line">username: bin uid:1</div><div class="line">....etc.</div></pre></td></tr></table></figure>
<h3 id="三-外部脚本"><a href="#三-外部脚本" class="headerlink" title="三. 外部脚本"></a>三. 外部脚本</h3><p>将脚本作为命令行自变量传递给 awk 对于小的单行程序来说是非常简单的，而对于多行程序，它就比较复杂。您肯定想要在外部文件中撰写脚本。然后可以向 awk 传递 -f 选项，以向它提供此脚本文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -f myscript.awk myfile.in</div></pre></td></tr></table></figure>
<p>将脚本放入文本文件还可以让您使用附加 awk 功能。例如，这个多行脚本与前面的单行脚本的作用相同，它们都打印出 /etc/passwd 中每一行的第一个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">FS=&quot;:&quot;</div><div class="line">&#125;</div><div class="line">&#123; print $1 &#125;</div></pre></td></tr></table></figure>
<p>这两个方法的差别在于如何设置字段分隔符。在这个脚本中，字段分隔符在代码自身中指定（通过设置 FS 变量），而在前一个示例中，通过在命令行上向 awk 传递 -F”:” 选项来设置 FS。通常，最好在脚本自身中设置字段分隔符，只是因为这表示您可以少输入一个命令行自变量。我们将在本文的后面详细讨论 FS 变量。</p>
<h3 id="四-BEGIN-和-END-块"><a href="#四-BEGIN-和-END-块" class="headerlink" title="四. BEGIN 和 END 块"></a>四. BEGIN 和 END 块</h3><p>通常，对于每个输入行，awk 都会执行每个脚本代码块一次。然而，在许多编程情况中，可能需要在 awk 开始处理输入文件中的文本之 前 执行初始化代码。对于这种情况，awk 允许您定义一个 BEGIN 块。我们在前一个示例中使用了 BEGIN 块。因为 awk 在开始处理输入文件之前会执行 BEGIN 块，因此它是初始化 FS（字段分隔符）变量、打印页眉或初始化其它在程序中以后会引用的全局变量的极佳位置。</p>
<p>awk 还提供了另一个特殊块，叫作 END 块。awk 在处理了输入文件中的所有行之后执行这个块。通常，END 块用于执行最终计算或打印应该出现在输出流结尾的摘要信息。</p>
<h3 id="五-规则表达式和块"><a href="#五-规则表达式和块" class="headerlink" title="五. 规则表达式和块"></a>五. 规则表达式和块</h3><p>awk 允许使用规则表达式，根据规则表达式是否匹配当前行来选择执行独立代码块。以下示例脚本只输出包含字符序列 foo 的那些行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/foo/ &#123; print &#125;</div></pre></td></tr></table></figure>
<p>当然，可以使用更复杂的规则表达式。以下脚本将只打印包含浮点数的行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/[0-9]+/.[0-9]*/ &#123; print &#125;</div></pre></td></tr></table></figure>
<h3 id="六-表达式和块"><a href="#六-表达式和块" class="headerlink" title="六. 表达式和块"></a>六. 表达式和块</h3><p>有许多其它方法可以选择执行代码块。我们可以将任意一种布尔表达式放在一个代码块之前，以控制何时执行某特定块。仅当对前面的布尔表达式求值为真时，awk 才执行代码块。以下示例脚本输出将输出其第一个字段等于 fred 的所有行中的第三个字段。如果当前行的第一个字段不等于 fred ，awk 将继续处理文件而不对当前行执行 print 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$1 == &quot;fred&quot; &#123; print $3 &#125;</div></pre></td></tr></table></figure>
<p>awk 提供了完整的比较运算符集合，包括 “==”、”&lt;”、”&gt;”、”&lt;=”、”&gt;=” 和 “!=”。另外，awk 还提供了 “~” 和 “!~” 运算符，它们分别表示“匹配”和“不匹配”。它们的用法是在运算符左边指定变量，在右边指定规则表达式。如果某一行的第五个字段包含字符序列 root ，那么以下示例将只打印这一行中的第三个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$5 ~ /root/ &#123; print $3 &#125;</div></pre></td></tr></table></figure>
<h3 id="七-条件语句"><a href="#七-条件语句" class="headerlink" title="七. 条件语句"></a>七. 条件语句</h3><p>awk 还提供了非常好的类似于 C 语言的 if 语句。如果您愿意，可以使用 if 语句重写前一个脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">if ( $5 ~ /root/ ) &#123; </div><div class="line">  print $3 </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个脚本的功能完全一样。第一个示例中，布尔表达式放在代码块外面。而在第二个示例中，将对每一个输入行执行代码块，而且我们使用 if 语句来选择执行 print 命令。这两个方法都可以使用，可以选择最适合脚本其它部分的一种方法。</p>
<p>以下是更复杂的 awk if 语句示例。可以看到，尽管使用了复杂、嵌套的条件语句， if 语句看上去仍与相应的 C 语言 if 语句一样：<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">  if ( $1 == &quot;foo&quot; ) &#123;</div><div class="line">    if ( $2 == &quot;foo&quot; ) &#123;</div><div class="line">      print &quot;uno&quot;</div><div class="line">    &#125; </div><div class="line">   else &#123;</div><div class="line">      print &quot;one&quot;</div><div class="line">    &#125;</div><div class="line">  &#125; </div><div class="line">  else if ($1 == &quot;bar&quot; ) &#123;</div><div class="line">    print &quot;two&quot;</div><div class="line">  &#125; </div><div class="line">  else &#123;</div><div class="line">   print &quot;three&quot; </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 if 语句还可以将代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">! /matchme/ &#123; print $1 $3 $4 &#125;</div><div class="line"></div><div class="line">转换成：</div><div class="line"></div><div class="line">&#123; </div><div class="line">  if ( $0 !~ /matchme/ ) &#123;</div><div class="line">  print $1 $3 $4</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个脚本都只输出 不 包含 matchme 字符序列的那些行。此外，还可以选择最适合您的代码的方法。它们的功能完全相同。</p>
<p>awk 还允许使用布尔运算符 “||”（逻辑与）和 “&amp;&amp;”（逻辑或），以便创建更复杂的布尔表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( $1 == &quot;foo&quot; ) &amp;&amp; ( $2 == &quot;bar&quot; ) &#123; print &#125;</div></pre></td></tr></table></figure>
<p>这个示例只打印第一个字段等于 foo 且 第二个字段等于 bar 的那些行。</p>
<h3 id="八-数值变量！"><a href="#八-数值变量！" class="headerlink" title="八. 数值变量！"></a>八. 数值变量！</h3><p>至今，我们不是打印字符串、整行就是特定字段。然而，awk 还允许我们执行整数和浮点运算。通过使用数学表达式，可以很方便地编写计算文件中空白行数量的脚本。以下就是这样一个脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123; x=0 &#125;</div><div class="line">  /^$/ &#123; x=x+1 &#125;</div><div class="line">END &#123; print &quot;I found &quot; x &quot; blank lines. :)&quot; &#125;</div></pre></td></tr></table></figure>
<p>在 BEGIN 块中，将整数变量 x 初始化成零。然后，awk 每次遇到空白行时，awk 将执行 x=x+1 语句，递增 x 。处理完所有行之后，执行 END 块，awk 将打印出最终摘要，指出它找到的空白行数量。</p>
<h3 id="九-字符串化变量"><a href="#九-字符串化变量" class="headerlink" title="九. 字符串化变量"></a>九. 字符串化变量</h3><p>awk 的优点之一就是“简单和字符串化”。我认为 awk 变量“字符串化”是因为所有 awk 变量在内部都是按字符串形式存储的。同时，awk 变量是“简单的”，因为可以对它执行数学操作，且只要变量包含有效数字字符串，awk 会自动处理字符串到数字的转换步骤。要理解我的观点，请研究以下这个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x=&quot;1.01&quot;</div><div class="line"># We just set x to contain the *string* &quot;1.01&quot;</div><div class="line">x=x+1</div><div class="line"># We just added one to a *string*</div><div class="line">print x</div><div class="line"># Incidentally, these are comments :)</div></pre></td></tr></table></figure>
<p>awk 将输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.01</div></pre></td></tr></table></figure>
<p>有趣吧！虽然将字符串值 1.01 赋值给变量 x ，我们仍然可以对它加一。但在 bash 和 python 中却不能这样做。首先，bash 不支持浮点运算。而且，如果 bash 有“字符串化”变量，它们并不“简单”；要执行任何数学操作，bash 要求我们将数字放到丑陋的 $( ) ) 结构中。如果使用 python，则必须在对 1.01 字符串执行任何数学运算之前，将它转换成浮点值。虽然这并不困难，但它仍是附加的步骤。如果使用 awk，它是全自动的，而那会使我们的代码又好又整洁。如果想要对每个输入行的第一个字段乘方并加一，可以使用以下脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; print ($1^2)+1 &#125;</div></pre></td></tr></table></figure>
<p>如果做一个小实验，就可以发现如果某个特定变量不包含有效数字，awk 在对数学表达式求值时会将该变量当作数字零处理。</p>
<h3 id="十-众多运算符"><a href="#十-众多运算符" class="headerlink" title="十. 众多运算符"></a>十. 众多运算符</h3><p>awk 的另一个优点是它有完整的数学运算符集合。除了标准的加、减、乘、除，awk 还允许使用前面演示过的指数运算符 “^”、模（余数）运算符 “%” 和其它许多从 C 语言中借入的易于使用的赋值操作符。</p>
<p>这些运算符包括前后加减（ i++ 、 –foo ）、加／减／乘／除赋值运算符（ a+=3 、 b*=2 、 c/=2.2 、 d-=6.2 ）。不仅如此 – 我们还有易于使用的模／指数赋值运算符（ a^=2 、 b%=4 ）。</p>
<h3 id="十一-字段分隔符"><a href="#十一-字段分隔符" class="headerlink" title="十一. 字段分隔符"></a>十一. 字段分隔符</h3><p>awk 有它自己的特殊变量集合。其中一些允许调整 awk 的运行方式，而其它变量可以被读取以收集关于输入的有用信息。我们已经接触过这些特殊变量中的一个，FS。前面已经提到过，这个变量让您可以设置 awk 要查找的字段之间的字符序列。我们使用 /etc/passwd 作为输入时，将 FS 设置成 “:”。当这样做有问题时，我们还可以更灵活地使用 FS。</p>
<p>FS 值并没有被限制为单一字符；可以通过指定任意长度的字符模式，将它设置成规则表达式。如果正在处理由一个或多个 tab 分隔的字段，您可能希望按以下方式设置 FS：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FS=&quot;/t+&quot;</div></pre></td></tr></table></figure></p>
<p>以上示例中，我们使用特殊 “+” 规则表达式字符，它表示“一个或多个前一字符”。<br>如果字段由空格分隔（一个或多个空格或 tab），您可能想要将 FS 设置成以下规则表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FS=&quot;[[:space:]+]&quot;</div></pre></td></tr></table></figure></p>
<p>这个赋值表达式也有问题，它并非必要。为什么？因为缺省情况下，FS 设置成单一空格字符，awk 将这解释成表示“一个或多个空格或 tab”。在这个特殊示例中，缺省 FS 设置恰恰是您最想要的！<br>复杂的规则表达式也不成问题。即使您的记录由单词 “foo” 分隔，后面跟着三个数字，以下规则表达式仍允许对数据进行正确的分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FS=&quot;foo[0-9][0-9][0-9]&quot;</div></pre></td></tr></table></figure></p>
<h3 id="十二-字段数量"><a href="#十二-字段数量" class="headerlink" title="十二. 字段数量"></a>十二. 字段数量</h3><p>接着我们要讨论的两个变量通常并不是需要赋值的，而是用来读取以获取关于输入的有用信息。第一个是 NF 变量，也叫做“字段数量”变量。awk 会自动将该变量设置成当前记录中的字段数量。可以使用 NF 变量来只显示某些输入行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NF == 3 &#123; print &quot;this particular record has three fields: &quot; $0 &#125;</div></pre></td></tr></table></figure>
<p>当然，也可以在条件语句中使用 NF 变量，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">  if ( NF &gt; 2 ) &#123;</div><div class="line">    print $1 &quot; &quot; $2 &quot;:&quot; $3 </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="十三-记录号"><a href="#十三-记录号" class="headerlink" title="十三. 记录号"></a>十三. 记录号</h3><p>记录号 (NR) 是另一个方便的变量。它始终包含当前记录的编号（awk 将第一个记录算作记录号 1）。迄今为止，我们已经处理了每一行包含一个记录的输入文件。对于这些情况，NR 还会告诉您当前行号。然而，当我们在本系列以后部分中开始处理多行记录时，就不会再有这种情况，所以要注意！可以象使用 NF 变量一样使用 NR 来只打印某些输入行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(NR &lt; 10 ) || (NR &gt; 100) &#123; print &quot;We are on record number 1-9 or 101+&quot; &#125;</div></pre></td></tr></table></figure>
<p>另一个示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  if ( NR &gt; 10 ) &#123;</div><div class="line">    print &quot;ok, now for the real information!&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>awk 提供了适合各种用途的附加变量。我们将在以后的文章中讨论这些变量。</p>
<h3 id="十四-多行记录"><a href="#十四-多行记录" class="headerlink" title="十四. 多行记录"></a>十四. 多行记录</h3><p>awk 是一种用于读取和处理结构化数据（如系统的 /etc/passwd 文件）的极佳工具。/etc/passwd 是 UNIX 用户数据库，并且是用冒号定界的文本文件，它包含许多重要信息，包括所有现有用户帐户和用户标识，以及其它信息。在我的 前一篇文章 中，我演示了 awk 如何轻松地分析这个文件。我们只须将 FS（字段分隔符）变量设置成 “:”。</p>
<p>正确设置了 FS 变量之后，就可以将 awk 配置成分析几乎任何类型的结构化数据，只要这些数据是每行一个记录。然而，如果要分析占据多行的记录，仅仅依靠设置 FS 是不够的。在这些情况下，我们还需要修改 RS 记录分隔符变量。RS 变量告诉 awk 当前记录什么时候结束，新记录什么时候开始。</p>
<p>譬如，让我们讨论一下如何完成处理“联邦证人保护计划”所涉及人员的地址列表的任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> Jimmy the Weasel</div><div class="line">100 Pleasant Drive</div><div class="line">San Francisco, CA 12345</div><div class="line"></div><div class="line">Big Tony</div><div class="line">200 Incognito Ave.</div><div class="line">Suburbia, WA 67890</div></pre></td></tr></table></figure>
<p>理论上，我们希望 awk 将每 3 行看作是一个独立的记录，而不是三个独立的记录。如果 awk 将地址的第一行看作是第一个字段 ($1)，街道地址看作是第二个字段 ($2)，城市、州和邮政编码看作是第三个字段 $3，那么这个代码就会变得很简单。以下就是我们想要得到的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">FS=&quot;/n&quot;</div><div class="line">RS=&quot;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面这段代码中，将 FS 设置成 “/n” 告诉 awk 每个字段都占据一行。通过将 RS 设置成 “”，还会告诉 awk 每个地址记录都由空白行分隔。一旦 awk 知道是如何格式化输入的，它就可以为我们执行所有分析工作，脚本的其余部分很简单。让我们研究一个完整的脚本，它将分析这个地址列表，并将每个记录打印在一行上，用逗号分隔每个字段。</p>
<p>address.awk<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">  FS=&quot;/n&quot;</div><div class="line">  RS=&quot;&quot;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  print $1 &quot;, &quot; $2 &quot;, &quot; $3</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果这个脚本保存为 address.awk，地址数据存储在文件 address.txt 中，可以通过输入 “awk -f address.awk address.txt” 来执行这个脚本。此代码将产生以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Jimmy the Weasel, 100 Pleasant Drive, San Francisco, CA 12345</div><div class="line">Big Tony, 200 Incognito Ave., Suburbia, WA 67890</div></pre></td></tr></table></figure></p>
<h3 id="十五-OFS-和-ORS"><a href="#十五-OFS-和-ORS" class="headerlink" title="十五. OFS 和 ORS"></a>十五. OFS 和 ORS</h3><p>在 address.awk 的 print 语句中，可以看到 awk 会连接（合并）一行中彼此相邻的字符串。我们使用此功能在同一行上的三个字段之间插入一个逗号和空格 (“, “)。这个方法虽然有用，但比较难看。与其在字段间插入 “, “ 字符串，倒不如让通过设置一个特殊 awk 变量 OFS，让 awk 完成这件事。请参考下面这个代码片断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print &quot;Hello&quot;, &quot;there&quot;, &quot;Jim!&quot;</div></pre></td></tr></table></figure>
<p>这行代码中的逗号并不是实际文字字符串的一部分。事实上，它们告诉 awk “Hello”、”there” 和 “Jim!” 是单独的字段，并且应该在每个字符串之间打印 OFS 变量。缺省情况下，awk 产生以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello there Jim!</div></pre></td></tr></table></figure>
<p>这是缺省情况下的输出结果，OFS 被设置成 “ “，单个空格。不过，我们可以方便地重新定义 OFS，这样 awk 将插入我们中意的字段分隔符。以下是原始 address.awk 程序的修订版，它使用 OFS 来输出那些中间的 “, “ 字符串：</p>
<p>address.awk 的修订版 　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line"> FS=&quot;/n&quot;</div><div class="line"> RS=&quot;&quot;</div><div class="line"> OFS=&quot;, &quot;</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line"> print $1, $2, $3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>awk 还有一个特殊变量 ORS，全称是“输出记录分隔符”。通过设置缺省为换行 (“/n”) 的 OFS，我们可以控制在 print 语句结尾自动打印的字符。缺省 ORS 值会使 awk 在新行中输出每个新的 print 语句。如果想使输出的间隔翻倍，可以将 ORS 设置成 “/n/n”。或者，如果想要用单个空格分隔记录（而不换行），将 ORS 设置成 “”。</p>
<p>将多行转换成用 tab 分隔的格式</p>
<p>假设我们编写了一个脚本，它将地址列表转换成每个记录一行，且用 tab 定界的格式，以便导入电子表格。使用稍加修改的 address.awk 之后，就可以清楚地看到这个程序只适合于三行的地址。如果 awk 遇到以下地址，将丢掉第四行，并且不打印该行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cousin Vinnie</div><div class="line">Vinnie&apos;s Auto Shop</div><div class="line">300 City Alley</div><div class="line">Sosueme, OR 76543</div></pre></td></tr></table></figure>
<p>要处理这种情况，代码最好考虑每个字段的记录数量，并依次打印每个记录。现在，代码只打印地址的前三个字段。以下就是我们想要的一些代码：</p>
<p>适合具有任意多字段的地址的 address.awk 版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">  FS=&quot;/n&quot;</div><div class="line">  RS=&quot;&quot;</div><div class="line">  ORS=&quot;&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">  x=1</div><div class="line">  while ( x&lt;NF ) &#123;</div><div class="line">   print $x &quot;/t&quot;</div><div class="line">   x++</div><div class="line">  &#125;</div><div class="line">  print $NF &quot;/n&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先，将字段分隔符 FS 设置成 “/n”，将记录分隔符 RS 设置成 “”，这样 awk 可以象以前一样正确分析多行地址。然后，将输出记录分隔符 ORS 设置成 “”，它将使 print 语句在每个调用结尾 不 输出新行。这意味着如果希望任何文本从新的一行开始，那么需要明确写入 print “/n” 。</p>
<p>在主代码块中，创建了一个变量 x 来存储正在处理的当前字段的编号。起初，它被设置成 1。然后，我们使用 while 循环（一种 awk 循环结构，等同于 C 语言中的 while 循环），对于所有记录（最后一个记录除外）重复打印记录和 tab 字符。最后，打印最后一个记录和换行；此外，由于将 ORS 设置成 “”，print 将不输出换行。程序输出如下，这正是我们所期望的：</p>
<p>我们想要的输出。不算漂亮，但用 tab 定界，以便于导入电子表格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Jimmy the Weasel 100 Pleasant Drive San Francisco, CA 12345 </div><div class="line">Big Tony 200 Incognito Ave. Suburbia, WA 67890</div><div class="line">Cousin Vinnie Vinnie Auto Shop 300 City Alley Sosueme, OR 76543</div></pre></td></tr></table></figure>
<h3 id="十六-循环结构"><a href="#十六-循环结构" class="headerlink" title="十六. 循环结构"></a>十六. 循环结构</h3><p>我们已经看到了 awk 的 while 循环结构，它等同于相应的 C 语言 while 循环。awk 还有 “do…while” 循环，它在代码块结尾处对条件求值，而不象标准 while 循环那样在开始处求值。它类似于其它语言中的 “repeat…until” 循环。以下是一个示例：</p>
<p>do…while 示例<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  count=1</div><div class="line">  do &#123;</div><div class="line">  print &quot;I get printed at least once no matter what&quot; </div><div class="line">  &#125; while ( count != 1 )</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与一般的 while 循环不同，由于在代码块之后对条件求值，”do…while” 循环永远都至少执行一次。换句话说，当第一次遇到普通 while 循环时，如果条件为假，将永远不执行该循环。</p>
<p>for 循环</p>
<p>awk 允许创建 for 循环，它就象 while 循环，也等同于 C 语言的 for 循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for ( initial assignment; comparison; increment ) &#123;</div><div class="line">code block</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是一个简短示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for ( x = 1; x &lt;= 4; x++ ) &#123;</div><div class="line">  print &quot;iteration&quot;,x</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此段代码将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iteration 1</div><div class="line">iteration 2</div><div class="line">iteration 3</div><div class="line">iteration 4</div></pre></td></tr></table></figure>
<p>十七. break 和 continue<br>此外，如同 C 语言一样，awk 提供了 break 和 continue 语句。使用这些语句可以更好地控制 awk 的循环结构。以下是迫切需要 break 语句的代码片断：</p>
<p>while 死循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (1) &#123;</div><div class="line">print &quot;forever and ever...&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>while 死循环 1 永远代表是真，这个 while 循环将永远运行下去。以下是一个只执行十次的循环：</p>
<p>break 语句示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x=1</div><div class="line">while(1) &#123;</div><div class="line">  print &quot;iteration&quot;,x</div><div class="line">  if ( x == 10 ) &#123;</div><div class="line">  break</div><div class="line">  &#125;</div><div class="line">  x++</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里，break 语句用于“逃出”最深层的循环。”break” 使循环立即终止，并继续执行循环代码块后面的语句。<br>continue 语句补充了 break，其作用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">x=1</div><div class="line">while (1) &#123;</div><div class="line">   if ( x == 4 ) &#123;</div><div class="line">   x++</div><div class="line">   continue</div><div class="line">   &#125;</div><div class="line">   print &quot;iteration&quot;,x</div><div class="line">   if ( x &gt; 20 ) &#123;</div><div class="line">   break</div><div class="line">   &#125;</div><div class="line">   x++</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码打印 “iteration 1” 到 “iteration 21”，”iteration 4” 除外。如果迭代等于 4，则增加 x 并调用 continue 语句，该语句立即使 awk 开始执行下一个循环迭代，而不执行代码块的其余部分。如同 break 一样，continue 语句适合各种 awk 迭代循环。在 for 循环主体中使用时，continue 将使循环控制变量自动增加。以下是一个等价循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for ( x=1; x&lt;=21; x++ ) &#123;</div><div class="line">  if ( x == 4 ) &#123;</div><div class="line">  continue</div><div class="line">  &#125;</div><div class="line">  print &quot;iteration&quot;,x&#125;</div></pre></td></tr></table></figure>
<p>在 while 循环中时，在调用 continue 之前没有必要增加 x ，因为 for 循环会自动增加 x 。</p>
<h3 id="十八-数组"><a href="#十八-数组" class="headerlink" title="十八. 数组"></a>十八. 数组</h3><p>如果您知道 awk 可以使用数组，您一定会感到高兴。然而，在 awk 中，数组下标通常从 1 开始，而不是 0：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myarray[1]=&quot;jim&quot;</div><div class="line">myarray[2]=456</div></pre></td></tr></table></figure>
<p>awk 遇到第一个赋值语句时，它将创建 myarray ，并将元素 myarray[1] 设置成 “jim”。执行了第二个赋值语句后，数组就有两个元素了。</p>
<ol>
<li>数组迭代</li>
</ol>
<p>定义之后，awk 有一个便利的机制来迭代数组元素，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">for ( x in myarray ) &#123;</div><div class="line">print myarray[x]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码将打印数组 myarray 中的每一个元素。当对于 for 使用这种特殊的 “in” 形式时，awk 将 myarray 的每个现有下标依次赋值给 x （循环控制变量），每次赋值以后都循环一次循环代码。虽然这是一个非常方便的 awk 功能，但它有一个缺点 – 当 awk 在数组下标之间轮转时，它不会依照任何特定的顺序。那就意味着我们不能知道以上代码的输出是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jim</div><div class="line">456</div></pre></td></tr></table></figure>
<p>还是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">456</div><div class="line">jim</div></pre></td></tr></table></figure>
<p>套用 Forrest Gump 的话来说，迭代数组内容就像一盒巧克力 – 您永远不知道将会得到什么。因此有必要使 awk 数组“字符串化”，我们现在就来研究这个问题。</p>
<ol>
<li>数组下标字符串化</li>
</ol>
<p>在我的前一篇文章 中，我演示了 awk 实际上以字符串格式来存储数字值。虽然 awk 要执行必要的转换来完成这项工作，但它却可以使用某些看起来很奇怪的代码：<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a=&quot;1&quot;</div><div class="line">b=&quot;2&quot;</div><div class="line">c=a+b+3</div></pre></td></tr></table></figure></p>
<p>执行了这段代码后， c 等于 6 。由于 awk 是“字符串化”的，添加字符串 “1” 和 “2” 在功能上并不比添加数字 1 和 2 难。这两种情况下，awk 都可以成功执行运算。awk 的“字符串化”性质非常可爱 – 您可能想要知道如果使用数组的字符串下标会发生什么情况。例如，使用以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">myarr[&quot;1&quot;]=&quot;Mr. Whipple&quot;</div><div class="line">print myarr[&quot;1&quot;]</div></pre></td></tr></table></figure></p>
<p>可以预料，这段代码将打印 “Mr. Whipple”。但如果去掉第二个 “1” 下标中的引号，情况又会怎样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myarr[&quot;1&quot;]=&quot;Mr. Whipple&quot;</div><div class="line">print myarr[1]</div></pre></td></tr></table></figure>
<p>猜想这个代码片断的结果比较难。awk 将 myarr[“1”] 和 myarr[1] 看作数组的两个独立元素，还是它们是指同一个元素？答案是它们指的是同一个元素，awk 将打印 “Mr. Whipple”，如同第一个代码片断一样。虽然看上去可能有点怪，但 awk 在幕后却一直使用数组的字符串下标！</p>
<p>了解了这个奇怪的真相之后，我们中的一些人可能想要执行类似于以下的古怪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myarr[&quot;name&quot;]=&quot;Mr. Whipple&quot;</div><div class="line">print myarr[&quot;name&quot;]</div></pre></td></tr></table></figure>
<p>这段代码不仅不会产生错误，而且它的功能与前面的示例完全相同，也将打印 “Mr. Whipple”！可以看到，awk 并没有限制我们使用纯整数下标；如果我们愿意，可以使用字符串下标，而且不会产生任何问题。只要我们使用非整数数组下标，如 myarr[“name”] ，那么我们就在使用 关联数组 。从技术上讲，如果我们使用字符串下标，awk 的后台操作并没有什么不同（因为即便使用“整数”下标，awk 还是会将它看作是字符串）。但是，应该将它们称作 关联数组 – 它听起来很酷，而且会给您的上司留下印象。字符串化下标是我们的小秘密。;)</p>
<ol>
<li>数组工具</li>
</ol>
<p>谈到数组时，awk 给予我们许多灵活性。可以使用字符串下标，而且不需要连续的数字序列下标（例如，可以定义 myarr[1] 和 myarr[1000] ，但不定义其它所有元素）。虽然这些都很有用，但在某些情况下，会产生混淆。幸好，awk 提供了一些实用功能有助于使数组变得更易于管理。</p>
<p>首先，可以删除数组元素。如果想要删除数组 fooarray 的元素 1 ，输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete fooarray[1]</div></pre></td></tr></table></figure>
<p>而且，如果想要查看是否存在某个特定数组元素，可以使用特殊的 “in” 布尔运算符，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ( 1 in fooarray ) &#123;</div><div class="line">print &quot;Ayep! It&apos;s there.&quot;</div><div class="line">&#125; else &#123;</div><div class="line">print &quot;Nope! Can&apos;t find it.&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="十九-格式化输出"><a href="#十九-格式化输出" class="headerlink" title="十九. 格式化输出"></a>十九. 格式化输出</h3><p>在这篇 awk 系列的总结中，Daniel 向您介绍 awk 重要的字符串函数，以及演示了如何从头开始编写完整的支票簿结算程序。在这个过程中，您将学习如何编写自己的函数，并使用 awk 的多维数组。学完本文之后，您将掌握更多 awk 经验，可以让您创建功能更强大的脚本。</p>
<p>虽然大多数情况下 awk 的 print 语句可以完成任务，但有时我们还需要更多。在那些情况下，awk 提供了两个我们熟知的老朋友 printf() 和 sprintf()。是的，如同其它许多 awk 部件一样，这些函数等同于相应的 C 语言函数。printf() 会将格式化字符串打印到 stdout，而 sprintf() 则返回可以赋值给变量的格式化字符串。如果不熟悉 printf() 和 sprintf()，介绍 C 语言的文章可以让您迅速了解这两个基本打印函数。在 Linux 系统上，可以输入 “man 3 printf” 来查看 printf() 帮助页面。</p>
<p>以下是一些 awk sprintf() 和 printf() 的样本代码。可以看到，它们几乎与 C 语言完全相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x=1</div><div class="line">b=&quot;foo&quot;</div><div class="line">printf(&quot;%s got a %d on the last test/n&quot;,&quot;Jim&quot;,83)</div><div class="line">myout=(&quot;%s-%d&quot;,b,x)</div><div class="line">print myout</div></pre></td></tr></table></figure>
<p>此代码将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Jim got a 83 on the last test</div><div class="line">foo-1</div></pre></td></tr></table></figure>
<h3 id="二十-字符串函数"><a href="#二十-字符串函数" class="headerlink" title="二十. 字符串函数"></a>二十. 字符串函数</h3><p>awk 有许多字符串函数，这是件好事。在 awk 中，确实需要字符串函数，因为不能象在其它语言（如 C、C++ 和 Python）中那样将字符串看作是字符数组。例如，如果执行以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mystring=&quot;How are you doing today?&quot;</div><div class="line">print mystring[3]</div></pre></td></tr></table></figure>
<p>将会接收到一个错误，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk: string.gawk:59: fatal: attempt to use scalar as array</div></pre></td></tr></table></figure>
<p>噢，好吧。虽然不象 Python 的序列类型那样方便，但 awk 的字符串函数还是可以完成任务。让我们来看一下。<br>首先，有一个基本 length() 函数，它返回字符串的长度。以下是它的使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print length(mystring)</div></pre></td></tr></table></figure></p>
<p>此代码将打印值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">24</div></pre></td></tr></table></figure>
<p>好，继续。下一个字符串函数叫作 index，它将返回子字符串在另一个字符串中出现的位置，如果没有找到该字符串则返回 0。使用 mystring，可以按以下方法调用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print index(mystring,&quot;you&quot;)</div></pre></td></tr></table></figure>
<p>awk 会打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">9</div></pre></td></tr></table></figure>
<p>让我们继续讨论另外两个简单的函数，tolower() 和 toupper()。与您猜想的一样，这两个函数将返回字符串并且将所有字符分别转换成小写或大写。请注意，tolower() 和 toupper() 返回新的字符串，不会修改原来的字符串。这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print tolower(mystring)</div><div class="line">print toupper(mystring)</div><div class="line">print mystring</div></pre></td></tr></table></figure>
<p>……将产生以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">how are you doing today?</div><div class="line">HOW ARE YOU DOING TODAY?</div><div class="line">How are you doing today?</div></pre></td></tr></table></figure>
<p>到现在为止一切不错，但我们究竟如何从字符串中选择子串，甚至单个字符？那就是使用 substr() 的原因。以下是 substr() 的调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysub=substr(mystring,startpos,maxlen)</div></pre></td></tr></table></figure>
<p>mystring 应该是要从中抽取子串的字符串变量或文字字符串。startpos 应该设置成起始字符位置，maxlen 应该包含要抽取的字符串的最大长度。请注意，我说的是 最大长度 ；如果 length(mystring) 比 startpos+maxlen 短，那么得到的结果就会被截断。substr() 不会修改原始字符串，而是返回子串。以下是一个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print substr(mystring,9,3)</div></pre></td></tr></table></figure>
<p>awk 将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">you</div></pre></td></tr></table></figure>
<p>如果您通常用于编程的语言使用数组下标访问部分字符串（以及不使用这种语言的人），请记住 substr() 是 awk 代替方法。需要使用它来抽取单个字符和子串；因为 awk 是基于字符串的语言，所以会经常用到它。</p>
<p>现在，我们讨论一些更耐人寻味的函数，首先是 match()。match() 与 index() 非常相似，它与 index() 的区别在于它并不搜索子串，它搜索的是规则表达式。match() 函数将返回匹配的起始位置，如果没有找到匹配，则返回 0。此外，match() 还将设置两个变量，叫作 RSTART 和 RLENGTH。RSTART 包含返回值（第一个匹配的位置），RLENGTH 指定它占据的字符跨度（如果没有找到匹配，则返回 -1）。通过使用 RSTART、RLENGTH、substr() 和一个小循环，可以轻松地迭代字符串中的每个匹配。以下是一个 match() 调用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print match(mystring,/you/), RSTART, RLENGTH</div></pre></td></tr></table></figure>
<p>awk 将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">9 9 3</div></pre></td></tr></table></figure>
<p>字符串替换</p>
<p>现在，我们将研究两个字符串替换函数，sub() 和 gsub()。这些函数与目前已经讨论过的函数略有不同，因为它们 确实修改原始字符串 。以下是一个模板，显示了如何调用 sub()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub(regexp,replstring,mystring)</div></pre></td></tr></table></figure>
<p>调用 sub() 时，它将在 mystring 中匹配 regexp 的第一个字符序列，并且用 replstring 替换该序列。sub() 和 gsub() 用相同的自变量；唯一的区别是 sub() 将替换第一个 regexp 匹配（如果有的话），gsub() 将执行全局替换，换出字符串中的所有匹配。以下是一个 sub() 和 gsub() 调用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub(/o/,&quot;O&quot;,mystring)</div><div class="line">print mystring</div><div class="line">mystring=&quot;How are you doing today?&quot;</div><div class="line">gsub(/o/,&quot;O&quot;,mystring)</div><div class="line">print mystring</div></pre></td></tr></table></figure>
<p>必须将 mystring 复位成其初始值，因为第一个 sub() 调用直接修改了 mystring。在执行时，此代码将使 awk 输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HOw are you doing today?</div><div class="line">HOw are yOu dOing tOday?</div></pre></td></tr></table></figure>
<p>当然，也可以是更复杂的规则表达式。我把测试一些复杂规则表达式的任务留给您来完成。</p>
<p>通过介绍函数 split()，我们来汇总一下已讨论过的函数。split() 的任务是“切开”字符串，并将各部分放到使用整数下标的数组中。以下是一个 split() 调用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numelements=split(&quot;Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec&quot;,mymonths,&quot;,&quot;)</div></pre></td></tr></table></figure>
<p>调用 split() 时，第一个自变量包含要切开文字字符串或字符串变量。在第二个自变量中，应该指定 split() 将填入片段部分的数组名称。在第三个元素中，指定用于切开字符串的分隔符。split() 返回时，它将返回分割的字符串元素的数量。split() 将每一个片段赋值给下标从 1 开始的数组，因此以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print mymonths[1],mymonths[numelements]</div></pre></td></tr></table></figure>
<p>……将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Jan Dec</div></pre></td></tr></table></figure>
<p>特殊字符串形式</p>
<p>简短注释 – 调用 length()、sub() 或 gsub() 时，可以去掉最后一个自变量，这样 awk 将对 $0（整个当前行）应用函数调用。要打印文件中每一行的长度，使用以下 awk 脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">print length()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二十一-财务上的趣事"><a href="#二十一-财务上的趣事" class="headerlink" title="二十一. 财务上的趣事"></a>二十一. 财务上的趣事</h3><p>几星期前，我决定用 awk 编写自己的支票簿结算程序。我决定使用简单的 tab 定界文本文件，以便于输入最近的存款和提款记录。其思路是将这个数据交给 awk 脚本，该脚本会自动合计所有金额，并告诉我余额。以下是我决定如何将所有交易记录到 “ASCII checkbook” 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">23 Aug 2000 food - - Y Jimmy&apos;s Buffet 30.25</div></pre></td></tr></table></figure>
<p>此文件中的每个字段都由一个或多个 tab 分隔。在日期（字段 1，$1）之后，有两个字段叫做“费用分类帐”和“收入分类帐”。以上面这行为例，输入费用时，我在费用字段中放入四个字母的别名，在收入字段中放入 “-“（空白项）。这表示这一特定项是“食品费用”。:) 以下是存款的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">23 Aug 2000 - inco - Y Boss Man 2001.00</div></pre></td></tr></table></figure>
<p>在这个实例中，我在费用分类帐中放入 “-“（空白），在收入分类帐中放入 “inco”。”inco” 是一般（薪水之类）收入的别名。使用分类帐别名让我可以按类别生成收入和费用的明细分类帐。至于记录的其余部分，其它所有字段都是不需加以说明的。“是否付清？”字段（”Y” 或 “N”）记录了交易是否已过帐到我的帐户；除此之外，还有一个交易描述，和一个正的美元金额。</p>
<p>用于计算当前余额的算法不太难。awk 只需要依次读取每一行。如果列出了费用分类帐，但没有收入分类帐（为 “-“），那么这一项就是借方。如果列出了收入分类帐，但没有费用分类帐（为 “-“），那么这一项就是贷方。而且，如果同时列出了费用和收入分类帐，那么这个金额就是“分类帐转帐”；即，从费用分类帐减去美元金额，并将此金额添加到收入分类帐。此外，所有这些分类帐都是虚拟的，但对于跟踪收入和支出以及预算却非常有用。</p>
<p>代码</p>
<p>现在该研究代码了。我们将从第一行（BEGIN 块和函数定义）开始：</p>
<p>balance，第 1 部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env awk -f</div><div class="line">BEGIN &#123; </div><div class="line">FS=&quot;/t+&quot;</div><div class="line">months=&quot;Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&quot;</div><div class="line">&#125;</div><div class="line">function monthdigit(mymonth) &#123;</div><div class="line">return (index(months,mymonth)+3)/4</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先执行 “chmod +x myscript” 命令，那么将第一行 “#!…” 添加到任何 awk 脚本将使它可以直接从 shell 中执行。其余行定义了 BEGIN 块，在 awk 开始处理支票簿文件之前将执行这个代码块。我们将 FS（字段分隔符）设置成 “/t+”，它会告诉 awk 字段由一个或多个 tab 分隔。另外，我们定义了字符串 months，下面将出现的 monthdigit() 函数将使用它。</p>
<p>最后三行显示了如何定义自己的 awk 。格式很简单 – 输入 “function”，再输入名称，然后在括号中输入由逗号分隔的参数。在此之后，”{ }” 代码块包含了您希望这个函数执行的代码。所有函数都可以访问全局变量（如 months 变量）。另外，awk 提供了 “return” 语句，它允许函数返回一个值，并执行类似于 C 和其它语言中 “return” 的操作。这个特定函数将以 3 个字母字符串格式表示的月份名称转换成等价的数值。例如，以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print monthdigit(&quot;Mar&quot;)</div></pre></td></tr></table></figure>
<p>……将打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3</div></pre></td></tr></table></figure>
<p>现在，让我们讨论其它一些函数。</p>
<p>财务函数</p>
<p>以下是其它三个执行簿记的函数。我们即将见到的主代码块将调用这些函数之一，按顺序处理支票簿文件的每一行，从而将相应交易记录到 awk 数组中。有三种基本交易，贷方 (doincome)、借方 (doexpense) 和转帐 (dotransfer)。您会发现这三个函数全都接受一个自变量，叫作 mybalance。mybalance 是二维数组的一个占位符，我们将它作为自变量进行传递。目前，我们还没有处理过二维数组；但是，在下面可以看到，语法非常简单。只须用逗号分隔每一维就行了。</p>
<p>我们将按以下方式将信息记录到 “mybalance” 中。数组的第一维从 0 到 12，用于指定月份，0 代表全年。第二维是四个字母的分类帐，如 “food” 或 “inco”；这是我们处理的真实分类帐。因此，要查找全年食品分类帐的余额，应查看 mybalance[0,”food”]。要查找 6 月的收入，应查看 mybalance[6,”inco”]。</p>
<p>balance，第 2 部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function doincome(mybalance) &#123;</div><div class="line">mybalance[curmonth,$3] += amount</div><div class="line">mybalance[0,$3] += amount</div><div class="line">&#125;</div><div class="line">function doexpense(mybalance) &#123;</div><div class="line">mybalance[curmonth,$2] -= amount</div><div class="line">mybalance[0,$2] -= amount</div><div class="line">&#125;</div><div class="line">function dotransfer(mybalance) &#123;</div><div class="line">mybalance[0,$2] -= amount</div><div class="line">mybalance[curmonth,$2] -= amount</div><div class="line">mybalance[0,$3] += amount</div><div class="line">mybalance[curmonth,$3] += amount</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 doincome() 或任何其它函数时，我们将交易记录到两个位置 – mybalance[0,category] 和 mybalance[curmonth, category]，它们分别表示全年的分类帐余额和当月的分类帐余额。这让我们稍后可以轻松地生成年度或月度收入／支出明细分类帐。</p>
<p>如果研究这些函数，将发现在我的引用中传递了 mybalance 引用的数组。另外，我们还引用了几个全局变量：curmonth，它保存了当前记录所属的月份的数值，$2（费用分类帐），$3（收入分类帐）和金额（$7，美元金额）。调用 doincome() 和其它函数时，已经为要处理的当前记录（行）正确设置了所有这些变量。</p>
<p>主块</p>
<p>以下是主代码块，它包含了分析每一行输入数据的代码。请记住，由于正确设置了 FS，可以用 $ 1 引用第一个字段，用 $2 引用第二个字段，依次类推。调用 doincome() 和其它函数时，这些函数可以从函数内部访问 curmonth、$2、$3 和金额的当前值。请先研究代码，在代码之后可以见到我的说明。</p>
<p>balance，第 3 部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">curmonth=monthdigit(substr($1,4,3))</div><div class="line">amount=$7</div><div class="line"></div><div class="line">#record all the categories encountered</div><div class="line">if ( $2 != &quot;-&quot; ) globcat[$2]=&quot;yes&quot;</div><div class="line">if ( $3 != &quot;-&quot; ) globcat[$3]=&quot;yes&quot;</div><div class="line">#tally up the transaction properly</div><div class="line">if ( $2 == &quot;-&quot; ) &#123;</div><div class="line">  if ( $3 == &quot;-&quot; ) &#123;</div><div class="line">  print &quot;Error: inc and exp fields are both blank!&quot;</div><div class="line">  exit 1</div><div class="line">  &#125; else &#123;</div><div class="line">  #this is income</div><div class="line">  doincome(balance)</div><div class="line">  if ( $5 == &quot;Y&quot; )   doincome(balance2)</div><div class="line">  &#125;</div><div class="line">&#125; </div><div class="line">else if ( $3 == &quot;-&quot; ) &#123;</div><div class="line">  #this is an expense </div><div class="line">  doexpense(balance)</div><div class="line">  if ( $5 == &quot;Y&quot; )   doexpense(balance2)</div><div class="line">  &#125; else &#123;</div><div class="line">  #this is a transfer</div><div class="line">  dotransfer(balance)</div><div class="line">  if ( $5 == &quot;Y&quot; )   dotransfer(balance2)</div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在主块中，前两行将 curmonth 设置成 1 到 12 之间的整数，并将金额设置成字段 7（使代码易于理解）。然后，是四行有趣的代码，它们将值写到数组 globcat 中。globcat，或称作全局分类帐数组，用于记录在文件中遇到的所有分类帐 – “inco”、”misc”、”food”、”util” 等。例如，如果 $2 == “inco”，则将 globcat[“inco”] 设置成 “yes”。稍后，我们可以使用简单的 “for (x in globcat)” 循环来迭代分类帐列表。</p>
<p>在接着的大约二十行中，我们分析字段 $2 和 $3，并适当记录交易。如果 $2==”-“ 且 $3!=”-“，表示我们有收入，因此调用 doincome()。如果是相反的情况，则调用 doexpense()；如果 $2 和 $3 都包含分类帐，则调用 dotransfer()。每次我们都将 “balance” 数组传递给这些函数，从而在这些函数中记录适当的数据。</p>
<p>您还会发现几行代码说“if ( $5 == “Y” )，那么将同一个交易记录到 balance2 中”。我们在这里究竟做了些什么？您将回忆起 $5 包含 “Y” 或 “N”，并记录交易是否已经过帐到帐户。由于仅当过帐了交易时我们才将交易记录到 balance2，因此 balance2 包含了真实的帐户余额，而 “balance” 包含了所有交易，不管是否已经过帐。可以使用 balance2 来验证数据项（因为它应该与当前银行帐户余额匹配），可以使用 “balance” 来确保没有透支帐户（因为它会考虑您开出的尚未兑现的所有支票）。</p>
<p>生成报表</p>
<p>主块重复处理了每一行记录之后，现在我们有了关于比较全面的、按分类帐和按月份划分的借方和贷方记录。现在，在这种情况下最合适的做法是只须定义生成报表的 END 块：</p>
<p>balance，第 4 部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">END &#123;</div><div class="line">bal=0</div><div class="line">bal2=0</div><div class="line">for (x in globcat) &#123;</div><div class="line">bal=bal+balance[0,x]</div><div class="line">bal2=bal2+balance2[0,x]</div><div class="line">&#125;</div><div class="line">printf(&quot;Your available funds: %10.2f/n&quot;, bal)</div><div class="line">printf(&quot;Your account balance: %10.2f/n&quot;, bal2)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个报表将打印出汇总，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Your available funds:1174.22</div><div class="line">Your account balance:2399.33</div></pre></td></tr></table></figure>
<p>在 END 块中，我们使用 “for (x in globcat)” 结构来迭代每一个分类帐，根据记录在案的交易结算主要余额。实际上，我们结算两个余额，一个是可用资金，另一个是帐户余额。要执行程序并处理您在文件 “mycheckbook.txt” 中输入的财务数据，将以上所有代码放入文本文件 “balance”，执行 “chmod +x balance”，然后输入 “./balance mycheckbook.txt”。然后 balance 脚本将合计所有交易，打印出两行余额汇总。</p>
<p>升级</p>
<p>我使用这个程序的更高级版本来管理我的个人和企业财务。我的版本（由于篇幅限制不能在此涵盖）会打印出收入和费用的月度明细分类帐，包括年度总合、净收入和其它许多内容。它甚至以 HTML 格式输出数据，因此我可以在 Web 浏览器中查看它。:) 如果您认为这个程序有用，我建议您将这些特性添加到这个脚本中。不必将它配置成要 记录 任何附加信息；所需的全部信息已经在 balance 和 balance2 里面了。只要升级 END 块就万事具备了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;awk是一种很棒的语言。awk 适合于文本处理和报表生成，它还有许多精心设计的特性，允许进行需要特殊技巧程序设计。与某些语言不同，awk 的
    
    </summary>
    
      <category term="linux shell" scheme="https://fudawei.github.io/categories/linux-shell/"/>
    
    
      <category term="linux shell" scheme="https://fudawei.github.io/tags/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码：核心容器</title>
    <link href="https://fudawei.github.io/2016/12/29/Spring%E6%BA%90%E7%A0%81%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8/"/>
    <id>https://fudawei.github.io/2016/12/29/Spring源码：核心容器/</id>
    <published>2016-12-29T12:53:14.000Z</published>
    <updated>2017-02-08T03:39:19.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h3><pre><code>IoC也被称作依赖注入(DI)。它是一个处理对象依赖项的过程，也就是将他们一起工作的其他的对象，只有通过构造参数、工厂方法参数或者（属性注入）通过构造参数实例化或通过工厂方法返回对象后再设置属性。当创建bean后，IoC容器再将这些依赖项注入进去。这个过程基本上是反转的，因此得名控制反转（IoC）。
</code></pre><p>下图是 IoC 的高级别视图<br><img src="/img/spring/container_1.png" alt=""></p>
<p>IoC容器利用Java的POJO类和配置元数据来生成 完全配置和可执行 的系统或应用程序。而Bean在Spring中就是POJO，也可以认为Bean就是对象</p>
<p>设计实现</p>
<p>   接口设计</p>
<p>   Spring作为面向对象编程的集大成之作，我们直接从接口入手可以帮助我们更直观的了解Ioc容器的设计原理。</p>
<pre><code>注1：笔者未能找到最新的Spring 4.0 接口体系图片，所以接口体系用都是Spring-3.1 接口体系，而分析的Sping 源码版本为：Spring-4.3。其实本来打算重新绘制新的接口体系，但分析过程中也发现两者鲜有差异，所以为了节省时间，固延用了老的版本。

注2：主要参考了《Spring技术内幕》第二版，但他的思维太过跳跃，所以我重新做了编排，还有就是很多细节部分参考了《Spring源码深度解析》，当然因为源码版本的不同，也会有些许差异。
</code></pre><p>下图描述了Ioc容器中的主要接口设计</p>
<p><img src="/img/spring/container_2.png" alt=""></p>
<p>这里主要是接口体系，而具体实现体系，比如DefaultListableBeanFactory就是为了实现ConfigurableBeanFactory，从而成为一个简单Ioc容器实现。与其他Ioc容器类似，XmlBeanFactory就是为了实现BeanFactory，但都是基于DefaultListableBeanFactory的基础做了扩展。同样的，ApplicationContext也一样。        </p>
<p>  从图中我们可以简要的做出以下分析：</p>
<ul>
<li><p>从接口BeanFactory到HierarchicalBeanFactory，再到ConfigurableBeanFactory,这是一条主要的BeanFactory设计路径。在这条接口设计路径中，BeanFactory，是一条主要的BeanFactory设计路径。在这条接口设计路径中，BeanFactory接口定义了基本的Ioc容器的规范。在这个接口定义中，包括了getBean()这样的Ioc容器的基本方法（通过这个方法可以从容器中取得Bean）。而HierarchicalBeanFactory接口在继承了BeanFactory的基本接口后，增加了getParentBeanFactory()的接口功能，使BeanFactory具备了双亲Ioc容器的管理功能。在接下来的ConfigurableBeanFactory接口中，主要定义了一些对BeanFactory的配置功能，比如通过setParentBeanFactory()设置双亲Ioc容器，通过addBeanPostProcessor()配置Bean后置处理器，等等。通过这些接口设计的叠加，定义了BeanFactory就是最简单的Ioc容器的基本功能。</p>
</li>
<li><p>第二条接口设计主线是，以ApplicationContext作为核心的接口设计，这里涉及的主要接口设计有，从BeanFactory到ListableBeanFactory，再到ApplicationContext，再到我们常用的WebApplicationContext或者ConfigurableApplicationContext接口。我们常用的应用基本都是org.framework.context 包里的WebApplicationContext或者ConfigurableApplicationContext实现。在这个接口体现中，ListableBeanFactory和HierarchicalBeanFactory两个接口，连接BeanFactory接口定义和ApplicationContext应用的接口定义。在ListableBeanFactory接口中，细化了许多BeanFactory的接口功能，比如定义了getBeanDefinitionNames()接口方法；对于ApplicationContext接口，它通过继承MessageSource、ResourceLoader、ApplicationEventPublisher接口，在BeanFactory简单Ioc容器的基础上添加了许多对高级容器的特性支持。</p>
</li>
<li><p>这个接口系统是以BeanFactory和ApplicationContext为核心设计的，而BeanFactory是Ioc容器中最基本的接口，在ApplicationContext的设计中，一方面，可以看到它继承了BeanFactory接口体系中的ListableBeanFactory、AutowireCapableBeanFactory、HierarchicalBeanFactory等BeanFactory的接口，具备了BeanFactory Ioc容器的基本功能；另一方面，通过继承MessageSource、ResourceLoadr、ApplicationEventPublisher这些接口，BeanFactory为ApplicationContext赋予了更高级的Ioc容器特性。对于ApplicationContext而言，为了在Web环境中使用它，还设计了WebApplicationContext接口，而这个接口通过继承ThemeSource接口来扩充功能。</p>
</li>
</ul>
<h3 id="BeanFactory容器的设计"><a href="#BeanFactory容器的设计" class="headerlink" title="BeanFactory容器的设计"></a>BeanFactory容器的设计</h3><pre><code>恩，我们与其写繁琐的文字，不如直接阅读代码来的直接的多。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">package org.springframework.beans.factory;</div><div class="line"></div><div class="line">import org.springframework.beans.BeansException;</div><div class="line">import org.springframework.core.ResolvableType;</div><div class="line"></div><div class="line">/**</div><div class="line"> * BeanFactory作为最原始同时也最重要的Ioc容器,它主要的功能是为依赖注入 （DI） 提供支持， BeanFactory 和相关的接口，比如，BeanFactoryAware、 </div><div class="line"> * DisposableBean、InitializingBean，仍旧保留在 Spring 中，主要目的是向后兼容已经存在的和那些 Spring 整合在一起的第三方框架。在 Spring 中</div><div class="line"> * ，有大量对 BeanFactory 接口的实现。其中，最常被使用的是 XmlBeanFactory 类。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一</div><div class="line"> * 个被配置化的系统或者应用。在资源宝贵的移动设备或者基于applet的应用当中， BeanFactory 会被优先选择。否则，一般使用的是 ApplicationContext</div><div class="line"> * </div><div class="line"> * 这里定义的只是一系列的接口方法，通过这一系列的BeanFactory接口，可以使用不同的Bean的检索方法很方便地从Ioc容器中得到需要的Bean，从而忽略具体</div><div class="line"> * 的Ioc容器的实现，从这个角度上看，这些检索方法代表的是最为基本的容器入口。</div><div class="line"> *</div><div class="line"> * @author Rod Johnson</div><div class="line"> * @author Juergen Hoeller</div><div class="line"> * @author Chris Beams</div><div class="line"> * @since 13 April 2001</div><div class="line"> */</div><div class="line">public interface BeanFactory &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 转定义符&quot;&amp;&quot; 用来引用实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;a会得到那个Factory</div><div class="line">	 *</div><div class="line">	 * FactoryBean和BeanFactory 是在Spring中使用最为频繁的类，它们在拼写上很相似。一个是Factory，也就是Ioc容器或对象工厂；一个</div><div class="line">	 * 是Bean。在Spring中，所有的Bean都是由BeanFactory（也就是Ioc容器）来进行管理的。但对FactoryBean而言，这个Bean不是简单的Be</div><div class="line">	 * an，而是一个能产生或者修饰对象生成的工厂Bean，它的实现与设计模式中的工厂模式和修饰器模式类似。</div><div class="line">	 */</div><div class="line">	String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 五个不同形式的getBean方法，获取实例</div><div class="line">	 * @param name 检索所用的Bean名</div><div class="line">	 * @return Object（&lt;T&gt; T） 实例对象</div><div class="line">	 * @throws BeansException 如果Bean不能取得</div><div class="line">	 */</div><div class="line">	Object getBean(String name) throws BeansException;</div><div class="line">	&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;</div><div class="line">	&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;</div><div class="line">	Object getBean(String name, Object... args) throws BeansException;</div><div class="line">	&lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 让用户判断容器是否含有指定名字的Bean.</div><div class="line">	 * @param name 搜索所用的Bean名</div><div class="line">	 * @return boolean 是否包含其中</div><div class="line">	 */</div><div class="line">	boolean containsBean(String name);</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 查询指定名字的Bean是否是Singleton类型的Bean.</div><div class="line">	 * 对于Singleton属性，可以在BeanDefinition指定.</div><div class="line">	 * @param name 搜索所用的Bean名</div><div class="line">	 * @return boolean 是否包是Singleton</div><div class="line">	 * @throws NoSuchBeanDefinitionException 没有找到Bean</div><div class="line">	 */</div><div class="line">	boolean isSingleton(String name) throws NoSuchBeanDefinitionException;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 查询指定名字的Bean是否是Prototype类型的。</div><div class="line">	 * 与Singleton属性一样，可以在BeanDefinition指定.</div><div class="line">	 * @param name 搜索所用的Bean名</div><div class="line">	 * @return boolean 是否包是Prototype</div><div class="line">	 * @throws NoSuchBeanDefinitionException 没有找到Bean</div><div class="line">	 */</div><div class="line">	boolean isPrototype(String name) throws NoSuchBeanDefinitionException;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 查询指定了名字的Bean的Class类型是否是特定的Class类型.</div><div class="line">	 * @param name 搜索所用的Bean名</div><div class="line">	 * @param typeToMatch 匹配类型</div><div class="line">	 * @return boolean 是否是特定类型</div><div class="line">	 * @throws NoSuchBeanDefinitionException 没有找到Bean</div><div class="line">	 */</div><div class="line">	boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;</div><div class="line">	boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 查询指定名字的Bean的Class类型.</div><div class="line">	 * @param name 搜索所用的Bean名</div><div class="line">	 * @return 指定的Bean或者null(没有找到合适的Bean)</div><div class="line">	 * @throws NoSuchBeanDefinitionException 没有找到Bean</div><div class="line">	 */</div><div class="line">	Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 查询指定了名字的Bean的所有别名，这些都是在BeanDefinition中定义的</div><div class="line">	 * @param name 搜索所用的Bean名</div><div class="line">	 * @return 指定名字的Bean的所有别名 或者一个空的数组</div><div class="line">	 */</div><div class="line">	String[] getAliases(String name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>容器的基础：XmlBeanFactory</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">package org.springframework.beans.factory.xml;</div><div class="line"></div><div class="line">import org.springframework.beans.BeansException;</div><div class="line">import org.springframework.beans.factory.BeanFactory;</div><div class="line">import org.springframework.beans.factory.support.DefaultListableBeanFactory;</div><div class="line">import org.springframework.core.io.Resource;</div><div class="line"></div><div class="line">/**</div><div class="line"> * XmlBeanFactory是BeanFactory的最简单实现类</div><div class="line"> * </div><div class="line"> * XmlBeanFactory的功能是建立在DefaultListableBeanFactory这个基本容器的基础上的，并在这个基本容器的基础上实行了其他诸如</div><div class="line"> * XML读取的附加功能。XmlBeanFactory使用了DefaultListableBeanFactory作为基础类，DefaultListableBeanFactory是一个很重</div><div class="line"> * 要的Ioc实现，会在下一章进行重点论述。</div><div class="line"> *</div><div class="line"> * @author Rod Johnson</div><div class="line"> * @author Juergen Hoeller</div><div class="line"> * @author Chris Beams</div><div class="line"> * @since 15 April 2001</div><div class="line"> */</div><div class="line">public class XmlBeanFactory extends DefaultListableBeanFactory &#123;</div><div class="line"></div><div class="line">	private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 根据给定来源，创建一个XmlBeanFactory</div><div class="line">	 * @param resource  Spring中对与外部资源的抽象，最常见的是对文件的抽象，特别是XML文件。而且Resource里面通常</div><div class="line">	 * 是保存了Spring使用者的Bean定义，比如applicationContext.xml在被加载时，就会被抽象为Resource来处理。</div><div class="line">	 * @throws BeansException 载入或者解析中发生错误</div><div class="line">	 */</div><div class="line">	public XmlBeanFactory(Resource resource) throws BeansException &#123;</div><div class="line">		this(resource, null);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 根据给定来源和BeanFactory，创建一个XmlBeanFactory</div><div class="line">	 * @param resource  Spring中对与外部资源的抽象，最常见的是对文件的抽象，特别是XML文件。而且Resource里面通常</div><div class="line">	 * 是保存了Spring使用者的Bean定义，比如applicationContext.xml在被加载时，就会被抽象为Resource来处理。</div><div class="line">	 * @param parentBeanFactory 父类的BeanFactory</div><div class="line">	 * @throws BeansException 载入或者解析中发生错误</div><div class="line">	 */</div><div class="line">	public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException &#123;</div><div class="line">		super(parentBeanFactory);</div><div class="line">		this.reader.loadBeanDefinitions(resource);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最原始Ioc容器的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import org.springframework.beans.factory.BeanFactory;</div><div class="line">import org.springframework.beans.factory.xml.XmlBeanFactory;</div><div class="line">import org.springframework.core.io.ClassPathResource;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 最原始的Ioc容器使用，当然这也是Spring容器中效率最高的用法，比起繁琐的文字，阅读源码来得直观得多。</div><div class="line"> * 只需要写两行代码就行了，当然前提是要准备好Spring的配置文件</div><div class="line"> *</div><div class="line"> * @author  kay</div><div class="line"> * @since   1.0</div><div class="line"> */</div><div class="line">@SuppressWarnings(&quot;deprecation&quot;)</div><div class="line">public class SimpleBeanFactory &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ClassPathResource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);</div><div class="line">		BeanFactory beanFactory = new XmlBeanFactory(resource);		</div><div class="line">		Message message = beanFactory.getBean(&quot;message&quot;, Message.class);    //Message是自己写的测试类</div><div class="line">		message.printMessage();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是XmlBeanFactory在使用过程中涉及到的类的关系图</p>
<p><img src="/img/spring/container_1.png" alt=""></p>
<p>图中空心三角加实线代表继承、空心三角加虚线代表实现、实线箭头加虚线代表依赖、实心菱形加实线代表组合。这里用下划线代表接口，没有下划线的代表类。</p>
<p>看着非常复杂是吧，不要紧，我们以代码来做简要说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import org.springframework.beans.factory.support.DefaultListableBeanFactory;</div><div class="line">import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;</div><div class="line">import org.springframework.core.io.ClassPathResource;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 这是与SimpleBeanFactory等效的编程式使用Ioc容器</div><div class="line"> * </div><div class="line"> * 从中我也可以看到一些Ioc的基本原理，同时也揭示了Ioc实现中的一些关键类：如Resource、DefaultListableBeanFactory</div><div class="line"> * 以及BeanDefinitionReader等等</div><div class="line"> *</div><div class="line"> * @author  kay</div><div class="line"> * @since   1.0</div><div class="line"> */</div><div class="line">public class ProgramBeanFactory&#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ClassPathResource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);</div><div class="line">		DefaultListableBeanFactory factory = new DefaultListableBeanFactory();</div><div class="line">		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);</div><div class="line">		reader.loadBeanDefinitions(resource);</div><div class="line">		Message message = factory.getBean(&quot;message&quot;, Message.class);	//Message是自己写的测试类</div><div class="line">		message.printMessage();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上，可以简单说明我们在使用Ioc容器时，需要如下几个步骤：</p>
<pre><code>    1，创建Ioc配置文件的抽象资源，这个抽象资源包含了BeanDefinition的定义信息。

    2，创建一个BeanFactory，这里使用了DefaultListableBeanFactory。

    3，创建一个载入BeanDefinition的读取器，这里使用XmlBeanDefinitionReader来载入XML文件形式的BeanDefinition，通过一个回调配置给BeanFactory。

    4，从定义好的资源位置读入配置信息，具体的解析过程由XmlBeanDefinitionReader来完成。完成整个载入和注册Bean定义之后，需要的Ioc容器就建立起来了。这个时候我们就可以直接使用Ioc容器了。

恩，以下是Bean在使用过程中的解析、注册时效图，我们来一步一步分析，它是怎么在源码中实现的。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;容器概述&quot;&gt;&lt;a href=&quot;#容器概述&quot; class=&quot;headerlink&quot; title=&quot;容器概述&quot;&gt;&lt;/a&gt;容器概述&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;IoC也被称作依赖注入(DI)。它是一个处理对象依赖项的过程，也就是将他们一起工作的其他的对象，只有通过构造
    
    </summary>
    
      <category term="JavaEE框架" scheme="https://fudawei.github.io/categories/JavaEE%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="https://fudawei.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>一致性HASH</title>
    <link href="https://fudawei.github.io/2016/12/27/%E4%B8%80%E8%87%B4%E6%80%A7Hash/"/>
    <id>https://fudawei.github.io/2016/12/27/一致性Hash/</id>
    <published>2016-12-27T04:53:14.000Z</published>
    <updated>2017-02-08T03:39:19.517Z</updated>
    
    <content type="html"><![CDATA[<p>   一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。</p>
<p> <strong>   一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：</strong></p>
<ol>
<li>平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li>
<li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 </li>
<li>分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 </li>
<li>负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li>
</ol>
<p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。接下来主要讲解一下一致性哈希算法是如何设计的：</p>
<h4 id="环形Hash空间"><a href="#环形Hash空间" class="headerlink" title="环形Hash空间"></a>环形Hash空间</h4><p>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图<br><img src="/img/hash/hash_1.png" alt=""></p>
<p>把数据通过一定的hash算法处理后映射到环上<br>现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图：<br>    Hash(object1) = key1；<br>    Hash(object2) = key2；<br>    Hash(object3) = key3；</p>
<p><img src="/img/hash/hash_2.png" alt=""></p>
<p>将机器通过hash算法映射到环上<br>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。<br>假设现在有NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：<br>Hash(NODE1) = KEY1;<br>Hash(NODE2) = KEY2;<br>Hash(NODE3) = KEY3;</p>
<p><img src="/img/hash/hash_3.png" alt=""></p>
<p>通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动object1存储到了NODE1中，object3存储到了NODE2中，object2、object4存储到了NODE3中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。</p>
<h4 id="机器的删除与添加"><a href="#机器的删除与添加" class="headerlink" title="机器的删除与添加"></a>机器的删除与添加</h4><p>普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。</p>
<ol>
<li>节点（机器）的删除<br> 以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图：</li>
</ol>
<p><img src="/img/hash/hash_4.png" alt=""></p>
<ol>
<li>节点（机器）的添加<br> 如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图：</li>
</ol>
<p><img src="/img/hash/hash_5.png" alt=""></p>
<p>通过按顺时针迁移的规则，那么object2被迁移到了NODE4中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p>
<h4 id="平衡性"><a href="#平衡性" class="headerlink" title="平衡性"></a>平衡性</h4><p>根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。hash算法是不保证平衡的，如上面只部署了NODE1和NODE3的情况（NODE2被删除的图），object1存储到了NODE1中，而object2、object3、object4都存储到了NODE3中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。<br>    ——“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。<br>以上面只部署了NODE1和NODE3的情况（NODE2被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：</p>
<p><img src="/img/hash/hash_6.png" alt=""></p>
<p>根据上图可知对象的映射关系：object1-&gt;NODE1-1，object2-&gt;NODE1-2，object3-&gt;NODE3-2，object4-&gt;NODE3-1。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，正真的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：</p>
<p><img src="/img/hash/hash_7.png" alt=""></p>
<p>虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设NODE1的IP地址为192.168.1.100。引入“虚拟节点”前，计算 cache A 的 hash 值：<br>Hash(“192.168.1.100”);<br>引入“虚拟节点”后，计算“虚拟节”点NODE1-1和NODE1-2的hash值：<br>Hash(“192.168.1.100#1”); // NODE1-1<br>Hash(“192.168.1.100#2”); // NODE1-2</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到
    
    </summary>
    
      <category term="分布式" scheme="https://fudawei.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="算法" scheme="https://fudawei.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分布式" scheme="https://fudawei.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="算法" scheme="https://fudawei.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何减少接口响应时间</title>
    <link href="https://fudawei.github.io/2016/12/16/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/"/>
    <id>https://fudawei.github.io/2016/12/16/如何减少接口的响应时间/</id>
    <published>2016-12-16T13:26:33.000Z</published>
    <updated>2017-02-08T03:39:19.513Z</updated>
    
    <content type="html"><![CDATA[<p>Premature optimization is the root of all evil.</p>
<p>　 — Donald Knuth</p>
<p>对于程序优化，我一直采取保守的态度，除非万不得已。但是随着业务的不断发展，程序越来越复杂，代码越写越多，优化似乎是终有一天会到来的事情。</p>
<p>那么对于一个典型的后台服务接口，我们可以从那些方面入手进行优化呢？</p>
<h2 id="接口拆分"><a href="#接口拆分" class="headerlink" title="接口拆分"></a>接口拆分</h2><h4 id="接口垂直拆分"><a href="#接口垂直拆分" class="headerlink" title="接口垂直拆分"></a>接口垂直拆分</h4><p>垂直拆分可以简单理解为微服务化，把一个大而复杂的服务拆分成多个相互独立，职能单一的服务，单独部署。 更细粒度拆分的好处是，能对某个具体的微服务进行特殊优化，以最大的投入产出比来解决整个服务的性能。 垂直拆分还有一个好处是，对于非必须的接口，可以很方便的进行降级处理，把坏影响隔离到核心逻辑外部。 最容易想到的优化办法是把某个对整体性能有决定性影响的微服务接口进行水平扩容。</p>
<p><strong>注意</strong>: 拆分后必定会增加外部接口调用，多少会有些额外开销，但是对于有限几个调用，拆分的还是值得的。</p>
<h4 id="接口水平拆分"><a href="#接口水平拆分" class="headerlink" title="接口水平拆分"></a>接口水平拆分</h4><p>这里说的水平拆分一定不是把一个接口部署更多份，因为这样只能解决接口的容量问题，但是不能减少接口的响应时间。 水平拆分可以简单理解成mapreduce模型，把整个计算逻辑或者数据平均分配到集群中的N个服务器去，然后由一台机器去并发调用并做结果合并。 理论上这种方式能把响应减少到1/N+合并+调用开销的时间。</p>
<p><strong>注意</strong>： 一个问题需要考虑的是，如果并发调用的接口返回的数据量比较大，可能会对合并机器的网络负载和数据序列化(CPU)有一定影响。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h4 id="接口缓存"><a href="#接口缓存" class="headerlink" title="接口缓存"></a>接口缓存</h4><p>一个有着复杂逻辑或者大量计算数据的接口，能对整个结果进行缓存再好不过了。缓存针对不同的场景会有多种策略，对于有大量并发请求的场景， 推荐一个方案：一种基于“哨兵”的分布式缓存设计，不会有损失第一个用户，也不会有定时更新缓存的额外开销</p>
<h4 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h4><p>本地缓存有两种场景，对于类似字典类型的数据，可以静态化后放入内存，定时去刷新或者采用通知机制去更新。</p>
<p>还有一种场景是用ThreadLocal缓存重复内部计算与重复的对象创建； 对于链路比较长或者循环比较深的接口，ThreadLocal减少重复计算和对象创建，从而降低RT和节约内存。</p>
<p>注意： 在有内部并发的地方使用ThreadLocal一定要注意不同线程间的数据同步。主线程的ThreadLocal数据和每个并发子线程的ThreadLocal数据要同步好<br>内部优化</p>
<h4 id="非核心流程异步化"><a href="#非核心流程异步化" class="headerlink" title="非核心流程异步化"></a>非核心流程异步化</h4><p>类似于发消息，写日志，更新缓存等不会影响接口准确性的非核心流程，可以采用异步方式进行处理，不阻塞主计算逻辑处理。</p>
<h4 id="内部并发"><a href="#内部并发" class="headerlink" title="内部并发"></a>内部并发</h4><p>如果进行水平拆分后，并发调用IO较大，可以考虑换成内部并发解决IO问题。如果内部并发涉及到每个线程更新同一个集合数据，不用忘了使用线程安全的集合。 这里有一个并发更新HashMap的case：并发环境下HashMap引起full gc排查。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优化一定不是一蹴而就的，整个优化过程是一个统计–&gt;方案–&gt;验证的闭环，需要不断试错，不断挖掘，最终达到预期。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Premature optimization is the root of all evil.&lt;/p&gt;
&lt;p&gt;　 — Donald Knuth&lt;/p&gt;
&lt;p&gt;对于程序优化，我一直采取保守的态度，除非万不得已。但是随着业务的不断发展，程序越来越复杂，代码越写越多，优化似乎是终
    
    </summary>
    
      <category term="Java" scheme="https://fudawei.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://fudawei.github.io/tags/Java/"/>
    
      <category term="优化" scheme="https://fudawei.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring架构详解：spring总体架构与设计理念个内部组件的作用和关系</title>
    <link href="https://fudawei.github.io/2016/12/15/Spring%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3%EF%BC%9ASpring%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%E5%92%8C%E5%86%85%E9%83%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%85%B3%E7%B3%BB/"/>
    <id>https://fudawei.github.io/2016/12/15/Spring架构详解：Spring总体架构与设计理念和内部组件的作用和关系/</id>
    <published>2016-12-15T04:53:14.000Z</published>
    <updated>2017-02-08T03:39:19.513Z</updated>
    
    <content type="html"><![CDATA[<p>Spring总体架构与设计理念<br>概述：</p>
<p>Spring作为现在最优秀的框架之一，已被广泛的使用。本系列文章将从以下角度对Spring的架构进行剖析：设计Spring框架总体结构的理念是什么？包含哪几个核心组件？为什么需要这些组件？它们又是如何结合在一起构成Spring的总体架构？Spring的AOP特性又是如何利用这些基础架构来工作的？</p>
<p>Spring的总体架构</p>
<p>Spring总共有十几个组件，但是真正核心的组件只有几个，下面是Spring框架的总体架构图：<br><img src="/img/spring/spring_infrastructure.png" alt=""></p>
<p>从上图中可以看出Spring框架中的核心组件只有三个：Core、Context和Beans。它们构建起了整个Spring的骨骼架构。没有它们就不可能有AOP、Web等上层的特性功能。下面也将主要从这三个组件入手分析Spring。</p>
<p>Spring的设计理念</p>
<p>前面介绍了Spring的三个核心组件，如果再在它们三个中选出核心的话，那就非Beans组件莫属了，为何这样说，其实Spring就是面向Bean的编程（BOP,Bean Oriented Programming），Bean在Spring 中才是真正的主角。</p>
<p>Bean在Spring中作用就像Object对OOP的意义一样，没有对象的概念就像没有面向对象编程，Spring中没有Bean也就没有Spring存在的意义。就像一次演出舞台都准备好了但是却没有演员一样。为什 么要Bean这种角色Bean或者为何在Spring如此重要，这由Spring框架的设计目标决定，Spring为何如此流行，我们用Spring的原因是什么，想想你会发现原来Spring解决了一个非常关键的问题他可以让 你把对象之间的依赖关系转而用配置文件来管理，也就是他的依赖注入机制。而这个注入关系在一个叫Ioc容器中管理，那Ioc容器中有又是什么就是被Bean包裹的对象。Spring正是通过把对象包装在 Bean中而达到对这些对象管理以及一些列额外操作的目的。</p>
<p>它这种设计策略完全类似于Java实现OOP的设计理念，当然了Java本身的设计要比Spring复杂太多太多，但是都是构建一个数据结构，然后根据这个数据结构设计他的生存环境，并让它在这个环境中 按照一定的规律在不停的运动，在它们的不停运动中设计一系列与环境或者与其他个体完成信息交换。这样想来回过头想想我们用到的其他框架都是大慨类似的设计理念。</p>
<p>Spring内部组件的作用和关系<br>前面说Bean是Spring中关键因素，那Context和Core又有何作用呢？前面吧Bean比作一场演出中的演员的话，那Context就是这场演出的舞台背景，而Core应该就是演出的道具了。只有他们在一起才能 具备能演出一场好戏的最基本的条件。当然有最基本的条件还不能使这场演出脱颖而出，还要他表演的节目足够的精彩，这些节目就是Spring能提供的特色功能了。</p>
<p>我们知道Bean包装的是Object，而Object必然有数据，如何给这些数据提供生存环境就是Context要解决的问题，对Context来说他就是要发现每个Bean之间的关系，为它们建立这种关系并且要维护好 这种关系。所以Context就是一个Bean关系的集合，这个关系集合又叫Ioc容器，一旦建立起这个Ioc容器后Spring就可以为你工作了。那Core组件又有什么用武之地呢？其实Core就是发现、建立和维护每 个Bean之间的关系所需要的一些列的工具，从这个角度看来，Core这个组件叫Util更能让你理解。</p>
<p>它们之间可以用下图来表示：<br><img src="/img/spring/spring_components.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring总体架构与设计理念&lt;br&gt;概述：&lt;/p&gt;
&lt;p&gt;Spring作为现在最优秀的框架之一，已被广泛的使用。本系列文章将从以下角度对Spring的架构进行剖析：设计Spring框架总体结构的理念是什么？包含哪几个核心组件？为什么需要这些组件？它们又是如何结合在一起构成
    
    </summary>
    
      <category term="JavaEE框架" scheme="https://fudawei.github.io/categories/JavaEE%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="https://fudawei.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring架构详解：Bean详解和Context组件详解</title>
    <link href="https://fudawei.github.io/2016/12/15/Spring%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3%EF%BC%9ABean%E8%AF%A6%E8%A7%A3%E5%92%8CContext%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>https://fudawei.github.io/2016/12/15/Spring架构详解：Bean详解和Context组件详解/</id>
    <published>2016-12-15T04:53:14.000Z</published>
    <updated>2017-02-08T03:39:19.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bean详解"><a href="#Bean详解" class="headerlink" title="Bean详解"></a>Bean详解</h1><p>前面已经说明了Bean组件对Spring的重要性，下面看看Bean这个组件式怎么设计的。Bean组件在Spring的org.springframework.beans包下。这个包下的所有类主要解决了三件事：Bean的定义、Bean 的创建以及对Bean的解析。对Spring的使用者来说唯一需要关心的就是Bean的创建，其他两个由Spring在内部帮你完成了，对你来说是透明的。</p>
<p>SpringBean的创建时典型的工厂模式，他的顶级接口是BeanFactory，下图是这个工厂的继承层次关系：</p>
<p><img src="/img/spring/spring_bean_factory.png" alt=""><br>BeanFactory有三个子类：ListableBeanFactory、HierarchicalBeanFactory和Autowire Capable Bean Factory。但是从上图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，他实 现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在Spring内部在操作过程中对象的传递和转化过程中，对对象的 数据访问所做的限制。例如ListableBeanFactory接口表示这些Bean是可列表的，而HierarchicalBeanFactory表示的是这些Bean是有继承关系的，也就是每个Bean有可能有父Bean。 AutowireCapableBeanFactory接口定义Bean的自动装配规则。这四个接口共同定义了Bean的集合、Bean之间的关系、以及Bean行为。</p>
<p>Bean的定义主要有BeanDefinition描述，如下图说明了这些类的层次关系：</p>
<p><img src="/img/spring/spring_BeanDefinition.png" alt=""><br>Bean的定义就是完整的描述了在Spring的配置文件中你定义的节点中所有的信息，包括各种子节点。当Spring成功解析你定义的一个节点后，在Spring的内部他就被转化 成BeanDefinition对象。以后所有的操作都是对这个对象完成的。 Bean的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过 下图中的类完成：<br><img src="/img/spring/spring_analysis.png" alt=""></p>
<h1 id="Context组件详解"><a href="#Context组件详解" class="headerlink" title="Context组件详解"></a>Context组件详解</h1><p>Context在Spring的org.springframework.context包下，前面已经讲解了Context组件在Spring中的作用，他实际上就是给Spring提供一个运行时的环境，用以保存各个对象的状态。下面看一下这个 环境是如何构建的。</p>
<p>ApplicationContext是Context的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了五个接口，这五个接口主要是扩展了Context的功能。下面是Context的类结构图：<br><img src="/img/spring/spring_context.png" alt=""></p>
<p>从上图中可以看出ApplicationContext继承了BeanFactory，这也说明了Spring容器中运行的主体对象是Bean，另外ApplicationContext继承了ResourceLoader接口，使得ApplicationContext可以访 问到任何外部资源，这将在Core中详细说明。</p>
<p>ApplicationContext的子类主要包含两个方面：</p>
<p>ConfigurableApplicationContext表示该Context是可修改的，也就是在构建Context中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的Context，即 AbstractRefreshableApplicationContext类。</p>
<p>WebApplicationContext顾名思义，就是为web准备的Context他可以直接访问到ServletContext，通常情况下，这个接口使用的少。</p>
<p>再往下分就是按照构建Context的文件类型，接着就是访问Context的方式。这样一级一级构成了完整的Context等级层次。</p>
<p>总体来说ApplicationContext必须要完成以下几件事：</p>
<p>标识一个应用环境<br>利用BeanFactory创建Bean对象<br>保存对象关系表<br>能够捕获各种事件<br>Context作为Spring的Ioc容器，基本上整合了Spring的大部分功能，或者说是大部分功能的基础。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Bean详解&quot;&gt;&lt;a href=&quot;#Bean详解&quot; class=&quot;headerlink&quot; title=&quot;Bean详解&quot;&gt;&lt;/a&gt;Bean详解&lt;/h1&gt;&lt;p&gt;前面已经说明了Bean组件对Spring的重要性，下面看看Bean这个组件式怎么设计的。Bean组件在Spr
    
    </summary>
    
      <category term="JavaEE框架" scheme="https://fudawei.github.io/categories/JavaEE%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="https://fudawei.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程编程之Promise模式</title>
    <link href="https://fudawei.github.io/2016/11/24/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B9%8BPromise%E6%A8%A1%E5%BC%8F/"/>
    <id>https://fudawei.github.io/2016/11/24/Java多线程编程之Promise模式/</id>
    <published>2016-11-24T14:42:01.000Z</published>
    <updated>2017-02-08T06:29:22.865Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Promise模式简介"><a href="#Promise模式简介" class="headerlink" title="Promise模式简介"></a>Promise模式简介</h3><p>Promise模式是一种异步编程模式 。它使得我们可以先开始一个任务的执行，并得到一个用于获取该任务执行结果的凭据对象，而不必等待该任务执行完毕就可以继续执行其他操作。等到我们需要该任务的执行结果时，再调用凭据对象的相关方法来获取。这样就避免了不必要的等待，增加了系统的并发性。这好比我们去小吃店，同时点了鸭血粉丝汤和生煎包。当我们点餐付完款后，我们拿到手的其实只是一张可借以换取相应食品的收银小票（凭据对象）而已，而不是对应的实物。由于鸭血粉丝汤可以较快制作好，故我们可以凭收银小票即刻兑换到。而生煎包的制作则比较耗时，因此我们可以先吃拿到手的鸭血粉丝汤，而不必饿着肚子等生煎包出炉再一起吃。等到我们把鸭血粉丝汤吃得差不多的时候，生煎包可能也出炉了，这时我们再凭收银小票去换取生煎包，如图所示。</p>
<p><img src="/img/concurrent-1.png" alt=""></p>
<h3 id="Promise模式的架构"><a href="#Promise模式的架构" class="headerlink" title="Promise模式的架构"></a>Promise模式的架构</h3><p>Promise模式中，客户端代码调用某个异步方法所得到的返回值仅是一个凭据对象（该对象被称为Promise，意为“承诺”）。凭借该对象，客户端代码可以获取异步方法相应的真正任务的执行结果。为了讨论方便，下文我们称异步方法对应的真正的任务为异步任务。</p>
<p>Promise模式的主要参与者有以下几种。其类图如图所示。</p>
<p><img src="/img/concurrent-2.png" alt=""></p>
<ul>
<li>Promisor：负责对外暴露可以返回Promise对象的异步方法，并启动异步任务的执行。其主要方法及职责如下。<ul>
<li>compute：启动异步任务的执行，并返回用于获取异步任务执行结果的凭据对象。</li>
</ul>
</li>
<li>Promise：包装异步任务处理结果的凭据对象。负责检测异步任务是否处理完毕、返回和存储异步任务处理结果。其主要方法及职责如下。<ul>
<li>getResult：获取与其所属Promise实例关联的异步任务的执行结果。</li>
<li>setResult：设置与其所属Promise实例关联的异步任务的执行结果。</li>
<li>isDone：检测与其所属Promise实例关联的异步任务是否执行完毕。</li>
</ul>
</li>
<li>Result：负责表示异步任务处理结果。具体类型由应用决定。</li>
<li>TaskExecutor：负责真正执行异步任务所代表的计算，并将其计算结果设置到相应的Promise实例。其主要方法及职责如下<ul>
<li>run：执行异步任务所代表的计算。<br>客户端代码获取异步任务处理结果的过程如图所示的序列图。</li>
</ul>
</li>
</ul>
<p><img src="/img/concurrent-3.png" alt=""></p>
<p>图中．获取异步任务的处理结果</p>
<p>第1步：客户端代码调用Promisor的异步方法compute。</p>
<p>第2、3步：compute方法创建Promise实例作为该方法的返回值，并返回。</p>
<p>第4步：客户端代码调用其所得到的Promise对象的getResult方法来获取异步任务处理结果。如果此时异步任务执行尚未完成，则getResult方法会阻塞（即调用方代码的运行线程暂时处于阻塞状态）。</p>
<p>异步任务的真正执行以及其处理结果的设置如图所示的序列图。</p>
<p><img src="/img/concurrent-4.png" alt=""></p>
<p>图中．设置异步任务的处理结果</p>
<p>第1步：Promisor的异步方法compute创建TaskExecutor实例。</p>
<p>第2步：TaskExecutor的run方法被执行（可以由专门的线程或者线程池 来调用run方法）。</p>
<p>第3步：run方法创建表示其执行结果的Result实例。</p>
<p>第4、5步：run方法将其处理结果设置到相应的Promise实例上。</p>
<h3 id="Promise模式实战案例解析"><a href="#Promise模式实战案例解析" class="headerlink" title="Promise模式实战案例解析"></a>Promise模式实战案例解析</h3><p>某系统的一个数据同步模块需要将一批本地文件上传到指定的目标FTP服务器上。这些文件是根据页面中的输入条件查询数据库的相应记录生成的。在将文件上传到目标服务器之前，需要对FTP客户端实例进行初始化（包括与对端服务器建立网络连接、向服务器发送登录用户和向服务器发送登录密码）。而FTP客户端实例初始化这个操作比较耗时间，我们希望它尽可能地在本地文件上传之前准备就绪。因此我们可以引入异步编程，使得FTP客户端实例初始化和本地文件上传这两个任务能够并发执行，减少不必要的等待。另一方面，我们不希望这种异步编程增加了代码编写的复杂性。这时，Promise模式就可以派上用场了：先开始FTP客户端实例的初始化，并得到一个获取FTP客户端实例的凭据对象。在不必等待FTP客户端实例初始化完毕的情况下，每生成一个本地文件，就通过凭据对象获取FTP客户端实例，再通过该FTP客户端实例将文件上传到目标服务器上。代码如清单1所示 。</p>
<p>清单1．数据同步模块的入口类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class DataSyncTask implements Runnable &#123;</div><div class="line"></div><div class="line">	private final Map&lt;String, String&gt; taskParameters;</div><div class="line">	public DataSyncTask(Map&lt;String, String&gt; taskParameters) &#123;</div><div class="line">		this.taskParameters = taskParameters;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		String ftpServer = taskParameters.get(&quot;server&quot;);</div><div class="line">		String ftpUserName = taskParameters.get(&quot;userName&quot;);</div><div class="line">		String password = taskParameters.get(&quot;password&quot;);</div><div class="line">		</div><div class="line">		//先开始初始化FTP客户端实例</div><div class="line">		Future&lt;FTPClientUtil&gt; ftpClientUtilPromise = FTPClientUtil.newInstance(</div><div class="line">		    ftpServer, ftpUserName, password);</div><div class="line">		//查询数据库生成本地文件</div><div class="line">		generateFilesFromDB();</div><div class="line">		FTPClientUtil ftpClientUtil = null;</div><div class="line">		try &#123;</div><div class="line">			// 获取初始化完毕的FTP客户端实例</div><div class="line">			ftpClientUtil = ftpClientUtilPromise.get();</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			;</div><div class="line">		&#125; catch (ExecutionException e) &#123;</div><div class="line">			throw new RuntimeException(e);</div><div class="line">		&#125;</div><div class="line">		// 上传文件</div><div class="line">		uploadFiles(ftpClientUtil);</div><div class="line">		//省略其他代码</div><div class="line">	&#125;</div><div class="line">	private void generateFilesFromDB() &#123;</div><div class="line">		// 省略其他代码</div><div class="line">	&#125;</div><div class="line">	private void uploadFiles(FTPClientUtil ftpClientUtil) &#123;</div><div class="line">		Set&lt;File&gt; files = retrieveGeneratedFiles();</div><div class="line">		for (File file : files) &#123;</div><div class="line">			try &#123;</div><div class="line">				ftpClientUtil.upload(file);</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private Set&lt;File&gt; retrieveGeneratedFiles() &#123;</div><div class="line">		Set&lt;File&gt; files = new HashSet&lt;File&gt;();</div><div class="line">		// 省略其他代码</div><div class="line">		return files;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从清单1的代码中可以看出，DataSyncTask类的run方法先开始FTP客户端实例的初始化，并得到获取相应FTP客户端实例的凭据对象ftpClientUtilPromise。接着，它直接开始查询数据库并生成本地文件。而此时，FTP客户端实例的初始化可能尚未完成。在本地文件生成之后，run方法通过调用ftpClientUtilPromise的get方法来获取相应的FTP客户端实例。此时，如果相应的FTP客户端实例的初始化仍未完成，则该调用会阻塞，直到相应的FTP客户端实例的初始化完成或者失败。run方法获取到FTP客户端实例后，调用其upload方法将文件上传到指定的FTP服务器。</p>
<p>清单1代码所引用的FTP客户端工具类FTPClientUtil的代码如清单6-2所示。</p>
<p>清单2．FTP客户端工具类源码</p>
<p>//模式角色：Promise.Promisor、Promise.Result<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">public class FTPClientUtil &#123;</div><div class="line">	private final FTPClient ftp = new FTPClient();</div><div class="line"></div><div class="line">	private final Map&lt;String, Boolean&gt; dirCreateMap = new HashMap&lt;String, Boolean&gt;();</div><div class="line"></div><div class="line">	private FTPClientUtil() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//模式角色：Promise.Promisor.compute</div><div class="line">	public static Future&lt;FTPClientUtil&gt; newInstance(final String ftpServer,</div><div class="line">	    final String userName, final String password) &#123;</div><div class="line"></div><div class="line">		Callable&lt;FTPClientUtil&gt; callable = new Callable&lt;FTPClientUtil&gt;() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public FTPClientUtil call() throws Exception &#123;</div><div class="line">				FTPClientUtil self = new FTPClientUtil();</div><div class="line">				self.init(ftpServer, userName, password);</div><div class="line">				return self;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		//task相当于模式角色：Promise.Promise</div><div class="line">		final FutureTask&lt;FTPClientUtil&gt; task = new FutureTask&lt;FTPClientUtil&gt;(</div><div class="line">		    callable);</div><div class="line"></div><div class="line">		/*</div><div class="line">		下面这行代码与本案例的实际代码并不一致，这是为了讨论方便。</div><div class="line">		下面新建的线程相当于模式角色：Promise.TaskExecutor</div><div class="line">		*/</div><div class="line">		new Thread(task).start();</div><div class="line">		return task;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void init(String ftpServer, String userName, String password)</div><div class="line">	    throws Exception &#123;</div><div class="line"></div><div class="line">		FTPClientConfig config = new FTPClientConfig();</div><div class="line">		ftp.configure(config);</div><div class="line"></div><div class="line">		int reply;</div><div class="line">		ftp.connect(ftpServer);</div><div class="line"></div><div class="line">		System.out.print(ftp.getReplyString());</div><div class="line"></div><div class="line">		reply = ftp.getReplyCode();</div><div class="line"></div><div class="line">		if (!FTPReply.isPositiveCompletion(reply)) &#123;</div><div class="line">			ftp.disconnect();</div><div class="line">			throw new RuntimeException(&quot;FTP server refused connection.&quot;);</div><div class="line">		&#125;</div><div class="line">		boolean isOK = ftp.login(userName, password);</div><div class="line">		if (isOK) &#123;</div><div class="line">			System.out.println(ftp.getReplyString());</div><div class="line"></div><div class="line">		&#125; else &#123;</div><div class="line">			throw new RuntimeException(&quot;Failed to login.&quot; + ftp.getReplyString());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		reply = ftp.cwd(&quot;~/subspsync&quot;);</div><div class="line">		if (!FTPReply.isPositiveCompletion(reply)) &#123;</div><div class="line">			ftp.disconnect();</div><div class="line">			throw new RuntimeException(&quot;Failed to change working directory.reply:&quot;</div><div class="line">			    + reply);</div><div class="line">		&#125; else &#123;</div><div class="line"></div><div class="line">			System.out.println(ftp.getReplyString());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		ftp.setFileType(FTP.ASCII_FILE_TYPE);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void upload(File file) throws Exception &#123;</div><div class="line">		InputStream dataIn = new BufferedInputStream(new FileInputStream(file),</div><div class="line">		    1024 * 8);</div><div class="line">		boolean isOK;</div><div class="line">		String dirName = file.getParentFile().getName();</div><div class="line">		String fileName = dirName + &apos;/&apos; + file.getName();</div><div class="line">		ByteArrayInputStream checkFileInputStream = new ByteArrayInputStream(</div><div class="line">		    &quot;&quot;.getBytes());</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">			if (!dirCreateMap.containsKey(dirName)) &#123;</div><div class="line">				ftp.makeDirectory(dirName);</div><div class="line">				dirCreateMap.put(dirName, null);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">				isOK = ftp.storeFile(fileName, dataIn);</div><div class="line">			&#125; catch (IOException e) &#123;</div><div class="line">				throw new RuntimeException(&quot;Failed to upload &quot; + file, e);</div><div class="line">			&#125;</div><div class="line">			if (isOK) &#123;</div><div class="line">				ftp.storeFile(fileName + &quot;.c&quot;, checkFileInputStream);</div><div class="line"></div><div class="line">			&#125; else &#123;</div><div class="line"></div><div class="line">				throw new RuntimeException(&quot;Failed to upload &quot; + file + &quot;,reply:&quot; + </div><div class="line">&quot;,&quot;+ ftp.getReplyString());</div><div class="line">			&#125;</div><div class="line">		&#125; finally &#123;</div><div class="line">			dataIn.close();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void disconnect() &#123;</div><div class="line">		if (ftp.isConnected()) &#123;</div><div class="line">			try &#123;</div><div class="line">				ftp.disconnect();</div><div class="line">			&#125; catch (IOException ioe) &#123;</div><div class="line">				// 什么也不做</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>FTPClientUtil类封装了FTP客户端，其构造方法是private修饰的，因此其他类无法通过new来生成相应的实例，而是通过其静态方法newInstance来获得实例。不过newInstance方法的返回值并不是一个FTPClientUtil实例，而是一个可以获取FTPClientUtil实例的凭据对象java.util.concurrent.Future（具体说是java.util.concurrent.FutureTask，它实现了java.util.concurrent.Future接口）实例。因此，FTPClientUtil既相当于Promise模式中的Promisor参与者实例，又相当于Result参与者实例。而newInstance方法的返回值java.util.concurrent.FutureTask实例既相当于Promise参与者实例，又相当于TaskExecutor参与者实例：newInstance方法的返回值java.util.concurrent.FutureTask实例不仅负责该方法真正处理结果（初始化完毕的FTP客户端实例）的存储和获取，还负责执行异步任务（调用FTPClientUtil实例的init方法），并设置任务的处理结果。</p>
<p>从如清单2所示的Promise客户端代码（DataSyncTask类的run方法）来看，使用Promise模式的异步编程并没有本质上增加编程的复杂性：客户端代码的编写方式与同步编程并没有太大差别，唯一一点差别就是获取FTP客户端实例的时候多了一步对java.util.concurrent.FutureTask实例的get方法的调用。</p>
<h3 id="Promise模式的评价与实现考量"><a href="#Promise模式的评价与实现考量" class="headerlink" title="Promise模式的评价与实现考量"></a>Promise模式的评价与实现考量</h3><p>Promise模式既发挥了异步编程的优势——增加系统的并发性，减少不必要的等待，又保持了同步编程的简单性：有关异步编程的细节，如创建新的线程或者提交任务到线程池执行等细节，都被封装在Promisor参与者实例中，而Promise的客户端代码则无须关心这些细节，其编码方式与同步编程并无本质上差别。这点正如清单6-1代码所展示的，客户端代码仅仅需要调用FTPClientUtil的newInstance静态方法，再调用其返回值的get方法，即可获得一个初始化完毕的FTP客户端实例。这本质上还是同步编程。当然，客户端代码也不能完全无视Promise模式的异步编程这一特性：为了减少客户端代码在调用Promise的getResult方法时出现阻塞的可能，客户端代码应该尽可能早地调用Promisor的异步方法，并尽可能晚地调用Promise的getResult方法。这当中间隔的时间可以由客户端代码用来执行其他操作，同时这段时间可以给TaskExecutor用于执行异步任务。</p>
<p>Promise模式一定程度上屏蔽了异步、同步编程的差异。前文我们一直说Promisor对外暴露的compute方法是个异步方法。事实上，如果compute方法是一个同步方法，那么Promise模式的客户端代码的编写方式也是一样的。也就是说，无论compute方法是一个同步方法还是异步方法，Promise客户端代码的编写方式都是一样的。例如，本章案例中FTPClientUtil的newInstance方法如果改成同步方法，我们只需要将其方法体中的语句new Thread(task).start();改为task.run();即可。而该案例中的其他代码无须更改。这就在一定程度上屏蔽了同步、异步编程的差异。而这可以给代码调试或者问题定位带来一定的便利。比如，我们的本意是要将compute方法设计成一个异步方法，但在调试代码的时候发现结果不对，那么我们可以尝试临时将其改为同步方法。若此时原先存在的问题不再出现，则说明问题是compute方法被编码为异步方法后所产生的多线程并发访问控制不正确导致的。</p>
<ol>
<li>异步方法的异常处理</li>
</ol>
<p>如果Promisor的compute方法是个异步方法，那么客户端代码在调用完该方法后异步任务可能尚未开始执行。另外，异步任务运行在自己的线程中，而不是compute方法的调用方线程中。因此，异步任务执行过程中产生的异常无法在compute方法中抛出。为了让Promise模式的客户端代码能够捕获到异步任务执行过程中出现的异常，一个可行的办法是让TaskExecutor在执行任务捕获到异常后，将异常对象“记录”到Promise实例的一个专门的实例变量上，然后由Promise实例的getResult方法对该实例变量进行检查。若该实例变量的值不为null，则getResult方法抛出异常。这样，Promise模式的客户端代码通过捕获getResult方法抛出的异常即可“知道”异步任务执行过程中出现的异常。JDK中提供的类java.util.concurrent.FutureTask就是采用这种方法对compute异步方法的异常进行处理的。</p>
<ol>
<li>轮询（Polling）</li>
</ol>
<p>客户端代码对Promise的getResult的调用可能由于异步任务尚未执行完毕而阻塞，这实际上也是一种等待。虽然我们可以通过尽可能早地调用compute方法并尽可能晚地调用getResult方法来减少这种等待的可能性，但是它仍然可能会出现。某些场景下，我们可能根本不希望进行任何等待。此时，我们需要在调用Promise的getResult方法之前确保异步任务已经执行完毕。因此，Promise需要暴露一个isDone方法用于检测异步任务是否已执行完毕。JDK提供的类java.util.concurrent.FutureTask的isDone方法正是出于这种考虑，它允许我们在“适当”的时候才调用Promise的getResult方法（相当于FutureTask的get方法）。</p>
<ol>
<li>异步任务的执行</li>
</ol>
<p>本章案例中，异步任务的执行我们是通过新建一个线程，由该线程去调用TaskExecutor的run方法来实现的（见清单6-2）。这只是为了讨论方便。如果系统中同时存在多个线程调用Promisor的异步方法，而每个异步方法都启动了各自的线程去执行异步任务，这可能导致一个JVM中启动的线程数量过多，增加了线程调度的负担，从而反倒降低了系统的性能。因此，如果Promise模式的客户端并发量比较大，则需要考虑由线程池负责执行TaskExecutor的run方法来实现异步任务的执行。例如，如清单2所示的异步任务如果改用线程池去执行，我们只需要将代码改为类似如清单3所示的代码即可。</p>
<p>清单3．用线程池执行异步任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">public class FTPClientUtil &#123;</div><div class="line">	private volatilestatic ThreadPoolExecutor threadPoolExecutor;</div><div class="line"></div><div class="line">	static &#123;</div><div class="line">		threadPoolExecutor = new ThreadPoolExecutor(1,Runtime.getRuntime()</div><div class="line">		    .availableProcessors() * 2, </div><div class="line">		    60, </div><div class="line">		    TimeUnit.SECONDS,</div><div class="line">		    new ArrayBlockingQueue&lt;Runnable&gt;(10), new ThreadFactory() &#123;</div><div class="line">			    public Thread newThread(Runnable r) &#123;</div><div class="line">				    Thread t = new Thread(r);</div><div class="line">				    t.setDaemon(true);</div><div class="line">				    return t;</div><div class="line">			    &#125;</div><div class="line">		    &#125;, new ThreadPoolExecutor.CallerRunsPolicy());</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private final FTPClient ftp = new FTPClient();</div><div class="line">	private final Map&lt;String, Boolean&gt; dirCreateMap = new HashMap&lt;String, Boolean&gt;();</div><div class="line"></div><div class="line">	//私有构造器</div><div class="line">	private FTPClientUtil() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static Future&lt;FTPClientUtil&gt; newInstance(final String ftpServer,</div><div class="line">	    final String userName, final String password) &#123;</div><div class="line"></div><div class="line">		Callable&lt;FTPClientUtil&gt; callable = new Callable&lt;FTPClientUtil&gt;() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public FTPClientUtil call() throws Exception &#123;</div><div class="line">				FTPClientUtil self = new FTPClientUtil();</div><div class="line">				self.init(ftpServer, userName, password);</div><div class="line">				return self;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;;</div><div class="line">		final FutureTask&lt;FTPClientUtil&gt; task = new FutureTask&lt;FTPClientUtil&gt;(</div><div class="line">		    callable);</div><div class="line"></div><div class="line">		threadPoolExecutor.execute(task);</div><div class="line">		return task;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void init(String ftpServer, String userName, String password)</div><div class="line">	    throws Exception &#123;</div><div class="line">		//省略与清单6-2中相同的代码</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void upload(File file) throws Exception &#123;</div><div class="line">		//省略与清单6-2中相同的代码</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void disconnect() &#123;</div><div class="line">		//省略与清单2中相同的代码</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Promise模式的可复用实现代码</p>
<p>JDK1.5开始提供的接口java.util.concurrent.Future可以看成是Promise模式中Promise参与者的抽象，其声明如下：</p>
<p>public interface Future<v><br>该接口的类型参数V相当于Promise模式中的Result参与者。该接口定义的方法及其与Promise参与者相关方法之间的对应关系如表6-1所示。</v></p>
<p>表1．接口java.util.concurrent.Future与Promise参与者的对应关系</p>
<p><img src="/img/concurrent-5.png" alt=""></p>
<p>接口java.util.concurrent.Future的实现类java.util.concurrent.FutureTask可以看作Promise模式的Promise参与者实例。</p>
<p>如清单2所示的代码中的异步方法newInstance展示了如何使用java.util.concurrent.FutureTask来作为Promise参与者。</p>
<p>Java标准库实例</p>
<p>JAX-WS 2.0 API中用于支持调用Web Service的接口javax.xml.ws.Dispatch就使用了Promise模式。该接口用于异步调用Web Service的方法声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Response&lt;T&gt;invokeAsync(T msg)</div></pre></td></tr></table></figure>
<p>该方法不等对端服务器给响应就返回了（即实现了异步调用Web Service），从而避免了Web Service客户端进行不必要的等待。而客户端需要其调用的Web Service的响应时，可以调用invokeAsync方法的返回值的相关方法来获取。invokeAsync的返回值类型为javax.xml.ws.Response，它继承自java.util.concurrent.Future。因此，javax.xml.ws.Dispatch相当于Promise模式中的Promisor参与者实例，其异步方法invokeAsync(T msg)的返回值相当于Promise参与者实例</p>
<p>相关模式</p>
<ol>
<li>Guarded Suspension模式</li>
</ol>
<p>Promise模式的客户端代码调用Promise的getResult方法获取异步任务处理结果时，如果异步任务已经执行完毕，则该调用会直接返回。否则，该调用会阻塞直到异步任务处理结束或者出现异常。这种通过线程阻塞而进行的等待可以看作Guarded Suspension模式的一个实例。只不过，一般情况下Promise参与者我们可以直接使用JDK中提供的类java.util.concurrent.FutureTask来实现，而无须自行编码。关于java.util.concurrent.FutureTask如何实现通过阻塞去等待异步方法执行结束，感兴趣的读者可以去阅读JDK标准库的源码。</p>
<ol>
<li>Active Object模式</li>
</ol>
<p>Active Object模式可以看成是包含了Promise模式的复合模式。其Proxy参与者相当于Promise模式的Promisor参与者。Proxy参与者的异步方法返回值相当于Promise模式的Promise参与者实例。Active Object模式的Scheduler参与者相当于Promise模式的TaskExecutor参与者。</p>
<ol>
<li>Master-Slave模式</li>
</ol>
<p>Master-Slave模式中，Slave参与者返回其对子任务的处理结果可能需要使用Promise模式。此时，Slave参与者相当于Promise模式的Promisor参与者，其subService方法的返回值是一个Promise模式的Promise参与者实例。</p>
<ol>
<li>Factory Method模式</li>
</ol>
<p>Promise模式中的Promisor参与者可以看成是Factory Method模式的一个例子：Promisor的异步方法可以看成一个工厂方法，该方法的返回值是一个Promise实例。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Promise模式简介&quot;&gt;&lt;a href=&quot;#Promise模式简介&quot; class=&quot;headerlink&quot; title=&quot;Promise模式简介&quot;&gt;&lt;/a&gt;Promise模式简介&lt;/h3&gt;&lt;p&gt;Promise模式是一种异步编程模式 。它使得我们可以先开始一个任务
    
    </summary>
    
      <category term="Java" scheme="https://fudawei.github.io/categories/Java/"/>
    
      <category term="多线程" scheme="https://fudawei.github.io/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://fudawei.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://fudawei.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Spark源码四]图解作业生命周期</title>
    <link href="https://fudawei.github.io/2016/10/25/%5BSpark%E6%BA%90%E7%A0%81%E5%9B%9B%5D%E5%9B%BE%E8%A7%A3%E4%BD%9C%E4%B8%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://fudawei.github.io/2016/10/25/[Spark源码四]图解作业生命周期/</id>
    <published>2016-10-25T14:42:01.000Z</published>
    <updated>2017-02-08T03:39:19.517Z</updated>
    
    <content type="html"><![CDATA[<p>这一章我们探索了Spark作业的运行过程，但是没把整个过程描绘出来，好，跟着我走吧，let you know！<br><img src="/img/spark4.1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一章我们探索了Spark作业的运行过程，但是没把整个过程描绘出来，好，跟着我走吧，let you know！&lt;br&gt;&lt;img src=&quot;/img/spark4.1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="大数据" scheme="https://fudawei.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://fudawei.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/"/>
    
    
      <category term="大数据" scheme="https://fudawei.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://fudawei.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>[Spark源码三】作业运行过程</title>
    <link href="https://fudawei.github.io/2016/10/25/%5BSpark%E6%BA%90%E7%A0%81%E4%B8%89%5D%E4%BD%9C%E4%B8%9A%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <id>https://fudawei.github.io/2016/10/25/[Spark源码三]作业运行过程/</id>
    <published>2016-10-25T14:42:01.000Z</published>
    <updated>2017-02-08T03:39:19.517Z</updated>
    
    <content type="html"><![CDATA[<p>官方给的例子里面，一执行collect方法就能出结果，那我们就从collect开始看吧，进入RDD，找到collect方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def collect(): Array[T] = &#123;</div><div class="line">    val results = sc.runJob(this, (iter: Iterator[T]) =&gt; iter.toArray)</div><div class="line">    Array.concat(results: _*)</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>它进行了两个操作：</p>
<p>1、调用SparkContext的runJob方法，把自身的引用传入去，再传了一个匿名函数（把Iterator转换成Array数组）<br>2、把result结果合并成一个Array，注意results是一个Array[Array[T]]类型，所以第二句的那个写法才会那么奇怪。这个操作是很重的一个操作，如果结果很大的话，这个操作是会报OOM的，因为它是把结果保存在Driver程序的内存当中的result数组里面。</p>
<p>我们点进去runJob这个方法吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">val callSite = getCallSite</div><div class="line">    val cleanedFunc = clean(func)</div><div class="line">    dagScheduler.runJob(rdd, cleanedFunc, partitions, callSite, allowLocal, resultHandler, localProperties.get)</div><div class="line">    rdd.doCheckpoint()</div></pre></td></tr></table></figure>
<p>追踪下去，我们会发现经过多个不同的runJob同名函数调用之后，执行job作业靠的是dagScheduler，最后把结果通过resultHandler保存返回。</p>
<p>DAGScheduler如何划分作业</p>
<p>好的，我们继续看DAGScheduler的runJob方法，提交作业，然后等待结果，成功什么都不做，失败抛出错误，我们接着看submitJob方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> val start = System.nanoTime</div><div class="line">// 记录作业成功与失败的数据结构，一个作业的Task数量是和分片的数量一致的，Task成功之后调用resultHandler保存结果。</div><div class="line">val waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties)</div><div class="line">val awaitPermission = null.asInstanceOf[scala.concurrent.CanAwait]</div><div class="line">waiter.completionFuture.ready(Duration.Inf)(awaitPermission)</div><div class="line">waiter.completionFuture.value.get match &#123;</div><div class="line">  case scala.util.Success(_) =&gt;</div><div class="line">    logInfo(&quot;Job %d finished: %s, took %f s&quot;.format</div><div class="line">      (waiter.jobId, callSite.shortForm, (System.nanoTime - start) / 1e9))</div><div class="line">  case scala.util.Failure(exception) =&gt;</div><div class="line">    logInfo(&quot;Job %d failed: %s, took %f s&quot;.format</div><div class="line">      (waiter.jobId, callSite.shortForm, (System.nanoTime - start) / 1e9))</div><div class="line">    // SPARK-8644: Include user stack trace in exceptions coming from DAGScheduler.</div><div class="line">    val callerStackTrace = Thread.currentThread().getStackTrace.tail</div><div class="line">    exception.setStackTrace(exception.getStackTrace ++ callerStackTrace)</div><div class="line">    throw exception</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>val jobId = nextJobId.getAndIncrement()
val func2 = func.asInstanceOf[(TaskContext, Iterator[_]) =&gt; _]

val waiter = new JobWaiter(this, jobId, partitions.size, resultHandler)
eventProcessActor ! JobSubmitted(jobId, rdd, func2, partitions.toArray, allowLocal, callSite, waiter, properties)
</code></pre><p>走到这里，感觉有点儿绕了，为什么到了这里，还不直接运行呢，还要给DAGSchedulerEventProcessLoop发送一个JobSubmitted请求呢，new一个线程和这个区别有多大？</p>
<p>不管了，搜索一下DAGSchedulerEventProcessLoop吧，结果发现它是一个DAGSchedulerEventProcessLoop，它的定义也在DAGScheduler这个类里面。它的receive方法里面定义了12种事件的处理方法，这里我们只需要看JobSubmitted的就行，它也是调用了自身的handleJobSubmitted方法。但是这里很奇怪，没办法打断点调试，但是它的结果倒是能返回的，因此我们得用另外一种方式，打开test工程，找到scheduler目录下的DAGSchedulerSuite这个类，我们自己写一个test方法，首先我们要在import那里加上import org.apache.spark.SparkContext._  ，然后加上这一段测试代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;官方给的例子里面，一执行collect方法就能出结果，那我们就从collect开始看吧，进入RDD，找到collect方法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;di
    
    </summary>
    
      <category term="大数据" scheme="https://fudawei.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://fudawei.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/"/>
    
    
      <category term="大数据" scheme="https://fudawei.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://fudawei.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下恢复rm删除的数据</title>
    <link href="https://fudawei.github.io/2016/10/19/ubuntu%E4%B8%8B%E6%81%A2%E5%A4%8Drm%E5%88%A0%E9%99%A4%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>https://fudawei.github.io/2016/10/19/ubuntu下恢复rm删除的数据/</id>
    <published>2016-10-19T08:12:41.000Z</published>
    <updated>2017-02-08T03:39:19.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-论“备份”的重要性"><a href="#1-论“备份”的重要性" class="headerlink" title="1. 论“备份”的重要性"></a>1. 论“备份”的重要性</h1><p>今天手真快，Tab补全文件名后回车，昨天一天写的代码就被我remove了。虽然自己写了脚本备份系统和home目录，但系统是1天一备份，home是2天一次增量备份。又恰巧昨晚没有备份home，并且Git也没有提交，欲哭无泪的感觉5555~~。</p>
<p>被remove掉的文件其实是可以恢复的，删除命令只是在文件节点中作了删除标记，并不是真正清空内容，但是其他用户和一些有写盘动作的进程会很快覆盖这些数据。所以要想恢复磁盘信息，必须马上停止任何写磁盘操作。</p>
<p>我是将整个磁盘卸载下来，用转接线挂到同学笔记本上才恢复成功的，下面将介绍具体的恢复过程。<br><a id="more"></a></p>
<h1 id="2-恢复工具介绍"><a href="#2-恢复工具介绍" class="headerlink" title="2. 恢复工具介绍"></a>2. 恢复工具介绍</h1><p>针对Linux下的EXT文件系统来说，常用的误删恢复工具有debugfs、ext3grep、extundelete等等。extundelete是一个开源的数据恢复工具，支持ext3、ext4文件系统。</p>
<p>我的系统是Ubuntu15.04，文件系统是ext4。尝试了debugfs来恢复，但没有成功。如果文件系统不是ext4的同学可以尝试下该方式，这里有篇参考文档。</p>
<h1 id="3-extundelete恢复文件"><a href="#3-extundelete恢复文件" class="headerlink" title="3. extundelete恢复文件"></a>3. extundelete恢复文件</h1><ul>
<li>安装extundelete</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">     sudo apt-get install extundelete</div><div class="line">```        </div><div class="line">- 任何的文件恢复工具，在使用前，均要将要恢复的分区卸载或挂载为只读，防止数据被覆盖使用。</div></pre></td></tr></table></figure>
<pre><code>umount /dev/sdb2 
mount -o remount,ro /dev/sdb2
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- 如果删的文件和操作系统是在同一个分区上，就只有把硬盘卸下来，挂载到另一台主机上。我就是这么干的^_^。</div><div class="line"></div><div class="line">- 在另一台主机上用df -h查看挂载分区。我的分区是/dev/sdb2。</div><div class="line"></div><div class="line">- 在该主机上执行：</div></pre></td></tr></table></figure>
<pre><code>extundelete /dev/sdb2 --restore-file /home/zhangchengfei/server.scala
extundelete执行完毕后在当前目录生产一个RECOVERED_FILES目录，里面即是恢复出来的文件。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 如果想恢复某个文件夹的内容，可以使用下面命令：</div></pre></td></tr></table></figure>
<pre><code>extundelete /dev/sdb2 --restore-directory /hom/zhangchengfei/tmp
</code></pre><p>```</p>
<ul>
<li>关于extundelete更多的使用细节，可以用extundelete -h进行查看，本文不再叙述。</li>
</ul>
<ul>
<li><p>总结经验</p>
<p>其实良好的备份和同步习惯才是最重要的，绝对比恢复数据要更简单。常见的备份策略有tar，rsync，git等等。为了防止以后rm误删数据，还有种做法是自己重新定义rm，每次不是直接删除文件或文件夹，而是将它们move到你指定的一个目录下存放。具体的实现可以上google搜索。</p>
</li>
</ul>
<p>看这篇博客的朋友一定是遇到和我一样的窘境，祝好运O(∩_∩)O~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-论“备份”的重要性&quot;&gt;&lt;a href=&quot;#1-论“备份”的重要性&quot; class=&quot;headerlink&quot; title=&quot;1. 论“备份”的重要性&quot;&gt;&lt;/a&gt;1. 论“备份”的重要性&lt;/h1&gt;&lt;p&gt;今天手真快，Tab补全文件名后回车，昨天一天写的代码就被我remove了。虽然自己写了脚本备份系统和home目录，但系统是1天一备份，home是2天一次增量备份。又恰巧昨晚没有备份home，并且Git也没有提交，欲哭无泪的感觉5555~~。&lt;/p&gt;
&lt;p&gt;被remove掉的文件其实是可以恢复的，删除命令只是在文件节点中作了删除标记，并不是真正清空内容，但是其他用户和一些有写盘动作的进程会很快覆盖这些数据。所以要想恢复磁盘信息，必须马上停止任何写磁盘操作。&lt;/p&gt;
&lt;p&gt;我是将整个磁盘卸载下来，用转接线挂到同学笔记本上才恢复成功的，下面将介绍具体的恢复过程。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://fudawei.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://fudawei.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://fudawei.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Btree</title>
    <link href="https://fudawei.github.io/2016/10/19/Btree/"/>
    <id>https://fudawei.github.io/2016/10/19/Btree/</id>
    <published>2016-10-19T08:12:41.000Z</published>
    <updated>2017-02-08T03:39:19.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言："><a href="#1-前言：" class="headerlink" title="1.前言："></a>1.前言：</h1><p>动态查找树主要有：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree），红黑树 (Red-Black Tree )，B-tree/B+-tree/ B*-tree (B~Tree)。前三者是典型的二叉查找树结构，其查找的时间复杂度O(log2N)与树的深度相关，那么降低树的深度自然对查找效率是有所提高的；还有一个实际问题：就是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下（为什么会出现这种情况，待会在外部存储器-磁盘中有所解释），那么如何减少树的深度（当然是不能减少查询的数据量），一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。</p>
<p>这样我们就提出了一个新的查找树结构——多路查找树。根据平衡二叉树的启发，自然就想到平衡多路查找树结构，也就是这篇文章所要阐述的主题B~tree(B树结构)，B-tree这棵神奇的树是在Rudolf Bayer, Edward M. McCreight(1970)写的一篇论文《Organization and Maintenance of Large Ordered Indices》中首次提出。具体介绍可以参考wikipedia中的介绍：<a href="http://en.wikipedia.org/wiki/B-tree，其中还阐述了B-tree名字来源以及相关的开源地址。" target="_blank" rel="external">http://en.wikipedia.org/wiki/B-tree，其中还阐述了B-tree名字来源以及相关的开源地址。</a></p>
<p>在开始介绍B~tree之前，先了解下相关的硬件知识，才能很好的了解为什么需要B~tree这种外存数据结构。</p>
<h1 id="2-外存储器—磁盘"><a href="#2-外存储器—磁盘" class="headerlink" title="2.外存储器—磁盘"></a>2.外存储器—磁盘</h1><p>计算机存储设备一般分为两种：内存储器(main memory)和外存储器(external memory)。内存存取速度快，但容量小，价格昂贵，而且不能长期保存数据(在不通电情况下数据会消失)。</p>
<p>外存储器—磁盘是一种直接存取的存储设备(DASD)。它是以存取时间变化不大为特征的。可以直接存取任何字符组，且容量大、速度较其它外存设备更快。</p>
<h2 id="2-1磁盘的构造"><a href="#2-1磁盘的构造" class="headerlink" title="2.1磁盘的构造"></a>2.1磁盘的构造</h2><p>磁盘时一个扁平的圆盘(与电唱机的唱片类似)。盘面上有许多称为磁道的圆圈，数据就记录在这些磁道上。磁盘可以是单片的，也可以是由若干盘片组成的盘组，每一盘片上有两个面。如下图6片盘组为例，除去最顶端和最底端的外侧面不存储数据之外，一共有10个面可以用来保存信息。</p>
<p><img src="/img/btree_1.png" alt=""></p>
<p>当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头(又叫磁头) 下通过时，就可以进行数据的读 / 写了。</p>
<p>一般磁盘分为固定头盘(磁头固定)和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。</p>
<p>活动头盘 (如上图)的磁头是可移动的。每一个盘面上只有一个磁头(磁头是双向的，因此正反盘面都能读写)。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的(行动整齐划一)。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面。因此，柱面的个数也就是盘面上的磁道数。</p>
<h2 id="2-2磁盘的读-写原理和效率"><a href="#2-2磁盘的读-写原理和效率" class="headerlink" title="2.2磁盘的读/写原理和效率"></a>2.2磁盘的读/写原理和效率</h2><p>磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号(磁道上的盘块)。</p>
<p>读/写磁盘上某一指定数据需要下面3个步骤：</p>
<p>(1)  首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找。</p>
<p>(2)  如上图6盘组示意图中，所有磁头都定位到了10个盘面的10条磁道上(磁头都是双向的)。这时根据盘面号来确定指定盘面上的磁道。</p>
<p>(3) 盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。</p>
<p>经过上面三个步骤，指定数据的存储位置就被找到。这时就可以开始读/写操作了。</p>
<p>访问某一具体信息，由3部分时间组成：</p>
<p>● 查找时间(seek time) Ts: 完成上述步骤(1)所需要的时间。这部分时间代价最高，最大可达到0.1s左右。</p>
<p>● 等待时间(latency time) Tl: 完成上述步骤(3)所需要的时间。由于盘片绕主轴旋转速度很快，一般为7200转/分(电脑硬盘的性能指标之一, 家用的普通硬盘的转速一般有5400rpm(笔记本)、7200rpm几种)。因此一般旋转一圈大约0.0083s。</p>
<p>● 传输时间(transmission time) Tt: 数据通过系统总线传送到内存的时间，一般传输一个字节(byte)大概0.02us=2*10^(-8)s</p>
<p>磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。</p>
<p>所以，在大规模数据存储方面，大量数据存储在外存磁盘中，而在外存磁盘中读取/写入块(block)中某数据时，首先需要定位到磁盘中的某块，如何有效地查找磁盘中的数据，需要一种合理高效的外存数据结构，就是下面所要重点阐述的B-tree结构，以及相关的变种结构：B+-tree结构和B*-tree结构。</p>
<h1 id="3-B-tree"><a href="#3-B-tree" class="headerlink" title="3.B-tree"></a>3.B-tree</h1><p>B-tree又叫平衡多路查找树。一棵m阶的B-tree (m叉树)的特性如下：</p>
<p>（其中ceil(x)是一个取上限的函数）</p>
<p>1)  树中每个结点至多有m个孩子；</p>
<p>2)  除根结点和叶子结点外，其它每个结点至少有有ceil(m / 2)个孩子；</p>
<p>3)  若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；</p>
<p>4)  所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，实际上这些结点不存在，指向这些结点的指针都为null)；</p>
<p>5)  每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：</p>
<pre><code>a)   Ki (i=1...n)为关键字，且关键字按顺序排序K(i-1)&lt; Ki。

b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。

c)   关键字的个数n必须满足： ceil(m / 2)-1 &lt;= n &lt;= m-1。
</code></pre><p>B-tree中的每个结点根据实际情况可以包含大量的关键字信息和分支(当然是不能超过磁盘块的大小，根据磁盘驱动(disk drives)的不同，一般块的大小在1k~4k左右)；这样树的深度降低了，这就意味着查找一个元素只要很少结点从外存磁盘中读入内存，很快访问到要查找的数据。</p>
<p><img src="/img/btree_2.png" alt=""></p>
<p>为了简单，这里用少量数据构造一棵3叉树的形式。上面的图中比如根结点，其中17表示一个磁盘文件的文件名；小红方块表示这个17文件的内容在硬盘中的存储位置；p1表示指向17左子树的指针。</p>
<p>其结构可以简单定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line"></div><div class="line">    /*文件数*/</div><div class="line"></div><div class="line">    int  file_num;</div><div class="line"></div><div class="line">    /*文件名(key)*/</div><div class="line"></div><div class="line">    char * file_name[max_file_num];</div><div class="line"></div><div class="line">    /*指向子节点的指针*/</div><div class="line"></div><div class="line">     BTNode * BTptr[max_file_num+1];</div><div class="line"></div><div class="line">     /*文件在硬盘中的存储位置*/</div><div class="line"></div><div class="line">     FILE_HARD_ADDR offset[max_file_num];</div><div class="line"></div><div class="line">&#125;BTNode;</div></pre></td></tr></table></figure>
<p>假如每个盘块可以正好存放一个B-tree的结点（正好存放2个文件名）。那么一个BTNode结点就代表一个盘块，而子树指针就是存放另外一个盘块的地址。</p>
<p>模拟查找文件29的过程：</p>
<p> (1) 根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作1次】</p>
<p> (2) 此时内存中有两个文件名17，35和三个存储其他磁盘页面地址的数据。根据算法我们发现17&lt;29&lt;35，因此我们找到指针p2。</p>
<p> (3) 根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作2次】</p>
<p> (4) 此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现26&lt;29&lt;30，因此我们找到指针p2。</p>
<p> (5) 根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作3次】</p>
<p> (6) 此时内存中有两个文件名28，29。根据算法我们查找到文件29，并定位了该文件内存的磁盘地址。</p>
<p>分析上面的过程，发现需要3次磁盘IO操作和3次内存查找操作。关于内存中的文件名查找，由于是一个有序表结构，可以利用折半查找提高效率。至于3次磁盘IO操作时影响整个B-tree查找效率的决定因素。</p>
<p>当然，如果我们使用平衡二叉树的磁盘存储结构来进行查找，磁盘IO操作最少4次，最多5次。而且文件越多，B-tree比平衡二叉树所用的磁盘IO操作次数将越少，效率也越高。</p>
<p>上面仅仅介绍了对于B-tree这种结构的查找过程，还有树节点的插入与删除过程，以及相关的算法和代码的实现，将在以后的深入学习中给出相应的实例。</p>
<p>上面简单介绍了利用B-tree这种结构如何访问外存磁盘中的数据的情况，下面咱们通过另外一个实例来对这棵B-tree的插入（insert）,删除（delete）基本操作进行详细的介绍：</p>
<p>下面以一棵5阶B-tree实例进行讲解(如下图所示)：</p>
<p>其满足上述条件：除根结点和叶子结点外，其它每个结点至少有ceil(5/2)=3个孩子（至少2个关键字）；当然最多5个孩子（最多4个关键字）。下图中关键字为大写字母，顺序为字母升序。</p>
<p>结点定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef struct&#123;</div><div class="line"></div><div class="line">   int Count;         // 当前节点中关键元素数目</div><div class="line"></div><div class="line">   ItemType Key[4];   // 存储关键字元素的数组</div><div class="line"></div><div class="line">   long Branch[5];    // 伪指针数组，(记录数目)方便判断合并和分裂的情况</div><div class="line"></div><div class="line">&#125; NodeType;</div></pre></td></tr></table></figure>
<p><img src="/img/btree_3.png" alt=""></p>
<p>插入（insert）操作：插入一个元素时，首先在B-tree中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素，注意：如果叶子结点空间足够，这里需要向右移动该叶子结点中大于新插入关键字的元素，如果空间满了以致没有足够的空间去添加新的元素，则将该结点进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中（当然，如果父结点空间满了，也同样需要“分裂”操作），而且当结点中关键元素向右移动了，相关的指针也需要向右移。如果在根结点插入新元素，空间满了，则进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。</p>
<p>咱们通过一个实例来逐步讲解下。插入以下字符字母到空的5阶B-tree中：C N G A H E K Q M F W L T Z D P R X Y S，5序意味着一个结点最多有5个孩子和4个关键字，除根结点外其他结点至少有2个关键字，首先，结点空间足够，4个字母插入相同的结点中，如下图：</p>
<p><img src="/img/btree_4.png" alt=""></p>
<p>当咱们试着插入H时，结点发现空间不够，以致将其分裂成2个结点，移动中间元素G上移到新的根结点中，在实现过程中，咱们把A和C留在当前结点中，而H和N放置新的其右邻居结点中。如下图：</p>
<p><img src="/img/btree_5.png" alt=""></p>
<p>当咱们插入E,K,Q时，不需要任何分裂操作</p>
<p><img src="/img/btree_6.png" alt=""></p>
<p>插入M需要一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中</p>
<p><img src="/img/btree_7.png" alt=""></p>
<p>插入F,W,L,T不需要任何分裂操作</p>
<p><img src="/img/btree_8.png" alt=""></p>
<p>插入Z时，最右的叶子结点空间满了，需要进行分裂操作，中间元素T上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在2个关键字元素。</p>
<p><img src="/img/btree_9.png" alt=""></p>
<p>插入D时，导致最左边的叶子结点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P,R,X,Y陆续插入不需要任何分裂操作。</p>
<p><img src="/img/btree_10.png" alt=""></p>
<p>最后，当插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中，注意以前在父节点中的第三个指针在修改后包括D和G节点中。这样具体插入操作的完成，下面介绍删除操作，删除操作相对于插入操作要考虑的情况多点。</p>
<p><img src="/img/btree_11.png" alt=""></p>
<p>删除(delete)操作：首先查找B-tree中需删除的元素,如果该元素在B-tree中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况.。</p>
<p>删除元素，移动相应元素之后，如果某结点中元素数目小于ceil(m/2)-1，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。那咱们通过下面实例来详细了解吧。</p>
<p>以上述插入操作构造的一棵5阶B-tree为例，依次删除H,T,R,E。</p>
<p>首先删除元素H，当然首先查找H，H在一个叶子结点中，且该叶子结点元素数目3大于最小元素数目ceil(m/2)-1=2，则操作很简单，咱们只需要移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）</p>
<p><img src="/img/btree_12.png" alt=""></p>
<p>下一步，删除T,因为T没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者W(字母升序的下个元素)，将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该孩子结点中元素个数大于2，无需进行合并操作。</p>
<p><img src="/img/btree_13.png" alt=""></p>
<p>下一步删除R，R在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目ceil(5/2)-1=2,如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中，在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。下一步删除R，R在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目ceil(5/2)-1=2,如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中，在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素W下移到该叶子结点中，代替原来S的位置，S前移；然后X在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除X，后面元素前移。</p>
<p><img src="/img/btree_14.png" alt=""></p>
<p>最后一步删除E，删除后会导致很多问题，因为E所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2）,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点和含有A,C的相邻兄弟结点进行合并成一个结点。</p>
<p><img src="/img/btree_15.png" alt=""></p>
<p>也许你认为这样删除操作已经结束了，其实不然，在看看上图，对于这种特殊情况，你立即会发现父节点只包含一个元素G，没达标，这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）有一个以上的元素（Q右边还有元素），然后咱们将M下移到元素很少的子结点中，将Q上移到M的位置，这时，Q的左子树将变成M的右子树，也就是含有N，P结点被依附在M的右指针上。所以在这个实例中，咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，这样，树的高度减少一层。</p>
<p><img src="/img/btree_16.png" alt=""></p>
<p>为了进一步详细讨论删除的情况。再举另外一个实例：</p>
<p>这里是一棵不同的5阶B-tree，那咱们试着删除C</p>
<p><img src="/img/btree_17.png" alt=""></p>
<p>于是将删除元素C的右子结点中的D元素上移到C的位置，但是出现上移元素后，只有一个元素的结点的情况。</p>
<p><img src="/img/btree_18.png" alt=""></p>
<p>又因为含有E的结点，其相邻兄弟结点才刚脱贫（最少元素个数为2），不可能向父节点借元素，所以只能进行合并操作，于是这里将含有A,B的左兄弟结点和含有E的结点进行合并成一个结点。</p>
<p><img src="/img/btree_19.png" alt=""></p>
<p>这样又出现只含有一个元素F结点的情况，这时，其相邻的兄弟结点是丰满的（元素个数为3&gt;最小元素个数2），这样就可以想父结点借元素了，把父结点中的J下移到该结点中，相应的如果结点中J后有元素则前移，然后相邻兄弟结点中的第一个元素（或者最后一个元素）上移到父节点中，后面的元素（或者前面的元素）前移（或者后移）；注意含有K，L的结点以前依附在M的左边，现在变为依附在J的右边。这样每个结点都满足B-tree结构性质。</p>
<p><img src="/img/btree_20.png" alt=""></p>
<h1 id="4-B-tree"><a href="#4-B-tree" class="headerlink" title="4.B+-tree"></a>4.B+-tree</h1><p>B+-tree：是应文件系统所需而产生的一种B-tree的变形树。</p>
<p>一棵m阶的B+-tree和m阶的B-tree的差异在于：</p>
<pre><code>1.有n棵子树的结点中含有n个关键字； (B-tree是n棵子树有n-1个关键字)

2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (B-tree的叶子节点并没有包括全部需要查找的信息)

3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (B-tree的非终节点也包含需要查找的有效信息)
</code></pre><p><img src="/img/btree_21.png" alt=""></p>
<p>a)      为什么说B+树比B-tree更适合实际应用中操作系统的文件索引和数据库索引？</p>
<p>1) B+-tree的磁盘读写代价更低</p>
<p>B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B-tree更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<pre><code>举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+-tree内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B-tree就比B+-tree多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。
</code></pre><p>2) B+-tree的查询效率更加稳定</p>
<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p>b)      B+-tree的应用: VSAM(虚拟存储存取法)文件(来源论文the ubiquitous Btree 作者：D COMER - 1979 )</p>
<p><img src="/img/btree_22.png" alt=""></p>
<p>关于B+-tree的详细介绍将在以后的学习中给出实例，待写。。。</p>
<h1 id="5-B-tree"><a href="#5-B-tree" class="headerlink" title="5.B*-tree"></a>5.B*-tree</h1><p>B<em>-tree是B+-tree的变体，在B+-tree的非根和非叶子结点再增加指向兄弟的指针；B</em>-tree定义了非叶子结点关键字个数至少为(2 /3)*M，即块的最低使用率为2/3（代替B+树的1/2）。给出了一个简单实例，如下图所示：</p>
<p><img src="/img/btree_23.png" alt=""></p>
<p>B+-tree的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+-tree的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。</p>
<p>B*-tree的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。</p>
<p>所以，B*-tree分配新结点的概率比B+-tree要低，空间使用率更高；</p>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h1><pre><code>B-tree，B+-tree，B*-tree总结如下： 

 B-tree：有序数组+平衡多叉树；

 B+-tree：有序数组链表+平衡多叉树；

 B*-tree：一棵丰满的B+-tree。



  在大规模数据存储的文件系统中，B~tree系列数据结构，起着很重要的作用，对于存储不同的数据，节点相关的信息也是有所不同，这里根据自己的理解，画的一个查找以职工号为关键字，职工号为38的记录的简单示意图。(这里假设每个物理块容纳3个索引，磁盘的I/O操作的基本单位是块（block),磁盘访问很费时，采用B+-tree有效的减少了访问磁盘的次数。）
</code></pre><p>对于像MySQL，DB2，Oracle等数据库中的索引结构有待深入的了解才行，不过网上可以找到很多B-tree相关的开源代码可以用来研究。</p>
<p><img src="/img/btree_24.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-前言：&quot;&gt;&lt;a href=&quot;#1-前言：&quot; class=&quot;headerlink&quot; title=&quot;1.前言：&quot;&gt;&lt;/a&gt;1.前言：&lt;/h1&gt;&lt;p&gt;动态查找树主要有：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary
    
    </summary>
    
      <category term="数据结构" scheme="https://fudawei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://fudawei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据库" scheme="https://fudawei.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="索引" scheme="https://fudawei.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>[Spark源码二】RDD讲解</title>
    <link href="https://fudawei.github.io/2016/10/10/%5BSpark%E6%BA%90%E7%A0%81%E4%BA%8C%5DRDD%E8%AE%B2%E8%A7%A3/"/>
    <id>https://fudawei.github.io/2016/10/10/[Spark源码二]RDD讲解/</id>
    <published>2016-10-10T14:42:01.000Z</published>
    <updated>2017-02-08T03:39:19.517Z</updated>
    
    <content type="html"><![CDATA[<p>1、什么是RDD？</p>
<p> RDD的全名是Resilient Distributed Dataset，意思是容错的分布式数据集，每一个RDD都会有5个特征：</p>
<p>1、有一个分片列表。就是能被切分，和hadoop一样的，能够切分的数据才能并行计算。<br>2、有一个函数计算每一个分片，这里指的是下面会提到的compute函数。<br>3、对其他的RDD的依赖列表，依赖还具体分为宽依赖和窄依赖，但并不是所有的RDD都有依赖。<br>4、可选：key-value型的RDD是根据哈希来分区的，类似于mapreduce当中的Paritioner接口，控制key分到哪个reduce。<br>5、可选：每一个分片的优先计算位置（preferred locations），比如HDFS的block的所在位置应该是优先计算的位置。</p>
<p>我们一项一项按着看。首先我们找到RDD这个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//对一个分片进行计算，得出一个可遍历的结果</div><div class="line">def compute(split: Partition, context: TaskContext): Iterator[T]</div><div class="line">//只调用一次，返回RDD分区</div><div class="line">protected def getPartitions: Array[Partition]</div><div class="line"> //也只会调用一次，返回依赖的Rdd</div><div class="line">protected def getDependencies: Seq[Dependency[_]] = deps</div></pre></td></tr></table></figure>
<p>多种RDD之间的转换<br>下面用一个实例讲解一下吧，就拿我们常用的一段代码来讲吧，然后会把我们常用的RDD都会讲到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val hdfsFile = sc.textFile(args(1))</div><div class="line">val flatMapRdd = hdfsFile.flatMap(s =&gt; s.split(&quot; &quot;))</div><div class="line">val filterRdd = flatMapRdd.filter(_.length == 2)</div><div class="line">val mapRdd = filterRdd.map(word =&gt; (word, 1))</div><div class="line">val reduce = mapRdd.reduceByKey(_ + _)</div></pre></td></tr></table></figure>
<p>这里涉及到多个RDD，首先sc.textFile得到一个HadoopRDD经过map之后MapPartitionsRDD经过flatMap之后为MapPartitionsRDD，经过filter之后MapPartitionsRDD经过map之后隐式转换未PairRDDFunctions静reduceByKey后转化为ShuffledRDD</p>
<p>我们先看一下<br>问题导读：<br>1.什么是RDD?<br>2.如何实现RDD转换？</p>
<p>1、什么是RDD？<br>上一章讲了Spark提交作业的过程，这一章我们要讲RDD。简单的讲，RDD就是Spark的input，知道input是啥吧，就是输入的数据。</p>
<p>RDD的全名是Resilient Distributed Dataset，意思是容错的分布式数据集，每一个RDD都会有5个特征：</p>
<p>1、有一个分片列表。就是能被切分，和hadoop一样的，能够切分的数据才能并行计算。<br>2、有一个函数计算每一个分片，这里指的是下面会提到的compute函数。<br>3、对其他的RDD的依赖列表，依赖还具体分为宽依赖和窄依赖，但并不是所有的RDD都有依赖。<br>4、可选：key-value型的RDD是根据哈希来分区的，类似于mapreduce当中的Paritioner接口，控制key分到哪个reduce。<br>5、可选：每一个分片的优先计算位置（preferred locations），比如HDFS的block的所在位置应该是优先计算的位置。</p>
<p>对应着上面这几点，我们在RDD里面能找到这4个方法和1个属性，别着急，下面我们会慢慢展开说这5个东东。</p>
<p>//只计算一次<br>  protected def getPartitions: Array[Partition]<br>  //对一个分片进行计算，得出一个可遍历的结果<br>  def compute(split: Partition, context: TaskContext): Iterator[T]<br>  //只计算一次，计算RDD对父RDD的依赖<br>  protected def getDependencies: Seq[Dependency[_]] = deps<br>  //可选的，分区的方法，针对第4点，类似于mapreduce当中的Paritioner接口，控制key分到哪个reduce<br>  @transient val partitioner: Option[Partitioner] = None<br>  //可选的，指定优先位置，输入参数是split分片，输出结果是一组优先的节点位置<br>  protected def getPreferredLocations(split: Partition): Seq[String] = Nil<br>复制代码</p>
<p>2、多种RDD之间的转换<br>下面用一个实例讲解一下吧，就拿我们常用的一段代码来讲吧，然后会把我们常用的RDD都会讲到。</p>
<p>val hdfsFile = sc.textFile(args(1))<br>    val flatMapRdd = hdfsFile.flatMap(s =&gt; s.split(“ “))<br>    val filterRdd = flatMapRdd.filter(<em>.length == 2)<br>    val mapRdd = filterRdd.map(word =&gt; (word, 1))<br>    val reduce = mapRdd.reduceByKey(</em> + _)<br>复制代码</p>
<p>这里涉及到很多个RDD，textFile是一个HadoopRDD经过map后的MappredRDD，经过flatMap是一个FlatMappedRDD，经过filter方法之后生成了一个FilteredRDD，经过map函数之后，变成一个MappedRDD，通过隐式转换成 PairRDD，最后经过reduceByKey。</p>
<p>我们首先看textFile的这个方法，进入SparkContext这个方法，找到它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def textFile(</div><div class="line">     path: String,</div><div class="line">     minPartitions: Int = defaultMinPartitions): RDD[String] = withScope &#123;</div><div class="line">   assertNotStopped()</div><div class="line">   hadoopFile(path, classOf[TextInputFormat], classOf[LongWritable], classOf[Text],</div><div class="line">     minPartitions).map(pair =&gt; pair._2.toString).setName(path)</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这个方法能读取hdfs文件、本地文件以及hadoop支持的其他文本文件，里面调用了hadoopFile,接着看这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">def hadoopFile[K, V](</div><div class="line">      path: String,</div><div class="line">      inputFormatClass: Class[_ &lt;: InputFormat[K, V]],</div><div class="line">      keyClass: Class[K],</div><div class="line">      valueClass: Class[V],</div><div class="line">      minPartitions: Int = defaultMinPartitions): RDD[(K, V)] = withScope &#123;</div><div class="line">    assertNotStopped()</div><div class="line">    // A Hadoop configuration can be about 10 KB, which is pretty big, so broadcast it.</div><div class="line">    val confBroadcast = broadcast(new SerializableConfiguration(hadoopConfiguration))</div><div class="line">    val setInputPathsFunc = (jobConf: JobConf) =&gt; FileInputFormat.setInputPaths(jobConf, path)</div><div class="line">    new HadoopRDD(</div><div class="line">      this,</div><div class="line">      confBroadcast,</div><div class="line">      Some(setInputPathsFunc),</div><div class="line">      inputFormatClass,</div><div class="line">      keyClass,</div><div class="line">      valueClass,</div><div class="line">      minPartitions).setName(path)</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>hadoopFile方法内静hadoop的配置文件放到广播变量，人后new 了一个HadoopRDD然后调用setName返回HadoopRDD，<br>以下构造HadoopRDD的参数<br>   sc:spark上下文<br> 　broadcastedConf：广播变量配置（hadoop的配置文件<br> 　initLocalJobConfFuncOpt:用于初始化HadoopRDD的job配置文件<br>   inputFormatClass:格式化读取数据文件<br> 　keyClass：为inputFormatClass指定的key<br> 　valueClass： inputFormatClass的Class<br> 　minPartitions：　HadoopRDD最小分区数<br>我们看一下HadoopRDD的主要方法：<br>首先getPartitions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">override def getPartitions: Array[Partition] = &#123;</div><div class="line">    val jobConf = getJobConf()</div><div class="line">    // add the credentials here as this can be called before SparkContext initialized</div><div class="line">    SparkHadoopUtil.get.addCredentials(jobConf)</div><div class="line">    val inputFormat = getInputFormat(jobConf)</div><div class="line">    val inputSplits = inputFormat.getSplits(jobConf, minPartitions)</div><div class="line">    val array = new Array[Partition](inputSplits.size)</div><div class="line">    for (i &lt;- 0 until inputSplits.size) &#123;</div><div class="line">      array(i) = new HadoopPartition(id, i, inputSplits(i))</div><div class="line">    &#125;</div><div class="line">    array</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>HadoopRDD按照inputSplits.size分割数据来分区的,然后把分片HadoopPartition包装到到array里面返回。</p>
<p>我们接下来看compute方法，它的输入值是一个Partition，返回是一个Iterator[(K, V)]类型的数据，这里面我们只需要关注2点即可。</p>
<p>1、把Partition转成HadoopPartition，然后通过InputSplit创建一个RecordReader<br>2、重写Iterator的getNext方法，通过创建的reader调用next方法读取下一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">override def compute(theSplit: Partition, context: TaskContext): InterruptibleIterator[(K, V)] = &#123;</div><div class="line">    val iter = new NextIterator[(K, V)] &#123;</div><div class="line"></div><div class="line">      val split = theSplit.asInstanceOf[HadoopPartition]</div><div class="line">      logInfo(&quot;Input split: &quot; + split.inputSplit)</div><div class="line">      val jobConf = getJobConf()</div><div class="line"></div><div class="line">      val inputMetrics = context.taskMetrics().inputMetrics</div><div class="line">      val existingBytesRead = inputMetrics.bytesRead</div><div class="line"></div><div class="line">      // Sets the thread local variable for the file&apos;s name</div><div class="line">      split.inputSplit.value match &#123;</div><div class="line">        case fs: FileSplit =&gt; InputFileNameHolder.setInputFileName(fs.getPath.toString)</div><div class="line">        case _ =&gt; InputFileNameHolder.unsetInputFileName()</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // Find a function that will return the FileSystem bytes read by this thread. Do this before</div><div class="line">      // creating RecordReader, because RecordReader&apos;s constructor might read some bytes</div><div class="line">      val getBytesReadCallback: Option[() =&gt; Long] = split.inputSplit.value match &#123;</div><div class="line">        case _: FileSplit | _: CombineFileSplit =&gt;</div><div class="line">          SparkHadoopUtil.get.getFSBytesReadOnThreadCallback()</div><div class="line">        case _ =&gt; None</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // For Hadoop 2.5+, we get our input bytes from thread-local Hadoop FileSystem statistics.</div><div class="line">      // If we do a coalesce, however, we are likely to compute multiple partitions in the same</div><div class="line">      // task and in the same thread, in which case we need to avoid override values written by</div><div class="line">      // previous partitions (SPARK-13071).</div><div class="line">      def updateBytesRead(): Unit = &#123;</div><div class="line">        getBytesReadCallback.foreach &#123; getBytesRead =&gt;</div><div class="line">          inputMetrics.setBytesRead(existingBytesRead + getBytesRead())</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      var reader: RecordReader[K, V] = null</div><div class="line">      val inputFormat = getInputFormat(jobConf)</div><div class="line">      HadoopRDD.addLocalConfiguration(new SimpleDateFormat(&quot;yyyyMMddHHmm&quot;).format(createTime),</div><div class="line">        context.stageId, theSplit.index, context.attemptNumber, jobConf)</div><div class="line">      reader = inputFormat.getRecordReader(split.inputSplit.value, jobConf, Reporter.NULL)</div><div class="line"></div><div class="line">      context.addTaskCompletionListener&#123; context =&gt; closeIfNeeded() &#125;</div><div class="line">      val key: K = reader.createKey()</div><div class="line">      val value: V = reader.createValue()</div><div class="line"></div><div class="line">      override def getNext(): (K, V) = &#123;</div><div class="line">       ......</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      override def close() &#123;</div><div class="line">       ......</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    new InterruptibleIterator[(K, V)](context, iter)</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>从这里我们可以看得出来compute方法是通过分片来获得Iterator接口，以遍历分片的数据。</p>
<p>getPreferredLocations方法就更简单了，直接调用InputSplit的getLocations方法获得所在的位置。</p>
<p>2.2 依赖<br>下面我们看RDD里面的map方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def map[U: ClassTag](f: T =&gt; U): RDD[U] = withScope &#123;</div><div class="line">    val cleanF = sc.clean(f)</div><div class="line">    new MapPartitionsRDD[U, T](this, (context, pid, iter) =&gt; iter.map(cleanF))</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>直接new了一个MapPartitionsRDD然后讲函数穿进去，我们杀进MapPartitionsRDD<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private[spark] class MapPartitionsRDD[U: ClassTag, T: ClassTag](</div><div class="line">    var prev: RDD[T],</div><div class="line">    f: (TaskContext, Int, Iterator[T]) =&gt; Iterator[U],  // (TaskContext, partition index, iterator)</div><div class="line">    preservesPartitioning: Boolean = false)</div><div class="line">  extends RDD[U](prev) &#123;</div><div class="line"></div><div class="line">  override val partitioner = if (preservesPartitioning) firstParent[T].partitioner else None</div><div class="line"></div><div class="line">  override def getPartitions: Array[Partition] = firstParent[T].partitions</div><div class="line"></div><div class="line">  override def compute(split: Partition, context: TaskContext): Iterator[U] =</div><div class="line">    f(context, split.index, firstParent[T].iterator(split, context))</div><div class="line">  // 清空父RDD</div><div class="line">  override def clearDependencies() &#123;</div><div class="line">    super.clearDependencies()</div><div class="line">    prev = null</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先看一下RDD对应的构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def this(@transient oneParent: RDD[_]) =</div><div class="line">    this(oneParent.context, List(new OneToOneDependency(oneParent)))</div></pre></td></tr></table></figure></p>
<p>就这样你会发现它把RDD复制给了deps，HadoopRDD成了我们杀进MapPartitionsRDD的父依赖了，这个OneToOneDependency是一个窄依赖，子RDD直接依赖于父RDD，继续看firstParent。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected[spark] def firstParent[U: ClassTag]: RDD[U] = &#123;</div><div class="line">   dependencies.head.rdd.asInstanceOf[RDD[U]]</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>由此我们可以得出两个结论：</p>
<p>1、getPartitions直接沿用了父RDD的分片信息<br>2、compute函数是在父RDD遍历每一行数据时套一个匿名函数f进行处理<br>好吧，现在我们可以理解compute函数真正是在干嘛的了</p>
<p>它的两个显著作用：</p>
<p>1、在没有依赖的条件下，根据分片的信息生成遍历数据的Iterable接口<br>2、在有前置依赖的条件下，在父RDD的Iterable接口上给遍历每个元素的时候再套上一个方法</p>
<p>我们看看点击进入map(f)的方法进去看一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def map[B](f: A =&gt; B): Iterator[B] = new AbstractIterator[B] &#123;</div><div class="line">    def hasNext = self.hasNext</div><div class="line">    def next() = f(self.next())</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>map方法将数据集的每一个数据按照f函数执行后返回数据</p>
<p>我们接着看RDD的flatMap方法，你会发现它和map函数几乎没什么区别，但是flatMap和map的效果还是差别挺大的。</p>
<p>比如((1,2),(3,4)), 如果是调用了flatMap函数，我们访问到的就是(1,2,3,4)4个元素；如果是map的话，我们访问到的就是(1,2),(3,4)两个元素。</p>
<p>有兴趣的可以去看看FlatMappedRDD和FilteredRDD</p>
<p>2.3 reduceByKey<br>下面我们看一下reduceByKey的实现。<br>reduceByKey隐藏的比较深，并没有在RDD中，而是在因式转换为PairRDDFunctions才可以使用，所以我们去PairRDDFunctions找一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> def reduceByKey(func: (V, V) =&gt; V): RDD[(K, V)] = self.withScope &#123;</div><div class="line">   reduceByKey(defaultPartitioner(self), func)</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">def defaultPartitioner(rdd: RDD[_], others: RDD[_]*): Partitioner = &#123;</div><div class="line">  val bySize = (Seq(rdd) ++ others).sortBy(_.partitions.length).reverse</div><div class="line">  for (r &lt;- bySize if r.partitioner.isDefined &amp;&amp; r.partitioner.get.numPartitions &gt; 0) &#123;</div><div class="line">    return r.partitioner.get</div><div class="line">  &#125;</div><div class="line">  if (rdd.context.conf.contains(&quot;spark.default.parallelism&quot;)) &#123;</div><div class="line">    new HashPartitioner(rdd.context.defaultParallelism)</div><div class="line">  &#125; else &#123;</div><div class="line">    new HashPartitioner(bySize.head.partitions.length)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">def reduceByKey(partitioner: Partitioner, func: (V, V) =&gt; V): RDD[(K, V)] = self.withScope &#123;</div><div class="line">   combineByKeyWithClassTag[V]((v: V) =&gt; v, func, func, partitioner)</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>我们可以看到reduceByKeyreduceByKeyWithClassTag方法，有心去可以看一下<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">def combineByKeyWithClassTag[C](</div><div class="line">     createCombiner: V =&gt; C,</div><div class="line">     mergeValue: (C, V) =&gt; C,</div><div class="line">     mergeCombiners: (C, C) =&gt; C,</div><div class="line">     partitioner: Partitioner,</div><div class="line">     mapSideCombine: Boolean = true,</div><div class="line">     serializer: Serializer = null)(implicit ct: ClassTag[C]): RDD[(K, C)] = self.withScope &#123;</div><div class="line">   require(mergeCombiners != null, &quot;mergeCombiners must be defined&quot;) // required as of Spark 0.9.0</div><div class="line">   if (keyClass.isArray) &#123;</div><div class="line">     if (mapSideCombine) &#123;</div><div class="line">       throw new SparkException(&quot;Cannot use map-side combining with array keys.&quot;)</div><div class="line">     &#125;</div><div class="line">     if (partitioner.isInstanceOf[HashPartitioner]) &#123;</div><div class="line">       throw new SparkException(&quot;Default partitioner cannot partition array keys.&quot;)</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   val aggregator = new Aggregator[K, V, C](</div><div class="line">     self.context.clean(createCombiner),  //设置句聚合函数</div><div class="line">     self.context.clean(mergeValue),   //valueMrege函数</div><div class="line">     self.context.clean(mergeCombiners)) // 最终结果的整合函数</div><div class="line">   if (self.partitioner == Some(partitioner)) &#123;</div><div class="line">   //不存在自定义分区</div><div class="line">     self.mapPartitions(iter =&gt; &#123;</div><div class="line">       val context = TaskContext.get()</div><div class="line">       new InterruptibleIterator(context, aggregator.combineValuesByKey(iter, context))</div><div class="line">     &#125;, preservesPartitioning = true)</div><div class="line">   &#125; else &#123;</div><div class="line">   //不存在自定义分区</div><div class="line">     new ShuffledRDD[K, V, C](self, partitioner)</div><div class="line">       .setSerializer(serializer)</div><div class="line">       .setAggregator(aggregator)</div><div class="line">       .setMapSideCombine(mapSideCombine)</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> .......</div><div class="line"> </div><div class="line"> override def getDependencies: Seq[Dependency[_]] = &#123;</div><div class="line">   val serializer = userSpecifiedSerializer.getOrElse &#123;</div><div class="line">     val serializerManager = SparkEnv.get.serializerManager</div><div class="line">     if (mapSideCombine) &#123;</div><div class="line">       serializerManager.getSerializer(implicitly[ClassTag[K]], implicitly[ClassTag[C]])</div><div class="line">     &#125; else &#123;</div><div class="line">       serializerManager.getSerializer(implicitly[ClassTag[K]], implicitly[ClassTag[V]])</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   //</div><div class="line">   List(new ShuffleDependency(prev, part, serializer, keyOrdering, aggregator, mapSideCombine))</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>reduce流程可以总结为<br>1、将分区包装秤HashPartitioner分区<br>2、如果没有自定义分区则，直接执行combineCombinersByKey<br>3、  如果有自定义分区，则对shuffle自行combineCombinersByKey</p>
<p>下面我们先看MapPartitionsRDD，我把和别的RDD有别的两行给拿出来了，很明显的区别，f方法是套在iterator的外边，这样才能对iterator的所有数据做一个合并。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> override val partitioner = if (preservesPartitioning) firstParent[T].partitioner else None</div><div class="line">  override def compute(split: Partition, context: TaskContext) =</div><div class="line">    f(context, split.index, firstParent[T].iterator(split, context))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们看Aggregator的combineValuesByKey的方法吧。</p>
<p>def combineValuesByKey(iter: Iterator[_ &lt;: Product2[K, V]],<br>                         context: TaskContext): Iterator[(K, C)] = {<br>    // 是否使用外部排序，是由参数spark.shuffle.spill，默认是true<br>    if (!externalSorting) {<br>      val combiners = new AppendOnlyMap[K,C]<br>      var kv: Product2[K, V] = null<br>      val update = (hadValue: Boolean, oldValue: C) =&gt; {<br>        if (hadValue) mergeValue(oldValue, kv._2) else createCombiner(kv.<em>2)<br>      }<br>      // 用map来去重，用update方法来更新值，如果没值的时候，返回值，如果有值的时候，通过mergeValue方法来合并<br>      // mergeValue方法就是我们在reduceByKey里面写的那个匿名函数，在这里就是（</em> + _）<br>      while (iter.hasNext) {<br>        kv = iter.next()<br>        combiners.changeValue(kv._1, update)<br>      }<br>      combiners.iterator<br>    } else {<br>      // 用了一个外部排序的map来去重，就不停的往里面插入值即可，基本原理和上面的差不多，区别在于需要外部排序<br>      val combiners = new ExternalAppendOnlyMap<a href="createCombiner, mergeValue, mergeCombiners">K, V, C</a><br>      while (iter.hasNext) {<br>        val (k, v) = iter.next()<br>        combiners.insert(k, v)<br>      }<br>      combiners.iterator<br>}</p>
<p>这个就是一个很典型的按照key来做合并的方法了，我们继续看ShuffledRDD吧。</p>
<p>ShuffledRDD和之前的RDD很明显的特征是</p>
<p>1、它的依赖传了一个Nil（空列表）进去，表示它没有依赖。<br>2、它的compute计算方式比较特别，这个在之后的文章说，过程比较复杂。<br>3、它的分片默认是采用HashPartitioner，数量和前面的RDD的分片数量一样，也可以不一样，我们可以在reduceByKey的时候多传一个分片数量即可。</p>
<p>在new完ShuffledRDD之后又来了一遍mapPartitionsWithContext，不过调用的匿名函数变成了combineCombinersByKey。</p>
<p>combineCombinersByKey和combineValuesByKey的逻辑基本相同，只是输入输出的类型有区别。combineCombinersByKey只是做单纯的合并，不会对输入输出的类型进行改变，combineValuesByKey会把iter[K, V]的V值变成iter[K, C]。</p>
<p>case class Aggregator[K, V, C] (<br>　　createCombiner: V =&gt; C,<br>　　mergeValue: (C, V) =&gt; C,<br>　　mergeCombiners: (C, C) =&gt; C)<br>　　……<br>}<br>复制代码</p>
<p>这个方法会根据我们传进去的匿名方法的参数的类型做一个自动转换。<br>到这里，作业都没有真正执行，只是将RDD各种嵌套，我们通过RDD的id和类型的变化观测到这一点，RDD[1]-&gt;RDD[2]-&gt;RDD[3]……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、什么是RDD？&lt;/p&gt;
&lt;p&gt; RDD的全名是Resilient Distributed Dataset，意思是容错的分布式数据集，每一个RDD都会有5个特征：&lt;/p&gt;
&lt;p&gt;1、有一个分片列表。就是能被切分，和hadoop一样的，能够切分的数据才能并行计算。&lt;br&gt;2
    
    </summary>
    
      <category term="大数据" scheme="https://fudawei.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://fudawei.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/"/>
    
    
      <category term="大数据" scheme="https://fudawei.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://fudawei.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>[Spark源码一】spark-submit提交作业过程</title>
    <link href="https://fudawei.github.io/2016/09/27/%5BSpark%E6%BA%90%E7%A0%81%E4%B8%80%5Dspark-submit%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A/"/>
    <id>https://fudawei.github.io/2016/09/27/[Spark源码一]spark-submit提交作业/</id>
    <published>2016-09-27T14:42:01.000Z</published>
    <updated>2017-02-08T03:39:19.517Z</updated>
    
    <content type="html"><![CDATA[<p>使用spark已经有一段时间了，今天开始读spark源码。<br>首先从spark提交作业开始。下图为spark的架构，以及Spark的APP运行图。它通过一个Driver来和集群通信，集群负责作业的分配。今天我要讲的是如何创建这个Driver Program的过程。</p>
<p><img src="/img/spark_architecture.png" alt=""><br>这个是Spark的App运行图，它通过一个Driver来和集群通信，集群负责作业的分配。今天我要讲的是如何创建这个Driver Program的过程。</p>
<h1 id="作业提交"><a href="#作业提交" class="headerlink" title="作业提交"></a>作业提交</h1><p>作业提交方法以及参数<br>我们先看一下用Spark Submit提交的方法吧，下面是从官方上面摘抄的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> Run on a Spark standalone cluster</div><div class="line">./bin/spark-submit \</div><div class="line">  --class org.apache.spark.examples.SparkPi \</div><div class="line">  --master spark://207.184.161.138:7077 \</div><div class="line">  --executor-memory 20G \</div><div class="line">  --total-executor-cores 100 \</div><div class="line">  /path/to/examples.jar \</div><div class="line">  1000</div></pre></td></tr></table></figure>
<p>这个是提交到standalone集群的方式，打开spark-submit这文件，我们会发现它最后是调用了org.apache.spark.deploy.SparkSubmit这个类。</p>
<p>直接打开这个类，找到main入口，发现代码很简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def main(args: Array[String]): Unit = &#123;</div><div class="line">   val appArgs = new SparkSubmitArguments(args)</div><div class="line">   if (appArgs.verbose) &#123;</div><div class="line">     // scalastyle:off println</div><div class="line">     printStream.println(appArgs)</div><div class="line">     // scalastyle:on println</div><div class="line">   &#125;</div><div class="line">   appArgs.action match &#123;</div><div class="line">     case SparkSubmitAction.SUBMIT =&gt; submit(appArgs)</div><div class="line">     case SparkSubmitAction.KILL =&gt; kill(appArgs)</div><div class="line">     case SparkSubmitAction.REQUEST_STATUS =&gt; requestStatus(appArgs)</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>该方法做两件事：<br>1、这里SparkSubmitArguments类初始化过程将会加载spark默认配置文件的配置信息、运行环境信息，另外会将提交的参数覆盖默认配置（并且校验参数的合法性）<br>2、通过反射调用class主方法</p>
<p>有兴趣可以看一下SparkSubmitArguments，一下为默认环境配置信息的代码（loadEnvironmentArguments()方法内部）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">master = Option(master)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.master&quot;))</div><div class="line">      .orElse(env.get(&quot;MASTER&quot;))</div><div class="line">      .orNull</div><div class="line">    driverExtraClassPath = Option(driverExtraClassPath)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.driver.extraClassPath&quot;))</div><div class="line">      .orNull</div><div class="line">    driverExtraJavaOptions = Option(driverExtraJavaOptions)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.driver.extraJavaOptions&quot;))</div><div class="line">      .orNull</div><div class="line">    driverExtraLibraryPath = Option(driverExtraLibraryPath)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.driver.extraLibraryPath&quot;))</div><div class="line">      .orNull</div><div class="line">    driverMemory = Option(driverMemory)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.driver.memory&quot;))</div><div class="line">      .orElse(env.get(&quot;SPARK_DRIVER_MEMORY&quot;))</div><div class="line">      .orNull</div><div class="line">    driverCores = Option(driverCores)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.driver.cores&quot;))</div><div class="line">      .orNull</div><div class="line">    executorMemory = Option(executorMemory)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.executor.memory&quot;))</div><div class="line">      .orElse(env.get(&quot;SPARK_EXECUTOR_MEMORY&quot;))</div><div class="line">      .orNull</div><div class="line">    executorCores = Option(executorCores)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.executor.cores&quot;))</div><div class="line">      .orElse(env.get(&quot;SPARK_EXECUTOR_CORES&quot;))</div><div class="line">      .orNull</div><div class="line">    totalExecutorCores = Option(totalExecutorCores)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.cores.max&quot;))</div><div class="line">      .orNull</div><div class="line">    name = Option(name).orElse(sparkProperties.get(&quot;spark.app.name&quot;)).orNull</div><div class="line">    jars = Option(jars).orElse(sparkProperties.get(&quot;spark.jars&quot;)).orNull</div><div class="line">    ivyRepoPath = sparkProperties.get(&quot;spark.jars.ivy&quot;).orNull</div><div class="line">    packages = Option(packages).orElse(sparkProperties.get(&quot;spark.jars.packages&quot;)).orNull</div><div class="line">    packagesExclusions = Option(packagesExclusions)</div><div class="line">      .orElse(sparkProperties.get(&quot;spark.jars.excludes&quot;)).orNull</div><div class="line">    deployMode = Option(deployMode).orElse(env.get(&quot;DEPLOY_MODE&quot;)).orNull</div><div class="line">    numExecutors = Option(numExecutors)</div><div class="line">      .getOrElse(sparkProperties.get(&quot;spark.executor.instances&quot;).orNull)</div><div class="line">    keytab = Option(keytab).orElse(sparkProperties.get(&quot;spark.yarn.keytab&quot;)).orNull</div><div class="line">    principal = Option(principal).orElse(sparkProperties.get(&quot;spark.yarn.principal&quot;)).orNull</div></pre></td></tr></table></figure></p>
<p>……</p>
<h1 id="提交流程"><a href="#提交流程" class="headerlink" title="提交流程"></a>提交流程</h1><p>Driver程序的部署模式有两种，client和cluster，默认是client。client的话默认就是直接在本地运行了Driver程序了，cluster模式还会兜一圈把作业发到集群上面去运行。(指定部署模式需要用参数–deploy-mode来指定，或者在环境变量当中添加DEPLOY_MODE变量来指定。)</p>
<p>下面讲的是cluster的部署方式，兜一圈的这种情况。</p>
<p>yarn模式的话mainClass是org.apache.spark.deploy.yarn.Client，standalone的mainClass是org.apache.spark.deploy.Client。<br>这次我们讲org.apache.spark.deploy.Client，yarn的话有时间单独讲，目前超哥还是推荐使用standalone的方式部署spark，具体原因不详，据说是因为资源调度方面的问题。</p>
<h1 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h1><p>我们首先看一下Client的实现，首先找到这个类。<br>main函数中主要有一下几行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val rpcEnv = RpcEnv.create(&quot;driverClient&quot;, Utils.localHostName(), 0, conf, new  SecurityManager(conf))</div><div class="line">val masterEndpoints = driverArgs.masters.map(RpcAddress.fromSparkURL).</div><div class="line">      map(rpcEnv.setupEndpointRef(_, Master.ENDPOINT_NAME))</div><div class="line">rpcEnv.setupEndpoint(&quot;client&quot;, new ClientEndpoint(rpcEnv, driverArgs, masterEndpoints, conf))</div><div class="line">rpcEnv.awaitTermination()</div></pre></td></tr></table></figure></p>
<pre><code>这里看到一个rpcEnv，最后还调用了awaitTermination()方法，好像时启动了什么。另外Client继承了RpcEndpoint（ThreadSafeRpcEndpoint），浏览一下RpcEnv和RpcEndpoint的内容，其实就时用做发消息的，之前听说spark用的actor模式，每个进程之间可以看作是一个个独立的实体，他们之间是毫无关联的。但是，他们可以通过消息来通信。所有的任务都是通过消息通信完成。据说spark使用的是akka框架，但RpcEnv和RpcEndpoint没看到akka的实现，只有netty的实现，有可能spark已经讲akka实现移除了。至于actor模型有兴趣大家可自行百度。
</code></pre><p><strong>为了便于阅读源码我们看一下RpcEndpoint中比较重要的几个函数：</strong><br>onStart()             //rpcEndpoint启动时执行的操作<br>onStop()              //rpcEndpoint停止时执行的操作<br>receive()             //接受并处理RpcEndpointRef.send发送的信息<br>receiveAndReply()     //接受并处理RpcEndpointRef.ask发送的信息</p>
<p>接下来看一下启动时client做了那些操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">override def onStart(): Unit = &#123;</div><div class="line">   driverArgs.cmd match &#123;</div><div class="line">     case &quot;launch&quot; =&gt;</div><div class="line">       // TODO: We could add an env variable here and intercept it in `sc.addJar` that would</div><div class="line">       //       truncate filesystem paths similar to what YARN does. For now, we just require</div><div class="line">       //       people call `addJar` assuming the jar is in the same directory.</div><div class="line">       val mainClass = &quot;org.apache.spark.deploy.worker.DriverWrapper&quot;</div><div class="line"></div><div class="line">       val classPathConf = &quot;spark.driver.extraClassPath&quot;</div><div class="line">       val classPathEntries = sys.props.get(classPathConf).toSeq.flatMap &#123; cp =&gt;</div><div class="line">         cp.split(java.io.File.pathSeparator)</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       val libraryPathConf = &quot;spark.driver.extraLibraryPath&quot;</div><div class="line">       val libraryPathEntries = sys.props.get(libraryPathConf).toSeq.flatMap &#123; cp =&gt;</div><div class="line">         cp.split(java.io.File.pathSeparator)</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       val extraJavaOptsConf = &quot;spark.driver.extraJavaOptions&quot;</div><div class="line">       val extraJavaOpts = sys.props.get(extraJavaOptsConf)</div><div class="line">         .map(Utils.splitCommandString).getOrElse(Seq.empty)</div><div class="line">       val sparkJavaOpts = Utils.sparkJavaOpts(conf)</div><div class="line">       val javaOpts = sparkJavaOpts ++ extraJavaOpts</div><div class="line">       val command = new Command(mainClass,</div><div class="line">         Seq(&quot;&#123;&#123;WORKER_URL&#125;&#125;&quot;, &quot;&#123;&#123;USER_JAR&#125;&#125;&quot;, driverArgs.mainClass) ++ driverArgs.driverOptions,</div><div class="line">         sys.env, classPathEntries, libraryPathEntries, javaOpts)</div><div class="line"></div><div class="line">       val driverDescription = new DriverDescription(</div><div class="line">         driverArgs.jarUrl,</div><div class="line">         driverArgs.memory,</div><div class="line">         driverArgs.cores,</div><div class="line">         driverArgs.supervise,</div><div class="line">         command)</div><div class="line">       ayncSendToMasterAndForwardReply[SubmitDriverResponse](</div><div class="line">         RequestSubmitDriver(driverDescription))</div><div class="line"></div><div class="line">     case &quot;kill&quot; =&gt;</div><div class="line">       val driverId = driverArgs.driverId</div><div class="line">       ayncSendToMasterAndForwardReply[KillDriverResponse](RequestKillDriver(driverId))</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>从上面的代码看得出来，它需要设置master的连接地址，最后提交了一个RequestSubmitDriver的信息。在receive方法里面，就是等待接受回应了，有两个Response分别对应着这里的launch和kill。这里发送的message信息是RequestSubmitDriver，顺便看一下ayncSendToMasterAndForwardReply实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private def ayncSendToMasterAndForwardReply[T: ClassTag](message: Any): Unit = &#123;</div><div class="line">   for (masterEndpoint &lt;- masterEndpoints) &#123;</div><div class="line">     masterEndpoint.ask[T](message).onComplete &#123;</div><div class="line">       case Success(v) =&gt; self.send(v)</div><div class="line">       case Failure(e) =&gt;</div><div class="line">         logWarning(s&quot;Error sending messages to master $masterEndpoint&quot;, e)</div><div class="line">     &#125;(forwardMessageExecutionContext)</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>注意：这里调用的是masterEndpoint.ask.</p>
<p><strong>小结：</strong></p>
<p>Client通过实现rpc框架实现了请求、接收请求、传递的消息、注册的地址和端口这些功能。</p>
<h1 id="Master端"><a href="#Master端" class="headerlink" title="Master端"></a>Master端</h1><p>接下来我们继续看Master段的代码</p>
<p>Master类同样继承了RpcEndpoint。Client端发送消息使用的时ask所以我们看一下receiveAndReply函数，找一下对应的消息接受处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = &#123;</div><div class="line"> case RequestSubmitDriver(description) =&gt;</div><div class="line">      if (state != RecoveryState.ALIVE) &#123;</div><div class="line">        val msg = s&quot;$&#123;Utils.BACKUP_STANDALONE_MASTER_PREFIX&#125;: $state. &quot; +</div><div class="line">          &quot;Can only accept driver submissions in ALIVE state.&quot;</div><div class="line">        context.reply(SubmitDriverResponse(self, false, None, msg))</div><div class="line">      &#125; else &#123;</div><div class="line">        logInfo(&quot;Driver submitted &quot; + description.command.mainClass)</div><div class="line">        val driver = createDriver(description)</div><div class="line">        persistenceEngine.addDriver(driver)</div><div class="line">        waitingDrivers += driver</div><div class="line">        drivers.add(driver)</div><div class="line">        //调度</div><div class="line">        schedule()</div><div class="line">        // 告诉client，提交成功了，把driver.id告诉它</div><div class="line">        context.reply(SubmitDriverResponse(self, true, Some(driver.id),</div><div class="line">          s&quot;Driver successfully submitted as $&#123;driver.id&#125;&quot;))</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>接下来看调度方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">private def schedule(): Unit = &#123;</div><div class="line">  if (state != RecoveryState.ALIVE) &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  // 首先调度Driver程序，从workers里面随机抽一些出来</div><div class="line">  val shuffledAliveWorkers = Random.shuffle(workers.toSeq.filter(_.state == WorkerState.ALIVE))</div><div class="line">  val numWorkersAlive = shuffledAliveWorkers.size</div><div class="line">  var curPos = 0</div><div class="line">  for (driver &lt;- waitingDrivers.toList) &#123; // iterate over a copy of waitingDrivers</div><div class="line">    // We assign workers to each waiting driver in a round-robin fashion. For each driver, we</div><div class="line">    // start from the last worker that was assigned a driver, and continue onwards until we have</div><div class="line">    // explored all alive workers.</div><div class="line">    var launched = false</div><div class="line">    var numWorkersVisited = 0</div><div class="line">    while (numWorkersVisited &lt; numWorkersAlive &amp;&amp; !launched) &#123;</div><div class="line">      val worker = shuffledAliveWorkers(curPos)</div><div class="line">      numWorkersVisited += 1</div><div class="line">      //判断内存和CPU资源是否足够，</div><div class="line">      if (worker.memoryFree &gt;= driver.desc.mem &amp;&amp; worker.coresFree &gt;= driver.desc.cores) &#123;</div><div class="line">        launchDriver(worker, driver)  //向worker发送信息，worker预留内存</div><div class="line">        waitingDrivers -= driver</div><div class="line">        launched = true</div><div class="line">      &#125;</div><div class="line">      curPos = (curPos + 1) % numWorkersAlive</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  //在worker上启动executor</div><div class="line">  startExecutorsOnWorkers()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里仔细看一下worker启动executor的方法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">private def scheduleExecutorsOnWorkers(</div><div class="line">     app: ApplicationInfo,</div><div class="line">     usableWorkers: Array[WorkerInfo],</div><div class="line">     spreadOutApps: Boolean): Array[Int] = &#123;</div><div class="line">   ......</div><div class="line">   ......</div><div class="line">   ......</div><div class="line">   while (freeWorkers.nonEmpty) &#123;</div><div class="line">     freeWorkers.foreach &#123; pos =&gt;</div><div class="line">       var keepScheduling = true</div><div class="line">       while (keepScheduling &amp;&amp; canLaunchExecutor(pos)) &#123;</div><div class="line">         coresToAssign -= minCoresPerExecutor</div><div class="line">         assignedCores(pos) += minCoresPerExecutor</div><div class="line"></div><div class="line">         // If we are launching one executor per worker, then every iteration assigns 1 core</div><div class="line">         // to the executor. Otherwise, every iteration assigns cores to a new executor.</div><div class="line">         if (oneExecutorPerWorker) &#123;</div><div class="line">           assignedExecutors(pos) = 1</div><div class="line">         &#125; else &#123;</div><div class="line">           assignedExecutors(pos) += 1</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         //spreadout 意味着分配executor时会尽可能均匀的分布到所有的worker节点上，否则会想将一个worker的资源分             //配完才会去其他的worker分配executor</div><div class="line">         if (spreadOutApps) &#123;</div><div class="line">           keepScheduling = false</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     freeWorkers = freeWorkers.filter(canLaunchExecutor)</div><div class="line">   &#125;</div><div class="line">   assignedCores</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>它的调度器是这样的，先调度Driver程序，然后再调度App，调度App的方式是从各个worker的里面和App进行匹配，看需要分配多少个cpu。<br>那我们接下来看两个方法launchDriver和launchExecutor即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private def launchDriver(worker: WorkerInfo, driver: DriverInfo) &#123;</div><div class="line">   logInfo(&quot;Launching     &quot; + driver.id + &quot; on worker &quot; + worker.id)</div><div class="line">   worker.addDriver(driver)</div><div class="line">   driver.worker = Some(worker)</div><div class="line">   worker.endpoint.send(LaunchDriver(driver.id, driver.desc))</div><div class="line">   driver.state = DriverState.RUNNING</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>给worker发送了一个LaunchDriver的消息，下面在看launchExecutor的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private def launchExecutor(worker: WorkerInfo, exec: ExecutorDesc): Unit = &#123;</div><div class="line">    logInfo(&quot;Launching executor &quot; + exec.fullId + &quot; on worker &quot; + worker.id)</div><div class="line">    worker.addExecutor(exec)</div><div class="line">    worker.endpoint.send(LaunchExecutor(masterUrl,</div><div class="line">      exec.application.id, exec.id, exec.application.desc, exec.cores, exec.memory))</div><div class="line">    exec.application.driver.send(</div><div class="line">      ExecutorAdded(exec.id, worker.id, worker.hostPort, exec.cores, exec.memory))</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>  它要做的事情多一点，除了给worker发送LaunchExecutor指令外，还需要给driver发送ExecutorAdded的消息，说你的任务已经有人干了。</p>
<p>在继续Worker讲之前，我们先看看它是怎么注册进来的，每个Worker启动之后，会自动去请求Master去注册自己，具体我们可以看receive的方法里面的RegisterWorker这一段，它需要上报自己的内存、Cpu、地址、端口等信息，注册成功之后返回RegisteredWorker信息给它，说已经注册成功了</p>
<h1 id="Worker执行"><a href="#Worker执行" class="headerlink" title="Worker执行"></a>Worker执行</h1><p>同样的，我们到Worker里面在receive方法找LaunchDriver和LaunchExecutor就可以找到我们要的东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">case LaunchDriver(driverId, driverDesc) =&gt;</div><div class="line">      logInfo(s&quot;Asked to launch driver $driverId&quot;)</div><div class="line">      val driver = new DriverRunner(</div><div class="line">        conf,</div><div class="line">        driverId,</div><div class="line">        workDir,</div><div class="line">        sparkHome,</div><div class="line">        driverDesc.copy(command = Worker.maybeUpdateSSLSettings(driverDesc.command, conf)),</div><div class="line">        self,</div><div class="line">        workerUri,</div><div class="line">        securityMgr)</div><div class="line">      drivers(driverId) = driver</div><div class="line">      driver.start()</div><div class="line"></div><div class="line">      coresUsed += driverDesc.cores</div><div class="line">      memoryUsed += driverDesc.mem</div></pre></td></tr></table></figure>
<p>这里运行LaunchDriver时，只是预分配了内存和CPU资源，接下来看一下start方法吧，start方法里面，其实是new Thread().start()，run方法里面是通过传过来的DriverDescription构造的一个命令，丢给ProcessBuilder去执行命令，结束之后调用。</p>
<p>worker ！DriverStateChanged通知worker，worker再通过master ! DriverStateChanged通知master，释放掉worker的cpu和内存。</p>
<p>接下来看一下看一下LaunchExecutor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">case LaunchExecutor(masterUrl, appId, execId, appDesc, cores_, memory_) =&gt;</div><div class="line">     if (masterUrl != activeMasterUrl) &#123;</div><div class="line">       logWarning(&quot;Invalid Master (&quot; + masterUrl + &quot;) attempted to launch executor.&quot;)</div><div class="line">     &#125; else &#123;</div><div class="line">       try &#123;</div><div class="line">         logInfo(&quot;Asked to launch executor %s/%d for %s&quot;.format(appId, execId, appDesc.name))</div><div class="line"></div><div class="line">         // Create the executor&apos;s working directory</div><div class="line">         val executorDir = new File(workDir, appId + &quot;/&quot; + execId)</div><div class="line">         if (!executorDir.mkdirs()) &#123;</div><div class="line">           throw new IOException(&quot;Failed to create directory &quot; + executorDir)</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         // Create local dirs for the executor. These are passed to the executor via the</div><div class="line">         // SPARK_EXECUTOR_DIRS environment variable, and deleted by the Worker when the</div><div class="line">         // application finishes.</div><div class="line">         val appLocalDirs = appDirectories.getOrElse(appId,</div><div class="line">           Utils.getOrCreateLocalRootDirs(conf).map &#123; dir =&gt;</div><div class="line">             val appDir = Utils.createDirectory(dir, namePrefix = &quot;executor&quot;)</div><div class="line">             Utils.chmod700(appDir)</div><div class="line">             appDir.getAbsolutePath()</div><div class="line">           &#125;.toSeq)</div><div class="line">         appDirectories(appId) = appLocalDirs</div><div class="line">         val manager = new ExecutorRunner(</div><div class="line">           appId,</div><div class="line">           execId,</div><div class="line">           appDesc.copy(command = Worker.maybeUpdateSSLSettings(appDesc.command, conf)),</div><div class="line">           cores_,</div><div class="line">           memory_,</div><div class="line">           self,</div><div class="line">           workerId,</div><div class="line">           host,</div><div class="line">           webUi.boundPort,</div><div class="line">           publicAddress,</div><div class="line">           sparkHome,</div><div class="line">           executorDir,</div><div class="line">           workerUri,</div><div class="line">           conf,</div><div class="line">           appLocalDirs, ExecutorState.RUNNING)</div><div class="line">         executors(appId + &quot;/&quot; + execId) = manager</div><div class="line">         manager.start()</div><div class="line">         coresUsed += cores_</div><div class="line">         memoryUsed += memory_</div><div class="line">         sendToMaster(ExecutorStateChanged(appId, execId, manager.state, None, None))</div><div class="line">       &#125; catch &#123;</div><div class="line">         case e: Exception =&gt;</div><div class="line">           logError(s&quot;Failed to launch executor $appId/$execId for $&#123;appDesc.name&#125;.&quot;, e)</div><div class="line">           if (executors.contains(appId + &quot;/&quot; + execId)) &#123;</div><div class="line">             executors(appId + &quot;/&quot; + execId).kill()</div><div class="line">             executors -= appId + &quot;/&quot; + execId</div><div class="line">           &#125;</div><div class="line">           sendToMaster(ExecutorStateChanged(appId, execId, ExecutorState.FAILED,</div><div class="line">             Some(e.toString), None))</div><div class="line">       &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>﻿同理，LaunchExecutor执行完毕了，通过worker ! ExecutorStateChanged通知worker，然后worker通过master ! ExecutorStateChanged通知master，释放掉worker的cpu和内存。</p>
<p>下面我们再梳理一下这个过程，只包括Driver注册，Driver运行之后的过程在之后的文章再说，比较复杂。</p>
<p>1、Client通过获得Url地址获得RpcEndPointRef（master的actor引用）,然后通过RpcEndPointRef给Master发送注册Driver请求（RequestSubmitDriver）<br>2、Master接收到请求之后就开始调度了，从workers列表里面找出可以用的Worker<br>3、通过Worker的actor引用RpcEndPointRef给可用的Worker发送启动Driver请求（LaunchDriver）<br>4、调度完毕之后，给Client回复注册成功消息(SubmitDriverResponse)<br>5、Worker接收到LaunchDriver请求之后，通过传过来的DriverDescription的信息构造出命令来，通过ProcessBuilder执行<br>6、ProcessBuilder执行完命令之后，通过DriverStateChanged通过Worker<br>7、Worker最后把DriverStateChanged汇报给Master</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用spark已经有一段时间了，今天开始读spark源码。&lt;br&gt;首先从spark提交作业开始。下图为spark的架构，以及Spark的APP运行图。它通过一个Driver来和集群通信，集群负责作业的分配。今天我要讲的是如何创建这个Driver Program的过程。&lt;/p
    
    </summary>
    
      <category term="大数据" scheme="https://fudawei.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://fudawei.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Spark/"/>
    
    
      <category term="大数据" scheme="https://fudawei.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Spark" scheme="https://fudawei.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构和对象-(一)简单动态字符串</title>
    <link href="https://fudawei.github.io/2016/09/25/Redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%AF%B9%E8%B1%A1--%EF%BC%88%E4%B8%80%EF%BC%89%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://fudawei.github.io/2016/09/25/Redis 数据结构和对象--（一）简单动态字符串/</id>
    <published>2016-09-25T06:32:02.000Z</published>
    <updated>2017-02-08T03:39:19.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h1><p>Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。</p>
<p>在 Redis 里面， C 字符串只会作为字符串字面量（string literal）， 用在一些无须对字符串值进行修改的地方， 比如打印日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; redisLog(REDIS_WARNING,&quot;Redis is now ready to exit, bye bye...&quot;);</div></pre></td></tr></table></figure>
<p>当 Redis 需要的不仅仅是一个字符串字面量， 而是一个可以被修改的字符串值时， Redis 就会使用 SDS 来表示字符串值： 比如在 Redis 的数据库里面， 包含字符串值的键值对在底层都是由 SDS 实现的。</p>
<p>举个例子， 如果客户端执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis&gt; SET msg &quot;hello world&quot;</div><div class="line">OK</div></pre></td></tr></table></figure>
<p>那么 Redis 将在数据库中创建了一个新的键值对， 其中：</p>
<p>键值对的键是一个字符串对象， 对象的底层实现是一个保存着字符串 “msg” 的 SDS 。<br>键值对的值也是一个字符串对象， 对象的底层实现是一个保存着字符串 “hello world” 的 SDS 。<br>又比如说， 如果客户端执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis&gt; RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</div><div class="line">(integer) 3</div></pre></td></tr></table></figure>
<p>那么 Redis 将在数据库中创建一个新的键值对， 其中：</p>
<p>键值对的键是一个字符串对象， 对象的底层实现是一个保存了字符串 “fruits” 的 SDS 。<br>键值对的值是一个列表对象， 列表对象包含了三个字符串对象， 这三个字符串对象分别由三个 SDS 实现： 第一个 SDS 保存着字符串 “apple” ， 第二个 SDS 保存着字符串 “banana” ， 第三个 SDS 保存着字符串 “cherry” 。<br>除了用来保存数据库中的字符串值之外， SDS 还被用作缓冲区（buffer）： AOF 模块中的 AOF 缓冲区， 以及客户端状态中的输入缓冲区， 都是由 SDS 实现的， 在之后介绍 AOF 持久化和客户端状态的时候， 我们会看到 SDS 在这两个模块中的应用。</p>
<h2 id="SDS-的定义"><a href="#SDS-的定义" class="headerlink" title="SDS 的定义"></a>SDS 的定义</h2><p>每个 sds.h/sdshdr 结构表示一个 SDS 值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">struct sdshdr &#123;</div><div class="line"></div><div class="line">    // 记录 buf 数组中已使用字节的数量</div><div class="line">    // 等于 SDS 所保存字符串的长度</div><div class="line">    int len;</div><div class="line"></div><div class="line">    // 记录 buf 数组中未使用字节的数量</div><div class="line">    int free;</div><div class="line"></div><div class="line">    // 字节数组，用于保存字符串</div><div class="line">    char buf[];</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>图 2-1 展示了一个 SDS 示例：</p>
<ul>
<li>free 属性的值为 0 ， 表示这个 SDS 没有分配任何未使用空间。</li>
<li>len 属性的值为 5 ， 表示这个 SDS 保存了一个五字节长的字符串。</li>
<li>buf 属性是一个 char 类型的数组， 数组的前五个字节分别保存了 ‘R’ 、 ‘e’ 、 ‘d’ 、 ‘i’ 、 ‘s’ 五个字符， 而最后一个字节则保存了空字符 ‘\0’ 。</li>
</ul>
<p><img src="/img/sds1.png" alt=""></p>
<p>SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面， 并且为空字符分配额外的 1 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的， 所以这个空字符对于 SDS 的使用者来说是完全透明的。</p>
<p>遵循空字符结尾这一惯例的好处是， SDS 可以直接重用一部分 C 字符串函数库里面的函数。</p>
<p>举个例子， 如果我们有一个指向图 2-1 所示 SDS 的指针 s ， 那么我们可以直接使用 stdio.h/printf 函数， 通过执行以下语句：</p>
<p>printf(“%s”, s-&gt;buf);<br>来打印出 SDS 保存的字符串值 “Redis” ， 而无须为 SDS 编写专门的打印函数。</p>
<p>图 2-2 展示了另一个 SDS 示例:</p>
<ul>
<li>这个 SDS 和之前展示的 SDS 一样， 都保存了字符串值 “Redis” 。</li>
<li>这个 SDS 和之前展示的 SDS 的区别在于， 这个 SDS 为 buf 数组分配了五字节未使用空间， 所以它的 free 属性的值为 5 （图中使用五个空格来表示五字节的未使用空间）。</li>
</ul>
<p><img src="/img/sds-2.png" alt=""></p>
<p>接下来的详细地说明未使用空间在 SDS 中的作用。</p>
<h2 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h2><p>根据传统， C 语言使用长度为 N+1 的字符数组来表示长度为 N 的字符串， 并且字符数组的最后一个元素总是空字符 ‘\0’ 。</p>
<p>比如说， 图 2-3 就展示了一个值为 “Redis” 的 C 字符串：<br><img src="/img/sds-2.png" alt=""></p>
<p>C 语言使用的这种简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求， 本节接下来的内容将详细对比 C 字符串和 SDS 之间的区别， 并说明 SDS 比 C 字符串更适用于 Redis 的原因。</p>
<p><em>常数复杂度获取字符串长度</em></p>
<p>因为 C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 O(N) 。</p>
<p>举个例子， 图 2-4 展示了程序计算一个 C 字符串长度的过程。</p>
<p><img src="/img/sds-c-1.png" alt=""><br><img src="/img/sds-c-2.png" alt=""><br><img src="/img/sds-c-3.png" alt=""><br><img src="/img/sds-c-4.png" alt=""><br><img src="/img/sds-c-5.png" alt=""><br><img src="/img/sds-c-6.png" alt=""></p>
<p>和 C 字符串不同， 因为 SDS 在 len 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1) 。</p>
<p>举个例子， 对于图 2-5 所示的 SDS 来说， 程序只要访问 SDS 的 len 属性， 就可以立即知道 SDS 的长度为 5 字节：<br><img src="/img/sds-c-7.png" alt=""></p>
<p>又比如说， 对于图 2-6 展示的 SDS 来说， 程序只要访问 SDS 的 len 属性， 就可以立即知道 SDS 的长度为 11 字节。![]<img src="/img/sds-c-8.png" alt=""></p>
<p>置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的， 使用 SDS 无须进行任何手动修改长度的工作。</p>
<p>通过使用 SDS 而不是 C 字符串， Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1) ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈。</p>
<p>比如说， 因为字符串键在底层使用 SDS 来实现， 所以即使我们对一个非常长的字符串键反复执行 STRLEN 命令， 也不会对系统性能造成任何影响， 因为 STRLEN 命令的复杂度仅为 O(1) 。</p>
<p><em>杜绝缓冲区溢出</em></p>
<p>除了获取字符串长度的复杂度高之外， C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。</p>
<p>举个例子， <string.h>/strcat 函数可以将 src 字符串中的内容拼接到 dest 字符串的末尾：</string.h></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">char *strcat(char *dest, const char *src);</div><div class="line"></div><div class="line">```因为 C 字符串不记录自身的长度， 所以 strcat 假定用户在执行这个函数时， 已经为 dest 分配了足够多的内存， 可以容纳 src 字符串中的所有内容， 而一旦这个假定不成立时， 就会产生缓冲区溢出。</div><div class="line"></div><div class="line">举个例子， 假设程序里有两个在内存中紧邻着的 C 字符串 s1 和 s2 ， 其中 s1 保存了字符串 &quot;Redis&quot; ， 而 s2 则保存了字符串 &quot;MongoDB&quot;， 如图 2-7 所示。</div><div class="line">![](/img/sds-c-9.png)</div><div class="line"></div><div class="line">如果一个程序员决定通过执行：</div></pre></td></tr></table></figure>
<p>strcat(s1, “ Cluster”);<br>```<br>将 s1 的内容修改为 “Redis Cluster” ， 但粗心的他却忘了在执行 strcat 之前为 s1 分配足够的空间， 那么在 strcat 函数执行之后， s1 的数据将溢出到 s2 所在的空间中， 导致 s2 保存的内容被意外地修改， 如图 2-8 所示。<br><img src="/img/sds-c-9.png" alt=""></p>
<p>与 C 字符串不同， SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性： 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。</p>
<p>举个例子， SDS 的 API 里面也有一个用于执行拼接操作的 sdscat 函数， 它可以将一个 C 字符串拼接到给定 SDS 所保存的字符串的后面， 但是在执行拼接操作之前， sdscat 会先检查给定 SDS 的空间是否足够， 如果不够的话， sdscat 就会先扩展 SDS 的空间， 然后才执行拼接操作。</p>
<p>比如说， 如果我们执行：</p>
<p>sdscat(s, “ Cluster”);<br>其中 SDS 值 s 如图 2-9 所示， 那么 sdscat 将在执行拼接操作之前检查 s 的长度是否足够， 在发现 s 目前的空间不足以拼接 “ Cluster”之后， sdscat 就会先扩展 s 的空间， 然后才执行拼接 “ Cluster” 的操作， 拼接操作完成之后的 SDS 如图 2-10 所示。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单动态字符串&quot;&gt;&lt;a href=&quot;#简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串&quot;&gt;&lt;/a&gt;简单动态字符串&lt;/h1&gt;&lt;p&gt;Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串），
    
    </summary>
    
      <category term="缓存" scheme="https://fudawei.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Redis" scheme="https://fudawei.github.io/categories/%E7%BC%93%E5%AD%98/Redis/"/>
    
    
      <category term="缓存" scheme="https://fudawei.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Redis" scheme="https://fudawei.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构和对象-(四)整数集合</title>
    <link href="https://fudawei.github.io/2016/09/24/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%AF%B9%E8%B1%A1--%EF%BC%88%E5%9B%9B%EF%BC%89%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>https://fudawei.github.io/2016/09/24/Redis数据结构和对象--（四）整数集合/</id>
    <published>2016-09-24T06:32:02.000Z</published>
    <updated>2017-02-08T03:39:19.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p>
<p>举个例子， 如果我们创建一个只包含五个元素的集合键， 并且集合中的所有元素都是整数值， 那么这个集合键的底层实现就会是整数集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">redis&gt; SADD numbers 1 3 5 7 9</div><div class="line">(integer) 5</div><div class="line"></div><div class="line">redis&gt; OBJECT ENCODING numbers</div><div class="line">&quot;intset&quot;</div></pre></td></tr></table></figure>
<p>下面将对整数集合及其相关操作的实现原理进行介绍。</p>
<h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。</p>
<p>每个 intset.h/intset 结构表示一个整数集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct intset &#123;</div><div class="line"></div><div class="line">    // 编码方式</div><div class="line">    uint32_t encoding;</div><div class="line"></div><div class="line">    // 集合包含的元素数量</div><div class="line">    uint32_t length;</div><div class="line"></div><div class="line">    // 保存元素的数组</div><div class="line">    int8_t contents[];</div><div class="line"></div><div class="line">&#125; intset;</div></pre></td></tr></table></figure></p>
<p>contents 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
<p>length 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。</p>
<p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值：</p>
<ul>
<li>如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是 一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。</li>
<li>如果 encoding 属性的值为 INTSET_ENC_INT32 ， 那么 contents 就是一个 int32_t 类型的数组， 数组里的每个项都是 一个 int32_t 类型的整数值 （最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ）。</li>
<li>如果 encoding 属性的值为 INTSET_ENC_INT64 ， 那么 contents 就是一个 int64_t 类型的数组， 数组里的每个项都是一个 int64_t 类型的整数值 （最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ）。</li>
</ul>
<p>图 6-1 展示了一个整数集合示例：</p>
<ul>
<li>encoding 属性的值为 INTSET_ENC_INT16 ， 表示整数集合的底层实现为 int16_t 类型的数组， 而集合保存的都是 int16_t 类型的整数值。</li>
<li>length 属性的值为 5 ， 表示整数集合包含五个元素。</li>
<li>contents 数组按从小到大的顺序保存着集合中的五个元素。<br>因为每个集合元素都是 int16_t 类型的整数值， 所以 contents 数组的大小等于 sizeof(int16_t) <em> 5 = 16 </em> 5 = 80 位。<br><img src="/img/intlist-1.png" alt=""></li>
</ul>
<p>图 6-2 展示了另一个整数集合示例：</p>
<ul>
<li>encoding 属性的值为 INTSET_ENC_INT64 ， 表示整数集合的底层实现为 int64_t 类型的数组， 而数组中保存的都是 int64_t 类型的整数值。</li>
<li>length 属性的值为 4 ， 表示整数集合包含四个元素。</li>
<li>contents 数组按从小到大的顺序保存着集合中的四个元素。<br>因为每个集合元素都是 int64_t 类型的整数值， 所以 contents 数组的大小为 sizeof(int64_t) <em> 4 = 64 </em> 4 = 256 位。<br><img src="/img/intlist-2.png" alt=""></li>
</ul>
<p>虽然 contents 数组保存的四个整数值中， 只有 -2675256175807981027 是真正需要用 int64_t 类型来保存的， 而其他的 1 、 3 、 5 三个值都可以用 int16_t 类型来保存， 不过根据整数集合的升级规则， 当向一个底层为 int16_t 数组的整数集合添加一个 int64_t 类型的整数值时， 整数集合已有的所有元素都会被转换成 int64_t 类型， 所以 contents 数组保存的四个整数值都是 int64_t 类型的， 不仅仅是-2675256175807981027 。</p>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<ul>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ul>
<p>举个例子， 假设现在有一个 INTSET_ENC_INT16 编码的整数集合， 集合中包含三个 int16_t 类型的元素， 如图 6-3 所示<br><img src="/img/intlist-3.png" alt=""></p>
<p>因为每个元素都占用 16 位空间， 所以整数集合底层数组的大小为 3 * 16 = 48 位， 图 6-4 展示了整数集合的三个元素在这 48 位里的位置。<br><img src="/img/intlist-4.png" alt=""></p>
<p>现在， 假设我们要将类型为 int32_t 的整数值 65535 添加到整数集合里面， 因为 65535 的类型 int32_t 比整数集合当前所有元素的类型都要长， 所以在将 65535 添加到整数集合之前， 程序需要先对整数集合进行升级。</p>
<p>升级首先要做的是， 根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配。</p>
<p>整数集合目前有三个元素， 再加上新元素 65535 ， 整数集合需要分配四个元素的空间， 因为每个 int32_t 整数值需要占用 32 位空间， 所以在空间重分配之后， 底层数组的大小将是 32 * 4 = 128 位， 如图 6-5 所示。<br><img src="/img/intlist-5.png" alt=""></p>
<p>然程序对底层数组进行了空间重分配， 但数组原有的三个元素 1 、 2 、 3 仍然是 int16_t 类型， 这些元素还保存在数组的前 48 位里面， 所以程序接下来要做的就是将这三个元素转换成 int32_t 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。</p>
<p>首先， 因为元素 3 在 1 、 2 、 3 、 65535 四个元素中排名第三， 所以它将被移动到 contents 数组的索引 2 位置上， 也即是数组 64 位至 95 位的空间内， 如图 6-6 所示。</p>
<p><img src="/img/intlist-6.png" alt=""></p>
<p>接着， 因为元素 2 在 1 、 2 、 3 、 65535 四个元素中排名第二， 所以它将被移动到 contents 数组的索引 1 位置上， 也即是数组的 32位至 63 位的空间内， 如图 6-7 所示。</p>
<p><img src="/img/intlist-7.png" alt=""></p>
<p>之后， 因为元素 1 在 1 、 2 、 3 、 65535 四个元素中排名第一， 所以它将被移动到 contents 数组的索引 0 位置上， 也即是数组的 0 位至 31 位的空间内， 如图 6-8 所示。</p>
<p><img src="/img/intlist-8.png" alt=""></p>
<p>然后， 因为元素 65535 在 1 、 2 、 3 、 65535 四个元素中排名第四， 所以它将被添加到 contents 数组的索引 3 位置上， 也即是数组的96 位至 127 位的空间内， 如图 6-9 所示。</p>
<p><img src="/img/intlist-9.png" alt=""></p>
<p>最后， 程序将整数集合 encoding 属性的值从 INTSET_ENC_INT16 改为 INTSET_ENC_INT32 ， 并将 length 属性的值从 3 改为 4 ， 设置完成之后的整数集合如图 6-10 所示。</p>
<p><img src="/img/intlist-10.png" alt=""></p>
<p>因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。</p>
<p>其他类型的升级操作， 比如从 INTSET_ENC_INT16 编码升级为 INTSET_ENC_INT64 编码， 或者从 INTSET_ENC_INT32 编码升级为 INTSET_ENC_INT64 编码， 升级的过程都和上面展示的升级过程类似。</p>
<p>升级之后新元素的摆放位置</p>
<p>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：</p>
<ul>
<li>在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 0 ）；</li>
<li>在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 length-1 ）。</li>
</ul>
<h2 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h2><p>整数集合的升级策略有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。</p>
<p><strong>提升灵活性</strong></p>
<p>因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。</p>
<p>比如说， 我们一般只使用 int16_t 类型的数组来保存 int16_t 类型的值， 只使用 int32_t 类型的数组来保存 int32_t 类型的值， 诸如此类。</p>
<p>但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 int16_t 、 int32_t 或者 int64_t 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</p>
<p><strong>节约内存</strong></p>
<p>当然， 要让一个数组可以同时保存 int16_t 、 int32_t 、 int64_t 三种类型的值， 最简单的做法就是直接使用 int64_t 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 int16_t 类型或者 int32_t 类型的值， 数组都需要使用 int64_t 类型的空间去保存它们， 从而出现浪费内存的情况。</p>
<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
<p>比如说， 如果我们一直只向整数集合添加 int16_t 类型的值， 那么整数集合的底层实现就会一直是 int16_t 类型的数组， 只有在我们要将int32_t 类型或者 int64_t 类型的值添加到集合时， 程序才会对数组进行升级。</p>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<p>举个例子， 对于图 6-11 所示的整数集合来说， 即使我们将集合里唯一一个真正需要使用 int64_t 类型来保存的元素 4294967295 删除了， 整数集合的编码仍然会维持 INTSET_ENC_INT64 ， 底层数组也仍然会是 int64_t 类型的， 如图 6-12 所示。</p>
<p><img src="/img/intlist-11.png" alt=""><br><img src="/img/intlist-12.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;整数集合&quot;&gt;&lt;a href=&quot;#整数集合&quot; class=&quot;headerlink&quot; title=&quot;整数集合&quot;&gt;&lt;/a&gt;整数集合&lt;/h1&gt;&lt;p&gt;整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 
    
    </summary>
    
      <category term="缓存" scheme="https://fudawei.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Redis" scheme="https://fudawei.github.io/categories/%E7%BC%93%E5%AD%98/Redis/"/>
    
    
      <category term="缓存" scheme="https://fudawei.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Redis" scheme="https://fudawei.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构和对象-(三)跳跃表</title>
    <link href="https://fudawei.github.io/2016/09/24/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%AF%B9%E8%B1%A1--%EF%BC%88%E4%B8%89%EF%BC%89%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <id>https://fudawei.github.io/2016/09/24/Redis数据结构和对象--（三）跳跃表/</id>
    <published>2016-09-24T06:32:02.000Z</published>
    <updated>2017-02-08T03:39:19.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><p>它是一种有序数据结构,通过在每个节点中维持多个 指向其他节点<br>的指针,从而达到快速访问节点的目的。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h2><p>Redis使用跳跃表作为有序集合键的底层实现之一,如果一个有序集合包含的元素数量比较多,又或者有序集合中元素的成(member)是比较长的字符串时,Redis就会使用跳跃表来作为有序集合键的底层实现。<br>另外,在集群节点中跳跃表被用作内部数据结构。除此之外在Redis中在无他用</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h2><p>跳跃表由zskiplistNode和zskiplist两个结构定义,其中zskiplistNode用<br>于表示跳跃表节点,而zskiplist用于保存跳跃表节点的相关信息。</p>
<p><img src="/img/skipList-1.png" alt=""></p>
<p>上图为zskiplist结构,其中</p>
<ul>
<li>header指向跳跃表的表头节点。</li>
<li>tail指向表尾节点。</li>
<li>level记录层数最大的那个节点的层数(注意:表头节点的层数不计算在内),是1-32之间的一个随机数,越大的数出现的概率越小。</li>
</ul>
<p>下图右为zskiplist结构,其中层(level):L1、L2、L3等标记各个节点的层,每个层都有前进指针和跨度,当程序从表头向表尾进行遍历时,访问会沿着层的前进指针进行。</p>
<p><strong>跨度</strong>:层的跨度(level[i].span属性)用于记录两个节点间的距离,节点间的跨度越大,它们相聚的就越远,指向NULL的所有前进指针的跨度都为0,因为它们没有连向任何节点。跨度跟遍历操作无关,是用来计算排位的(可根据排位获取元素节点),如下图,查找分值为3.0、对象为o3的节点时,只经过了一个层,并且层的跨度为3,所以该节点在跳跃表中的排位为3。</p>
<p><img src="/img/skipList-2.png" alt=""></p>
<ul>
<li><strong>后退(backward)指针</strong>:BW标记节点的后退指针,它指向位于当前节点的前一个节点,后退指针在程序从表尾向表头遍历时使用,与前进指针不同,后退针每次只能后退至前一个节点,因为每个节点只有一个后退指针。</li>
<li><strong>分值</strong>(score):1.0、2.0和3.0是节点所保存的分值,分值是一个double类型的浮点数,可重复,用于节点排序(分值相同则按在字典中大小排)。</li>
<li><strong>成员对象</strong>(obj):o1、o2和o3是节点所保存的成员对象,成员对象是一个指针,它指向一个字符串对象,而字符串对象则保存着一个SDS值,并且是唯一的。<br><em>注意:表头节点跟其他节点一样,也有后退指针、分值、成员对象等属性,但都不会被用到,故在图中没有画出。</em></li>
</ul>
<h2 id="跳跃表API"><a href="#跳跃表API" class="headerlink" title="跳跃表API"></a>跳跃表API</h2><p><img src="/img/skipList-3.png" alt=""></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>a.跳表具有如下性质:</p>
<ol>
<li>由很多层结构组成</li>
<li>每一层都是一个有序的链表</li>
<li>最底层(Level 1)的链表包含所有元素</li>
<li>如果一个元素出现在 Level i 的链表中,则它在 Level i 之下的链表也都会出现。</li>
<li>每个节点包含两个指针,一个指向同一链表中的下一个元素,一个指向下面一层的元素。</li>
</ol>
<p>b.插入</p>
<p>先确定该元素要占据的层数 K(采用丢硬币的方式,这完全是随机的)<br>然后在 Level 1 … Level K 各个层的链表都插入元素。<br>例子:插入 119, K = 2<br><img src="/img/skipList-4.png" alt=""></p>
<p>如果 K 大于链表的层数,则要添加新的层。<br>例子:插入 119, K = 4<br><img src="/img/skipList-5.png" alt=""></p>
<p>c.删除<br>三个步骤:</p>
<ol>
<li>在跳跃表中查找到这个元素的位置(如果未找到,则退出)</li>
<li>将该元素所在整列从表中删除</li>
<li>将多余的“空链”删除<br><img src="/img/skipList-6.png" alt=""></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义:&quot;&gt;&lt;/a&gt;定义:&lt;/h2&gt;&lt;p&gt;它是一种有序数据结构,通过在每个节点中维持多个 指向其他节点&lt;br&gt;的指针,从而达到快速访问节点的目的。&lt;/p&gt;
&lt;h2 id=&quot;使用场
    
    </summary>
    
      <category term="缓存" scheme="https://fudawei.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Redis" scheme="https://fudawei.github.io/categories/%E7%BC%93%E5%AD%98/Redis/"/>
    
    
      <category term="缓存" scheme="https://fudawei.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Redis" scheme="https://fudawei.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
